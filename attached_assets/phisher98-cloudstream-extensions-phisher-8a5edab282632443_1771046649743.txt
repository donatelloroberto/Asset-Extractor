Directory structure:
└── phisher98-cloudstream-extensions-phisher/
    ├── README.md
    ├── build.gradle.kts
    ├── gradle.properties
    ├── gradlew
    ├── gradlew.bat
    ├── settings.gradle.kts
    ├── AllMovieLandProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── AllMovieLandProvider.kt
    │                       └── AllMovieLandProviderPlugin.kt
    ├── AllWish/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── allwish/
    │                       ├── AllWish.kt
    │                       ├── AllWishPlugin.kt
    │                       ├── AllWishUtils.kt
    │                       └── Extractors.kt
    ├── Anichi/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Anichi/
    │                       ├── Anichi.kt
    │                       ├── AnichiExtractors.kt
    │                       ├── AnichiParser.kt
    │                       ├── AnichiPlugin.kt
    │                       └── AnichiUtils.kt
    ├── Animeav1/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Animeav1/
    │                       ├── Animeav1.kt
    │                       ├── Animeav1Provider.kt
    │                       └── Extractor.kt
    ├── AnimeCloud/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Animecloud/
    │                       ├── Animecloud.kt
    │                       ├── AnimecloudProvider.kt
    │                       ├── Extractor.kt
    │                       └── Parser.kt
    ├── AnimeDekhoProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── AnimeDekhoPlugin.kt
    │                       ├── AnimeDekhoProvider.kt
    │                       ├── Extractor.kt
    │                       ├── HindiSubAnime.kt
    │                       └── OnePace.kt
    ├── AnimeKai/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── AnimeKai/
    │           │           ├── AnimeKai.kt
    │           │           ├── AnimeKaiParser.kt
    │           │           ├── AnimeKaiPlugin.kt
    │           │           ├── BottomSheet.kt
    │           │           └── Extractor.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── outline.xml
    │               │   └── save_icon.xml
    │               └── layout/
    │                   ├── bottom_sheet_layout.xml
    │                   └── radio_button.xml
    ├── Animekhor/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Animekhor/
    │                       ├── Animekhor.kt
    │                       ├── AnimekhorProvider.kt
    │                       ├── Donghuaword.kt
    │                       └── Extractor.kt
    ├── Animenosub/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Animenosub/
    │                       ├── Animenosub.kt
    │                       ├── AnimenosubProvider.kt
    │                       └── Extractor.kt
    ├── AnimePahe/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── AnimePahe.kt
    │                       ├── AnimePahePlugin.kt
    │                       └── Utils.kt
    ├── Animesalt/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Animesalt.kt
    │                       ├── AnimesaltProvider.kt
    │                       └── Extractor.kt
    ├── AnimeWorld/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── AnimeWorld.kt
    │                       ├── AnimeWorldProvider.kt
    │                       └── Extractor.kt
    ├── Animexin/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Animexin/
    │                       ├── Animexin.kt
    │                       ├── AnimexinProvider.kt
    │                       └── Extractor.kt
    ├── Animez/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── animez/
    │                       ├── Animez.kt
    │                       └── AnimezProvider.kt
    ├── Aniworld/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Aniworld/
    │                       ├── Aniworld.kt
    │                       ├── AniworldPlugin.kt
    │                       └── Serienstream.kt
    ├── BanglaPlex/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── BanglaPlex/
    │                       ├── BanglaPlex.kt
    │                       ├── BanglaPlexProvider.kt
    │                       └── Extractors.kt
    ├── Cinemacity/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Cinemacity/
    │                       ├── Cinemacity.kt
    │                       ├── CinemacityPlugin.kt
    │                       └── Utils.kt
    ├── Coflix/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Coflix/
    │                       ├── Coflix.kt
    │                       ├── CoflixProvider.kt
    │                       ├── Extractor.kt
    │                       └── Parser.kt
    ├── Desicinemas/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Desicinemas/
    │                       ├── BollyzoneProvider.kt
    │                       ├── DesicinemasPlugin.kt
    │                       ├── DesicinemasProvider.kt
    │                       ├── Tellygossips.kt
    │                       ├── Tvlogy.kt
    │                       └── Utils.kt
    ├── docs/
    │   ├── README-StremioAddon.md
    │   ├── README-StremioX.md
    │   └── ULTIMA_SYNC_SETUP.md
    ├── Donghuastream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Donghuastream/
    │                       ├── Donghuastream.kt
    │                       ├── Donghuastreamparser.kt
    │                       ├── DonghuastreamProvider.kt
    │                       ├── Extractor.kt
    │                       └── SeaTV.kt
    ├── DoraBash/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── DoraBash/
    │                       ├── DoraBash.kt
    │                       ├── DoraBashParser.kt
    │                       ├── DoraBashProvider.kt
    │                       └── Extractor.kt
    ├── DramaFull/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── dramafull/
    │                       ├── DramaFull.kt
    │                       ├── DramaFullParser.kt
    │                       └── DramaFullPlugin.kt
    ├── DudeFilms/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── dudefilms/
    │                       ├── dudefilms.kt
    │                       ├── dudefilmsPlugin.kt
    │                       ├── Extractors.kt
    │                       └── Utils.kt
    ├── Fibwatch/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── fibwatch/
    │                       ├── Fibtoon.kt
    │                       ├── Fibwatch.kt
    │                       ├── fibWatchDrama.kt
    │                       ├── FibwatchPlugin.kt
    │                       └── Utils.kt
    ├── Filmycab/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Filmycab/
    │                       ├── Extractor.kt
    │                       ├── Filmycab.kt
    │                       └── FilmycabProvider.kt
    ├── Filmyfiy/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Filmyfiy/
    │                       ├── Extractor.kt
    │                       ├── Filmyfiy.kt
    │                       └── FilmyfiyProvider.kt
    ├── Fivemovierulz/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── darkdemon/
    │                       ├── Extractor.kt
    │                       ├── FivemovierulzPlugin.kt
    │                       └── FivemovierulzProvider.kt
    ├── FourKHDHub/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── fourKHDHub/
    │                       ├── Extractor.kt
    │                       ├── FourKHDHub.kt
    │                       ├── FourKHDHubProvider.kt
    │                       └── Utils.kt
    ├── Funmovieslix/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Funmovieslix/
    │                       ├── Extractors.kt
    │                       ├── Funmovieslix.kt
    │                       └── FunmovieslixProvider.kt
    ├── Goojara/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Goojara/
    │                       ├── Extractor.kt
    │                       ├── Goojara.kt
    │                       ├── GoojaraProvider.kt
    │                       └── Parser.kt
    ├── gradle/
    │   └── wrapper/
    │       └── gradle-wrapper.properties
    ├── HDhub4u/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── hdhub4u/
    │                       ├── Extractors.kt
    │                       ├── HDhub4uPlugin.kt
    │                       ├── HDhub4uProvider.kt
    │                       └── Utils.kt
    ├── HiAnime/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── HiAnime/
    │           │           ├── BottomSheet.kt
    │           │           ├── Extractor.kt
    │           │           ├── HiAnime.kt
    │           │           └── HiAnimePlugin.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── outline.xml
    │               │   └── save_icon.xml
    │               └── layout/
    │                   ├── bottom_sheet_layout.xml
    │                   └── radio_button.xml
    ├── Hindmoviez/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── hindmoviez/
    │                       ├── hindmoviez.kt
    │                       ├── hindmoviezPlugin.kt
    │                       └── Utils.kt
    ├── IdlixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── hexated/
    │                       ├── Extractor.kt
    │                       ├── IdlixProvider.kt
    │                       └── IdlixProviderPlugin.kt
    ├── IPTVPlayer/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── IPTVPlayer.kt
    │                       └── IPTVPlayerPlugin.kt
    ├── Jellyfin/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── Jellyfin.kt
    │           │           ├── JellyfinParser.kt
    │           │           ├── JellyfinPlugin.kt
    │           │           └── settings/
    │           │               └── SettingsFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── focusable_button_background.xml
    │               │   ├── focusable_input_bg.xml
    │               │   ├── ic_visibility.xml
    │               │   ├── ic_visibility_off.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               ├── layout/
    │               │   └── settings_fragment.xml
    │               └── values/
    │                   └── strings.xml
    ├── Kartoons/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Kartoons/
    │                       ├── Kartoons.kt
    │                       ├── KartoonsParser.kt
    │                       ├── KartoonsPlugin.kt
    │                       └── Utils.kt
    ├── Kickassanime/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Kickassanime/
    │                       ├── Crypto.kt
    │                       ├── GogoExtractor.kt
    │                       ├── Kickassanime.kt
    │                       ├── KickassanimePlugin.kt
    │                       └── KickassanimeUtils.kt
    ├── KisskhProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── KisskhProvider.kt
    │                       ├── KisskhProviderPlugin.kt
    │                       └── SubDecryptor.kt
    ├── Latanime/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── latanime/
    │                       ├── Extractor.kt
    │                       ├── Latanime.kt
    │                       └── LatanimeProvider.kt
    ├── LayarKacaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── LayarKacaProvider/
    │                       ├── Extractors.kt
    │                       ├── LayarKacaProvider.kt
    │                       └── LayarKacaProviderPlugin.kt
    ├── MassTamilanProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── likdev256/
    │                       ├── MassTamilanProvider.kt
    │                       └── MassTamilanProviderPlugin.kt
    ├── Megakino/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Megakino/
    │                       ├── Extractor.kt
    │                       ├── Megakino.kt
    │                       └── MegakinoProvider.kt
    ├── MovieBlast/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── MovieBlast/
    │                       ├── MovieBlast.kt
    │                       ├── MovieBlastParser.kt
    │                       └── MovieBlastProvider.kt
    ├── MovieBoxProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── MovieBox/
    │                       ├── MovieBoxProvider.kt
    │                       └── MovieBoxProviderPlugin.kt
    ├── Movierulzhd/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractors.kt
    │                       ├── Hdmovie2.kt
    │                       ├── Movierulzhd.kt
    │                       └── MovierulzhdPlugin.kt
    ├── MPlayerProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── MPlayer/
    │                       ├── MPlayer.kt
    │                       ├── MPlayerPlugin.kt
    │                       ├── Parser.kt
    │                       └── Utils.kt
    ├── MultiMoviesProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractor.kt
    │                       ├── MultiMoviesProvider.kt
    │                       └── MultiMoviesProviderPlugin.kt
    ├── Netcinez/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Netcinez/
    │                       ├── Netcinez.kt
    │                       └── NetcinezProvider.kt
    ├── NOXXProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── NOXXProvider.kt
    │                       └── NOXXProviderPlugin.kt
    ├── OHLI24/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── ohli24/
    │                       ├── Extractor.kt
    │                       ├── OHLI24.kt
    │                       └── OHLI24Plugin.kt
    ├── OnePace/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── AnimedekhoOnePace.kt
    │                       ├── Extractor.kt
    │                       └── OnePacePlugin.kt
    ├── OneTouchTV/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── OneTouchTV/
    │                       ├── Decryption.kt
    │                       ├── OneTouchTV.kt
    │                       ├── OneTouchTVParser.kt
    │                       └── OneTouchTVPlugin.kt
    ├── Pelisplushd/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── pelisplushd/
    │                       ├── Extractor.kt
    │                       ├── Pelisplushd.kt
    │                       ├── PelisplushdParser.kt
    │                       └── PelisplushdProvider.kt
    ├── Pencurimovie/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Pencurimovie/
    │                       ├── Pencurimovie.kt
    │                       └── PencurimovieProvider.kt
    ├── Pinoymoviepedia/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Pinoymoviepedia/
    │                       ├── Bluray7.kt
    │                       ├── Extractor.kt
    │                       ├── Pinoymoviepedia.kt
    │                       └── PinoymoviepediaProvider.kt
    ├── PublicSportsIPTV/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── PublicSportsIPTV/
    │                       ├── PublicSportsIPTV.kt
    │                       ├── PublicSportsIPTVParser.kt
    │                       └── PublicSportsIPTVProvider.kt
    ├── QuickIPTV/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── JapanIPTV.kt
    │                       ├── PirateIPTV.kt
    │                       ├── QuickIPTV.kt
    │                       ├── QuickIPTVPlugin.kt
    │                       └── SonyIPTV.kt
    ├── RingZ/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── RingZ/
    │                       ├── RingZ.kt
    │                       ├── RingZParser.kt
    │                       ├── RingZProvider.kt
    │                       └── Utils.kt
    ├── ShowFlixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractor.kt
    │                       ├── ShowFlixParser.kt
    │                       ├── ShowFlixProvider.kt
    │                       └── ShowFlixProviderPlugin.kt
    ├── Streamblasters/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Streamblasters/
    │                       ├── Extractors.kt
    │                       ├── Streamblasters.kt
    │                       └── StreamblastersProvider.kt
    ├── StreamPlay/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── Phisher98/
    │           │           ├── ProvidersList.kt
    │           │           ├── StreamPlay.kt
    │           │           ├── StreamPlayAnime.kt
    │           │           ├── StreamPlayLite.kt
    │           │           ├── StreamPlayParser.kt
    │           │           ├── StreamPlayPlugin.kt
    │           │           ├── StreamPlayStremioCatelog.kt
    │           │           ├── StreamPlayTest.kt
    │           │           ├── StreamPlayTorrent.kt
    │           │           ├── StreamplayTorrentAnime.kt
    │           │           ├── StreamplayTorrentExtractor.kt
    │           │           ├── StreamPlayTorrentParser.kt
    │           │           └── settings/
    │           │               ├── LanguageSelectFragment.kt
    │           │               ├── MainSettingsFragment.kt
    │           │               ├── ProvidersFragment.kt
    │           │               ├── SettingsFragment.kt
    │           │               ├── StreamPlayStremioCatelogFrag.kt
    │           │               └── ToggleFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   ├── settings_icon.xml
    │               │   └── toggle_item_background.xml
    │               ├── layout/
    │               │   ├── fragment_language_select.xml
    │               │   ├── fragment_main_settings.xml
    │               │   ├── fragment_providers.xml
    │               │   ├── fragment_toggle_extensions.xml
    │               │   ├── item_language.xml
    │               │   ├── item_provider_checkbox.xml
    │               │   ├── list_toggle_item.xml
    │               │   ├── settings_fragment.xml
    │               │   ├── streamio_addon_addlinks.xml
    │               │   ├── stremio_bottom_sheet_layout.xml
    │               │   ├── stremio_dialog_list_links.xml
    │               │   └── stremio_item_saved_link.xml
    │               └── values/
    │                   └── strings.xml
    ├── StremioAddon/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── StremioAddon.kt
    │           │           ├── StremioAddonProvider.kt
    │           │           ├── StremioAddonUtils.kt
    │           │           ├── SubsExtractors.kt
    │           │           └── settings/
    │           │               └── SettingsFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── ic_android_24dp.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               ├── layout/
    │               │   ├── item_stremio_addon.xml
    │               │   └── settings.xml
    │               ├── values/
    │               │   └── strings.xml
    │               └── values-pl/
    │                   └── strings.xml
    ├── StremioX/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── StremioC.kt
    │           │           ├── StremioX.kt
    │           │           ├── StremioXPlugin.kt
    │           │           ├── SubsExtractors.kt
    │           │           ├── Utils.kt
    │           │           └── settings/
    │           │               └── SettingsBottomFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               └── layout/
    │                   ├── addlinks.xml
    │                   ├── bottom_sheet_layout.xml
    │                   ├── dialog_list_links.xml
    │                   └── item_saved_link.xml
    ├── SuperStream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── SuperStream.kt
    │           │           ├── SuperStreamExtractor.kt
    │           │           ├── SuperStreamParser.kt
    │           │           ├── SuperStreamPlugin.kt
    │           │           ├── SuperStreamUtils.kt
    │           │           └── settings/
    │           │               └── SettingsFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               ├── layout/
    │               │   └── settings_fragment.xml
    │               └── values/
    │                   └── strings.xml
    ├── SuperstreamBeta/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── Extractors.kt
    │           │           ├── Superstream.kt
    │           │           ├── SuperStreamparser.kt
    │           │           ├── SuperstreamPlugin.kt
    │           │           └── settings/
    │           │               └── SettingsFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               ├── layout/
    │               │   └── settings_fragment.xml
    │               └── values/
    │                   └── strings.xml
    ├── Tamilblasters/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── tamilblasters/
    │                   ├── Extractor.kt
    │                   ├── TamilblastersPlugin.kt
    │                   └── TamilblastersProvider.kt
    ├── Tamilian/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Tamilian/
    │                       ├── Tamilian.kt
    │                       └── TamilianPlugin.kt
    ├── Telugumv/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractors.kt
    │                       ├── Telugumv.kt
    │                       └── TelugumvPlugin.kt
    ├── Tennistream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Tennistream/
    │                       ├── Extractors.kt
    │                       ├── Tennistream.kt
    │                       └── TennistreamProvider.kt
    ├── TokusatsuUltimate/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           └── kotlin/
    │               └── com/
    │                   └── tokusatsu/
    │                       └── ultimate/
    │                           ├── TokusatsuParser.kt
    │                           ├── TokusatsuUltimate.kt
    │                           └── TokusatsuUltimatePlugin.kt
    ├── ToonHub/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── toonhub4u/
    │                       ├── Extractor.kt
    │                       ├── Toonhub4u.kt
    │                       └── Toonhub4uPlugin.kt
    ├── Toonstream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Toonstream/
    │                       ├── Extractors.kt
    │                       ├── Toonstream.kt
    │                       └── ToonstreamProvider.kt
    ├── ToonTales/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── ToonTales/
    │                       ├── ToonTales.kt
    │                       └── ToonTalesProvider.kt
    ├── Topcartoons/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Topcartoons/
    │                       ├── Topcartoons.kt
    │                       └── TopcartoonsProvider.kt
    ├── Topstreamfilm/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Topstreamfilm/
    │                       ├── Extractor.kt
    │                       ├── Topstreamfilm.kt
    │                       └── TopstreamfilmPlugin.kt
    ├── TorraStream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── TorraStream.kt
    │           │           ├── TorraStreamAnime.kt
    │           │           ├── TorraStreamExtractor.kt
    │           │           ├── TorraStreamParser.kt
    │           │           ├── TorraStreamProvider.kt
    │           │           ├── TorraStreamUtils.kt
    │           │           └── settings/
    │           │               └── SettingsFragment.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── add_icon.xml
    │               │   ├── delete_icon.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── settings_icon.xml
    │               └── layout/
    │                   └── settings.xml
    ├── UHDmoviesProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractors.kt
    │                       ├── UHDmoviesProvider.kt
    │                       ├── UHDmoviesProviderPlugin.kt
    │                       └── Utils.kt
    ├── Ultima/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── Ultima.kt
    │           │           ├── UltimaPlugin.kt
    │           │           ├── MediaProviders/
    │           │           │   ├── AllMovieland.kt
    │           │           │   ├── AnimeKai.kt
    │           │           │   ├── DahmerMovies.kt
    │           │           │   ├── Elevenmovies.kt
    │           │           │   ├── HiAnime.kt
    │           │           │   ├── MovieBox.kt
    │           │           │   ├── MoviesDrive.kt
    │           │           │   ├── MultiEmbededAPI.kt
    │           │           │   ├── MultiMovies.kt
    │           │           │   ├── Noverse.kt
    │           │           │   ├── NowTv.kt
    │           │           │   ├── PrimeWireProvider.kt
    │           │           │   ├── TwoEmbed.kt
    │           │           │   ├── VegaMovies.kt
    │           │           │   ├── Vidflast.kt
    │           │           │   ├── Vidsrccc.kt
    │           │           │   ├── Watch32.kt
    │           │           │   └── XPrimeProvider.kt
    │           │           ├── MetaProviders/
    │           │           │   ├── AniList.kt
    │           │           │   ├── MetaProviders.kt
    │           │           │   ├── MyAnimeList.kt
    │           │           │   ├── Simkl.kt
    │           │           │   ├── Tmdb.kt
    │           │           │   ├── Trakt.kt
    │           │           │   └── WatchSync.kt
    │           │           ├── Settings/
    │           │           │   ├── ConfigureExtensions.kt
    │           │           │   ├── ConfigureWatchSync.kt
    │           │           │   ├── MetaProviders.kt
    │           │           │   ├── Reorder.kt
    │           │           │   └── Settings.kt
    │           │           └── Utils/
    │           │               ├── StorageManager.kt
    │           │               ├── UltimaUtils.kt
    │           │               └── WatchSyncUtils.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── delete_icon.xml
    │               │   ├── edit_icon.xml
    │               │   ├── ic_eye.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── triangle.xml
    │               └── layout/
    │                   ├── configure_extensions.xml
    │                   ├── configure_watch_sync.xml
    │                   ├── list_extension_item.xml
    │                   ├── list_media_provider_item.xml
    │                   ├── list_meta_provider_item.xml
    │                   ├── list_section_item.xml
    │                   ├── list_section_reorder_item.xml
    │                   ├── meta_providers.xml
    │                   ├── reorder.xml
    │                   ├── settings.xml
    │                   ├── watch_sync_creds.xml
    │                   └── watch_sync_device.xml
    ├── UltimaBeta/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── phisher98/
    │           │           ├── Ultima.kt
    │           │           ├── UltimaPlugin.kt
    │           │           ├── MediaProviders/
    │           │           │   ├── AllMovieland.kt
    │           │           │   ├── AnimeKai.kt
    │           │           │   ├── DahmerMovies.kt
    │           │           │   ├── Elevenmovies.kt
    │           │           │   ├── HiAnime.kt
    │           │           │   ├── MovieBox.kt
    │           │           │   ├── MoviesDrive.kt
    │           │           │   ├── MultiEmbededAPI.kt
    │           │           │   ├── MultiMovies.kt
    │           │           │   ├── Noverse.kt
    │           │           │   ├── NowTv.kt
    │           │           │   ├── PrimeWireProvider.kt
    │           │           │   ├── TwoEmbed.kt
    │           │           │   ├── VegaMovies.kt
    │           │           │   ├── Vidflast.kt
    │           │           │   ├── Vidsrccc.kt
    │           │           │   ├── Watch32.kt
    │           │           │   └── XPrimeProvider.kt
    │           │           ├── MetaProviders/
    │           │           │   ├── AniList.kt
    │           │           │   ├── MetaProviders.kt
    │           │           │   ├── MyAnimeList.kt
    │           │           │   ├── Simkl.kt
    │           │           │   ├── Tmdb.kt
    │           │           │   ├── Trakt.kt
    │           │           │   └── WatchSync.kt
    │           │           ├── Settings/
    │           │           │   ├── ConfigureExtensions.kt
    │           │           │   ├── ConfigureWatchSync.kt
    │           │           │   ├── MetaProviders.kt
    │           │           │   ├── Reorder.kt
    │           │           │   └── Settings.kt
    │           │           └── Utils/
    │           │               ├── StorageManager.kt
    │           │               ├── UltimaUtils.kt
    │           │               └── WatchSyncUtils.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── delete_icon.xml
    │               │   ├── edit_icon.xml
    │               │   ├── ic_eye.xml
    │               │   ├── outline.xml
    │               │   ├── save_icon.xml
    │               │   └── triangle.xml
    │               └── layout/
    │                   ├── configure_extensions.xml
    │                   ├── configure_watch_sync.xml
    │                   ├── list_extension_item.xml
    │                   ├── list_media_provider_item.xml
    │                   ├── list_meta_provider_item.xml
    │                   ├── list_section_item.xml
    │                   ├── list_section_reorder_item.xml
    │                   ├── meta_providers.xml
    │                   ├── reorder.xml
    │                   ├── settings.xml
    │                   ├── watch_sync_creds.xml
    │                   └── watch_sync_device.xml
    ├── Watch32/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── phisher98/
    │                       ├── Extractors.kt
    │                       ├── Watch32.kt
    │                       ├── Watch32Parser.kt
    │                       └── Watch32Plugin.kt
    ├── WatchMMAFull/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── WatchMMAFull/
    │                       ├── Extractor.kt
    │                       ├── WatchMMAFull.kt
    │                       └── WatchMMAFullProvider.kt
    ├── XDMovies/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── Phisher98/
    │                       ├── Extractor.kt
    │                       ├── XDMovies.kt
    │                       ├── XDMoviesParser.kt
    │                       └── XDMoviesProvider.kt
    ├── Yflix/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           ├── kotlin/
    │           │   └── com/
    │           │       └── yflix/
    │           │           ├── BottomSheet.kt
    │           │           ├── Extractor.kt
    │           │           ├── Yflix.kt
    │           │           └── YflixPlugin.kt
    │           └── res/
    │               ├── drawable/
    │               │   ├── outline.xml
    │               │   └── save_icon.xml
    │               └── layout/
    │                   ├── bottom_sheet_layout.xml
    │                   └── radio_button.xml
    ├── YTS/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── YTS/
    │                       ├── YTS MAX.kt
    │                       ├── YTS.kt
    │                       └── YTSProvider.kt
    └── .github/
        ├── ISSUE_TEMPLATE/
        │   ├── 01_report_issue.yml
        │   ├── 02_site-request.yml
        │   └── 09_Other_Issue.yml
        └── workflows/
            └── newrun.yml

================================================
FILE: README.md
================================================
# 🎯 Phisher Cloudstream Plugin Server

**Shortcode**: `phisherrepo`

---

### ❤️ Support

If you find this project helpful, consider supporting its development!

<a href="https://buymeacoffee.com/phisher98" target="_blank"><img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="Buy Me A Coffee" style="height: 60px !important;width: 217px !important;" ></a>

[![Support me on Ko-fi](https://img.shields.io/badge/Ko--fi-Support%20Me-red?logo=ko-fi)](https://ko-fi.com/phisher98)

## 🌐 Plugin Servers

### 🔹 Phisher Cloudstream Plugin Server
[![Discord](https://invidget.switchblade.xyz/3VmSzGeCTz)](https://discord.com/invite/3VmSzGeCTz)

### 🔸 Cloudstream Plugin Server
[![Discord](https://invidget.switchblade.xyz/JrGk2MjX7S)](https://discord.com/invite/JrGk2MjX7S)

---

## 🧰 Tools & Technologies

<p align="left">
  <a href="https://skillicons.dev">
    <img src="https://skillicons.dev/icons?i=kotlin,androidstudio,gradle,github,githubactions&theme=light&perline=5" />
  </a>
</p>

---

## 🔄 Ultima Sync Setup

Want to sync your devices using **Ultima’s Cross Device Watch Sync**?

📘 [View the full setup guide →](docs/ULTIMA_SYNC_SETUP.md)

📘 [View YouTube guide →](https://cloudstream.miraheze.org/wiki/Ultima)

This guide will show you how to use a **private GitHub project** and a **personal access token** to sync playback history across devices.

---

## STREMIO ADDON SETUPS

Want to learn how to add and manage Stremio addons more effectively?

📘 **Stremio Addon – Written Guide**  
Step-by-step instructions for adding, managing, and using Stremio addon links in Cloudstream.  
[Open guide →](https://github.com/phisher98/cloudstream-extensions-phisher/blob/master/docs/README-StremioAddon.md)

📘 **StremioX / StremioC – Written Guide**  
Detailed explanation of StremioX (stream addons) and StremioC (catalogue addons), including usage and limitations.  
[Open guide →](https://github.com/phisher98/cloudstream-extensions-phisher/blob/master/docs/README-StremioX.md)

---

## 📄 License

[![GNU GPLv3 Image](https://www.gnu.org/graphics/gplv3-127x51.png)](http://www.gnu.org/licenses/gpl-3.0.en.html)

These extensions are **free software**: you can use, study, share, and modify them as you wish.

They are distributed under the terms of the [GNU General Public License](https://www.gnu.org/licenses/gpl.html) version 3 or later, published by the Free Software Foundation.

---

## ⚖️ DMCA Disclaimer

We hereby issue this notice to clarify that these extensions function similarly to a standard web browser by fetching video files from the internet.

- **No content is hosted by this repository or the Cloudstream 3 application.**
- Any content accessed is hosted by third-party websites.
- Users are solely responsible for their usage and must comply with their local laws.

If you believe content is violating copyright laws, please contact the **actual file hosts**, **not** the developers of this repository or the Cloudstream 3 app.

---

**Thank You for using Phisher Repo!**



================================================
FILE: build.gradle.kts
================================================
import com.android.build.gradle.BaseExtension
import com.lagradost.cloudstream3.gradle.CloudstreamExtension
import org.gradle.kotlin.dsl.register
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile

buildscript {
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }

    dependencies {
        classpath("com.android.tools.build:gradle:8.13.2")
        classpath("com.github.recloudstream:gradle:master-SNAPSHOT")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:2.3.0")
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}

fun Project.cloudstream(configuration: CloudstreamExtension.() -> Unit) = extensions.getByName<CloudstreamExtension>("cloudstream").configuration()

fun Project.android(configuration: BaseExtension.() -> Unit) = extensions.getByName<BaseExtension>("android").configuration()

subprojects {
    apply(plugin = "com.android.library")
    apply(plugin = "kotlin-android")
    apply(plugin = "com.lagradost.cloudstream3.gradle")

    cloudstream {
        setRepo(System.getenv("GITHUB_REPOSITORY") ?: "https://github.com/phisher98/cloudstream-extensions-phisher")
        authors = listOf("Phisher98")
    }

    android {
        namespace = "com.phisher98"

        defaultConfig {
            minSdk = 21
            compileSdkVersion(35)
            targetSdk = 35

        }

        compileOptions {
            sourceCompatibility = JavaVersion.VERSION_1_8
            targetCompatibility = JavaVersion.VERSION_1_8
        }


        tasks.withType<KotlinJvmCompile> {
            compilerOptions {
                jvmTarget.set(JvmTarget.JVM_1_8)
                freeCompilerArgs.addAll(
                    "-Xno-call-assertions",
                    "-Xno-param-assertions",
                    "-Xno-receiver-assertions"
                )
            }
        }
    }

    dependencies {
        val implementation by configurations
        val cloudstream by configurations
        cloudstream("com.lagradost:cloudstream3:pre-release")

        // Other dependencies
        implementation(kotlin("stdlib"))
        implementation("com.github.Blatzar:NiceHttp:0.4.16")
        implementation("org.jsoup:jsoup:1.22.1")
        implementation("androidx.annotation:annotation:1.9.1")
        implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.20.1")
        implementation("com.fasterxml.jackson.core:jackson-databind:2.20.1")
        implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.10.2")
        implementation("org.mozilla:rhino:1.9.0")
        implementation("me.xdrop:fuzzywuzzy:1.4.0")
        implementation("com.google.code.gson:gson:2.13.2")
        implementation("org.jetbrains.kotlinx:kotlinx-serialization-json:1.9.0")
        implementation("com.github.vidstige:jadb:v1.2.1")
        implementation("org.bouncycastle:bcpkix-jdk15on:1.70")
    }
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}



================================================
FILE: gradle.properties
================================================
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true
android.buildFeatures.buildConfig=true
# org.gradle.java.home=/usr/lib/jvm/java-17-openjdk

org.gradle.caching=true
# org.gradle.configuration-cache=true



================================================
FILE: gradlew
================================================
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/master/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

APP_HOME=$( cd "${APP_HOME:-./}" && pwd -P ) || exit

APP_NAME="Gradle"
APP_BASE_NAME=${0##*/}

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi

# Collect all arguments for the java command;
#   * $DEFAULT_JVM_OPTS, $JAVA_OPTS, and $GRADLE_OPTS can contain fragments of
#     shell script including quotes and variable substitutions, so put them in
#     double quotes to make sure that they get re-expanded; and
#   * put everything else in single quotes, so that it's not re-expanded.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"



================================================
FILE: gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: settings.gradle.kts
================================================
rootProject.name = "CloudstreamPlugins"

// This file sets what projects are included. All new projects should get automatically included unless specified in "disabled" variable.
val disabled = listOf<String>()

File(rootDir, ".").eachDir { dir ->
    if (!disabled.contains(dir.name) && File(dir, "build.gradle.kts").exists()) {
        include(dir.name)
    }
}

fun File.eachDir(block: (File) -> Unit) {
    listFiles()?.filter { it.isDirectory }?.forEach { block(it) }
}

// To only include a single project, comment out the previous lines (except the first one), and include your plugin like so:
// include("PluginName")



================================================
FILE: AllMovieLandProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 17


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Indian MultiLanguage Provider (Mostly Hindi)"
    language = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
        "Cartoon"
    )
    iconUrl = "https://raw.githubusercontent.com/LikDev-256/likdev256-tamil-providers/master/AllMovieLandProvider/icon.png"

    isCrossPlatform = true
}



================================================
FILE: AllMovieLandProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: AllMovieLandProvider/src/main/kotlin/com/phisher98/AllMovieLandProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.nicehttp.NiceResponse
import okhttp3.FormBody
import org.jsoup.nodes.Element
import java.net.URI

class AllMovieLandProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://allmovieland.io"
    override var name = "AllMovieLand"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Cartoon
    )

    private var playerDomain: String? = ""
    private var cookiesSSID: String? = ""
    private var cookies = mapOf<String, String>()
    private var tokenKey: String? = ""

    override val mainPage = mainPageOf(
        "$mainUrl/films/" to "Movies",
        "$mainUrl/bollywood/" to "Bollywood Movies",
        "$mainUrl/hollywood/" to "Hollywood Movies",
        "$mainUrl/series/" to "TV Shows",
        "$mainUrl/cartoon/" to "Cartoons"
    )

    private suspend fun querySearchApi(query: String): NiceResponse {
        val body = FormBody.Builder()
            .addEncoded("do", "search")
            .addEncoded("subaction", "search")
            .addEncoded("search_start", "0")
            .addEncoded("full_search", "0")
            .addEncoded("result_from", "1")
            .addEncoded("story", query)
            .build()

        return app.post(
            "$mainUrl/index.php?do=opensearch", //$mainUrl/engine/ajax/controller.php?mod=search
            requestBody = body,
            referer = "$mainUrl/",
            cookies = cookies
        )
    }

    private suspend fun getDlJson(link: String, url: String): String {
        val baseurl=getBaseUrl(link)
        val doc = app.get(link, referer = url).documentLarge
        val jsonString = Regex("""\{.*\}""").find(doc.select("body > script:last-child").toString())?.value.toString()
        val json = parseJson<Getfile>(jsonString)
        tokenKey = json.key
        val jsonfile=if (json.file.startsWith("http")) json.file else baseurl+json.file
        val m3u8Langs = app.post(
            jsonfile,
            referer = link,
            headers = mapOf(
                "X-CSRF-TOKEN" to "${json.key}",
            ),
        ).toString()
        return m3u8Langs.replace(Regex("(,)\\s*\\[]"), "")
    }

    private suspend fun getM3u8(file: String?): String {
        return app.post(
            "$playerDomain/playlist/$file.txt",
            headers = mapOf(
                "X-CSRF-TOKEN" to "$tokenKey",
            ),
            referer = "$mainUrl/"
        ).toString()
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        cookiesSSID = app.get("$mainUrl/").cookies["PHPSESSID"]
        cookies = mapOf(
            "PHPSESSID" to "$cookiesSSID"
        )
        val document = if (page == 1) {
            app.get(request.data, cookies = cookies).documentLarge
        } else {
            app.get(request.data + "/page/$page/", cookies = cookies).documentLarge
        }

        //Log.d("Document", request.data)
        val home = document.select("article.short-mid").mapNotNull {
                    it.toHomeSearchResult()
                }
        return newHomePageResponse(arrayListOf(HomePageList(request.name, home)), hasNext = true)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        //Log.d("mygodcookie",cookies.toString())
        val title = this.selectFirst("a > h3")?.text()?.trim() ?: return null
        //Log.d("mybatitle", title)
        val href = fixUrl(this.select("a").attr("href"))
        //Log.d("href", href)
        val posterUrl = fixUrlNull(mainUrl + this.select("div.new-short__poster > a.new-short__poster--link > img").attr("data-src"))
        //Log.d("mygodposterUrl", posterUrl.toString())
        val checkType = this.select("span.new-short__cats").text()
        //Log.d("mybacheck", checkType)
        val type = if (checkType.contains("films", true)) TvType.Movie
        else if (checkType.contains("series", true)) TvType.TvSeries
        else TvType.Cartoon
        return when (type) {
            TvType.Movie -> {
                newMovieSearchResponse(title, href, TvType.Movie) {
                    this.posterUrl = posterUrl
                    posterHeaders = cookies
                }
            }
            TvType.TvSeries -> {
                newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                    this.posterUrl = posterUrl
                    posterHeaders = cookies
                }
            }
            else -> {
                newMovieSearchResponse(title, href, TvType.Cartoon) {
                    this.posterUrl = posterUrl
                    posterHeaders = cookies
                }
            }
        }
    }

    private fun Element.toHomeSearchResult(): SearchResponse? {
        //Log.d("mygodcookie",cookies.toString())
        val title = this.selectFirst("a > h3")?.text()?.trim() ?: return null
        //Log.d("title", title)
        val href = fixUrl(this.select("a").attr("href"))
        //Log.d("href", href)
        val posterUrl = fixUrlNull(mainUrl + this.select("div.new-short__poster > a.new-short__poster--link > img").attr("data-src"))
        //Log.d("mygodposterUrl", posterUrl.toString())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            posterHeaders = cookies
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchList = querySearchApi(
            query
        ).documentLarge

        return searchList.select("article.short-mid").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get(url).documentLarge
        val title = doc.selectFirst("h1.fs__title")?.text()?.trim()
            ?: return null
        val poster = fixUrlNull(mainUrl + doc.selectFirst("img.fs__poster-img")?.attr("src"))
        val tags = doc.select("div.xfs__item--value[itemprop=genre] > a").map { it.text() }
        val yearRegex = Regex("(?<=\\()[\\d(\\]]+(?!=\\))")
        val year = yearRegex.find(title)?.value
            ?.toIntOrNull()
        val description = doc.select("div.fs__descr--text > p").joinToString {
            it.text().trim()
        }
        val isMovie    = tags.filter { it.contains("films", true) }.joinToString()
        val isTvSeries = tags.filter { it.contains("series", true) }.joinToString()
        //val isCartoon  = tags.filter { it.contains("cartoon", true) }.joinToString()
        //Log.d("mybaddesc", mycheckType.toString())
        val type = if (isMovie.contains("films", true)) TvType.Movie
        else if (isTvSeries.contains("series", true)) TvType.TvSeries
        else TvType.Cartoon
        val trailerLink = doc.select("#player > div").map {
            it.select("iframe").attr("src")
        }.filter { it.contains("youtube") }.joinToString()
        val trailer = fixUrlNull(trailerLink)
        val rating = doc.select("b.imdb__value").text().replace(",", ".")
        val duration =
            doc.select("li.xfs__item_op:nth-child(3) > b").text().removeSuffix(" min.").trim()
                .toIntOrNull()
        val actors =
            doc.select("div.xfs__item_op > b[itemprop=actors]").text().split(", ").map {
                ActorData(
                    Actor(it)
                )
            }
        val recommendations = doc.select("li.short-mid").mapNotNull {
            it.toSearchResult()
        }
        val idRegex = Regex("(src:.')+(\\D.*\\d)")
        val id = idRegex.find(doc.select("div.tabs__content script").toString())?.groups?.get(2)?.value
        // Automating awful player domain changes
        val playerScript = doc.select("script:containsData(AwsIndStreamDomain)").toString()

        val domainRegex = Regex("const AwsIndStreamDomain.*'(.*)';")
        playerDomain = domainRegex.find(playerScript)?.groups?.get(1)?.value
        val embedLink = "$playerDomain/play/$id"
        val jsonReceive = getDlJson(embedLink, url)
        var episodes: List<Episode> = listOf()
        var data = ""
        if (type == TvType.TvSeries) {
            if (jsonReceive.contains("folder", true)) {
                    //Log.d("mybadEmbed", jsonReceive)
                    episodes = parseJson<ArrayList<Seasons>>(jsonReceive).map { Seasons ->
                        val sNum = Seasons.id.toIntOrNull()
                        //Log.d("mybadSnum", Snum.toString())
                        Seasons.folder.map { ep ->
                            val eNum = ep.episode.toIntOrNull()
                            newEpisode(ep.folder.toJson())
                            {
                                this.name=ep.title
                                this.episode=eNum
                                this.season=sNum
                                this.posterUrl=poster
                            }
                        }
                    }.flatten()
                } else {
                    episodes = parseJson<Array<Extract>>(jsonReceive).map {
                        newEpisode(jsonReceive.toJson())
                        {
                            this.name="1 episode"
                            this.season=1
                            this.episode=1
                            this.posterUrl=poster
                        }
                    }
            }
        } else {
            data = jsonReceive.toJson()
        }

        return when (type) {
            TvType.Movie -> {
                newMovieLoadResponse(title, url, TvType.Movie, data) {
                    this.posterUrl = poster?.trim()
                    this.year = year
                    this.plot = description
                    this.tags = tags
                    this.score = Score.from100(rating)
                    this.duration = duration
                    this.actors = actors
                    this.recommendations = recommendations
                    addTrailer(trailer)
                }
            }
            TvType.TvSeries -> {
                newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                    this.posterUrl = poster?.trim()
                    this.year = year
                    this.plot = description
                    this.tags = tags
                    this.score = Score.from100(rating)
                    this.duration = duration
                    this.actors = actors
                    this.recommendations = recommendations
                    addTrailer(trailer)
                }
            }
            else -> {
                newMovieLoadResponse(title, url, TvType.Movie, data) {
                    this.posterUrl = poster?.trim()
                    this.year = year
                    this.plot = description
                    this.tags = tags
                    this.score = Score.from100(rating)
                    this.actors = actors
                    this.recommendations = recommendations
                    addTrailer(trailer)
                }
            }
        }
    }

    data class Getfile (
        @JsonProperty("file"       ) var file       : String,
        @JsonProperty("hls"        ) var hls        : Int?   ,
        @JsonProperty("id"         ) var id         : String?,
        @JsonProperty("cuid"       ) var cuid       : String?,
        @JsonProperty("key"        ) var key        : String?,
        @JsonProperty("movie"      ) var movie      : String?,
        @JsonProperty("host"       ) var host       : String?,
        @JsonProperty("masterId"   ) var masterId   : String?,
        @JsonProperty("masterHash" ) var masterHash : String?,
        @JsonProperty("userIp"     ) var userIp     : String?,
        @JsonProperty("poster"     ) var poster     : String?,
        @JsonProperty("href"       ) var href       : String,
        @JsonProperty("p2p"        ) var p2p        : Boolean?,
        @JsonProperty("rek"        ) var rek        : Any?,
        @JsonProperty("autoplay"   ) var autoplay   : Int?   ,
        @JsonProperty("domain"     ) var domain     : Any?,
        @JsonProperty("kp"         ) var kp         : String?,
    )

    data class Extract (
        @JsonProperty("title" ) var title : String?,
        @JsonProperty("id"    ) var id    : String?,
        @JsonProperty("file"  ) var file  : String?
    )

    data class Seasons (
        @JsonProperty("title"  ) var title  : String?,
        @JsonProperty("id"     ) var id     : String,
        @JsonProperty("folder" ) var folder : List<Episodes> = listOf()
    )

    data class Episodes (
        @JsonProperty("episode" ) var episode : String,
        @JsonProperty("title"   ) var title   : String?,
        @JsonProperty("id"      ) var id      : String?,
        @JsonProperty("folder"  ) var folder  : List<Files> = listOf()
    )

    data class Files (
        @JsonProperty("file"    ) var file   : String,
        @JsonProperty("end_tag" ) var endTag : String?,
        @JsonProperty("title"   ) var title  : String?,
        @JsonProperty("id"      ) var id     : String?
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        //Log.d("mybadembedlink", data)
        val m3u8Links = parseJson<List<Extract>>(data.replace(Regex("""\[],"""), ""))
        m3u8Links.forEach {
            safeApiCall {
                val headers = mapOf(
                    "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/144.0.0.0 Safari/537.36",
                    "Accept" to "*/*",
                    "Referer" to playerDomain.toString(),
                    "Origin" to playerDomain.toString()
                )

                M3u8Helper.generateM3u8(
                    "AllMovieLand-$lang",
                    getM3u8(it.file),
                    playerDomain.toString(),
                    headers = headers
                ).forEach(callback)
            }
        }
        return true
    }

    fun getBaseUrl(url: String): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }
}



================================================
FILE: AllMovieLandProvider/src/main/kotlin/com/phisher98/AllMovieLandProviderPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AllMovieLandProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AllMovieLandProvider())
    }
}



================================================
FILE: AllWish/build.gradle.kts
================================================
// use an integer for version numbers
version = 3


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Anime from all-wish.me"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1

    tvTypes = listOf("All")

    language = "en"

    // random cc logo i found
    iconUrl = "https://manga.all-wish.me/logo4.png"

    isCrossPlatform = true
}



================================================
FILE: AllWish/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: AllWish/src/main/kotlin/com/allwish/AllWish.kt
================================================
package com.allwish

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.AnimeSearchResponse
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addDubStatus
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

class AllWish : MainAPI() {
    override var mainUrl = AllWish.mainUrl
    override var name = AllWish.name
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val hasMainPage = true
    
    companion object {
        val mainUrl = "https://all-wish.me"
        var name = "AllWish"
        val xmlHeader = mapOf("X-Requested-With" to "XMLHttpRequest")
    }

    override val mainPage = mainPageOf(
        "$mainUrl/ajax/home/widget/trending?page=" to "Trending",
        "$mainUrl/ajax/home/widget/updated-sub?page=" to "Recently Updated (Sub)",
        "$mainUrl/ajax/home/widget/updated-dub?page=" to "Recently Updated (Dub)",
        "$mainUrl/ajax/home/widget/random?page=" to "Random Animes",
    )

    private fun searchResponseBuilder(res: Document): List<AnimeSearchResponse> {
        val results = mutableListOf<AnimeSearchResponse>()
        res.select("div.item").forEach { item ->
            val name = item.selectFirst("div.name > a")?.text() ?: ""
            val url = item.selectFirst("div.name > a")?.attr("href")?.substringBeforeLast("/") ?: ""
            val subCount = item.selectFirst("div.dub-sub-total > span.sub")?.text()?.toIntOrNull()
            val dubCount = item.selectFirst("div.dub-sub-total > span.dub")?.text()?.toIntOrNull()
            results += newAnimeSearchResponse(name, url) {
                this.posterUrl = item.selectFirst("a.poster img")?.attr("data-src")
                addDubStatus(dubCount != null, subCount != null, dubCount, subCount)
            }
        }
        return results
    }

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val res = app.get("$mainUrl/filter?keyword=$query&page=$page").documentLarge
        return searchResponseBuilder(res).toNewSearchResponseList()
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        val res = app.get(request.data + page.toString(), xmlHeader).parsedSafe<APIResponse>()
        return if (res?.status == 200) {
            val searchRes = searchResponseBuilder(res.html)
            newHomePageResponse(request.name, searchRes, true)
        } else null
    }

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun load(url: String): LoadResponse {
        val res = app.get(url).documentLarge
        val id = res.select("main > div.container").attr("data-id")

        val vrf = generateEpisodeVrf(id)
        val epRes = app.get("$mainUrl/ajax/episode/list/$id?vrf=$vrf", xmlHeader)
            .parsedSafe<APIResponse>()

        val malId = epRes?.html?.selectFirst("div.range > div > a")
            ?.attr("data-mal")?.toIntOrNull()

        val syncMetaData = app.get("https://api.ani.zip/mappings?mal_id=$malId").toString()
        val animeMetaData = parseAnimeData(syncMetaData)

        val data = res.selectFirst("div#media-info")
        val name = data?.selectFirst("h1.title")?.text()?.trim()?.replace(" (Dub)", "") ?: ""
        val posterRegex = Regex("/'(.*)'/gm")

        val (subEpisodes, dubEpisodes) = parseEpisodes(epRes, animeMetaData)
        val status = getStatus(data?.select("div:contains(Status:) > span > a")?.text()?.trim())
        val genres = data?.select("div:contains(Genre:) > span > a")?.map { it.text() }
        val content = data?.select("div.status > span.rating.mini-status")?.text()
        val year = data?.select("div:contains(Premiered:) > span > a")?.text()?.trim()?.substringAfterLast(" ")?.toIntOrNull()

        return newAnimeLoadResponse(name, url, TvType.Anime) {
            addEpisodes(DubStatus.Subbed, subEpisodes)
            addEpisodes(DubStatus.Dubbed, dubEpisodes)
            addMalId(malId)
            this.showStatus = status
            this.tags = genres
            this.plot = data?.selectFirst("div.description > div.full > div")?.text()?.trim()
            this.contentRating = content
            this.year = year
            this.backgroundPosterUrl = animeMetaData?.images
                ?.firstOrNull { it.coverType == "Fanart" }?.url
                ?: posterRegex.find(res.selectFirst("div.media-bg")?.attr("style") ?: "")
                    ?.destructured?.toList()?.getOrNull(0)
                        ?: data?.selectFirst("div.poster img")?.attr("src").orEmpty()
            this.posterUrl = data?.selectFirst("#media-info div.poster img")?.attr("src") ?: animeMetaData?.images
                ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }?.url
            this.year = data?.select("div.meta > div > span")
                ?.find { it.attr("itemprop") == "dateCreated" }
                ?.text()?.toIntOrNull()
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val type = data.replace("$mainUrl/", "").split("|")[0].split(",")
        val id = data.replace("$mainUrl/", "").split("|")[1]
        val res = app.get("$mainUrl/ajax/server/list?servers=$id", xmlHeader).parsedSafe<APIResponse>()

        if (res?.status == 200) {
            res.html.select("div.server-type").forEach { section ->
                val sectionType = section.attr("data-type") // sub/dub
                val isHardSub = section.selectFirst("span")?.text()?.contains("H-Sub", ignoreCase = true) ?: false

                if (type.contains(sectionType)) {
                    section.select("div.server-list > div.server").forEach { server ->
                        //val serverName = server.selectFirst("div > span")?.text() ?: ""
                        val dataId = server.attr("data-link-id")
                        val apiRes = app.get("$mainUrl/ajax/server?get=$dataId", xmlHeader)
                            .parsedSafe<APIResponseUrl>()
                        val realUrl = apiRes?.result?.url ?: ""

                        val epIdWithType = when {
                            sectionType == "dub" -> "[Dub]"
                            sectionType == "sub" && isHardSub -> "[Hard Sub]"
                            else -> "[Sub]"
                        }
                        loadExtractor(realUrl,epIdWithType,subtitleCallback,callback)
                    }
                }
            }
        }

        return true
    }

    data class APIResponse(
        @JsonProperty("status") val status: Int? = null,
        @JsonProperty("result") val result: String? = null,
        val html: Document = Jsoup.parse(result ?: "")
    )

    data class APIResponseUrl(
        @JsonProperty("status") val status: Int? = null,
        @JsonProperty("result") val result: ServerUrl? = null,
    )

    data class ServerUrl(
        @JsonProperty("url") val url: String? = null,
    )

    private fun createEpisode(
        animeMetaData: MetaAnimeData?,
        episodeNumber: Int,
        epId: String,
        isDub: Boolean,
        htmlTitle: String
    ): Episode {
        val epData = animeMetaData?.episodes?.get(episodeNumber.toString())
        val prefix = when {
            isDub -> "dub"
            epId.contains("|HSub") -> "hardsub"
            else -> "sub"
        }

        return newEpisode("$prefix|$epId") {
            this.episode = episodeNumber
            this.name = resolveTitle(epData, htmlTitle, episodeNumber)
            this.posterUrl = epData?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
            this.description = epData?.overview ?: "No summary available"
            this.score = Score.from10(epData?.rating)
            this.runTime = epData?.runtime
            this.addDate(epData?.airDateUtc)
        }
    }

    private fun resolveTitle(epData: MetaEpisode?, htmlTitle: String, episodeNumber: Int): String {
        val jsonTitle = epData?.title?.get("en")
            ?: epData?.title?.get("ja")
            ?: epData?.title?.get("x-jat")
            ?: htmlTitle
        return jsonTitle.ifBlank { "Episode $episodeNumber" }
    }

    private fun parseEpisodes(
        epRes: APIResponse?,
        animeMetaData: MetaAnimeData?
    ): Pair<List<Episode>, List<Episode>> {
        val subEpisodes = mutableListOf<Episode>()
        val dubEpisodes = mutableListOf<Episode>()

        if (epRes?.status == 200) {
            epRes.html.select("div.range > div > a").forEach { element ->
                val epId = element.attr("data-ids")
                val title = element.attr("title")
                val episodeNumber = element.attr("data-slug").toIntOrNull() ?: 0
                val hasSub = element.attr("data-sub") == "1"
                val hasDub = element.attr("data-dub") == "1"

                if (hasSub) {
                    subEpisodes += createEpisode(
                        animeMetaData,
                        episodeNumber,
                        epId,
                        isDub = false,
                        htmlTitle = "$title (Sub)"
                    )
                }

                if (hasDub) {
                    dubEpisodes += createEpisode(
                        animeMetaData,
                        episodeNumber,
                        epId,
                        isDub = true,
                        htmlTitle = "$title (Dub)"
                    )
                }
            }
        }

        return Pair(subEpisodes, dubEpisodes)
    }
}



================================================
FILE: AllWish/src/main/kotlin/com/allwish/AllWishPlugin.kt
================================================
package com.allwish

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AllWishPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(AllWish())
        registerExtractorAPI(MegaPlay())
        registerExtractorAPI(Zen())
    }
}



================================================
FILE: AllWish/src/main/kotlin/com/allwish/AllWishUtils.kt
================================================
package com.allwish

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.lagradost.cloudstream3.ShowStatus
import java.net.URLEncoder
import java.util.Base64

@RequiresApi(Build.VERSION_CODES.O)
fun generateEpisodeVrf(episodeId: String): String {
    // Secret key from JS
    val secretKey = "ysJhV6U27FVIjjuk"

    // 1. encodeURIComponent equivalent
    // FIX 1: URLEncoder.encode is not the same as JS encodeURIComponent.
    // It encodes space as '+' (not '%20') and also encodes other reserved chars '()*!~'.
    val encodedId = URLEncoder.encode(episodeId, "UTF-8")
        .replace("+", "%20")
        .replace("%21", "!")
        .replace("%27", "'")
        .replace("%28", "(")
        .replace("%29", ")")
        .replace("%7E", "~")
        .replace("%2A", "*")

    // 2. RC4-like transform
    val keyCodes = secretKey.map { it.code }
    val dataCodes = encodedId.map { it.code } // This is correct (maps char codes of the UTF-8 string)
    val n = IntArray(256) { it }
    var a = 0
    for (o in 0..255) {
        a = (a + n[o] + keyCodes[o % keyCodes.size]) % 256
        n[o] = n[a].also { n[a] = n[o] } // swap
    }

    val out = mutableListOf<Int>()
    var o = 0
    a = 0
    for (r in dataCodes.indices) {
        o = (o + 1) % 256
        // val e = n[o] // e is not used, but that's fine
        a = (a + n[o]) % 256
        n[o] = n[a].also { n[a] = n[o] }
        val k = n[(n[o] + n[a]) % 256]
        out.add(dataCodes[r] xor k)
    }
    val step1 = out.map { (it and 0xFF).toByte() }.toByteArray()

    // 3. Base64 URL safe
    // FIX 2: Use getUrlEncoder() which correctly uses '_' and '-'
    // AND importantly, it omits padding ('='), which your manual replace version did not.
    val base1 = Base64.getUrlEncoder().encodeToString(step1)

    // 4. Position-based transform
    val step2Bytes = base1.toByteArray(Charsets.ISO_8859_1) // This is fine
    val transformedList: List<Byte> = step2Bytes.mapIndexed { index, value ->
        var s = value.toInt()
        s += when (index % 8) {
            1 -> 3
            7 -> 5
            2 -> -4
            4 -> -2
            6 -> 4
            0 -> -3
            3 -> 2
            5 -> 5
            else -> 0
        }
        (s and 0xFF).toByte()
    }
    val transformedBytes = transformedList.toByteArray()

    // 5. Base64 URL safe again
    // FIX 2 (Applied again): Use getUrlEncoder()
    val base2 = Base64.getUrlEncoder().encodeToString(transformedBytes)

    // 6. ROT13 for letters
    val final = base2.map { c ->
        when (c) {
            in 'A'..'Z' -> 'A' + (c - 'A' + 13) % 26
            in 'a'..'z' -> 'a' + (c - 'a' + 13) % 26
            else -> c
        }
    }.joinToString("")

    return final
}

fun parseAnimeData(jsonString: String): MetaAnimeData? {
    return try {
        val objectMapper = ObjectMapper()
        objectMapper.readValue(jsonString, MetaAnimeData::class.java)
    } catch (_: Exception) {
        null // Return null for invalid JSON instead of crashing
    }
}


@JsonIgnoreProperties(ignoreUnknown = true)
data class ImageData(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaEpisode(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airdate") val airdate: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,
    @JsonProperty("length") val length: Int?,
    @JsonProperty("runtime") val runtime: Int?,
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)


@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>? = null,
    @JsonProperty("images") val images: List<ImageData>? = null,
    @JsonProperty("episodes") val episodes: Map<String, MetaEpisode>? = null,
)


fun getStatus(t: String?): ShowStatus {
    return when (t) {
        "Finished Airing" -> ShowStatus.Completed
        "Updating" -> ShowStatus.Ongoing
        else -> ShowStatus.Completed
    }
}


================================================
FILE: AllWish/src/main/kotlin/com/allwish/Extractors.kt
================================================
package com.allwish

import android.annotation.SuppressLint
import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


class MegaPlay : ExtractorApi() {
        override val name = "MegaPlay"
        override val mainUrl = "https://megaplay.buzz"
        override val requiresReferer = false

        @SuppressLint("NewApi")
        override suspend fun getUrl(
            url: String,
            referer: String?,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            val mainheaders = mapOf(
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
                "Accept" to "*/*",
                "Accept-Language" to "en-US,en;q=0.5",
                "Accept-Encoding" to "gzip, deflate, br, zstd",
                "Origin" to "https://megaplay.buzz",
                "Referer" to "https://megaplay.buzz/",
                "Connection" to "keep-alive",
                "Pragma" to "no-cache",
                "Cache-Control" to "no-cache"
            )

            try {
                // --- Primary API Method ---
                val headers = mapOf(
                    "Accept" to "*/*",
                    "X-Requested-With" to "XMLHttpRequest",
                    "Referer" to mainUrl
                )

                val id = app.get(url, headers = headers).documentLarge.selectFirst("#megaplay-player")?.attr("data-id")

                val apiUrl = "$mainUrl/stream/getSources?id=$id&id=$id"
                val gson = Gson()
                val response = try {
                    val json = app.get(apiUrl, headers).text
                    gson.fromJson(json, MegaPlay::class.java)
                } catch (_: Exception) {
                    null
                }

                val encoded = response?.sources?.file
                    ?: throw Exception("No sources found")

                val m3u8: String = encoded

                M3u8Helper.generateM3u8(name, m3u8, mainUrl, headers = mainheaders).forEach(callback)

                response.tracks.forEach { track ->
                    if (track.kind == "captions" || track.kind == "subtitles") {
                        subtitleCallback(newSubtitleFile(track.label, track.file))
                    }
                }
            } catch (e: Exception) {
                // --- Fallback using WebViewResolver ---
                Log.e("Megacloud", "Primary method failed, using fallback: ${e.message}")

                val jsToClickPlay = """
                (() => {
                    const btn = document.querySelector('.jw-icon-display.jw-button-color.jw-reset');
                    if (btn) { btn.click(); return "clicked"; }
                    return "button not found";
                })();
            """.trimIndent()

                val m3u8Resolver = WebViewResolver(
                    interceptUrl = Regex("""\.m3u8"""),
                    additionalUrls = listOf(Regex("""\.m3u8""")),
                    script = jsToClickPlay,
                    scriptCallback = { result -> Log.d("Megacloud", "JS Result: $result") },
                    useOkhttp = false,
                    timeout = 15_000L
                )

                val vttResolver = WebViewResolver(
                    interceptUrl = Regex("""\.vtt"""),
                    additionalUrls = listOf(Regex("""\.vtt""")),
                    script = jsToClickPlay,
                    scriptCallback = { result -> Log.d("Megacloud", "Subtitle JS Result: $result") },
                    useOkhttp = false,
                    timeout = 15_000L
                )

                try {
                    val vttResponse = app.get(url = url, referer = mainUrl, interceptor = vttResolver)
                    val subtitleUrls = listOf(vttResponse.url)
                        .filter { it.endsWith(".vtt") && !it.contains("thumbnails", ignoreCase = true) }
                    subtitleUrls.forEachIndexed { _, subUrl ->
                        subtitleCallback(newSubtitleFile("English", subUrl))
                    }

                    val fallbackM3u8 = app.get(url = url, referer = mainUrl, interceptor = m3u8Resolver).url
                    M3u8Helper.generateM3u8(name, fallbackM3u8, mainUrl, headers = mainheaders).forEach(callback)

                } catch (ex: Exception) {
                    Log.e("Megacloud", "Fallback also failed: ${ex.message}")
                }
            }
        }

        data class MegaPlay(
            val sources: Sources,
            val tracks: List<Track>,
            val t: Long,
            val intro: Intro,
            val outro: Outro,
            val server: Long,
        )

        data class Sources(
            val file: String,
        )

        data class Track(
            val file: String,
            val label: String,
            val kind: String,
            val default: Boolean?,
        )

        data class Intro(
            val start: Long,
            val end: Long,
        )

        data class Outro(
            val start: Long,
            val end: Long,
        )
    }

    class Zen : ExtractorApi() {
        override val name = "Zen"
        override val mainUrl = "https://player.sgsgsgsr.site"
        override val requiresReferer = false

        override suspend fun getUrl(
            url: String,
            referer: String?,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            val res = app.get(url).documentLarge
            val script = res.selectFirst("script[type=module]")?.data() ?: return

            val videoB64 = Regex("video_b64:\\s*\"([^\"]+)\"").find(script)?.groupValues?.get(1) ?: return
            val keyB64 = Regex("enc_key_b64:\\s*\"([^\"]+)\"").find(script)?.groupValues?.get(1) ?: return
            val ivB64 = Regex("iv_b64:\\s*\"([^\"]+)\"").find(script)?.groupValues?.get(1) ?: return

            val decryptedUrl = decryptVideoUrl(videoB64, keyB64, ivB64)
            if (decryptedUrl.isNullOrBlank()) return

            callback.invoke(
                newExtractorLink(
                    this.name,
                    this.name,
                    decryptedUrl.trim(),
                    ExtractorLinkType.M3U8
                )
                {
                    this.quality = Qualities.P1080.value
                }
            )

            val regex = Regex("subtitles:\\s\"(.*)\"")
            val match = regex.find(script)
            match?.groupValues?.get(1)?.let { rawSubs ->
                val jsonString = rawSubs.replace("\\\"", "\"")
                    .replace("\\\\/", "/")

                val mapper = com.fasterxml.jackson.module.kotlin.jacksonObjectMapper()
                val subsNode = mapper.readTree(jsonString)

                subsNode.forEach { sub ->
                    val subUrl = sub["url"]?.asText() ?: return@forEach
                    val lang = sub["language"]?.asText() ?: "Unknown"
                    val format = sub["format"]?.asText() ?: "srt"

                    if (format.equals("ass", ignoreCase = true)) {
                        subtitleCallback(newSubtitleFile(lang, subUrl))
                    }
                }
            }

        }

        private fun decryptVideoUrl(videoB64: String, keyB64: String, ivB64: String): String? {
            return try {
                val encryptedData = base64DecodeArray(videoB64)
                val keyBytes = base64DecodeArray(keyB64)
                val ivBytes = base64DecodeArray(ivB64)

                val secretKey = SecretKeySpec(keyBytes, "AES")
                val ivSpec = IvParameterSpec(ivBytes)
                val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")

                cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
                val decryptedBytes = cipher.doFinal(encryptedData)
                String(decryptedBytes, Charsets.UTF_8)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }
    }



================================================
FILE: Anichi/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 10

android {
    buildFeatures {
        buildConfig = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())

        buildConfigField("String", "ANICHI_API", "\"${properties.getProperty("ANICHI_API")}\"")
        buildConfigField("String", "ANICHI_SERVER", "\"${properties.getProperty("ANICHI_SERVER")}\"")
        buildConfigField("String", "ANICHI_ENDPOINT", "\"${properties.getProperty("ANICHI_ENDPOINT")}\"")
        buildConfigField("String", "ANICHI_APP", "\"${properties.getProperty("ANICHI_APP")}\"")
    }
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
     authors = listOf("Hexated,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "OVA",
    )
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Allanime.png"

    isCrossPlatform = true
}


================================================
FILE: Anichi/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Anichi/src/main/kotlin/com/Anichi/Anichi.kt
================================================
package com.Anichi

import android.annotation.SuppressLint
import com.Anichi.AnichiExtractors.invokeInternalSources
import com.Anichi.AnichiParser.AnichiLoadData
import com.Anichi.AnichiParser.AnichiQuery
import com.Anichi.AnichiParser.Detail
import com.Anichi.AnichiParser.Edges
import com.Anichi.AnichiParser.JikanResponse
import com.Anichi.AnichiUtils.aniToMal
import com.Anichi.AnichiUtils.getTracker
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorRole
import com.lagradost.cloudstream3.AnimeSearchResponse
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addDub
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.addSub
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import com.phisher98.BuildConfig
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import java.util.Calendar

open class Anichi : MainAPI() {
    override var name = "Anichi"
    override val instantLinkLoading = true
    override val hasQuickSearch = true
    override val hasMainPage = true

    private fun getStatus(t: String): ShowStatus {
        return when (t) {
            "Finished" -> ShowStatus.Completed
            "Releasing" -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }

    override val supportedSyncNames = setOf(SyncIdName.Anilist, SyncIdName.MyAnimeList)
    override val supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie)

    private val popularTitle = "Popular"
    private val animeRecentTitle = "Latest Anime"
    private val donghuaRecentTitle = "Latest Donghua"
    private val movieTitle = "Movie"
    val calendar: Calendar = Calendar.getInstance()
    val year = calendar.get(Calendar.YEAR)
    val month = calendar.get(Calendar.MONTH) + 1

    val season = when (month) {
        in 1..3 -> "Winter"
        in 4..6 -> "Spring"
        in 7..9 -> "Summer"
        else -> "Fall"
    }

    @SuppressLint("NewApi")
    override val mainPage = mainPageOf(
        """$apiUrl?variables={"search":{"season":"$season","year":$year},"limit":26,"page":1,"translationType":"sub","countryOrigin":"ALL"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$maipageshaHash"}}""" to "New Series",
        """$apiUrl?variables={"search":{},"limit":26,"page":1,"translationType":"sub","countryOrigin":"ALL"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$maipageshaHash"}}""" to animeRecentTitle,
        """$apiUrl?variables={"search":{},"limit":26,"page":1,"translationType":"sub","countryOrigin":"CN"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$maipageshaHash"}}""" to donghuaRecentTitle,
        """$apiUrl?variables={"type":"anime","size":30,"dateRange":1,"page":%d,"allowAdult":${settingsForProvider.enableAdult},"allowUnknown":false}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$popularHash"}}""" to popularTitle,
        """$apiUrl?variables={"search":{"types":["Movie"]},"limit":26,"page":1,"translationType":"sub","countryOrigin":"ALL"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$maipageshaHash"}}""" to movieTitle,
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {

        val url = request.data.format(page)
        val res = app.get(url, headers = headers).parsedSafe<AnichiQuery>()?.data
        val query = res?.shows ?: res?.queryPopular ?: res?.queryListForTag
        val card =
                if (request.name == popularTitle) query?.recommendations?.map { it.anyCard }
                else query?.edges
        val home =
                card
                        ?.filter {
                            // filtering in case there is an anime with 0 episodes available on the
                            // site.
                            !(it?.availableEpisodes?.raw == 0 &&
                                    it.availableEpisodes.sub == 0 &&
                                    it.availableEpisodes.dub == 0)
                        }
                        ?.mapNotNull { media -> media?.toSearchResponse() }
                        ?: emptyList()
        return newHomePageResponse(
                list =
                        HomePageList(
                                name = request.name,
                                list = home,
                        ),
                hasNext = request.name != movieTitle
        )
    }

    private fun Edges.toSearchResponse(): AnimeSearchResponse? {
        val posterUrl = if (thumbnail?.startsWith("http") == true) thumbnail else "https://wp.youtube-anime.com/aln.youtube-anime.com/$thumbnail"
        return newAnimeSearchResponse(
                name ?: englishName ?: nativeName ?: "",
                Id ?: return null,
                fix = false
        ) {
            this.posterUrl = posterUrl
            this.year = airedStart?.year
            this.otherName = englishName
            addDub(availableEpisodes?.dub)
            addSub(availableEpisodes?.sub)
        }
    }
    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(
        withContext(
            Dispatchers.IO
        ) {
            URLEncoder.encode(query, StandardCharsets.UTF_8.toString())
        },1
    )?.items

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val encodedQuery = withContext(Dispatchers.IO) {
            URLEncoder.encode(query, StandardCharsets.UTF_8.toString())
        }
        val link =
                """$apiUrl?variables={"search":{"query":"$encodedQuery"},"limit":26,"page":$page,"translationType":"sub","countryOrigin":"ALL"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$maipageshaHash"}}"""
        val res: String =
            app.get(link, headers = headers).text.takeUnless {
                it.contains("PERSISTED_QUERY_NOT_FOUND")
            }
                ?: app.get(link, headers = headers).text.takeUnless {
                    it.contains("PERSISTED_QUERY_NOT_FOUND")
                }
                ?: return null

        val response = parseJson<AnichiQuery>(res)

        val results =
                response.data?.shows?.edges?.filter {
                    // filtering in case there is an anime with 0 episodes available on the site.
                    !(it.availableEpisodes?.raw == 0 &&
                            it.availableEpisodes.sub == 0 &&
                            it.availableEpisodes.dub == 0)
                }

        return results?.map {
            val posterUrl = if (it.thumbnail?.startsWith("http") == true) it.thumbnail else "https://wp.youtube-anime.com/aln.youtube-anime.com/${it.thumbnail}"
            newAnimeSearchResponse(it.name ?: "", "${it.Id}", fix = false) {
                this.posterUrl = posterUrl
                this.year = it.airedStart?.year
                this.otherName = it.englishName
                addDub(it.availableEpisodes?.dub)
                addSub(it.availableEpisodes?.sub)
            }
        }?.toNewSearchResponseList()
    }

    override suspend fun getLoadUrl(name: SyncIdName, id: String): String? {
        val syncId = id.split("/").last()
        val malId =
                if (name == SyncIdName.MyAnimeList) {
                    syncId
                } else {
                    aniToMal(syncId)
                }
        val media = app.get("$jikanApi/anime/$malId").parsedSafe<JikanResponse>()?.data
        val link = """$apiUrl?variables={"search":{"allowAdult":false,"allowUnknown":false,"query":"${media?.title}"},"limit":26,"page":1,"translationType":"sub","countryOrigin":"ALL"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$mainHash"}}"""
        val res = app.get(link, headers = headers).parsedSafe<AnichiQuery>()?.data?.shows?.edges
        return res
                ?.find {
                    (it.name.equals(media?.title, true) ||
                            it.englishName.equals(media?.title_english, true) ||
                            it.nativeName.equals(media?.title_japanese, true)) &&
                            it.airedStart?.year == media?.year
                }
                ?.Id
    }

    override suspend fun load(url: String): LoadResponse? {
        val id = url.substringAfterLast("/")

        // lazy to format
        val body =
                """
        {
            "query": "                        query(\n                      ${'$'}_id: String!\n                    ) {\n                      show(\n                        _id: ${'$'}_id\n                      ) {\n                          _id\n                          name\n                          description\n                          thumbnail\n                          thumbnails\n                          lastEpisodeInfo\n                          lastEpisodeDate       \n                          type\n                          genres\n                          score\n                          status\n                          season\n                          altNames  \n                          averageScore\n                          rating\n                          episodeCount\n                          episodeDuration\n                          broadcastInterval\n                          banner\n                          airedEnd\n                          airedStart \n                          studios\n                          characters\n                          availableEpisodesDetail\n                          availableEpisodes\n                          prevideos\n                          nameOnlyString\n                          relatedShows\n                          relatedMangas\n                          musics\n                          isAdult\n                          \n                          tags\n                          countryOfOrigin\n\n                          pageStatus{\n                            _id\n                            notes\n                            pageId\n                            showId\n                            \n                              # ranks:[Object]\n    views\n    likesCount\n    commentCount\n    dislikesCount\n    reviewCount\n    userScoreCount\n    userScoreTotalValue\n    userScoreAverValue\n    viewers{\n        firstViewers{\n          viewCount\n          lastWatchedDate\n        user{\n          _id\n          displayName\n          picture\n          # description\n          hideMe\n          # createdAt\n          # badges\n          brief\n        }\n      \n      }\n      recViewers{\n        viewCount\n          lastWatchedDate\n        user{\n          _id\n          displayName\n          picture\n          # description\n          hideMe\n          # createdAt\n          # badges\n          brief\n        }\n      \n      }\n      }\n\n                        }\n                      }\n                    }",
            "extensions": "{\"persistedQuery\":{\"version\":1,\"sha256Hash\":\"$detailHash\"}}",
            "variables": "{\"_id\":\"$id\"}"
        }
    """
                        .trimIndent()
                        .trim()
                        .toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())
        val res = app.post(apiUrl, requestBody = body, headers = headers)
        val showData = res.parsedSafe<Detail>()?.data?.show ?: return null

        val title = showData.name
        val description = showData.description

        val trackers =
                getTracker(
                        title,
                        showData.altNames?.firstOrNull(),
                        showData.airedStart?.year,
                        showData.season?.quarter,
                        showData.type
                )
        val data = anilistAPICall(
            "query (\$id: Int = ${trackers?.id}) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore status bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")


        val syncData = app.get("https://api.ani.zip/mappings?mal_id=${trackers?.idMal}").toString()
        val animeMetadata = parseAnimeData(syncData)

        val backgroundposter = data.bannerImage ?: trackers?.coverImage?.large

        val logotvType = if (showData.type?.contains("movie", ignoreCase = true) == true) TvType.AnimeMovie else TvType.Anime

        val tmdbid = animeMetadata?.mappings?.themoviedbId?.toIntOrNull()

        val logoUrl = fetchTmdbLogoUrl(
            tmdbAPI = "https://api.themoviedb.org/3",
            apiKey = "98ae14df2b8d8f8f8136499daf79f0e0",
            type = logotvType,
            tmdbId = tmdbid,
            appLangCode = "en"
        )

        val poster = showData.thumbnail
        val episodes = showData.availableEpisodesDetail?.let { detail ->
            val id = showData.Id ?: return@let null

            // 🔹 Helper to safely get episode metadata
            fun getEpMeta(epNum: Int?): EpisodeInfo? =
                epNum?.let { animeMetadata?.episodes?.get(it.toString()) }

            val sub = detail.sub.map { eps ->
                val epNum = eps.toIntOrNull()
                val meta = getEpMeta(epNum)

                newEpisode(
                    AnichiLoadData(id, "sub", eps, trackers?.idMal).toJson()
                ) {
                    this.episode = epNum
                    this.name = meta?.title?.get("en") ?: meta?.title?.get("ja") ?: meta?.title?.get("x-jat") ?: "Episode $eps"
                    this.score = Score.from10(meta?.rating)
                    this.posterUrl = meta?.image ?: showData.thumbnail
                    this.description = meta?.overview ?: "No summary available"
                    this.addDate(meta?.airDateUtc)
                    this.runTime = meta?.runtime
                }
            }

            val dub = detail.dub.map { eps ->
                val epNum = eps.toIntOrNull()
                val meta = getEpMeta(epNum)
                newEpisode(
                    AnichiLoadData(id, "dub", eps, trackers?.idMal).toJson()
                ) {
                    this.episode = epNum
                    this.name = meta?.title?.get("en") ?: meta?.title?.get("ja") ?: meta?.title?.get("x-jat") ?: "Episode $eps"
                    this.score = Score.from10(meta?.rating)
                    this.posterUrl = meta?.image ?: showData.thumbnail
                    this.description = meta?.overview ?: "No summary available"
                    this.addDate(meta?.airDateUtc)
                    this.runTime = meta?.runtime
                }
            }

            Pair(sub.reversed(), dub.reversed())
        }

        val (subEpisodes, dubEpisodes) = episodes ?: Pair(emptyList(), emptyList())
        val characters =
                showData.characters?.map {
                    val role =
                            when (it.role) {
                                "Main" -> ActorRole.Main
                                "Supporting" -> ActorRole.Supporting
                                "Background" -> ActorRole.Background
                                else -> null
                            }
                    val name = it.name?.full ?: it.name?.native ?: ""
                    val image = it.image?.large ?: it.image?.medium
                    Pair(Actor(name, image), role)
                }

        val tvType = if (showData.type?.contains("movie", ignoreCase = true) == true) TvType.AnimeMovie else TvType.Anime

        return newAnimeLoadResponse(title ?: "", url, tvType) {
            this.engName = showData.altNames?.firstOrNull()
            this.posterUrl = poster ?: trackers?.coverImage?.extraLarge ?: trackers?.coverImage?.large
            this.backgroundPosterUrl = backgroundposter ?: trackers?.coverImage?.extraLarge
            try { this.logoUrl = logoUrl } catch(_:Throwable){}
            this.score = Score.from100(showData.averageScore)
            this.tags = showData.genres
            this.year = showData.airedStart?.year
            this.duration = showData.episodeDuration?.div(60_000)
            addTrailer(
                    showData.prevideos.filter { it.isNotBlank() }.map {
                        "https://www.youtube.com/watch?v=$it"
                    }
            )
            addEpisodes(DubStatus.Subbed, subEpisodes)
            addEpisodes(DubStatus.Dubbed, dubEpisodes)
            addActors(characters)
            // this.recommendations = recommendations

            showStatus = getStatus(showData.status.toString())
            addMalId(trackers?.idMal)
            addAniListId(trackers?.id)
            plot = description?.replace(Regex("""<(.*?)>"""), "")
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {

        val loadData = parseJson<AnichiLoadData>(data)
        invokeInternalSources(
                loadData.hash,
                loadData.dubStatus,
                loadData.episode,
                subtitleCallback,
                callback
        )

        return true
    }

    companion object {
        const val apiUrl = BuildConfig.ANICHI_API
        //const val serverUrl = BuildConfig.ANICHI_SERVER
        const val apiEndPoint = BuildConfig.ANICHI_ENDPOINT

        const val anilistApi = "https://graphql.anilist.co"
        const val jikanApi = "https://api.jikan.moe/v4"

        private const val mainHash =
                "e42a4466d984b2c0a2cecae5dd13aa68867f634b16ee0f17b380047d14482406"
        private const val popularHash =
                "31a117653812a2547fd981632e8c99fa8bf8a75c4ef1a77a1567ef1741a7ab9c"
        //private const val slugHash = "bf603205eb2533ca21d0324a11f623854d62ed838a27e1b3fcfb712ab98b03f4"
        private const val detailHash =
                "bb263f91e5bdd048c1c978f324613aeccdfe2cbc694a419466a31edb58c0cc0b"
        const val serverHash = "5f1a64b73793cc2234a389cf3a8f93ad82de7043017dd551f38f65b89daa65e0"
        const val maipageshaHash="06327bc10dd682e1ee7e07b6db9c16e9ad2fd56c1b769e47513128cd5c9fc77a"
        val headers =
                mapOf(
                        "app-version" to "android_c-247",
                        "from-app" to BuildConfig.ANICHI_APP,
                        "platformstr" to "android_c",
                        "Referer" to "https://allmanga.to"
                )
    }
}



================================================
FILE: Anichi/src/main/kotlin/com/Anichi/AnichiExtractors.kt
================================================
package com.Anichi

import com.Anichi.AnichiParser.AnichiVideoApiResponse
import com.Anichi.AnichiParser.LinksQuery
import com.Anichi.AnichiUtils.fixSourceUrls
import com.Anichi.AnichiUtils.fixUrlPath
import com.Anichi.AnichiUtils.getHost
import com.Anichi.AnichiUtils.getM3u8Qualities
import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.getPacked
import com.lagradost.cloudstream3.utils.httpsify
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import java.net.URI

object AnichiExtractors : Anichi() {

    fun invokeInternalSources(
        hash: String,
        dubStatus: String,
        episode: String,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ) = runBlocking {
        val fullApiUrl = """$apiUrl?variables={"showId":"$hash","translationType":"$dubStatus","episodeString":"$episode"}&extensions={"persistedQuery":{"version":1,"sha256Hash":"$serverHash"}}"""

        val apiResponse = try {
            app.get(fullApiUrl, headers = headers).parsed<LinksQuery>()
        } catch (e: Exception) {
            e.printStackTrace()
            return@runBlocking
        }

        val sources = apiResponse.data?.episode?.sourceUrls ?: return@runBlocking

        sources.forEach { source ->
            launch {
                safeApiCall {
                    Log.d("Phisher", "${source.sourceName} ${source.sourceUrl}")

                    val rawLink = source.sourceUrl ?: return@safeApiCall
                    val link = fixSourceUrls(rawLink, source.sourceName) ?: return@safeApiCall

                    if (URI(link).isAbsolute || link.startsWith("//")) {
                        val fixedLink = if (link.startsWith("//")) "https:$link" else link
                        loadCustomExtractor(
                            "Allanime",
                            fixedLink,
                            "",
                            subtitleCallback,
                            callback
                        )
                        loadExtractor(fixedLink, subtitleCallback, callback)
                        /*
                        when {
                            URI(fixedLink).path.contains(".m3u") -> {
                                getM3u8Qualities(fixedLink, serverUrl, host).forEach(callback)
                            }
                            else -> {

                            }
                        }
                         */
                    } else {
                        val decodedlink=if (link.startsWith("--"))
                        {
                            decrypthex(link)
                        }
                        else link
                        val fixedLink = decodedlink.fixUrlPath()
                        val links = try {
                            app.get(fixedLink, headers=headers).parsedSafe<AnichiVideoApiResponse>()?.links ?: emptyList()
                        } catch (e: Exception) {
                            e.printStackTrace()
                            return@safeApiCall
                        }
                        links.forEach { server ->
                            val host = server.link.getHost()
                            when {
                                source.sourceName?.contains("Default") == true &&
                                        (server.resolutionStr == "SUB" || server.resolutionStr == "Alt vo_SUB") -> {
                                    getM3u8Qualities(
                                        server.link,
                                        "https://static.crunchyroll.com/",
                                        host
                                    ).forEach(callback)
                                }

                                server.hls == null -> {
                                    callback.invoke(
                                        newExtractorLink(
                                            "Allanime ${host.capitalize()}",
                                            "Allanime ${host.capitalize()}",
                                            server.link,
                                            INFER_TYPE
                                        )
                                        {
                                            this.quality=Qualities.P1080.value
                                        }
                                    )
                                }

                                server.hls == true -> {
                                    val endpoint = "$apiEndPoint/player?uri=" +
                                            (if (URI(server.link).host.isNotEmpty())
                                                server.link
                                            else apiEndPoint + URI(server.link).path)

                                    getM3u8Qualities(server.link, server.headers?.referer ?: endpoint, host).forEach(callback)
                                }

                                else -> {
                                    server.subtitles?.forEach { sub ->
                                        val lang = SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang.orEmpty()
                                        val src = sub.src ?: return@forEach
                                        subtitleCallback(newSubtitleFile(lang, httpsify(src)))
                                    }
                                }
                            }
                        }
                    }
                }

                // Handle AllAnime direct download

                val downloadUrl = source.downloads?.downloadUrl
                if (!downloadUrl.isNullOrEmpty() && downloadUrl.startsWith("http")) {
                    val downloadId = downloadUrl.substringAfter("id=", "")
                    if (downloadId.isNotEmpty()) {
                        val sourcename = downloadUrl.getHost()
                        val clockApi = "https://allanime.day/apivtwo/clock.json?id=$downloadId"
                        try {
                            val downloads = app.get(clockApi).parsedSafe<AnichiDownload>()?.links ?: emptyList()
                            downloads.forEach { item ->
                                callback.invoke(
                                    newExtractorLink(
                                        "Allanime [${dubStatus.uppercase()}] [$sourcename]",
                                        "Allanime [${dubStatus.uppercase()}] [$sourcename]",
                                        item.link,
                                        INFER_TYPE
                                    )
                                    {
                                        this.quality=Qualities.P1080.value
                                    }
                                )
                            }
                        } catch (e: Exception) {
                            e.printStackTrace()
                        }
                    }
                }
            }
        }
    }

    private fun decrypthex(inputStr: String): String {
        val hexString = if (inputStr.startsWith("-")) {
            inputStr.substringAfterLast("-")
        } else {
            inputStr
        }

        val bytes = ByteArray(hexString.length / 2) { i ->
            val hexByte = hexString.substring(i * 2, i * 2 + 2)
            (hexByte.toInt(16) and 0xFF).toByte()
        }

        return bytes.joinToString("") { (it.toInt() xor 56).toChar().toString() }
    }

}

class swiftplayers : StreamWishExtractor() {
    override var mainUrl = "https://swiftplayers.com"
    override var name = "StreamWish"
}


open class StreamWishExtractor : ExtractorApi() {
    override val name = "Streamwish"
    override val mainUrl = "https://streamwish.to"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Accept" to "*/*",
            "Connection" to "keep-alive",
            "Sec-Fetch-Dest" to "empty",
            "Sec-Fetch-Mode" to "cors",
            "Sec-Fetch-Site" to "cross-site",
            "Referer" to "$mainUrl/",
            "Origin" to "$mainUrl/",
            "User-Agent" to USER_AGENT
        )

        val response = app.get(getEmbedUrl(url), referer = referer)

        val script = when {
            !getPacked(response.text).isNullOrEmpty() -> getAndUnpack(response.text)
            response.documentLarge.select("script").any { it.html().contains("jwplayer(\"vplayer\").setup(") } ->
                response.documentLarge.select("script").firstOrNull {
                    it.html().contains("jwplayer(\"vplayer\").setup(")
                }?.html()
            else -> response.documentLarge.selectFirst("script:containsData(sources:)")?.data()
        }

        var m3u8: String? = null
        if (script != null) {
            m3u8 = Regex("file:\\s*\"(.*?m3u8.*?)\"").find(script)?.groupValues?.getOrNull(1)
        }

        if (m3u8 != null) {
            M3u8Helper.generateM3u8(
                name,
                m3u8,
                mainUrl,
                headers = headers
            ).forEach(callback)
        } else {
            val m3u8Resolver = WebViewResolver(
                interceptUrl = Regex("""txt|m3u8"""),
                additionalUrls = listOf(Regex("""txt|m3u8""")),
                useOkhttp = false,
                timeout = 15_000L
            )


            val intercepted = app.get(
                url,
                referer = referer,
                interceptor = m3u8Resolver
            ).url

            if (intercepted.isNotEmpty()) {
                M3u8Helper.generateM3u8(
                    name,
                    intercepted,
                    mainUrl,
                    headers = headers
                ).forEach(callback)
            } else {
                Log.d("Error:", "No m3u8 found in fallback either.")
            }
        }
    }

    private fun getEmbedUrl(url: String): String {
        return if (url.contains("/f/")) {
            val videoId = url.substringAfter("/f/")
            "$mainUrl/$videoId"
        } else {
            url
        }
    }
}


class FilemoonV2 : ExtractorApi() {
    override var name = "Filemoon"
    override var mainUrl = "https://filemoon.to"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Referer" to url,
            "Sec-Fetch-Dest" to "iframe",
            "Sec-Fetch-Mode" to "navigate",
            "Sec-Fetch-Site" to "cross-site",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64; rv:137.0) Gecko/20100101 Firefox/137.0"
        )


        val href = app.get(url,headers).documentLarge.selectFirst("iframe")?.attr("src") ?: ""
        val scriptContent = app.get(
            href,
            headers = mapOf("Accept-Language" to "en-US,en;q=0.5", "sec-fetch-dest" to "iframe")
        ).documentLarge.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()

        val m3u8 = JsUnpacker(scriptContent).unpack()?.let { unpacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unpacked)?.groupValues?.get(1)
        }

        if (m3u8 != null) {
            M3u8Helper.generateM3u8(
                name,
                m3u8,
                mainUrl,
                headers = headers
            ).forEach(callback)
        } else {
            val resolver = WebViewResolver(
                interceptUrl = Regex("""(m3u8|master\.txt)"""),
                additionalUrls = listOf(Regex("""(m3u8|master\.txt)""")),
                useOkhttp = false,
                timeout = 15_000L
            )

            val m3u82 = app.get(
                href,
                referer = referer,
                interceptor = resolver
            ).url

            if (m3u82.isNotEmpty()) {
                M3u8Helper.generateM3u8(
                    name,
                    m3u82,
                    mainUrl,
                    headers = headers
                ).forEach(callback)
            } else {
                Log.d("Error", "No m3u8 intercepted in fallback.")
            }
        }
    }
}



================================================
FILE: Anichi/src/main/kotlin/com/Anichi/AnichiParser.kt
================================================
package com.Anichi

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty

object AnichiParser {

    data class AnichiLoadData(
            val hash: String,
            val dubStatus: String,
            val episode: String,
            val idMal: Int? = null,
    )

    data class JikanData(
            @JsonProperty("title") val title: String? = null,
            @JsonProperty("title_english") val title_english: String? = null,
            @JsonProperty("title_japanese") val title_japanese: String? = null,
            @JsonProperty("year") val year: Int? = null,
            @JsonProperty("season") val season: String? = null,
            @JsonProperty("type") val type: String? = null,
    )

    data class JikanResponse(
            @JsonProperty("data") val data: JikanData? = null,
    )

    data class IdMal(
            @JsonProperty("idMal") val idMal: String? = null,
    )

    data class MediaAni(
            @JsonProperty("Media") val media: IdMal? = null,
    )

    data class DataAni(
            @JsonProperty("data") val data: MediaAni? = null,
    )

    data class CoverImage(
            @JsonProperty("extraLarge") var extraLarge: String? = null,
            @JsonProperty("large") var large: String? = null,
    )

    data class AniMedia(
            @JsonProperty("id") var id: Int? = null,
            @JsonProperty("idMal") var idMal: Int? = null,
            @JsonProperty("coverImage") var coverImage: CoverImage? = null,
            @JsonProperty("bannerImage") var bannerImage: String? = null,
    )

    data class AniPage(@JsonProperty("media") var media: ArrayList<AniMedia> = arrayListOf())

    data class AniData(@JsonProperty("Page") var Page: AniPage? = AniPage())

    data class AniSearch(@JsonProperty("data") var data: AniData? = AniData())

    data class AkIframe(
            @JsonProperty("idUrl") val idUrl: String? = null,
    )

    data class Stream(
            @JsonProperty("format") val format: String? = null,
            @JsonProperty("audio_lang") val audio_lang: String? = null,
            @JsonProperty("hardsub_lang") val hardsub_lang: String? = null,
            @JsonProperty("url") val url: String? = null,
    )

    data class PortData(
            @JsonProperty("streams") val streams: ArrayList<Stream>? = arrayListOf(),
    )

    data class Subtitles(
            @JsonProperty("lang") val lang: String?,
            @JsonProperty("label") val label: String?,
            @JsonProperty("src") val src: String?,
    )

    data class Links(
        @JsonProperty("link") val link: String,
        @JsonProperty("hls") val hls: Boolean? = null,
        @JsonProperty("resolutionStr") val resolutionStr: String,
        @JsonProperty("src") val src: String? = null,
        @JsonProperty("headers") val headers: Headers? = null,
        @JsonProperty("portData") val portData: PortData? = null,
        @JsonProperty("subtitles") val subtitles: ArrayList<Subtitles>? = arrayListOf(),
    )

    data class Headers(
        @JsonProperty("Referer") val referer: String? = null,
        @JsonProperty("Origin") val origin: String? = null,
        @JsonProperty("user-agent") val userAgent: String? = null,
    )


    data class AnichiVideoApiResponse(@JsonProperty("links") val links: List<Links>)

    data class Data(
            @JsonProperty("shows") val shows: Shows? = null,
            @JsonProperty("queryListForTag") val queryListForTag: Shows? = null,
            @JsonProperty("queryPopular") val queryPopular: Shows? = null,
    )

    data class Shows(
            @JsonProperty("edges") val edges: List<Edges>? = arrayListOf(),
            @JsonProperty("recommendations") val recommendations: List<EdgesCard>? = arrayListOf(),
    )

    data class EdgesCard(
            @JsonProperty("anyCard") val anyCard: Edges? = null,
    )

    data class CharacterImage(
            @JsonProperty("large") val large: String?,
            @JsonProperty("medium") val medium: String?
    )

    data class CharacterName(
            @JsonProperty("full") val full: String?,
            @JsonProperty("native") val native: String?
    )

    data class Characters(
            @JsonProperty("image") val image: CharacterImage?,
            @JsonProperty("role") val role: String?,
            @JsonProperty("name") val name: CharacterName?,
    )

    data class Edges(
            @JsonProperty("_id") val Id: String?,
            @JsonProperty("name") val name: String?,
            @JsonProperty("englishName") val englishName: String?,
            @JsonProperty("nativeName") val nativeName: String?,
            @JsonProperty("thumbnail") val thumbnail: String?,
            @JsonProperty("type") val type: String?,
            @JsonProperty("season") val season: Season?,
            @JsonProperty("score") val score: Double?,
            @JsonProperty("airedStart") val airedStart: AiredStart?,
            @JsonProperty("availableEpisodes") val availableEpisodes: AvailableEpisodes?,
            @JsonProperty("availableEpisodesDetail")
            val availableEpisodesDetail: AvailableEpisodesDetail?,
            @JsonProperty("studios") val studios: List<String>?,
            @JsonProperty("genres") val genres: List<String>?,
            @JsonProperty("averageScore") val averageScore: Int?,
            @JsonProperty("characters") val characters: List<Characters>?,
            @JsonProperty("altNames") val altNames: List<String>?,
            @JsonProperty("description") val description: String?,
            @JsonProperty("status") val status: String?,
            @JsonProperty("banner") val banner: String?,
            @JsonProperty("episodeDuration") val episodeDuration: Int?,
            @JsonProperty("prevideos") val prevideos: List<String> = emptyList(),
    )

    data class AvailableEpisodes(
            @JsonProperty("sub") val sub: Int,
            @JsonProperty("dub") val dub: Int,
            @JsonProperty("raw") val raw: Int
    )

    data class AiredStart(
            @JsonProperty("year") val year: Int,
            @JsonProperty("month") val month: Int,
            @JsonProperty("date") val date: Int
    )

    data class Season(
            @JsonProperty("quarter") val quarter: String,
            @JsonProperty("year") val year: Int
    )

    data class AnichiQuery(@JsonProperty("data") val data: Data? = null)

    data class Detail(@JsonProperty("data") val data: DetailShow)

    data class DetailShow(@JsonProperty("show") val show: Edges)

    data class AvailableEpisodesDetail(
            @JsonProperty("sub") val sub: List<String>,
            @JsonProperty("dub") val dub: List<String>,
            @JsonProperty("raw") val raw: List<String>
    )

    data class LinksQuery(@JsonProperty("data") val data: LinkData? = LinkData())

    data class LinkData(@JsonProperty("episode") val episode: Episode? = Episode())

    data class SourceUrls(
        @JsonProperty("sourceUrl") val sourceUrl: String? = null,
        @JsonProperty("downloads") val downloads: Downloads? = null,
        @JsonProperty("priority") val priority: Double? = null, // 5.5 is a Float/Double
        @JsonProperty("sourceName") val sourceName: String? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("className") val className: String? = null,
        @JsonProperty("streamerId") val streamerId: String? = null
    )

    data class Downloads(
        @JsonProperty("sourceName") val sourceName: String? = null,
        @JsonProperty("downloadUrl") val downloadUrl: String? = null
    )

    data class Episode(
            @JsonProperty("sourceUrls") val sourceUrls: ArrayList<SourceUrls> = arrayListOf(),
    )

}


@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaMappings(
    @JsonProperty("themoviedb_id") val themoviedbId: String? = null,
    @JsonProperty("thetvdb_id") val thetvdbId: Int? = null,
    @JsonProperty("imdb_id") val imdbId: String? = null,
    @JsonProperty("mal_id") val malId: Int? = null,
    @JsonProperty("anilist_id") val anilistId: Int? = null,
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class Image(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class EpisodeInfo(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,  // Keeping only one field
    @JsonProperty("runtime") val runtime: Int?,     // Keeping only one field
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>?,
    @JsonProperty("images") val images: List<Image>?,
    @JsonProperty("episodes") val episodes: Map<String, EpisodeInfo>?,
    @JsonProperty("mappings") val mappings: MetaMappings? = null
)

data class AnichiDownload(
    val links: List<AnichiDownloadLink>,
)

data class AnichiDownloadLink(
    val link: String,
    val hls: Boolean,
    val mp4: Boolean?,
    val resolutionStr: String,
    val priority: Long,
    val src: String?,
)


================================================
FILE: Anichi/src/main/kotlin/com/Anichi/AnichiPlugin.kt
================================================
package com.Anichi

import com.lagradost.cloudstream3.extractors.Okrulink
import com.lagradost.cloudstream3.extractors.Vidguardto2
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnichiPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(Anichi())
        registerExtractorAPI(swiftplayers())
        registerExtractorAPI(StreamWishExtractor())
        registerExtractorAPI(FilemoonV2())
        registerExtractorAPI(Vidguardto2())
        registerExtractorAPI(Okrulink())
    }
}



================================================
FILE: Anichi/src/main/kotlin/com/Anichi/AnichiUtils.kt
================================================
package com.Anichi

import com.Anichi.Anichi.Companion.anilistApi
import com.Anichi.Anichi.Companion.apiEndPoint
import com.Anichi.AnichiParser.AkIframe
import com.Anichi.AnichiParser.AniMedia
import com.Anichi.AnichiParser.AniSearch
import com.Anichi.AnichiParser.DataAni
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixTitle
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.net.URI
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

object AnichiUtils {

    suspend fun getTracker(
            name: String?,
            altName: String?,
            year: Int?,
            season: String?,
            type: String?
    ): AniMedia? {
        return fetchId(name, year, season, type).takeIf { it?.id != null }
                ?: fetchId(altName, year, season, type)
    }

    suspend fun fetchId(title: String?, year: Int?, season: String?, type: String?): AniMedia? {
        val query =
                """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}year: String
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              startDate_like: ${'$'}year
              format_in: ${'$'}format
            ) {
              id
              idMal
              coverImage { extraLarge large }
              bannerImage
            }
          }
        }
    """
                        .trimIndent()
                        .trim()

        val variables =
                mapOf(
                                "search" to title,
                                "sort" to "SEARCH_MATCH",
                                "type" to "ANIME",
                                "season" to
                                        if (type.equals("ona", true)) "" else season?.uppercase(),
                                "year" to "$year%",
                                "format" to listOf(type?.uppercase())
                        )
                        .filterValues { value -> value != null && value.toString().isNotEmpty() }

        val data =
                mapOf("query" to query, "variables" to variables)
                        .toJson()
                        .toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        return try {
            app.post(anilistApi, requestBody = data)
                    .parsedSafe<AniSearch>()
                    ?.data
                    ?.Page
                    ?.media
                    ?.firstOrNull()
        } catch (t: Throwable) {
            logError(t)
            null
        }
    }

    suspend fun aniToMal(id: String): String? {
        return app.post(
                        anilistApi,
                        data =
                                mapOf(
                                        "query" to "{Media(id:$id,type:ANIME){idMal}}",
                                )
                )
                .parsedSafe<DataAni>()
                ?.data
                ?.media
                ?.idMal
    }

    private val embedBlackList =
            listOf(
                    "https://mp4upload.com/",
                    "https://streamsb.net/",
                    "https://dood.to/",
                    "https://videobin.co/",
                    "https://ok.ru",
                    "https://streamlare.com",
                    "https://filemoon",
                    "streaming.php",
            )

    suspend fun getM3u8Qualities(
            m3u8Link: String,
            referer: String,
            qualityName: String,
    ): List<ExtractorLink> {
        return M3u8Helper.generateM3u8(
                qualityName,
                m3u8Link,
                referer
        )
    }

    fun String.getHost(): String {
        return fixTitle(URI(this).host.substringBeforeLast(".").substringAfterLast("."))
    }

    fun String.fixUrlPath(): String {
        return if (this.contains(".json?")) apiEndPoint + this
        else apiEndPoint + URI(this).path + ".json?" + URI(this).query
    }

    fun fixSourceUrls(url: String, source: String?): String? {
        return if (source == "Ak" || url.contains("/player/vitemb")) {
            AppUtils.tryParseJson<AkIframe>(base64Decode(url.substringAfter("=")))?.idUrl
        } else {
            url.replace(" ", "%20")
        }
    }
}


fun parseAnimeData(jsonString: String): MetaAnimeData? {
    return try {
        val objectMapper = ObjectMapper()
        objectMapper.readValue(jsonString, MetaAnimeData::class.java)
    } catch (_: Exception) {
        null // Return null for invalid JSON instead of crashing
    }
}

suspend fun fetchTmdbLogoUrl(
    tmdbAPI: String,
    apiKey: String,
    type: TvType,
    tmdbId: Int?,
    appLangCode: String?
): String? {

    if (tmdbId == null) return null

    val appLang = appLangCode
        ?.substringBefore("-")
        ?.lowercase()

    val url = if (type == TvType.Movie) {
        "$tmdbAPI/movie/$tmdbId/images?api_key=$apiKey"
    } else {
        "$tmdbAPI/tv/$tmdbId/images?api_key=$apiKey"
    }

    val json = runCatching { JSONObject(app.get(url).text) }.getOrNull()
        ?: return null

    val logos = json.optJSONArray("logos") ?: return null
    if (logos.length() == 0) return null

    fun logoUrlAt(i: Int): String = "https://image.tmdb.org/t/p/w500${logos.getJSONObject(i).optString("file_path")}"

    if (!appLang.isNullOrBlank()) {
        for (i in 0 until logos.length()) {
            val logo = logos.optJSONObject(i) ?: continue
            if (logo.optString("iso_639_1") == appLang) {
                return logoUrlAt(i)
            }
        }
    }

    for (i in 0 until logos.length()) {
        val logo = logos.optJSONObject(i) ?: continue
        if (logo.optString("iso_639_1") == "en") {
            return logoUrlAt(i)
        }
    }

    return logoUrlAt(0)
}

private val apiUrl = "https://graphql.anilist.co"

private val headerJSON =
    mapOf("Accept" to "application/json", "Content-Type" to "application/json")

suspend fun anilistAPICall(query: String): AnilistAPIResponse {
    val data = mapOf("query" to query)
    val test = app.post(apiUrl, headers = headerJSON, data = data)
    val res =
        test.parsedSafe<AnilistAPIResponse>()
            ?: throw Exception("Unable to fetch or parse Anilist api response")
    return res
}

data class AnilistAPIResponse(
    @JsonProperty("data") val data: AnilistData,
) {
    data class AnilistData(
        @JsonProperty("Page") val page: AnilistPage?,
        @JsonProperty("Media") val media: anilistMedia?,
    ) {
        data class AnilistPage(
            @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
            @JsonProperty("media") val media: List<Media>,
        )
    }

    data class anilistMedia(
        @JsonProperty("id") val id: Int,
        @JsonProperty("startDate") val startDate: StartDate,
        @JsonProperty("episodes") val episodes: Int?,
        @JsonProperty("title") val title: Title,
        @JsonProperty("season") val season: String?,
        @JsonProperty("genres") val genres: List<String>,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("status") val status: String,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("bannerImage") val bannerImage: String?,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
        @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
        @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
        @JsonProperty("format") val format: String?,
    ) {
        data class StartDate(@JsonProperty("year") val year: Int)

        data class AiringScheduleNodes(
            @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
        )

        fun totalEpisodes(): Int {
            return nextAiringEpisode?.episode?.minus(1)
                ?: episodes
                ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                ?: 0
        }

        fun getTitle(): String {
            return title.english
                ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
        }

        fun getCoverImage(): String? {
            return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
        }
    }

    data class Media(
        @JsonProperty("id") val id: Int,
        @JsonProperty("idMal") val idMal: Int?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("seasonYear") val seasonYear: Int,
        @JsonProperty("format") val format: String?,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("episodes") val episodes: Int,
        @JsonProperty("title") val title: Title,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("synonyms") val synonyms: List<String>,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
    )
}


suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}



================================================
FILE: Animeav1/build.gradle.kts
================================================
// use an integer for version numbers
version = 5


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "(Mexican) Anime Extension"
    language    = "mx"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","Anime","AnimeMovie")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/animeav1.png"

    isCrossPlatform = false
}



================================================
FILE: Animeav1/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Animeav1/src/main/kotlin/com/Animeav1/Animeav1.kt
================================================
package com.Animeav1

import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject
import org.jsoup.nodes.Element

class Animeav1 : MainAPI() {
    override var mainUrl              = "https://animeav1.com"
    override var name                 = "AnimeAv1"
    override val hasMainPage          = true
    override var lang                 = "es-mx"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Anime, TvType.AnimeMovie)

    override val mainPage = mainPageOf(
        "catalogo?status=emision" to "Emision",
        "catalogo?status=finalizado" to "Finalizado",
        "catalogo?category=pelicula" to "Pelicula",
        "catalogo?category=ova" to "OVA",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}&page=$page").documentLarge
        val home     = document.select("article").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("h3").text()
        val href      = this.select("a").attr("href")
        val posterUrl = fixUrlNull(this.select("figure img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("${mainUrl}/catalogo?search=$query").documentLarge
        val results = document.select("article").mapNotNull { it.toSearchResult() }
        return results
    }


    private fun String.toTvType(): TvType {
        return when {
            this.contains("TV Anime", ignoreCase = true) -> TvType.Anime
            this.contains("Película", ignoreCase = true) -> TvType.Movie
            this.contains("OVA", ignoreCase = true) -> TvType.Anime
            else -> TvType.Movie
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document    = app.get(url).documentLarge
        val title       = document.selectFirst("article h1")?.text() ?: "Desconocido"
        val poster      = document.select("img.aspect-poster").attr("src")
        val description = document.selectFirst("div.entry.text-lead p")?.text()
        val type        = document.select("header div.text-sm").text().toTvType()
        val tags        = document.select("header a[href*=?genre=]").map { it.text() }
        val year        = document.select("header div.text-sm span:matches(\\d{4})").text().toIntOrNull()
        val score       = document.select("article [class*=ic-star] .text-lead").text()
        val href        = fixUrl(document.select("div.grid > article a").attr("href"))

        return if (type == TvType.Anime) {
            val episodes = mutableListOf<Episode>()
            val mediaId = Regex("/(\\d+)\\.jpg$").find(poster)?.groupValues?.get(1) ?: "0"
            val scriptContent = document.select("script").html()
            val episodeZeroRegex = Regex("number:\\s*0")
            val regex = Regex("media:\\{.*?episodesCount:(\\d+).*?slug:\"(.*?)\"", RegexOption.DOT_MATCHES_ALL)

            val match = regex.find(scriptContent)
            if (match != null) {
                val totalEpisodes = match.groupValues[1].toIntOrNull() ?: 0
                val slug = match.groupValues[2]
                val hasEpisodeZero = episodeZeroRegex.containsMatchIn(scriptContent)
                val startEp = if (hasEpisodeZero) 0 else 1

                for (i in startEp..totalEpisodes) {
                    val epUrl = "https://animeav1.com/media/$slug/$i"
                    val epposter = "https://cdn.animeav1.com/screenshots/$mediaId/$i.jpg"

                    episodes.add(
                        newEpisode(epUrl) {
                            this.name = "Episode $i"
                            this.episode = i
                            this.posterUrl = epposter
                        }
                    )
                }
            }
            newAnimeLoadResponse(title, url, TvType.Anime) {
                addEpisodes(DubStatus.Subbed, episodes)
                this.posterUrl = poster
                this.plot = description
                this.tags = tags
                this.year = year
                this.score = Score.from10(score)
            }
        } else newMovieLoadResponse(title, url, TvType.AnimeMovie, href) {
            this.posterUrl = poster
            this.plot = description
            this.tags = tags
            this.year = year
            this.score = Score.from10(score)
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge

        val scriptHtml = document.select("script")
            .firstOrNull { it.html().contains("__sveltekit_") }
            ?.html()
            .orEmpty()

        fun cleanJsToJson(js: String): String {
            var cleaned = js.replaceFirst("""^\s*\w+\s*:\s*""".toRegex(), "")
            cleaned = cleaned.replace("void 0", "null")
            cleaned = Regex("""(?<=[{,])\s*(\w+)\s*:""").replace(cleaned) { "\"${it.groupValues[1]}\":" }

            return cleaned.trim()
        }

        val embedsPattern = "embeds:\\s*\\{([^}]*\\{[^}]*\\})*[^}]*\\}".toRegex(RegexOption.DOT_MATCHES_ALL)
        val embedsMatch = embedsPattern.find(scriptHtml)?.value
        val embedsJson = embedsMatch?.let { cleanJsToJson(it) }

        if (!embedsJson.isNullOrEmpty()) {
            val embedsObject = JSONObject(embedsJson)
            fun extractLinks(arrayName: String): List<Pair<String, String>> {
                val list = mutableListOf<Pair<String, String>>()
                if (embedsObject.has(arrayName)) {
                    val jsonArray = embedsObject.getJSONArray(arrayName)
                    for (i in 0 until jsonArray.length()) {
                        val obj = jsonArray.getJSONObject(i)
                        list.add(obj.getString("server") to obj.getString("url"))
                    }
                }
                return list
            }

            val subEmbeds = extractLinks("SUB")
            val dubEmbeds = extractLinks("DUB")

            subEmbeds.forEach { (server, url) ->
                loadCustomExtractor(
                    "Animeav1 [SUB:$server]",
                    url,
                    "",
                    subtitleCallback,
                    callback
                )
            }

            dubEmbeds.forEach { (server, url) ->
                loadCustomExtractor(
                    "Animeav1 [DUB:$server]",
                    url,
                    "",
                    subtitleCallback,
                    callback
                )
            }
        }
        return true
    }
}

suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


================================================
FILE: Animeav1/src/main/kotlin/com/Animeav1/Animeav1Provider.kt
================================================
package com.Animeav1

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class Animeav1Provider: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Animeav1())
        registerExtractorAPI(Animeav1upn())
        registerExtractorAPI(Zilla())
    }
}


================================================
FILE: Animeav1/src/main/kotlin/com/Animeav1/Extractor.kt
================================================
package com.Animeav1

import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

open class Zilla : ExtractorApi() {
    override var name = "HLS"
    override var mainUrl = "https://player.zilla-networks.com"
    override val requiresReferer = false

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
            val mp4 = "$mainUrl/m3u8/${url.substringAfterLast("/")}"
            return listOf(
                newExtractorLink(
                    this.name,
                    this.name,
                    url = mp4,
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = referer ?: ""
                    this.quality = Qualities.P1080.value
                }
            )
    }
}

class Animeav1upn : VidStack() {
    override var mainUrl = "https://animeav1.uns.bio"
}


================================================
FILE: AnimeCloud/build.gradle.kts
================================================
// use an integer for version numbers
version = 6


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "German (Lang) Anime"
    language    = "de"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Anime")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/AnimeCloud.jpg"

    isCrossPlatform = true
}



================================================
FILE: AnimeCloud/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: AnimeCloud/src/main/kotlin/com/Animecloud/Animecloud.kt
================================================
package com.Animecloud

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl

class Animecloud : MainAPI() {
    override var mainUrl              = "https://fireani.me"
    override var name                 = "Animecloud"
    override val hasMainPage          = true
    override var lang                 = "de"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime)

    override val mainPage = mainPageOf(
        "best-last-7d?page=" to "Trending",
        "genre?genere=Action&page=" to "Action",
        "genre?genere=Drama&page=" to "Drama",
        "genre?genere=Komödie&page=" to "Comedy",
        "genre?genere=Mystery&page=" to "Mystery",
        "genre?genere=Romanze&page=" to "Romanze",
        "genre?genere=Abenteuer&page=" to "Abenteuer",
        "genre?genere=EngSub&page=" to "EngSub",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {

        val url = "$mainUrl/api/animes/${request.data}$page"

        val response = app.get(url).parsedSafe<Home>()
            ?: return newHomePageResponse(
                list = HomePageList(
                    name = request.name,
                    list = emptyList(),
                    isHorizontalImages = false
                ),
                hasNext = false
            )

        val home = response.data.map { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = page < response.pages
        )
    }

    private fun HomeDaum.toSearchResult(): SearchResponse {
        val href = "$mainUrl/api/anime?slug=${this.slug}"
        val posterslug= this.poster
        return newMovieSearchResponse(
            name = this.title,
            url = href,
            type = TvType.Movie
        ) {
            posterUrl = fixUrlNull("$mainUrl/img/posters/${posterslug}")
        }
    }


    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query)

    override suspend fun search(query: String): List<SearchResponse>? {
        val searchResponse = app.get("$mainUrl/api/anime/search?q=$query").parsedSafe<SearchParser>()?.data?.map { it.toSearchResponse() }
        return searchResponse
    }

    private fun Daum.toSearchResponse(): SearchResponse {
        val title=this.title
        val poster= fixUrlNull("$mainUrl/img/posters/${this.poster}")
        val href= "$mainUrl/api/anime?slug=${this.slug}"
        return newAnimeSearchResponse(
            title,
            href,
            TvType.TvSeries,
        ) {
            this.posterUrl=poster
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document= app.get(url).parsedSafe<EpisodeParser>()?.data
        val title = document?.title ?: "Unknown"
        val imdburl=document?.imdb
        val poster= fixUrlNull("$mainUrl/img/posters/${document?.poster}")
        val backgroundurl = "$mainUrl/img/posters/bg-${document?.backdrop}.webp"
        val description = document?.desc
        val genres=document?.generes
        val animeSeasons= document?.animeSeasons
        val episodes = mutableListOf<Episode>()
        animeSeasons?.map { info->
             var season:String
             season = info.season
             if (season.contains("Filme")) season="0"
             info.animeEpisodes.map {
                 val episode=it.episode?.toIntOrNull()
                 val epname="Episode $episode "
                 val epposter="${mainUrl}/img/thumbs/${it.image}"
                 val animename=url.substringAfterLast("slug=")
                 val searchSeason = if (season == "0") "Filme" else season
                 val href = "$mainUrl/api/anime/episode?slug=$animename&season=$searchSeason&episode=$episode"
                 episodes+= newEpisode(href)
                     {
                         this.name=epname
                         this.season=season.toIntOrNull()
                         this.episode=episode
                         this.posterUrl=epposter
                     }
             }
        }
        return newTvSeriesLoadResponse(title, url, TvType.Anime, episodes) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundurl
                this.plot = description
                this.tags = genres
                addImdbUrl(imdburl)
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        app.get(data).parsedSafe<AnimecloudEP>()?.data?.anime_episode_links?.map {
            val dubtype=it.lang
            val href=it.link
            loadSourceNameExtractor("$name ${dubtype.uppercase()}",href, "", subtitleCallback, callback, quality = "1080P")
        }
        return true
    }
}



================================================
FILE: AnimeCloud/src/main/kotlin/com/Animecloud/AnimecloudProvider.kt
================================================
package com.Animecloud

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnimecloudProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Animecloud())
        registerExtractorAPI(AnimeCloudProxy())
        registerExtractorAPI(LuluStream())
    }
}


================================================
FILE: AnimeCloud/src/main/kotlin/com/Animecloud/Extractor.kt
================================================
package com.Animecloud

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

open class AnimeCloudProxy : ExtractorApi() {
    override var name = "AnimeCloudProxy"
    override var mainUrl = "https://fireani.me"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit) {
        val id=url.substringAfterLast("/")
        val csrftkn = app.get(url,referer=mainUrl).documentLarge.select("form#wrapper input[name=csrftkn]").attr("value")
        val seassion_ck = app.get("$mainUrl/proxy/player/adehu1awmdxx?csrftkn=$csrftkn",referer=mainUrl).cookies["session"]
        val m3u8="$mainUrl/proxy/nocache/$id/"
        val headers= mapOf("Cookie" to "session=$seassion_ck")
        callback.invoke(
            newExtractorLink(
                name,
                name,
                url = m3u8,
                ExtractorLinkType.M3U8
            ) {
                this.referer = mainUrl
                this.quality = Qualities.P1080.value
                this.headers = headers
            }
        )
        return
    }
}


open class LuluStream : ExtractorApi() {
    override var name = "LuluStream"
    override var mainUrl = "https://luluvdo.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val filecode = url.substringAfterLast("/")
        val postUrl = "$mainUrl/dl"
        val post = app.post(
            postUrl,
            data = mapOf(
                "op" to "embed",
                "file_code" to filecode,
                "auto" to "1",
                "referer" to (referer ?: "")
            )
        ).documentLarge
        post.selectFirst("script:containsData(vplayer)")?.data()
            ?.let { script ->
                Regex("file:\"(.*)\"").find(script)?.groupValues?.get(1)?.let { link ->
                    callback.invoke(
                        newExtractorLink(
                            name,
                            name,
                            url = link,
                            INFER_TYPE
                        ) {
                            this.referer = mainUrl
                            this.quality = Qualities.P1080.value
                        }
                    )
                }
            }
    }
}




================================================
FILE: AnimeCloud/src/main/kotlin/com/Animecloud/Parser.kt
================================================
package com.Animecloud

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

data class Home(
    val data: List<HomeDaum>,
    val pages: Long,
    val status: Long,
)

data class HomeDaum(
    val id: Long,
    @JsonProperty("created_at")
    val createdAt: String?,
    @JsonProperty("updated_at")
    val updatedAt: String?,
    val slug: String,
    val title: String,
    @JsonProperty("alternate_titles")
    val alternateTitles: String?,
    val generes: Any?,
    val imdb: String?,
    val tmdb: Long,
    @JsonProperty("tmdb_type")
    val tmdbType: String,
    val anilist: Any?,
    val desc: String?,
    val start: Long,
    val end: Long?,
    val poster: String,
    val backdrop: String,
    @JsonProperty("vote_avg")
    val voteAvg: Double,
    @JsonProperty("vote_count")
    val voteCount: Long,
    @JsonProperty("item_type")
    val itemType: String,
    @JsonProperty("view_count")
    val viewCount: Long,
)

data class EpisodeParser(
    val data: Data?,
    val status: Long?,
)

data class Data(
    val id: Long?,
    @JsonProperty("created_at")
    val createdAt: String?,
    @JsonProperty("updated_at")
    val updatedAt: String?,
    @JsonProperty("last_sync")
    val lastSync: String?,
    val slug: String?,
    val title: String?,
    @JsonProperty("alternate_titles")
    val alternateTitles: String?,
    val generes: List<String>?,
    val imdb: String?,
    val tmdb: Long?,
    @JsonProperty("tmdb_type")
    val tmdbType: String?,
    val anilist: Any?,
    val desc: String?,
    val start: Long?,
    val end: Long?,
    val poster: String?,
    val backdrop: String?,
    @JsonProperty("vote_avg")
    val voteAvg: Double?,
    @JsonProperty("vote_count")
    val voteCount: Long?,
    @JsonProperty("item_type")
    val itemType: String?,
    @JsonProperty("anime_seasons")
    val animeSeasons: List<AnimeSeason>?,
)

data class AnimeSeason(
    val id: Long?,
    @JsonProperty("created_at")
    val createdAt: String?,
    @JsonProperty("updated_at")
    val updatedAt: String?,
    val season: String,
    @JsonProperty("anime_id")
    val animeId: Long?,
    @JsonProperty("anime_episodes")
    val animeEpisodes: List<AnimeEpisode>,
)

data class AnimeEpisode(
    val id: Long?,
    @JsonProperty("created_at")
    val createdAt: String?,
    @JsonProperty("updated_at")
    val updatedAt: String?,
    @JsonProperty("last_sync")
    val lastSync: String?,
    val episode: String?,
    val image: String?,
    @JsonProperty("view_count")
    val viewCount: Long?,
    @JsonProperty("anime_season_id")
    val animeSeasonId: Long?,
    @JsonProperty("has_ger_sub")
    val hasGerSub: Boolean?,
    @JsonProperty("has_ger_dub")
    val hasGerDub: Boolean?,
    @JsonProperty("has_eng_sub")
    val hasEngSub: Boolean?,
    @JsonProperty("anime_episode_links")
    val animeEpisodeLinks: Any?,
)




data class AnimecloudEP(
    val `data`: Data,
    val status: Int
) {
    data class Data(
        val anime_episode_links: List<AnimeEpisodeLink>,
        val anime_season_id: Int,
        val dislike_count: Int,
        val episode: String,
        val has_eng_sub: Boolean,
        val has_ger_dub: Boolean,
        val has_ger_sub: Boolean,
        val id: Int,
        val image: String,
        val like_count: Int,
        val view_count: Int
    ) {
        data class AnimeEpisodeLink(
            val anime_episode_id: Int,
            val created_at: String,
            val id: Int,
            val lang: String,
            val link: String,
            val name: String,
            val updated_at: String
        )
    }
}


//SearchParser

data class SearchParser(
    val data: List<Daum>,
    val pages: Long,
    val status: Long,
)

data class Daum(
    val id: Long,
    @JsonProperty("created_at")
    val createdAt: String,
    @JsonProperty("updated_at")
    val updatedAt: String,
    @JsonProperty("last_sync")
    val lastSync: String,
    val slug: String,
    val title: String,
    @JsonProperty("alternate_titles")
    val alternateTitles: String,
    val generes: List<String>,
    val imdb: String?,
    val tmdb: Long,
    @JsonProperty("tmdb_type")
    val tmdbType: String,
    val anilist: Any?,
    val desc: String,
    val start: Long,
    val end: Long?,
    val poster: String,
    val backdrop: String,
    @JsonProperty("vote_avg")
    val voteAvg: Double,
    @JsonProperty("vote_count")
    val voteCount: Long,
    @JsonProperty("item_type")
    val itemType: String,
    @JsonProperty("anime_seasons")
    val animeSeasons: Any?,
)



suspend fun loadSourceNameExtractor(
    source: String,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: String? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    source,
                    source,
                    url = link.url,
                    type = link.type
                ) {
                    this.referer = link.referer
                    this.quality = getQualityFromName(quality)
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}



================================================
FILE: AnimeDekhoProvider/build.gradle.kts
================================================
version = 61

cloudstream {
    language = "hi"
    authors = listOf("Hindi Provider")
    description = "Includes AnimeDekho,OnePace(DUB,SUB) and HindiSubAnime"
    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "Cartoon"
    )

    iconUrl = "https://animedekho.app/wp-content/uploads/2023/07/AnimeDekho-Logo-300x-1.png"

    isCrossPlatform = true
}



================================================
FILE: AnimeDekhoProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />



================================================
FILE: AnimeDekhoProvider/src/main/kotlin/com/Phisher98/AnimeDekhoPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.FileMoon
import com.lagradost.cloudstream3.extractors.FilemoonV2
import com.lagradost.cloudstream3.extractors.GDMirrorbot
import com.lagradost.cloudstream3.extractors.Krakenfiles
import com.lagradost.cloudstream3.extractors.StreamTape
import com.lagradost.cloudstream3.extractors.Voe

@CloudstreamPlugin
class AnimeDekhoPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(AnimeDekhoProvider())
        //registerMainAPI(OnepaceProvider())
        registerMainAPI(HindiSubAnime())
        registerExtractorAPI(StreamRuby())
        registerExtractorAPI(Vidmolynet())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(Cdnwish())
        registerExtractorAPI(Multimovies())
        registerExtractorAPI(FileMoon())
        registerExtractorAPI(FileMoonNL())
        registerExtractorAPI(Krakenfiles())
        registerExtractorAPI(Voe())
        registerExtractorAPI(StreamTape())
        registerExtractorAPI(FilemoonV2())
        registerExtractorAPI(Animezia())
        registerExtractorAPI(Cloudy())
        registerExtractorAPI(vidcloudupns())
        registerExtractorAPI(Animedekhoco())
        registerExtractorAPI(Blakiteapi())
        registerExtractorAPI(ascdn21())
    }
}



================================================
FILE: AnimeDekhoProvider/src/main/kotlin/com/Phisher98/AnimeDekhoProvider.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element

open class AnimeDekhoProvider : MainAPI() {
    override var mainUrl = "https://animedekho.app"
    override var name = "Anime Dekho"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true

    override val supportedTypes =
        setOf(
            TvType.Cartoon,
            TvType.Anime,
            TvType.AnimeMovie,
            TvType.Movie,
        )

    override val mainPage =
        mainPageOf(
            "/series/" to "Series",
            "/movie/" to "Movies",
            "/category/anime/" to "Anime",
            "/category/cartoon/" to "Cartoon",
            "/category/crunchyroll/" to "Crunchyroll",
            "/category/hindi-dub/" to "Hindi",
            "/category/tamil/" to "Tamil",
            "/category/telugu/" to "Telugu"
        )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest,
    ): HomePageResponse {
        val link = "$mainUrl${request.data}"
        val document = app.get(link).documentLarge
        val home =
            document.select("article").mapNotNull {
                it.toSearchResult()
            }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): AnimeSearchResponse? {
        val href = this.selectFirst("a.lnk-blk")?.attr("href") ?: return null
        val title = this.selectFirst("header h2")?.text() ?: "null"
        var posterUrl = this.selectFirst("div figure img")?.attr("src")
        if (posterUrl!!.contains("data:image"))
        {
            posterUrl=this.selectFirst("div figure img")?.attr("data-lazy-src")
        }
        return newAnimeSearchResponse(title, Media(href, posterUrl).toJson(), TvType.Anime, false) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<AnimeSearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        return document.select("ul[data-results] li article").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val media = parseJson<Media>(url)
        val document = app.get(media.url).documentLarge
        val title = document.selectFirst("h1.entry-title")?.text()?.trim()?.substringAfter("Watch Online ")
            ?: document.selectFirst("meta[property=og:title]")?.attr("content")?.substringAfter("Watch Online ")?.substringBefore(" Movie in Hindi Dubbed Free") ?: "No Title"
        val poster = fixUrlNull(document.selectFirst("div.post-thumbnail figure img")?.attr("src") ?: media.poster)
        val plot = document.selectFirst("div.entry-content p")?.text()?.trim()
            ?: document.selectFirst("meta[name=twitter:description]")?.attr("content")
        val year = (document.selectFirst("span.year")?.text()?.trim()
            ?: document.selectFirst("meta[property=og:updated_time]")?.attr("content")
                ?.substringBefore("-"))?.toIntOrNull()
        val lst = document.select("ul.seasons-lst li")

        return if (lst.isEmpty()) {
            newMovieLoadResponse(title, url, TvType.Movie, Media(
                media.url,
                mediaType = 1
            ).toJson()) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
            }
        } else {
            val episodes = document.select("ul.seasons-lst li").mapNotNull {
                val name = it.selectFirst("h3.title")?.ownText() ?: "null"
                val href = it.selectFirst("a")?.attr("href") ?: return@mapNotNull null
                val poster=it.selectFirst("div > div > figure > img")?.attr("src")
                val seasonnumber = it.selectFirst("h3.title > span")?.text().toString().substringAfter("S").substringBefore("-")
                val season=seasonnumber.toIntOrNull()
                newEpisode(Media(href, mediaType = 2).toJson())
                {
                    this.name=name
                    this.posterUrl=poster
                    this.season=season
                }
            }
            val recommendations = document.select("div.swiper-wrapper article").map {
                val recName = it.selectFirst("h2")?.text() ?: "Unknown"
                val recHref = it.selectFirst("a")!!.attr("href")
                val recPosterUrl = it.selectFirst("figure img")?.attr("src")
                val mediadata = Media(
                    url = recHref,
                    poster = recPosterUrl,
                    mediaType = 0 // You can adjust this
                )
                val mediaJson = Gson().toJson(mediadata)
                newTvSeriesSearchResponse(recName, mediaJson, TvType.TvSeries) {
                    this.posterUrl = mediadata.poster
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
                this.recommendations = recommendations
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val media = runCatching { parseJson<Media>(data) }.getOrElse {
            Log.e("Error:", "Failed to parse media JSON $it" )
            return false
        }

        //VidStream
        val headers = mapOf("Cookie" to "toronites_server=vidstream")
        val doc = app.get(media.url, headers = headers).document
        doc.select("iframe.serversel[src]").forEach { iframe ->
            val serverUrl = iframe.attr("src")
            if (serverUrl.isBlank()) return@forEach

            val innerIframeUrl = runCatching {
                app.get(serverUrl).document
                    .selectFirst("iframe[src]")
                    ?.attr("src")
            }.getOrNull()

            if (!innerIframeUrl.isNullOrBlank()) {
                loadExtractor(innerIframeUrl, subtitleCallback, callback)
            }
        }
        //

        val bodyClass = runCatching {
            app.get(media.url).documentLarge.selectFirst("body")?.attr("class")
        }.getOrNull()

        val term = Regex("""(?:term|postid)-(\d+)""").find(bodyClass ?: "")
            ?.groupValues?.getOrNull(1)

        if (term.isNullOrEmpty()) {
            Log.e("Error:", "No postid/term ID found in body class: $bodyClass")
            return false
        }

        var success = false
        for (i in 0..10) {
            val iframeUrl = runCatching {
                app.get("$mainUrl/?trdekho=$i&trid=$term&trtype=${media.mediaType}")
                    .documentLarge.selectFirst("iframe")?.attr("src")
            }.getOrNull()
            if (!iframeUrl.isNullOrEmpty()) {
                Log.d("Error:", "Found iframe: $iframeUrl")
                runCatching {
                    loadExtractor(iframeUrl, subtitleCallback, callback)
                    success = true
                }.onFailure {
                    Log.e("Error:", "Failed to load extractor for $iframeUrl $it")
                }
            } else {
                Log.w("Error:", "No iframe found for iteration $i")
            }
        }

        return success
    }


    data class Media(val url: String, val poster: String? = null, val mediaType: Int? = null)

}



================================================
FILE: AnimeDekhoProvider/src/main/kotlin/com/Phisher98/Extractor.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.extractors.Vidmoly
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONObject
import org.jsoup.nodes.Document

class vidcloudupns : VidStack() {
    override var mainUrl = "https://vidcloud.upns.ink"
}

class ascdn21 : AWSStream() {
    override val name = "Zephyrflick"
    override val mainUrl = "https://as-cdn21.top"
    override val requiresReferer = true
}


open class AWSStream : ExtractorApi() {
    override val name = "AWSStream"
    override val mainUrl = "https://z.awstream.net"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val extractedHash = url.substringAfterLast("/")
        val doc = app.get(url).documentLarge
        val m3u8Url = "$mainUrl/player/index.php?data=$extractedHash&do=getVideo"
        val header = mapOf("x-requested-with" to "XMLHttpRequest")
        val formdata = mapOf("hash" to extractedHash, "r" to mainUrl)
        val response = app.post(m3u8Url, headers = header, data = formdata).parsedSafe<Response>()
        response?.videoSource?.let { m3u8 ->
            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    url = m3u8,
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = ""
                    this.quality = Qualities.P1080.value
                }
            )
            val extractedPack = doc.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().orEmpty()

            JsUnpacker(extractedPack).unpack()?.let { unpacked ->
                Regex(""""kind":\s*"captions"\s*,\s*"file":\s*"(https.*?\.srt)""")
                    .find(unpacked)
                    ?.groupValues
                    ?.get(1)
                    ?.let { subtitleUrl ->
                        subtitleCallback.invoke(
                            newSubtitleFile(
                                "English",
                                subtitleUrl
                            )
                        )
                    }
            }
        }
    }

    data class Response(
        val hls: Boolean,
        val videoImage: String,
        val videoSource: String,
        val securedLink: String,
        val downloadLinks: List<Any?>,
        val attachmentLinks: List<Any?>,
        val ck: String,
    )
}

class Multimovies: StreamWishExtractor() {
    override var name = "Multimovies Cloud"
    override var mainUrl = "https://multimovies.cloud"
    override var requiresReferer = true
}

class FileMoonNL : Filesim() {
    override val mainUrl = "https://filemoon.nl"
    override val name = "FileMoon"
}

class Vidmolynet : Vidmoly() {
    override val mainUrl = "https://vidmoly.net"
}

class Cdnwish : StreamWishExtractor() {
    override var name = "Streamwish"
    override var mainUrl = "https://cdnwish.com"
}

class Cloudy : VidStack() {
    override var mainUrl = "https://cloudy.upns.one"
}

class Animezia : VidhideExtractor() {
    override var name = "Animezia"
    override var mainUrl = "https://animezia.cloud"
    override var requiresReferer = true
}

data class Media(val url: String, val poster: String? = null, val mediaType: Int? = null)


class Animedekhoco : ExtractorApi() {
    override val name = "Animedekhoco"
    override val mainUrl = "https://animedekho.co"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc: Document? = if (url.contains("url=")) app.get(url).documentLarge else null
        val text: String? = if (!url.contains("url=")) app.get(url).text else null

        val links = mutableListOf<Pair<String, String>>()

        doc?.select("select#serverSelector option")?.forEach { option ->
            val link = option.attr("value")
            val name = option.text().ifBlank { "Unknown" }
            if (link.isNotBlank()) links.add(name to link)
        }

        text?.let {
            val regex = Regex("""file\s*:\s*"([^"]+)"""")
            regex.find(it)?.groupValues?.get(1)?.let { link ->
                links.add("Player File" to link)
            }
        }

        links.forEach { (serverName, serverUrl) ->
            callback.invoke(
                newExtractorLink(
                    serverName,
                    serverName,
                    url = serverUrl,
                    INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }
}

class StreamRuby : ExtractorApi() {
    override val name = "StreamRuby"
    override val mainUrl = "https://rubystm.com"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val cleanedUrl = url.replace("/e", "")
        val response = app.get(
            cleanedUrl,
            referer = cleanedUrl,
            headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).documentLarge

        val scriptData = response.selectFirst("script:containsData(vplayer)")?.data().orEmpty()

        val headers = mapOf(
            "Accept" to "*/*",
            "Connection" to "keep-alive",
            "Sec-Fetch-Dest" to "empty",
            "Sec-Fetch-Mode" to "cors",
            "Sec-Fetch-Site" to "cross-site",
            "Origin" to cleanedUrl,
        )

        Regex("file:\"(.*)\"").find(scriptData)?.groupValues?.getOrNull(1)?.let { link ->
            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    url = link,
                    INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.P1080.value
                    this.headers = headers
                }
            )
        }
    }
}


class Blakiteapi : ExtractorApi() {
    override val name = "Blakiteapi"
    override val mainUrl = "https://blakiteapi.xyz"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val apiurl = "$mainUrl/api/get.php?id=${url.substringAfterLast("/")}&tmdbId=${url.substringAfter("embed/").substringBefore("/")}"

        val responseText = app.get(apiurl).text

        val json = JSONObject(responseText)
        val success = json.optBoolean("success", false)

        if (success) {
            val data = json.getJSONObject("data")

            val quality = data.optString("quality", "480p")
            val format = data.optString("format", "MP4")
            val dataId = data.optString("dataId", "")
            val streamUrl = "$mainUrl/stream/$dataId.$format"
            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    streamUrl,
                    INFER_TYPE
                )
                {
                    this.quality=getQualityFromString(quality)
                }
            )
        }
    }

    private fun getQualityFromString(q: String): Int {
        return when {
            q.contains("1080", true) -> Qualities.P1080.value
            q.contains("720", true) -> Qualities.P720.value
            q.contains("480", true) -> Qualities.P480.value
            q.contains("360", true) -> Qualities.P360.value
            else -> Qualities.Unknown.value
        }
    }
}


================================================
FILE: AnimeDekhoProvider/src/main/kotlin/com/Phisher98/HindiSubAnime.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class HindiSubAnime : AnimeDekhoProvider() {
    override var mainUrl = "https://hindisubanime.co"
    override var name = "HindiSubAnime"
    override val hasMainPage = true
    override var lang = "hi"

    override val mainPage =
        mainPageOf(
            "/category/shounen/" to "Shounen",
            "/category/action/" to "Action",
            "/category/fantasy/" to "Fantasy",
            "/serie/" to "Series",
        )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val media = parseJson<Media>(data)
        val body = app.get(media.url).documentLarge.selectFirst("body")?.attr("class") ?: return false
        val term = Regex("""(?:term|postid)-(\d+)""").find(body)?.groupValues?.get(1)
            ?: throw ErrorLoadingException("no id found")
        for (i in 0..4) {
            val link = app.get("$mainUrl/?trdekho=$i&trid=$term&trtype=${media.mediaType}")
                .documentLarge.selectFirst("iframe")?.attr("src")
                ?: throw ErrorLoadingException("no iframe found")
            Log.d("Phisher", link)
            loadExtractor(link, subtitleCallback, callback)
        }
        return true
    }
}


================================================
FILE: AnimeDekhoProvider/src/main/kotlin/com/Phisher98/OnePace.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element

open class OnepaceProvider : MainAPI() {
    override var mainUrl = "https://onepace.me"
    override var name = "OnePace"
    override val hasMainPage = true
    override var lang = "en"

    override val supportedTypes =
        setOf(
            TvType.Anime,
        )

    override val mainPage =
        mainPageOf(
            "/series/one-pace-english-sub/" to "One Pace English Sub",
            "/series/one-pace-english-dub/" to "One Pace English Dub",
        )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest,
    ): HomePageResponse {
        val link = "$mainUrl${request.data}"
        val document = app.get(link).documentLarge
        val home =
            document.select("div.seasons.aa-crd > div.seasons-bx").map {
                it.toSearchResult()
            }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): AnimeSearchResponse {
        val hreftitle= this.selectFirst("picture img")?.attr("alt")
        var href=""
        if (hreftitle!!.isNotEmpty()) {
            if (hreftitle.contains("Dub")) {
                href = "https://onepace.me/series/one-pace-english-dub"
            } else {
                href = "https://onepace.me/series/one-pace-english-sub"
            }
        }
        val title = this.selectFirst("p")?.text() ?:""
        val posterUrl = this.selectFirst("img")?.getsrcAttribute()
        val dubtype:Boolean
        val subtype:Boolean
        if (hreftitle.contains("Dub"))
        {
            dubtype = true
            subtype =false
        }
        else
        {
            dubtype = false
            subtype = true

        }
        return newAnimeSearchResponse(title, Media(href, posterUrl,title).toJson(), TvType.Anime, false) {
            this.posterUrl = posterUrl
            addDubStatus(dubExist = dubtype, subExist = subtype)
        }
    }

    override suspend fun search(query: String): List<AnimeSearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        return document.select("ul[data-results] li article").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val media = parseJson<Media>(url)
        val document = app.get(media.url).documentLarge
        val ArcINT=media.mediaType?.substringAfter("Arc ")
        val element= document.selectFirst("div.seasons.aa-crd > div.seasons-bx:contains($ArcINT)")
        val title = media.mediaType ?:"No Title"
        val poster = "https://images3.alphacoders.com/134/1342304.jpeg"
        val plot = document.selectFirst("div.entry-content p")?.text()?.trim()
            ?: document.selectFirst("meta[name=twitter:description]")?.attr("content")
        val year = (document.selectFirst("span.year")?.text()?.trim()
            ?: document.selectFirst("meta[property=og:updated_time]")?.attr("content")
                ?.substringBefore("-"))?.toIntOrNull()
        val lst = element?.select("ul.seasons-lst.anm-a li")
        return if (lst!!.isEmpty()) {
            newMovieLoadResponse(title, url, TvType.Movie, Media(
                media.url,
                mediaType = 1
            ).toJson()) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
            }
        } else {
            @Suppress("NAME_SHADOWING") val episodes = element.select("ul.seasons-lst.anm-a li").mapNotNull {
                val name = it.selectFirst("h3.title")?.ownText() ?: "null"
                val href = it.selectFirst("a")?.attr("href") ?: return@mapNotNull null
                val poster= "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/OnePack.png"
                val seasonnumber = it.selectFirst("h3.title > span")?.text().toString().substringAfter("S").substringBefore("-")
                val season=seasonnumber.toIntOrNull()
                newEpisode(AnimeDekhoProvider.Media(href, mediaType = 2).toJson())
                {
                    this.name=name
                    this.posterUrl=poster
                    this.season=season
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val media = parseJson<Media>(data)
        val body = app.get(media.url).documentLarge.selectFirst("body")?.attr("class") ?: return false
        val term = Regex("""(?:term|postid)-(\d+)""").find(body)?.groupValues?.get(1) ?: throw ErrorLoadingException("no id found")
        for (i in 0..4) {
            val link = app.get("$mainUrl/?trdekho=$i&trid=$term&trtype=${media.mediaType}")
                .documentLarge.selectFirst("iframe")?.attr("src")
                ?: throw ErrorLoadingException("no iframe found")
            loadExtractor(link,subtitleCallback, callback)
        }
        return true
    }

    data class Media(val url: String, val poster: String? = null, val mediaType: String? = null)

    private fun Element.getsrcAttribute(): String {
        val src = this.attr("src")
        val dataSrc = this.attr("data-src")
        val lazysrc=this.attr("data-lazy-src")
        return when {
            src.startsWith("http") -> src
            dataSrc.startsWith("http") -> dataSrc
            lazysrc.startsWith("http") -> lazysrc
            else -> ""
        }
    }
}



================================================
FILE: AnimeKai/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 59


android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "KAISVA", "\"${properties.getProperty("KAISVA")}\"")
        buildConfigField("String", "KAIDEC", "\"${properties.getProperty("KAIDEC")}\"")
        buildConfigField("String", "KAIENC", "\"${properties.getProperty("KAIENC")}\"")
        buildConfigField("String", "KAIMEG", "\"${properties.getProperty("KAIMEG")}\"")


    }
}
dependencies {
    implementation("com.google.android.material:material:1.13.0")
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them
    description = "Animes & Animes Movie"
    authors = listOf("Phisher98")
    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Anime",
        "OVA",
        "AnimeMovie"
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=animekai.to&sz=%size%"

    requiresResources = true
    isCrossPlatform = false
}


================================================
FILE: AnimeKai/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: AnimeKai/src/main/kotlin/com/AnimeKai/AnimeKai.kt
================================================
package com.AnimeKai

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addKitsuId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addDubStatus
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.phisher98.BuildConfig
import kotlinx.coroutines.delay
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element
import kotlin.random.Random


class AnimeKai : MainAPI() {
    override var mainUrl = AnimeKaiPlugin.currentAnimeKaiServer
    override var name = "Animekai"
    override val hasQuickSearch = true
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val usesWebView = true
    override val supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)

    private fun Element.toSearchResult(): SearchResponse {
        val href = fixUrl(this.select("a.poster").attr("href"))
        val title = this.select("a.title").text()
        val subCount = this.selectFirst("div.info span.sub")?.text()?.toIntOrNull()
        val dubCount = this.selectFirst("div.info span.dub")?.text()?.toIntOrNull()
        val posterUrl = fixUrl(this.select("a.poster img").attr("data-src"))
        val type = getType(this.selectFirst("div.fd-infor > span.fdi-item")?.text() ?: "")

        return newAnimeSearchResponse(title, href, type) {
            this.posterUrl = posterUrl
            addDubStatus(dubCount != null, subCount != null, dubCount, subCount)
        }
    }

    private fun Element.toRecommendResult(): SearchResponse {
        val href = fixUrl(this.attr("href"))
        val title = this.select("div.title").text()
        val posterUrl = fixUrl(this.attr("style").substringAfter("('").substringBefore("')"))
        return newAnimeSearchResponse(title, href) {
            this.posterUrl = posterUrl
        }
    }


    companion object {

        suspend fun decode(text: String?): String {
            return try {
                val res = app.get("${BuildConfig.KAIENC}?text=$text").text
                JSONObject(res).getString("result")
            } catch (_: Exception) {
                app.get("${BuildConfig.KAISVA}/?f=e&d=$text").text
            }
        }

        private val JSON = "application/json; charset=utf-8".toMediaType()

        suspend fun decodeReverse(text: String): String {
            val jsonBody = """{"text":"$text"}""".toRequestBody(JSON)

            return try {
                val res = app.post(
                    BuildConfig.KAIDEC,
                    requestBody = jsonBody
                ).text
                JSONObject(res).getString("result")
            } catch (_: Exception) {
                app.get("${BuildConfig.KAISVA}/?f=d&d=$text").text
            }
        }



        fun getType(t: String): TvType {
            val lower = t.lowercase()
            return when {
                "ova" in lower || "special" in lower -> TvType.OVA
                "movie" in lower -> TvType.AnimeMovie
                else -> TvType.Anime
            }
        }

        fun getStatus(t: String): ShowStatus {
            return when (t) {
                "Finished Airing" -> ShowStatus.Completed
                "Releasing" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed // optionally log unexpected status
            }
        }
    }


    override val mainPage = mainPageOf(
            "$mainUrl/browser?keyword=&status[]=releasing&sort=trending" to "Trending",
            "$mainUrl/browser?keyword=&status[]=releasing&sort=updated_date" to "Latest Episode",
            "$mainUrl/browser?keyword=&type[]=tv&status[]=releasing&sort=added_date&language[]=sub&language[]=softsub" to "Recently SUB",
            "$mainUrl/browser?keyword=&type[]=tv&status[]=releasing&sort=added_date&language[]=dub" to "Recently DUB",
    )

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query,1).items


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val link = "$mainUrl/browser?keyword=$query&page=$page"
        val res = app.get(link).documentLarge
        return res.select("div.aitem-wrapper div.aitem").map { it.toSearchResult() }.toNewSearchResponseList()
    }


    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        delay(Random.nextLong(1000, 2000))

        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language" to "en-US,en;q=0.9",
            "Referer" to "$mainUrl/",
            "Connection" to "keep-alive",
            "Upgrade-Insecure-Requests" to "1",
            "Cookie" to "usertype=guest; session=Mv2Y6x1b2I8SEw3fj0eNDfQYJM3CTpH9KjJc3ACK; cf_clearance=z9kEgtOSx3us4aluy5_5MfYEL6Ei8RJ3jCbcFTD2R1E-1745122952-1.2.1.1-UYjW2QUhPKUmojZE3XUE.gqHf3g5O6lvdl0qDCNPb5IjjavrpZIOpbE64osKxLbcblCAWynfNLv6bKSO75WzURG.FqDtfcu_si3MrCHECNtbMJC.k9cuhqDRcsz8hHPgpQE2fY8rR1z5Z4HfGmCw2MWMT6GelsZW_RQrTMHUYtIqjaEiAtxfcg.O4v_RGPwio_2J2V3rP16JbWO8wRh_dObNvWSMwMW.t44PhOZml_xWuh7DH.EIxLu3AzI91wggYU9rw6JJkaWY.UBbvWB0ThZRPTAJZy_9wlx2QFyh80AXU2c5BPHwEZPQhTQHBGQZZ0BGZkzoAB8pYI3f3eEEpBUW9fEbEJ9uoDKs7WOow8g"
        )

        val res = app.get("${request.data}&page=$page", headers).documentLarge
        val items = res.select("div.aitem-wrapper div.aitem").map { it.toSearchResult() }

        return newHomePageResponse(request.name, items)
    }



    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val malid = document.select("div.watch-section").attr("data-mal-id")
        val aniid = document.select("div.watch-section").attr("data-al-id")
        val poster = document.select("div.poster img").attr("src")
        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=$aniid").toString()
        val animeMetaData = parseAnimeData(syncMetaData)
        val kitsuid = animeMetaData?.mappings?.kitsuid

        val data = anilistAPICall(
            "query (\$id: Int = ${aniid}) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore status bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val backgroundposter = data.bannerImage ?: animeMetaData?.images?.find { it.coverType == "Fanart" }?.url ?: data.coverImage.extraLarge
        ?: document.selectFirst(".anisc-poster img")?.attr("src")
        val title = document.selectFirst("h1.title")?.text().orEmpty()
        val jptitle = document.selectFirst("h1.title")?.attr("data-jp").orEmpty()
        val plot= document.selectFirst("div.desc")?.text()

        val animeId = document.selectFirst("div.rate-box")?.attr("data-id")
        val subCount = document.selectFirst("#main-entity div.info span.sub")?.text()?.toIntOrNull()
        val dubCount = document.selectFirst("#main-entity div.info span.dub")?.text()?.toIntOrNull()

        val subEpisodes = mutableListOf<Episode>()
        val dubEpisodes = mutableListOf<Episode>()

        val decoded = decode(animeId)

        val epRes = app.get("$mainUrl/ajax/episodes/list?ani_id=$animeId&_=$decoded")
            .parsedSafe<Response>()?.getDocument()

        epRes?.select("div.eplist a")?.forEachIndexed { index, ep ->
            // --- Helper to get best episode title ---
            fun resolveTitle(ep: Element, episodeKey: String): String {
                val titleMap = animeMetaData?.episodes?.get(episodeKey)?.title
                val jsonTitle = titleMap?.get("en")
                    ?: titleMap?.get("ja")
                    ?: titleMap?.get("x-jat")
                    ?: animeMetaData?.titles?.get("en")
                    ?: animeMetaData?.titles?.get("ja")
                    ?: animeMetaData?.titles?.get("x-jat")
                    ?: ""
                val attrTitle = ep.selectFirst("span")?.text() ?: ep.attr("title")
                return jsonTitle.ifBlank { attrTitle }
            }

            val episodeNum = index + 1
            fun createEpisode(source: String, ep: Element, episodeNum: Int): Episode {
                val episodeKey = episodeNum.toString()
                val metaEp = animeMetaData?.episodes?.get(episodeKey)
                return newEpisode("$source|${ep.attr("token")}") {
                    this.name = resolveTitle(ep, episodeKey)
                    this.episode = episodeNum
                    this.score = Score.from10(metaEp?.rating)
                    this.posterUrl = metaEp?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
                    this.description = metaEp?.overview ?: "No summary available"
                    this.addDate(metaEp?.airdate)
                    this.runTime = metaEp?.runtime
                }
            }
            // Sub episodes
            subCount?.let { subTotal ->
                if (index < subTotal) {
                    subEpisodes += createEpisode("sub", ep, episodeNum)
                }
            }

            // Dub episodes
            dubCount?.let { dubTotal ->
                if (index < dubTotal) {
                    val dubEpisodeNum = ep.attr("num").toIntOrNull() ?: episodeNum
                    dubEpisodes += createEpisode("dub", ep, dubEpisodeNum)
                }
            }
        }

        val recommendations = document.select("div.aitem-col a").map { it.toRecommendResult() }
        val genres = document.select("div.detail a")
            .asSequence()
            .filter { it.attr("href").contains("/genres/") }
            .map { it.text() }
            .toList()
        val status = document.select("div:containsOwn(Status) span")
            .firstOrNull()
            ?.text()?.trim()

        return newAnimeLoadResponse(title, url, TvType.Anime) {
            engName = title
            japName = jptitle
            posterUrl = poster
            backgroundPosterUrl = backgroundposter
            addEpisodes(DubStatus.Subbed, subEpisodes)
            addEpisodes(DubStatus.Dubbed, dubEpisodes)
            this.recommendations = recommendations
            this.tags = genres
            this.plot = plot
            showStatus = status?.let { getStatus(it) }
            addMalId(malid.toIntOrNull())
            addAniListId(aniid.toIntOrNull())
            try { addKitsuId(kitsuid) } catch(_:Throwable){}
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val token = data.split("|").last().split("=").last()
        val dubType = data.replace("$mainUrl/", "").split("|").firstOrNull() ?: "raw"
        val types = if ("sub" in data) listOf(dubType, "softsub") else listOf(dubType)
        val decodetoken =decode(token)
        val document =
            app.get("$mainUrl/ajax/links/list?token=$token&_=$decodetoken")
                .parsed<Response>()
                .getDocument()

        val servers = types.flatMap { type ->
            document.select("div.server-items[data-id=$type] span.server[data-lid]")
                .map { server ->
                    val lid = server.attr("data-lid")
                    val serverName = server.text()
                    Triple(type, lid, serverName)
                }
        }.distinct()

        servers.amap { (type, lid, serverName) ->
            val decodelid = decode(lid)

            val result = app.get("$mainUrl/ajax/links/view?id=$lid&_=$decodelid")
                .parsed<Response>().result
            val decodeiframe= decodeReverse(result)

            val iframe = extractVideoUrlFromJson(decodeiframe)
            val nameSuffix = if (type == "softsub") " [Soft Sub]" else ""
            val name = "⌜ AnimeKai ⌟  |  $serverName  | $nameSuffix"
            loadExtractor(iframe, name, subtitleCallback, callback)
        }
        return true
    }

    data class Response(
        @JsonProperty("status") val status: Boolean,
        @JsonProperty("result") val result: String
    ) {
        fun getDocument(): Document {
            return Jsoup.parse(result)
        }
    }

    private fun extractVideoUrlFromJson(jsonData: String): String {
        val jsonObject = JSONObject(jsonData)
        return jsonObject.getString("url")
    }
}



================================================
FILE: AnimeKai/src/main/kotlin/com/AnimeKai/AnimeKaiParser.kt
================================================
package com.AnimeKai

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title


@JsonIgnoreProperties(ignoreUnknown = true)
data class Image(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class Episode(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airdate") val airdate: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,
    @JsonProperty("runtime") val runtime: Int?,     // Keeping only one field
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaMappings(
    @JsonProperty("themoviedb_id") val themoviedbId: String? = null,
    @JsonProperty("thetvdb_id") val thetvdbId: Int? = null,
    @JsonProperty("imdb_id") val imdbId: String? = null,
    @JsonProperty("mal_id") val malId: Int? = null,
    @JsonProperty("anilist_id") val anilistId: Int? = null,
    @JsonProperty("kitsu_id") val kitsuid: String? = null,
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>?,
    @JsonProperty("images") val images: List<Image>?,
    @JsonProperty("episodes") val episodes: Map<String, Episode>?,
    @JsonProperty("mappings") val mappings: MetaMappings? = null
)

fun parseAnimeData(jsonString: String): MetaAnimeData? {
    return try {
        val objectMapper = ObjectMapper()
        objectMapper.readValue(jsonString, MetaAnimeData::class.java)
    } catch (_: Exception) {
        null // Return null for invalid JSON instead of crashing
    }
}

private val apiUrl = "https://graphql.anilist.co"

private val headerJSON =
    mapOf("Accept" to "application/json", "Content-Type" to "application/json")
suspend fun anilistAPICall(query: String): AnilistAPIResponse {
    val data = mapOf("query" to query)
    val test = app.post(apiUrl, headers = headerJSON, data = data)
    val res =
        test.parsedSafe<AnilistAPIResponse>()
            ?: throw Exception("Unable to fetch or parse Anilist api response")
    return res
}

data class AnilistAPIResponse(
    @JsonProperty("data") val data: AnilistData,
) {
    data class AnilistData(
        @JsonProperty("Page") val page: AnilistPage?,
        @JsonProperty("Media") val media: anilistMedia?,
    ) {
        data class AnilistPage(
            @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
            @JsonProperty("media") val media: List<Media>,
        )
    }

    data class anilistMedia(
        @JsonProperty("id") val id: Int,
        @JsonProperty("startDate") val startDate: StartDate,
        @JsonProperty("episodes") val episodes: Int?,
        @JsonProperty("title") val title: Title,
        @JsonProperty("season") val season: String?,
        @JsonProperty("genres") val genres: List<String>,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("status") val status: String,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("bannerImage") val bannerImage: String?,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
        @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
        @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
        @JsonProperty("externalLinks") val externalLinks: List<ExternalLink>?,
        @JsonProperty("format") val format: String?,
    ) {
        data class StartDate(@JsonProperty("year") val year: Int)

        data class AiringScheduleNodes(
            @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
        )

        data class ExternalLink(
            val site: String,
            val url: String
        )

        fun getCoverImage(): String? {
            return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
        }
    }

    data class Media(
        @JsonProperty("id") val id: Int,
        @JsonProperty("idMal") val idMal: Int?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("seasonYear") val seasonYear: Int,
        @JsonProperty("format") val format: String?,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("episodes") val episodes: Int,
        @JsonProperty("title") val title: Title,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("synonyms") val synonyms: List<String>,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
    )
}



================================================
FILE: AnimeKai/src/main/kotlin/com/AnimeKai/AnimeKaiPlugin.kt
================================================
package com.AnimeKai

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.AcraApplication.Companion.setKey
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin

enum class ServerList(val link: Pair<String, Boolean>) {
    IM("https://animekai.im" to true),
    IN("https://animekai.in" to true),
    LA("https://animekai.la" to true),
    NL("https://animekai.nl" to true),
    VC("https://animekai.vc" to true),
    BEST("https://anikai.to" to true)
}


@CloudstreamPlugin
class AnimeKaiPlugin : Plugin() {

    override fun load(context: Context) {
        registerMainAPI(AnimeKai())
        registerExtractorAPI(MegaUp())
        registerExtractorAPI(Fourspromax())
        registerExtractorAPI(MegaUpTwoTwo())

        this.openSettings = { ctx ->
            val activity = ctx as AppCompatActivity
            val frag = BottomFragment(this)
            frag.show(activity.supportFragmentManager, "")
        }
    }


    companion object {
        var currentAnimeKaiServer: String
            get() = getKey("ANIMEKAI_CURRENT_SERVER") ?: ServerList.BEST.link.first
            set(value) {
                setKey("ANIMEKAI_CURRENT_SERVER", value)
            }
    }
}




================================================
FILE: AnimeKai/src/main/kotlin/com/AnimeKai/BottomSheet.kt
================================================
package com.AnimeKai

import android.annotation.SuppressLint
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Toast
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig

class BottomFragment(private val plugin: AnimeKaiPlugin) : BottomSheetDialogFragment() {

    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val id = plugin.resources!!.getIdentifier(
            "bottom_sheet_layout",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val layout = plugin.resources!!.getLayout(id)
        val view = inflater.inflate(layout, container, false)

        val outlineId = plugin.resources!!.getIdentifier(
            "outline",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )

        // Save button
        val saveIconId = plugin.resources!!.getIdentifier(
            "save_icon",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val saveBtn = view.findView<ImageView>("save")
        saveBtn.setImageDrawable(plugin.resources!!.getDrawable(saveIconId, null))
        saveBtn.background = plugin.resources!!.getDrawable(outlineId, null)
        saveBtn.setOnClickListener {
            context?.let { ctx ->
                AlertDialog.Builder(ctx)
                    .setTitle("Restart App?")
                    .setMessage("Save changes and restart the app?")
                    .setPositiveButton("Yes") { _, _ ->
                        restartApp(ctx)
                    }
                    .setNegativeButton("No") { dialog, _ ->
                        dialog.dismiss()
                        Toast.makeText(ctx, "Changes saved", Toast.LENGTH_SHORT).show()
                        dismiss()
                    }
                    .show()
            }
        }

        // Server selection radio buttons
        val serverGroup = view.findView<RadioGroup>("server_group")
        val radioBtnId = plugin.resources!!.getIdentifier(
            "radio_button",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        ServerList.entries.forEach { server ->
            val radioBtnLayout = plugin.resources!!.getLayout(radioBtnId)
            val radioBtnView = inflater.inflate(radioBtnLayout, container, false)
            val radioBtn = radioBtnView.findView<RadioButton>("radio_button")
            radioBtn.text = server.link.first
            radioBtn.isEnabled = server.link.second
            val newId = View.generateViewId()
            radioBtn.id = newId
            radioBtn.background = plugin.resources!!.getDrawable(outlineId, null)
            radioBtn.setOnClickListener {
                AnimeKaiPlugin.currentAnimeKaiServer = radioBtn.text.toString()
                serverGroup.check(newId)
            }
            serverGroup.addView(radioBtnView)
            if (AnimeKaiPlugin.currentAnimeKaiServer == server.link.first) {
                serverGroup.check(newId)
            }
        }

        return view
    }

    private fun <T : View> View.findView(name: String): T {
        val id = plugin.resources!!.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val dialog = super.onCreateDialog(savedInstanceState)
        (dialog as? BottomSheetDialog)?.behavior?.state = BottomSheetBehavior.STATE_EXPANDED
        return dialog
    }

    private fun restartApp(context: Context) {
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: AnimeKai/src/main/kotlin/com/AnimeKai/Extractor.kt
================================================
package com.AnimeKai

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Voe
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.phisher98.BuildConfig
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject


class Fourspromax : MegaUp() {
    override var mainUrl = "https://4spromax.site"
    override val requiresReferer = true
}

class MegaUpTwoTwo : MegaUp() {
    override var mainUrl = "https://megaup22.online"
    override val requiresReferer = true
}

//Thanks to https://github.com/AzartX47/EncDecEndpoints
open class MegaUp : ExtractorApi() {
    override var name = "MegaUp"
    override var mainUrl = "https://megaup.live"
    override val requiresReferer = true

    companion object {
        private val HEADERS = mapOf(
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0",
                "Accept" to "text/html, *//*; q=0.01",
                "Accept-Language" to "en-US,en;q=0.5",
                "Sec-GPC" to "1",
                "Sec-Fetch-Dest" to "empty",
                "Sec-Fetch-Mode" to "cors",
                "Sec-Fetch-Site" to "same-origin",
                "Priority" to "u=0",
                "Pragma" to "no-cache",
                "Cache-Control" to "no-cache",
                "referer" to "https://animekai.to/",
        )
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val mediaUrl = url.replace("/e/", "/media/").replace("/e2/", "/media/")
        val displayName = referer ?: this.name
        
        val encodedResult = app.get(mediaUrl, headers = HEADERS)
        .parsedSafe<AnimeKaiResponse>()
        ?.result

        if (encodedResult == null) return

        val body = """
        {
        "text": "$encodedResult",
        "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0"
        }
        """.trimIndent()
            .trim()
            .toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val m3u8Data=app.post(BuildConfig.KAIMEG, requestBody = body).text
        if (m3u8Data.isBlank()) {
            Log.d("Phisher", "Encoded result is null or empty")
            return
        }

        try {
            val root = JSONObject(m3u8Data)
            val result = root.optJSONObject("result")
            if (result == null) {
                Log.d("Error:", "No 'result' object in M3U8 JSON")
                return
            }

            val sources = result.optJSONArray("sources") ?: JSONArray()
            if (sources.length() > 0) {
                val firstSourceObj = sources.optJSONObject(0)
                val m3u8File = when {
                    firstSourceObj != null -> firstSourceObj.optString("file").takeIf { it.isNotBlank() }
                    else -> {
                        val maybeString = sources.optString(0)
                        maybeString.takeIf { it.isNotBlank() }
                    }
                }
                if (m3u8File != null) {
                    M3u8Helper.generateM3u8(displayName, m3u8File, mainUrl).forEach(callback)
                } else {
                    Log.d("Error:", "No 'file' found in first source")
                }
            } else {
                Log.d("Error:", "No sources found in M3U8 data")
            }

            val tracks = result.optJSONArray("tracks") ?: JSONArray()
            for (i in 0 until tracks.length()) {
                val trackObj = tracks.optJSONObject(i) ?: continue
                val label = trackObj.optString("label").trim().takeIf { it.isNotEmpty() }
                val file = trackObj.optString("file").takeIf { it.isNotBlank() }
                if (label != null && file != null) {
                    subtitleCallback(newSubtitleFile(label, file))
                }
            }
        } catch (_: JSONException) {
            Log.e("Error", "Failed to parse M3U8 JSON")
        }
      }

    data class AnimeKaiResponse(
        @JsonProperty("status") val status: Int,
        @JsonProperty("result") val result: String
    )

}


================================================
FILE: AnimeKai/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="2dp"
                android:bottomRightRadius="2dp"
                android:topLeftRadius="2dp"
                android:topRightRadius="2dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: AnimeKai/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: AnimeKai/src/main/res/layout/bottom_sheet_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="20dp">

            <TextView
                android:id="@+id/text1"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Extension Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:background="#FFF"
                    android:padding="5dp"
                    android:contentDescription="Save changes" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:text="AnimeKai Domains"
                android:textSize="17sp"
                android:textStyle="bold" />

            <RadioGroup
                android:id="@+id/server_group"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"/>

        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: AnimeKai/src/main/res/layout/radio_button.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <RadioButton
        android:id="@+id/radio_button"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:paddingRight="5dp"
        android:text="test" />
</LinearLayout>



================================================
FILE: Animekhor/build.gradle.kts
================================================
// use an integer for version numbers
version = 8


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Anime and Movies"
    language    = "zh"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime")
    iconUrl="https://animekhor.org/wp-content/uploads/2021/11/AnimeKhor_darkmode.png"

    isCrossPlatform = true
}



================================================
FILE: Animekhor/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Animekhor/src/main/kotlin/com/Animekhor/Animekhor.kt
================================================
package com.Animekhor

import com.lagradost.api.Log
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

open class Animekhor : MainAPI() {
    override var mainUrl              = "https://animekhor.org"
    override var name                 = "Animekhor"
    override val hasMainPage          = true
    override var lang                 = "zh"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime)

    override val mainPage = mainPageOf(
        "anime/?status=ongoing&type=&order=update" to "Recently Updated",
        "anime/?type=comic&order=update" to "Comic Recently Updated",
        "anime/?type=comic" to "Comic Series",
        "anime/?status=&type=ona&sub=&order=update" to "Donghua Recently Updated",
        "anime/?status=&type=ona" to "Donghua Series",
        "anime/?status=&sub=&order=latest" to "Latest Added",
        "anime/?status=&type=&order=popular" to "Popular",
        "anime/?status=completed&order=update" to "Completed",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}&page=$page").documentLarge
        val home     = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.bsx > a").attr("title")
        val href      = fixUrl(this.select("div.bsx > a").attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst("div.bsx > a img")?.getsrcAttribute())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    private fun Element.toSearchquery(): SearchResponse {
        val title     = this.select("div.bsx > a").attr("title")
        val href      = fixUrl(this.select("div.bsx > a").attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst("div.bsx > a img")?.getsrcAttribute())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/page/$i/?s=$query").documentLarge

            val results = document.select("div.listupd > article").mapNotNull { it.toSearchquery() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title= document.selectFirst("h1.entry-title")?.text()?.trim().toString()
        val href=document.selectFirst(".eplister li > a")?.attr("href") ?:""
        var poster = document.select("meta[property=og:image]").attr("content")
        val description = document.selectFirst("div.entry-content")?.text()?.trim()
        val type=document.selectFirst(".spe")?.text().toString()
        val tvtag=if (type.contains("Movie")) TvType.Movie else TvType.TvSeries
        return if (tvtag == TvType.TvSeries) {
            val Eppage= document.selectFirst(".eplister li > a")?.attr("href") ?:""
            val doc= app.get(Eppage).documentLarge
            val epposter = doc.select("meta[property=og:image]").attr("content")
            val episodes=doc.select("div.episodelist > ul > li").map { info->
                        val href1 = info.select("a").attr("href")
                        val episode = info.select("a span").text().substringAfter("-").substringBeforeLast("-")
                        newEpisode(href1)
                        {
                            this.name=episode
                            this.posterUrl=epposter
                        }
            }
            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes.reversed()) {
                this.posterUrl = poster
                this.plot = description
            }
        } else {
            if (poster.isEmpty())
            {
                poster=document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
            }
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select(".mobius option").forEach { server->
            val base64 = server.attr("value")
            val regex = Regex("""src=["']([^"']+)["']""",RegexOption.IGNORE_CASE)
            val decodedUrl = base64Decode(base64)
            val matchResult = regex.find(decodedUrl)
            var url = matchResult?.groups?.get(1)?.value ?: "Not found"
            if (url.startsWith("//"))
            {
                    url= httpsify(url)
            }
            Log.d("Phisher",url)
                loadExtractor(url, referer = mainUrl, subtitleCallback, callback)

        }
        return true
    }

    private fun Element.getsrcAttribute(): String {
        val src = this.attr("src")
        val dataSrc = this.attr("data-src")

        return when {
            src.startsWith("http") -> src
            dataSrc.startsWith("http") -> dataSrc
            else -> ""
        }
    }

}



================================================
FILE: Animekhor/src/main/kotlin/com/Animekhor/AnimekhorProvider.kt
================================================
package com.Animekhor

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Dailymotion
import com.lagradost.cloudstream3.extractors.EmturbovidExtractor
import com.lagradost.cloudstream3.extractors.Mp4Upload

@CloudstreamPlugin
class AnimenosubProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Animekhor())
        registerMainAPI(Donghuaword())
        registerExtractorAPI(embedwish())
        registerExtractorAPI(Filelions())
        registerExtractorAPI(VidHidePro5())
        registerExtractorAPI(Swhoi())
        registerExtractorAPI(EmturbovidExtractor())
        registerExtractorAPI(Dailymotion())
        registerExtractorAPI(Rumble())
        registerExtractorAPI(Mp4Upload())
        registerExtractorAPI(PlayerDonghuaworld())
        registerExtractorAPI(P2pstream())
    }
}


================================================
FILE: Animekhor/src/main/kotlin/com/Animekhor/Donghuaword.kt
================================================
package com.Animekhor

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor


class Donghuaword  : Animekhor() {
    override var mainUrl              = "https://donghuaworld.com"
    override var name                 = "Donghuaword"
    override val hasMainPage          = true
    override var lang                 = "zh"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie, TvType.Anime)

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select("div.server-item a").map {
            val base64=it.attr("data-hash")
            val decodedUrl = base64Decode(base64)
            val regex = Regex("""src=["']([^"']+)["']""",RegexOption.IGNORE_CASE)
            val matchResult = regex.find(decodedUrl)
            val url = matchResult?.groups?.get(1)?.value ?: "Not found"
            loadExtractor(url, referer = mainUrl, subtitleCallback, callback)

        }
        return true
    }
}


================================================
FILE: Animekhor/src/main/kotlin/com/Animekhor/Extractor.kt
================================================
package com.Animekhor


import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink

class embedwish : StreamWishExtractor() {
    override var mainUrl = "https://embedwish.com"
}

class P2pstream : VidStack() {
    override var mainUrl = "https://animekhor.p2pstream.vip"
}

class Filelions : VidhideExtractor() {
    override var name = "Filelions"
    override var mainUrl = "https://filelions.live"
}

class Swhoi : StreamWishExtractor() {
    override var mainUrl = "https://swhoi.com"
    override val requiresReferer = true
}

class VidHidePro5: VidHidePro() {
    override val mainUrl = "https://vidhidevip.com"
    override val requiresReferer = true
}

class PlayerDonghuaworld: Rumble() {
    override var mainUrl = "https://player.donghuaworld.in"
    override val requiresReferer = true
}

open class Rumble : ExtractorApi() {
    override var name = "Rumble"
    override var mainUrl = "https://rumble.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val response = app.get(url, referer = referer ?: "$mainUrl/")
        val document = response.documentLarge

        val playerScript = document.selectFirst("script:containsData(jwplayer)")?.data()
            ?: return

        // Extract sources (mp4 or m3u8)
        val sourceRegex = """"file"\s*:\s*"(https:[^"]+\.(?:mp4|m3u8)[^"]*)"""".toRegex()
        val sources = sourceRegex.findAll(playerScript)

        for ((index, source) in sources.withIndex()) {
            val index = index + 1
            val fileUrl = source.groupValues[1].replace("\\/", "/")
            if (fileUrl.contains(".mp4"))
            {
                callback.invoke(
                    newExtractorLink(
                        name,
                        "$name Video Server $index",
                        url = fileUrl,
                        INFER_TYPE
                    ) {
                        this.referer = ""
                        this.quality = getQualityFromName("")
                    }
                )
            } else M3u8Helper.generateM3u8(name, fileUrl, mainUrl).forEach(callback)
            val fallback="${mainUrl}/hls-vod/${url.substringAfter("/embed/v").substringBefore("/")}/playlist.m3u8?u=0&b=0"
            M3u8Helper.generateM3u8(name, fallback, mainUrl).forEach(callback)
        }


        // Extract subtitle tracks
        val trackRegex = """"file"\s*:\s*"(https:[^"]+\.vtt[^"]*)"\s*,\s*"label"\s*:\s*"([^"]+)"""".toRegex()
        val tracks = trackRegex.findAll(playerScript)

        for (track in tracks) {
            val fileUrl = track.groupValues[1].replace("\\/", "/")
            val label = track.groupValues[2]

            subtitleCallback.invoke(
                newSubtitleFile(label, fileUrl)
            )
        }
    }
}




================================================
FILE: Animenosub/build.gradle.kts
================================================
// use an integer for version numbers
version = 7


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Anime and Movies"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://animenosub.to/wp-content/uploads/2024/02/Animenosub-logo.png"

    isCrossPlatform = true
}



================================================
FILE: Animenosub/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Animenosub/src/main/kotlin/com/Animenosub/Animenosub.kt
================================================
package com.Animenosub

import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class Animenosub : MainAPI() {
    override var mainUrl              = "https://animenosub.to"
    override var name                 = "Animenosub"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime)

    override val mainPage = mainPageOf(
        "anime/?status=&type=&order=update&page=" to "Recently Updated",
        "anime/?type=tv&page=" to "Anime",
        "anime/?status=&type=tv&sub=sub&page=" to "Anime (SUB)",
        "anime/?status=&type=tv&sub=dub&page=" to "Anime (DUB)",
        "anime/?status=&type=movie&page=" to "Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}$page").documentLarge
        val home     = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.bsx > a").attr("title")
        val href      = fixUrl(this.select("div.bsx > a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.bsx > a img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/page/$i/?s=$query").documentLarge

            val results = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("h1.entry-title")?.text()?.trim().toString()
        val href=document.selectFirst(".eplister li > a")?.attr("href") ?:""
        var poster = document.select("div.ime > img").attr("src")
        val description = document.selectFirst("div.entry-content")?.text()?.trim()
        val type=document.selectFirst(".spe")?.text().toString()
        val tvtag=if (type.contains("Movie")) TvType.Movie else TvType.TvSeries
        return if (tvtag == TvType.TvSeries) {
            val episodes=document.select("div.eplister > ul > li").map { info->
                        val href1 = info.select("a").attr("href")
                        val episode = info.select("a div.epl-title").text().substringAfter("-").substringBeforeLast("-")
                        val posterr=info.selectFirst("a img")?.attr("src") ?:""
                        newEpisode(href1)
                        {
                            this.name=episode
                            this.posterUrl=posterr
                        }
            }.reversed()
            if (poster.isEmpty())
            {
                poster=document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
            }
            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes) {
                this.posterUrl = poster
                this.plot = description
            }
        } else {
            if (poster.isEmpty())
            {
                poster=document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
            }
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select(".mobius option").amap { server ->
            val base64 = server.attr("value")
            val iframe = Jsoup.parse(base64Decode(base64)).select("iframe").attr("src")
            if (iframe.startsWith("//"))
            {
                val fixiframe=fixUrl(iframe)
                loadExtractor(fixiframe,referer = fixiframe,subtitleCallback, callback)
            }
            else {
                Log.d("Phisher",iframe)
                loadExtractor(iframe, referer = iframe, subtitleCallback, callback)
            }
        }
        return true
    }
}



================================================
FILE: Animenosub/src/main/kotlin/com/Animenosub/AnimenosubProvider.kt
================================================
package com.Animenosub

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnimenosubProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Animenosub())
        registerExtractorAPI(Vtbe())
        registerExtractorAPI(waaw())
        registerExtractorAPI(wishfast())
        registerExtractorAPI(FileMoonSx())
        registerExtractorAPI(AnimenosubExtractor())
    }
}


================================================
FILE: Animenosub/src/main/kotlin/com/Animenosub/Extractor.kt
================================================
package com.Animenosub


import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

open class Vtbe : ExtractorApi() {
    override var name = "Vtbe"
    override var mainUrl = "https://vtbe.to"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
        val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
        JsUnpacker(extractedpack).unpack()?.let { unPacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        }
        return null
    }
}

class wishfast : StreamWishExtractor() {
    override var mainUrl = "https://wishfast.top"
    override var name = "StreamWish"
}

class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class FileMoonSx : Filesim() {
    override val mainUrl = "https://filemoon.sx"
    override val name = "FileMoonSx"
}


class AnimenosubExtractor : ExtractorApi() {
    override var name = "Animenosub"
    override var mainUrl = "https://animenosub.upn.one"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers= mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0")
        val hash=url.substringAfterLast("#")
        val encoded= app.get("$mainUrl/api/v1/video?id=$hash",headers=headers).text.trim()
        val decryptedText = AesHelper.decryptAES(encoded, "kiemtienmua911ca", "0123456789abcdef")
        val m3u8=Regex("\"source\":\"(.*?)\"").find(decryptedText)?.groupValues?.get(1)?.replace("\\/","/") ?:""
        if (m3u8.isNotEmpty())
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    this.name,
                    m3u8,
                    ExtractorLinkType.M3U8
                ){
                    this.referer = url
                    this.quality = Qualities.P1080.value
                }
            )
        }
    }
}

object AesHelper {
    private const val TRANSFORMATION = "AES/CBC/PKCS5PADDING"

    fun decryptAES(inputHex: String, key: String, iv: String): String {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        val secretKey = SecretKeySpec(key.toByteArray(Charsets.UTF_8), "AES")
        val ivSpec = IvParameterSpec(iv.toByteArray(Charsets.UTF_8))

        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
        val decryptedBytes = cipher.doFinal(inputHex.hexToByteArray())
        return String(decryptedBytes, Charsets.UTF_8)
    }

    private fun String.hexToByteArray(): ByteArray {
        check(length % 2 == 0) { "Hex string must have an even length" }
        return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }
}



================================================
FILE: AnimePahe/build.gradle.kts
================================================
// use an integer for version numbers
version = 16


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    description = "Animes (SUB/DUB)"
    authors = listOf("Cloudburst,Lorem Ipsum,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "OVA",
    )
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/animepahe.png"

    isCrossPlatform = true
}



================================================
FILE: AnimePahe/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: AnimePahe/src/main/kotlin/com/Phisher98/AnimePahe.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.APIHolder.unixTime
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.mvvm.safeAsync
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.Jsoup
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit

class AnimePahe : MainAPI() {
    companion object {
        const val MAIN_URL = "https://animepahe.si"
        val headers = mapOf("Cookie" to "__ddg2_=1234567890")
        private const val Proxy="https://animepaheproxy.phisheranimepahe.workers.dev/?url="
        //var cookies: Map<String, String> = mapOf()
        private fun getType(t: String): TvType {
            return if (t.contains("OVA") || t.contains("Special")) TvType.OVA
            else if (t.contains("Movie")) TvType.AnimeMovie
            else TvType.Anime
        }
    }

    override var mainUrl = MAIN_URL
    override var name = "AnimePahe"
    override val hasQuickSearch = false
    override val hasMainPage = true

    override val supportedTypes = setOf(
        TvType.AnimeMovie,
        TvType.Anime,
        TvType.OVA
    )

    override val mainPage =
        listOf(MainPageData("Latest Releases", "$Proxy$mainUrl/api?m=airing&page=", true))

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        data class Data(
//            @JsonProperty("id") val id: Int,
//            @JsonProperty("anime_id") val animeId: Int,
            @JsonProperty("anime_title") val animeTitle: String,
//            @JsonProperty("anime_slug") val animeSlug: String,
            @JsonProperty("episode") val episode: Int?,
            @JsonProperty("snapshot") val snapshot: String?,
            @JsonProperty("created_at") val createdAt: String?,
            @JsonProperty("anime_session") val animeSession: String,
        )

        data class AnimePaheLatestReleases(
            @JsonProperty("total") val total: Int,
            @JsonProperty("data") val data: List<Data>
        )
        val response = app.get(request.data + page, headers = headers).text
        val episodes = parseJson<AnimePaheLatestReleases>(response).data.map {
            newAnimeSearchResponse(
                it.animeTitle,
                LoadData(it.animeSession, unixTime, it.animeTitle).toJson(),
                fix = false
            ) {
                this.posterUrl = it.snapshot
                addDubStatus(DubStatus.Subbed, it.episode)
            }
        }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = episodes,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    data class AnimePaheSearchData(
        @JsonProperty("id") val id: Int?,
        @JsonProperty("slug") val slug: String?,
        @JsonProperty("title") val title: String,
        @JsonProperty("type") val type: String?,
        @JsonProperty("episodes") val episodes: Int?,
        @JsonProperty("status") val status: String?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("year") val year: Int?,
        @JsonProperty("score") val score: Double?,
        @JsonProperty("poster") val poster: String?,
        @JsonProperty("session") val session: String,
        @JsonProperty("relevance") val relevance: String?
    )

    data class AnimePaheSearch(
        @JsonProperty("total") val total: Int,
        @JsonProperty("data") val data: List<AnimePaheSearchData>
    )


    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$Proxy$mainUrl/api?m=search&l=8&q=$query"
        val headers = mapOf("referer" to "$mainUrl/","Cookie" to "__ddg2_=1234567890")

        val req = app.get(url, headers = headers).text
        val data = parseJson<AnimePaheSearch>(req)

        return data.data.map {
            newAnimeSearchResponse(
                it.title,
                LoadData(it.session, unixTime, it.title).toJson(),
                fix = false
            ) {
                this.posterUrl = it.poster
                addDubStatus(DubStatus.Subbed, it.episodes)
            }
        }
    }

    private data class AnimeData(
        @JsonProperty("id") val id: Int,
        @JsonProperty("anime_id") val animeId: Int,
        @JsonProperty("episode") val episode: Int,
        @JsonProperty("title") val title: String,
        @JsonProperty("snapshot") val snapshot: String,
        @JsonProperty("session") val session: String,
        @JsonProperty("filler") val filler: Int,
        @JsonProperty("created_at") val createdAt: String
    )

    private data class AnimePaheAnimeData(
        @JsonProperty("total") val total: Int,
        @JsonProperty("per_page") val perPage: Int,
        @JsonProperty("current_page") val currentPage: Int,
        @JsonProperty("last_page") val lastPage: Int,
        @JsonProperty("next_page_url") val nextPageUrl: String?,
        @JsonProperty("prev_page_url") val prevPageUrl: String?,
        @JsonProperty("from") val from: Int,
        @JsonProperty("to") val to: Int,
        @JsonProperty("data") val data: List<AnimeData>
    )

    data class LinkLoadData(
        @JsonProperty("mainUrl") val mainUrl: String,
        @JsonProperty("is_play_page") val is_play_page: Boolean,
        @JsonProperty("episode_num") val episode_num: Int,
        @JsonProperty("page") val page: Int,
        @JsonProperty("session") val session: String,
        @JsonProperty("episode_session") val episode_session: String,
    ) {
        private val headers = mapOf("Cookie" to "__ddg2_=1234567890")
        suspend fun getUrl(): String? {
            return if (is_play_page) {
                "$Proxy$mainUrl/play/${session}/${episode_session}"
            } else {
                val url = "$Proxy$mainUrl/api?m=release&id=${session}&sort=episode_asc&page=${page + 1}"
                val jsonResponse = app.get(url,headers=headers).parsedSafe<AnimePaheAnimeData>() ?: return null
                val episode = jsonResponse.data.firstOrNull { it.episode == episode_num }?.session
                    ?: return null
                "$Proxy$mainUrl/play/${session}/${episode}"
            }
        }
    }

    @OptIn(DelicateCoroutinesApi::class)
    private suspend fun generateListOfEpisodes(session: String): ArrayList<Episode> {
        val episodes = ArrayList<Episode>()
        val semaphore = Semaphore(5) // Limit to 5 concurrent requests (adjust based on server capability)

        try {
            val uri = "https://animepaheproxy.phisheranimepahe.workers.dev/?url=$mainUrl/api?m=release&id=$session&sort=episode_asc&page=1"
            val req = app.get(uri, headers = headers).text
            val data = parseJson<AnimePaheAnimeData>(req)

            val lastPage = data.lastPage
            val perPage = data.perPage
            val total = data.total
            var currentEpisode = 1

            fun getEpisodeTitle(episodeData: AnimeData): String {
                return episodeData.title.ifEmpty { "Episode ${episodeData.episode}" }
            }
            // If only one page, process all episodes in that page
            if (lastPage == 1 && perPage > total) {
                data.data.forEach { episodeData ->
                    episodes.add(
                        newEpisode(
                            LinkLoadData(
                                mainUrl,
                                true,
                                0,
                                0,
                                session,
                                episodeData.session
                            ).toJson()
                        ) {
                            addDate(episodeData.createdAt)
                            this.name = getEpisodeTitle(episodeData)
                            this.posterUrl = episodeData.snapshot
                        }
                    )
                }
            } else {
                // Fetch multiple pages concurrently with limited threads
                val deferredResults = (1..lastPage).map { page ->
                    GlobalScope.async {
                        semaphore.withPermit {
                            try {
                                val pageUri = "$mainUrl/api?m=release&id=$session&sort=episode_asc&page=$page"
                                val pageReq = app.get(pageUri, headers = headers).text
                                val pageData = parseJson<AnimePaheAnimeData>(pageReq)
                                pageData.data.map { episodeData ->
                                    newEpisode(
                                        LinkLoadData(
                                            mainUrl,
                                            true,
                                            currentEpisode++,
                                            page,
                                            session,
                                            episodeData.session
                                        ).toJson()
                                    ) {
                                        addDate(episodeData.createdAt)
                                        this.name = getEpisodeTitle(episodeData)
                                        this.posterUrl = episodeData.snapshot
                                    }
                                }
                            } catch (e: Exception) {
                                Log.e("generateListOfEpisodes", "Error on page $page: ${e.message}")
                                emptyList<Episode>()
                            }
                        }
                    }
                }

                // Wait for all pages to load and combine results
                episodes.addAll(deferredResults.awaitAll().flatten())
            }

        } catch (e: Exception) {
            Log.e("generateListOfEpisodes", "Error generating episodes: ${e.message}")
        }
        return episodes
    }
    /**
     * Required to make bookmarks work with a session system
     **/
    data class LoadData(val session: String, val sessionDate: Long, val name: String)

    override suspend fun load(url: String): LoadResponse? {
        return safeAsync {
            val session = parseJson<LoadData>(url).let { data ->
                // Outdated
                if (data.sessionDate + 60 * 10 < unixTime) {
                    parseJson<LoadData>(
                        search(data.name).firstOrNull()?.url ?: return@let null
                    ).session
                } else {
                    data.session
                }
            } ?: return@safeAsync null
            val html = app.get("$Proxy$mainUrl/anime/$session",headers=headers).text
            val doc = Jsoup.parse(html)
            val japTitle = doc.selectFirst("h2.japanese")?.text()
            val animeTitle = doc.selectFirst("span.sr-only.unselectable")?.text()
            val poster = doc.selectFirst(".anime-poster a")?.attr("href")

            val tvType = doc.selectFirst("""a[href*="/anime/type/"]""")?.text()

            /*
            val trailer: String? = if (html.contains("https://www.youtube.com/watch")) {
                YOUTUBE_VIDEO_LINK.find(html)?.destructured?.component1()
            } else {
                null
            }
             */
            val episodes = generateListOfEpisodes(session)
            val year = Regex("""<strong>Aired:</strong>[^,]*, (\d+)""")
                .find(html)?.destructured?.component1()
                ?.toIntOrNull()

            val status =
                if (doc.selectFirst("a[href='/anime/airing']") != null)
                    ShowStatus.Ongoing
                else if (doc.selectFirst("a[href='/anime/completed']") != null)
                    ShowStatus.Completed
                else null

            val synopsis = doc.selectFirst(".anime-synopsis")?.text()

            var anilistId: Int? = null
            var malId: Int? = null

            doc.select(".external-links > a").forEach { aTag ->
                val split = aTag.attr("href").split("/")

                if (aTag.attr("href").contains("anilist.co")) {
                    anilistId = split[split.size - 1].toIntOrNull()
                } else if (aTag.attr("href").contains("myanimelist.net")) {
                    malId = split[split.size - 1].toIntOrNull()
                }
            }

            newAnimeLoadResponse(animeTitle ?: japTitle ?: "", url, getType(tvType.toString())) {
                engName = animeTitle
                japName = japTitle
                this.posterUrl = poster
                this.year = year
                addEpisodes(DubStatus.Subbed, episodes)
                this.showStatus = status
                plot = synopsis
                tags = if (!doc.select(".anime-genre > ul a").isEmpty()) {
                    ArrayList(doc.select(".anime-genre > ul a").map { it.text() })
                } else {
                    null
                }

                addMalId(malId)
                addAniListId(anilistId)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val parsed = parseJson<LinkLoadData>(data)
        val episodeUrl = parsed.getUrl() ?: ""
        val document= app.get(episodeUrl, headers= headers).documentLarge
        document.select("#resolutionMenu button")
            .map {
                val dubText = it.select("span").text().lowercase()
                val type = if ("eng" in dubText) "DUB" else "SUB"

                val qualityRegex = Regex("""(.+?)\s+·\s+(\d{3,4}p)""")
                val text = it.text()
                val match = qualityRegex.find(text)
                val source = match?.groupValues?.getOrNull(1)?.trim() ?: "Unknown"
                val quality = match?.groupValues?.getOrNull(2)?.substringBefore("p")?.toIntOrNull()
                    ?: Qualities.Unknown.value

                val href = it.attr("data-src")
                if ("kwik" in href) {
                    loadCustomExtractor(
                        "Animepahe $source [$type]",
                        href,
                        "",
                        subtitleCallback,
                        callback,
                        quality
                    )
                }
            }


        document.select("div#pickDownload > a").amap {
            val qualityRegex = Regex("""(.+?)\s+·\s+(\d{3,4}p)""")
            val href = it.attr("href")
            var type = "SUB"
            if(it.select("span").text().contains("eng"))
                type="DUB"
            val text = it.text()
            val match = qualityRegex.find(text)
            val source = match?.groupValues?.getOrNull(1) ?: "Unknown"
            val quality = match?.groupValues?.getOrNull(2)?.substringBefore("p") ?: "Unknown"

            loadCustomExtractor(
                "Animepahe Pahe $source [$type]",
                href,
                "",
                subtitleCallback,
                callback,
                quality.toIntOrNull()
            )
        }
        return true
    }
}



================================================
FILE: AnimePahe/src/main/kotlin/com/Phisher98/AnimePahePlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnimePaheProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AnimePahe())
        registerExtractorAPI(Kwik())
        registerExtractorAPI(Pahe())
    }
}


================================================
FILE: AnimePahe/src/main/kotlin/com/Phisher98/Utils.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import okhttp3.FormBody
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response


suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}

class Kwik : ExtractorApi() {
    override val name            = "Kwik"
    override val mainUrl         = "https://kwik.cx"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit) {
        val res = app.get(url,referer=url)
        val script =
            res.documentLarge.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data()
        val unpacked = getAndUnpack(script ?: return)
        val m3u8 =Regex("source=\\s*'(.*?m3u8.*?)'").find(unpacked)?.groupValues?.getOrNull(1) ?:""
        callback.invoke(
            newExtractorLink(
                name,
                name,
                url = m3u8,
                INFER_TYPE
            ) {
                this.referer = mainUrl
                this.quality = getQualityFromName("")
                this.headers= mapOf("origin" to mainUrl)
            }
        )
    }
}

//Credit Thanks to https://github.com/SaurabhKaperwan/CSX/blob/7256fe183966412b2323beb15d03331009bfb80f/CineStream/src/main/kotlin/com/megix/Extractors.kt#L108
class Pahe : ExtractorApi() {
    override val name = "Pahe"
    override val mainUrl = "https://pahe.win"
    override val requiresReferer = true
    private val kwikParamsRegex = Regex("""\("(\w+)",\d+,"(\w+)",(\d+),(\d+),\d+\)""")
    private val kwikDUrl = Regex("action=\"([^\"]+)\"")
    private val kwikDToken = Regex("value=\"([^\"]+)\"")
    private val client = OkHttpClient()

    private fun decrypt(fullString: String, key: String, v1: Int, v2: Int): String {
        val keyIndexMap = key.withIndex().associate { it.value to it.index }
        val sb = StringBuilder()
        var i = 0
        val toFind = key[v2]

        while (i < fullString.length) {
            val nextIndex = fullString.indexOf(toFind, i)
            val decodedCharStr = buildString {
                for (j in i until nextIndex) {
                    append(keyIndexMap[fullString[j]] ?: -1)
                }
            }

            i = nextIndex + 1

            val decodedChar = (decodedCharStr.toInt(v2) - v1).toChar()
            sb.append(decodedChar)
        }

        return sb.toString()
    }

    override suspend fun getUrl(url: String, referer: String?, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit) {
        val noRedirects = OkHttpClient.Builder()
            .followRedirects(false)
            .followSslRedirects(false)
            .build()

        val initialRequest = Request.Builder()
            .url("$url/i")
            .get()
            .build()

        val kwikUrl = "https://" + noRedirects.newCall(initialRequest).execute()
            .header("location")!!.substringAfterLast("https://")

        val fContentRequest = Request.Builder()
            .url(kwikUrl)
            .header("referer", "https://kwik.cx/")
            .get()
            .build()

        val fContent = client.newCall(fContentRequest).execute()
        val fContentString = fContent.body.string()

        val (fullString, key, v1, v2) = kwikParamsRegex.find(fContentString)!!.destructured
        val decrypted = decrypt(fullString, key, v1.toInt(), v2.toInt())

        val uri = kwikDUrl.find(decrypted)!!.destructured.component1()
        val tok = kwikDToken.find(decrypted)!!.destructured.component1()

        val noRedirectClient = OkHttpClient().newBuilder()
            .followRedirects(false)
            .followSslRedirects(false)
            .cookieJar(client.cookieJar)
            .build()

        var code = 419
        var tries = 0
        var content: Response? = null

        while (code != 302 && tries < 20) {
            val formBody = FormBody.Builder()
                .add("_token", tok)
                .build()

            val postRequest = Request.Builder()
                .url(uri)
                .header("user-agent", " Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36")
                .header("referer", fContent.request.url.toString())
                .header("cookie",  fContent.headers("set-cookie").firstOrNull().toString())
                .post(formBody)
                .build()

            content = noRedirectClient.newCall(postRequest).execute()
            code = content.code
            tries++
        }

        val location = content?.header("location").toString()
        content?.close()

        callback.invoke(
            newExtractorLink(
                name,
                name,
                url = location,
                INFER_TYPE
            ) {
                this.referer = "https://kwik.cx/"
                this.quality = getQualityFromName("")
            }
        )
    }
}


================================================
FILE: Animesalt/build.gradle.kts
================================================
version = 4


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

    description = "Anime/Cartoon in Hindi"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "Cartoon"
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=animesalt.cc&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: Animesalt/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />



================================================
FILE: Animesalt/src/main/kotlin/com/phisher98/Animesalt.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element

class Animesalt : MainAPI() {
    override var mainUrl = "https://animesalt.top"
    override var name = "Animesalt"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    override val mainPage =
            mainPageOf(
                    "category/status/ongoing" to "On-Air Shows",
                    "category/type/anime/?type=series" to "New Anime Arrivals",
                    "category/type/cartoon/?type=series" to "Just In: Cartoon Series",
                    "category/type/anime/?type=movies" to "Latest Anime Movies",
                    "category/type/cartoon/?type=movies" to "Fresh Cartoon Films",
                    "category/network/crunchyroll" to "Crunchyroll",
                    "category/network/netflix" to "Netflix",
                    "category/network/prime-video" to "Prime Video"
            )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url=if(request.data.contains("type="))
        {
            val data=request.data.split("/?type=")
            "$mainUrl/${data[0]}/page/$page/?type=${data[1]}"
        }
        else
        {
            "$mainUrl/${request.data}/page/$page"
        }
        val document = app.get(url).documentLarge
        val home = document.select("article").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("header h2")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.getImageAttr())

        return newMovieSearchResponse(title, href, TvType.Movie) { this.posterUrl = posterUrl }
    }

    private fun Element.toRecommend(): SearchResponse {
        val title = ""
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("data-src"))

        return newMovieSearchResponse(title, href, TvType.Movie) { this.posterUrl = posterUrl }
    }

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        val formData = mapOf(
            "action" to "torofilm_infinite_scroll",
            "page" to page.toString(),
            "per_page" to "12",
            "query_type" to "search",
            "query_args[s]" to query
        )
        val response = app.post("$mainUrl/wp-admin/admin-ajax.php", data = formData)
            .parsedSafe<Search>() ?: return null
        val doc = response.data.asJsoup()
        val results = doc.select("article")
            .mapNotNull { it.toSearchResult() }
        return results.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title =document.selectFirst("h1")?.text()?: throw NotImplementedError("Unable to find title")
        val poster = fixUrlNull(document.selectFirst("div.bgft img")?.attr("data-src"))
        val sections = listOf("Genres", "Languages")
        val tags: List<String> = sections.flatMap { label ->
            document.select("h4:contains($label)")
                .first()
                ?.nextElementSibling()
                ?.select("a")
                ?.map { it.text() }
                ?: emptyList()
        }
        val yearDiv = document.select("div").firstOrNull { it.text().trim().matches(Regex("\\d{4}")) }
        val year = yearDiv?.text()?.trim()?.toIntOrNull()
        val tvType = if (url.contains("movies")) TvType.Movie else TvType.TvSeries
        val description = document.selectFirst("#overview-text p")?.text()?.trim()
        val recommendations = document.select("section.section.episodes div.owl-carousel article").mapNotNull { it.toRecommend() }
        return if (tvType == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            document.select("div.season-buttons a").forEach { seasonBtn ->
                val postId = seasonBtn.attr("data-post")
                val dataSeason = seasonBtn.attr("data-season")

                val seasonResponse = app.post(
                    "$mainUrl/wp-admin/admin-ajax.php",
                    data = mapOf(
                        "action" to "action_select_season",
                        "season" to dataSeason,
                        "post" to postId
                    )
                )

                seasonResponse.documentLarge.select("li article").forEachIndexed { index, ep ->
                    val href = ep.select("a").attr("href")
                    val image = ep.select("div.post-thumbnail img").attr("src")
                    val spanText = ep.select("h2.entry-title").text()
                    val season = dataSeason.toIntOrNull()
                    val episodeNumber = index + 1
                    val epName = if (spanText.contains("x$episodeNumber")) {
                        "Episode $episodeNumber"
                    } else {
                        spanText
                    }

                    episodes.add(newEpisode(href) {
                        this.name = epName
                        this.season = season
                        this.episode = episodeNumber
                        this.posterUrl = image
                    })
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.recommendations = recommendations
            }
        } else {
            return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
            }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).documentLarge.select("#options-0 iframe").forEach { iframeElement ->
            loadExtractor(iframeElement.attr("data-src"),mainUrl,subtitleCallback, callback)
        }
        return true
    }

    data class Search(
        val success: Boolean,
        val data: Data,
    )

    data class Data(
        val content: String,
        @JsonProperty("has_more")
        val hasMore: Boolean,
        @JsonProperty("max_pages")
        val maxPages: Long,
    ) {
        fun asJsoup(): Document {
            return Jsoup.parse(content)
        }
    }

    private fun Element.getImageAttr(): String? {
        return this.attr("data-src")
            .takeIf { it.isNotBlank() }
            ?: this.attr("src").takeIf { it.isNotBlank() }
    }
}



================================================
FILE: Animesalt/src/main/kotlin/com/phisher98/AnimesaltProvider.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnimesaltProvider : BasePlugin() {
    override fun load() {
        registerMainAPI(Animesalt())
        registerExtractorAPI(Pixdrive())
        registerExtractorAPI(Ghbrisk())
        registerExtractorAPI(AWSStream())
        registerExtractorAPI(Zephyrflick())
        registerExtractorAPI(betaAwstream())
        registerExtractorAPI(MegaPlay())
        registerExtractorAPI(Rapid())
        registerExtractorAPI(ascdn21())
    }
}



================================================
FILE: Animesalt/src/main/kotlin/com/phisher98/Extractor.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.newExtractorLink

class Pixdrive : Filesim() {
    override var mainUrl = "https://pixdrive.cfd"
}

class Ghbrisk : Filesim() {
    override val name = "Streamwish"
    override val mainUrl = "https://ghbrisk.com"
    override val requiresReferer = true
}

class ascdn21 : AWSStream() {
    override val name = "Zephyrflick"
    override val mainUrl = "https://as-cdn21.top"
    override val requiresReferer = true
}

class Zephyrflick : AWSStream() {
    override val name = "Zephyrflick"
    override val mainUrl = "https://play.zephyrflick.top"
    override val requiresReferer = true
}

class betaAwstream : AWSStream() {
    override val name = "AWSStream"
    override val mainUrl = "https://beta.awstream.net"
    override val requiresReferer = true
}

class Rapid : MegaPlay() {
    override val name = "Rapid"
    override val mainUrl = "https://rapid-cloud.co"
    override val requiresReferer = true
}

open class AWSStream : ExtractorApi() {
    override val name = "AWSStream"
    override val mainUrl = "https://z.awstream.net"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val extractedHash = url.substringAfterLast("/")
        val doc = app.get(url).documentLarge
        val m3u8Url = "$mainUrl/player/index.php?data=$extractedHash&do=getVideo"
        val header = mapOf("x-requested-with" to "XMLHttpRequest")
        val formdata = mapOf("hash" to extractedHash, "r" to mainUrl)
        val response = app.post(m3u8Url, headers = header, data = formdata).parsedSafe<Response>()
        response?.videoSource?.let { m3u8 ->
            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    url = m3u8,
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = ""
                    this.quality = Qualities.P1080.value
                }
            )
            val extractedPack = doc.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().orEmpty()

            JsUnpacker(extractedPack).unpack()?.let { unpacked ->
                Regex(""""kind":\s*"captions"\s*,\s*"file":\s*"(https.*?\.srt)""")
                    .find(unpacked)
                    ?.groupValues
                    ?.get(1)
                    ?.let { subtitleUrl ->
                        subtitleCallback.invoke(
                            newSubtitleFile(
                                "English",
                                subtitleUrl
                            )
                        )
                    }
            }
        }
    }

    data class Response(
        val hls: Boolean,
        val videoImage: String,
        val videoSource: String,
        val securedLink: String,
        val downloadLinks: List<Any?>,
        val attachmentLinks: List<Any?>,
        val ck: String,
    )
}

open class MegaPlay : ExtractorApi() {
    override val name = "MegaPlay"
    override val mainUrl = "https://megaplay.buzz"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val mainheaders = mapOf(
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.5",
            "Accept-Encoding" to "gzip, deflate, br, zstd",
            "Origin" to "https://rapid-cloud.co",
            "Referer" to "https://rapid-cloud.co/",
            "Connection" to "keep-alive",
            "Pragma" to "no-cache",
            "Cache-Control" to "no-cache"
        )

        try {
            // --- Primary API Method ---
            val headers = mapOf(
                "Accept" to "*/*",
                "X-Requested-With" to "XMLHttpRequest",
                "Referer" to mainUrl
            )

            val id = app.get(url, headers = headers).documentLarge.selectFirst("#megaplay-player")?.attr("data-id")

            val apiUrl = "$mainUrl/stream/getSources?id=$id&id=$id"
            val gson = Gson()
            val response = try {
                val json = app.get(apiUrl, headers).text
                gson.fromJson(json, MegaPlay::class.java)
            } catch (_: Exception) {
                null
            }

            val encoded = response?.sources?.file
                ?: throw Exception("No sources found")
            Log.d("Phisher",encoded)
            val m3u8: String = encoded

            M3u8Helper.generateM3u8(name, m3u8, mainUrl, headers = mainheaders).forEach(callback)

            response.tracks.forEach { track ->
                if (track.kind == "captions" || track.kind == "subtitles") {
                    subtitleCallback(newSubtitleFile(track.label, track.file))
                }
            }
        } catch (e: Exception) {
            // --- Fallback using WebViewResolver ---
            Log.e("Megacloud", "Primary method failed, using fallback: ${e.message}")

            val jsToClickPlay = """
                (() => {
                    const btn = document.querySelector('.jw-icon-display.jw-button-color.jw-reset');
                    if (btn) { btn.click(); return "clicked"; }
                    return "button not found";
                })();
            """.trimIndent()

            val m3u8Resolver = WebViewResolver(
                interceptUrl = Regex("""master\.m3u8"""),
                additionalUrls = listOf(Regex("""master\.m3u8""")),
                script = jsToClickPlay,
                scriptCallback = { result -> Log.d("Megacloud", "JS Result: $result") },
                useOkhttp = false,
                timeout = 15_000L
            )

            val vttResolver = WebViewResolver(
                interceptUrl = Regex("""\.vtt"""),
                additionalUrls = listOf(Regex("""\.vtt""")),
                script = jsToClickPlay,
                scriptCallback = { result -> Log.d("Megacloud", "Subtitle JS Result: $result") },
                useOkhttp = false,
                timeout = 15_000L
            )

            try {
                val vttResponse = app.get(url = url, referer = mainUrl, interceptor = vttResolver)
                val subtitleUrls = listOf(vttResponse.url)
                    .filter { it.endsWith(".vtt") && !it.contains("thumbnails", ignoreCase = true) }
                subtitleUrls.forEachIndexed { _, subUrl ->
                    subtitleCallback(newSubtitleFile("English", subUrl))
                }

                val fallbackM3u8 = app.get(url = url, referer = mainUrl, interceptor = m3u8Resolver).url
                M3u8Helper.generateM3u8(name, fallbackM3u8, mainUrl, headers = mainheaders).forEach(callback)

            } catch (ex: Exception) {
                Log.e("Megacloud", "Fallback also failed: ${ex.message}")
            }
        }
    }

    data class MegaPlay(
        val sources: Sources,
        val tracks: List<Track>,
        val t: Long,
        val intro: Intro,
        val outro: Outro,
        val server: Long,
    )

    data class Sources(
        val file: String,
    )

    data class Track(
        val file: String,
        val label: String,
        val kind: String,
        val default: Boolean?,
    )

    data class Intro(
        val start: Long,
        val end: Long,
    )

    data class Outro(
        val start: Long,
        val end: Long,
    )
}




================================================
FILE: AnimeWorld/build.gradle.kts
================================================
version = 5


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

    description = "Anime/Cartoon in Hindi"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "Cartoon"
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/animeworld.jpg"

    isCrossPlatform = true
}



================================================
FILE: AnimeWorld/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />



================================================
FILE: AnimeWorld/src/main/kotlin/com/Phisher98/AnimeWorld.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class AnimeWorld : MainAPI() {
    override var mainUrl = "https://myanimeworld.in"
    override var name = "AnimeWorld"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)
    companion object
    {
        const val API="https://z.awstream.net"
    }

    override val mainPage =
            mainPageOf(
                "series" to "Series",
                "movies" to "Movies",
                "platform/netflix" to "Netflix",
                "platform/crunchyroll" to "Crunchyroll",
                "genre/kids" to "Cartoon Network"
            )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val currentPageUrl = "$mainUrl/${request.data}?page=$page"
        val nextPageUrl = "$mainUrl/${request.data}?page=${page + 1}"

        val currentPageDocument = app.get(currentPageUrl).documentLarge
        val nextPageDocument = app.get(nextPageUrl).documentLarge

        val currentResults = currentPageDocument.select("#movies-a ul li").mapNotNull { it.toSearchResult() }
        val nextResults = nextPageDocument.select("#movies-a ul li").mapNotNull { it.toSearchResult() }

        val combinedResults = currentResults + nextResults

        return newHomePageResponse(request.name, combinedResults)
    }


    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("header h2")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.getImageAttr())

        return newMovieSearchResponse(title, href, TvType.Movie) { this.posterUrl = posterUrl }
    }

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val document = app.get("$mainUrl/search?q=$query&page=$page").documentLarge
        return document.select("#movies-a ul li").mapNotNull { it.toSearchResult() }.toNewSearchResponseList()
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title =document.selectFirst("div.dfxb  h2.entry-title")?.text() ?: document.selectFirst("meta[property=og:title]")?.attr("content")?.trim() ?: throw NotImplementedError("Unable to find title")
        val poster = fixUrlNull(document.selectFirst("div.bghd img")?.attr("src"))
        val tags = document.select("header.entry-header ul li:contains(Genres) p a").map { it.text() }
        val year = document.select("span.year span").text().trim().toIntOrNull()
        val tvType = if (url.contains("movie")) TvType.Movie else TvType.TvSeries
        val description = document.selectFirst("div.description p")?.text()?.trim()
        val recommendations = document.select("section.section.episodes div.owl-carousel article").mapNotNull { it.toSearchResult() }
        return if (tvType == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            val seasonLinks = document.select("ul.aa-cnt li a").map { it.attr("href") }
            for (seasonUrl in seasonLinks) {
                val seasonDoc = app.get(mainUrl+seasonUrl).documentLarge
                seasonDoc.select("#episode_by_temp li").forEach { ep ->
                    val href = ep.select("a").attr("href")
                    val name = "Episode " + ep.select("header.entry-header h2").text().substringAfter("EP").trim()
                    val image = ep.select("div.post-thumbnail img").attr("data-src")
                    val episode = ep.select("header.entry-header span").text().substringAfter("x").toIntOrNull()
                    val season = ep.select("header.entry-header span").text().substringBefore("x").toIntOrNull()

                    episodes.add(newEpisode(href) {
                        this.name = name
                        this.season = season
                        this.episode = episode
                        this.posterUrl = image
                    })
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.recommendations = recommendations
            }
        } else {
            return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        val scriptWithServerData = document.select("script")
            .firstOrNull { it.data().contains("serverData") }?.data() ?: return false
        val regex = Regex("""https:\\/\\/[^\s"']+""")
        val urls = regex.findAll(scriptWithServerData).map { it.value.replace("\\/", "/") }.toList()
        urls.forEach { url ->
            Log.d("Phisher",url)
            loadExtractor(url, mainUrl, subtitleCallback, callback)
        }
        document.select("tr > td a").forEach {
            val link=it.attr("href").replace("files","embed")
            loadExtractor(link, mainUrl, subtitleCallback, callback)
        }

        return true
    }

    private fun Element.getImageAttr(): String {
        return when {
            this.hasAttr("data-src") -> this.attr("abs:data-src")
            this.hasAttr("data-lazy-src") -> this.attr("abs:data-lazy-src")
            this.hasAttr("srcset") -> this.attr("abs:srcset").substringBefore(" ")
            else -> this.attr("abs:src")
        }
    }

}



================================================
FILE: AnimeWorld/src/main/kotlin/com/Phisher98/AnimeWorldProvider.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class AnimeWorldPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(AnimeWorld())
        registerExtractorAPI(Techinmind())
        registerExtractorAPI(Pixdrive())
        registerExtractorAPI(Ghbrisk())
        registerExtractorAPI(AWSStream())
    }
}



================================================
FILE: AnimeWorld/src/main/kotlin/com/Phisher98/Extractor.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.AnimeWorld.Companion.API
import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.loadExtractor
import java.net.URI

class Pixdrive : Filesim() {
    override var mainUrl = "https://pixdrive.cfd"
}

class Ghbrisk : Filesim() {
    override val name = "Streamwish"
    override val mainUrl = "https://ghbrisk.com"
    override val requiresReferer = true
}

class Techinmind  : GDMirrorbot() {
    override var name = "Techinmind"
    override var mainUrl = "https://dlx.techinmind.space"
    override val requiresReferer = true
}

open class GDMirrorbot : ExtractorApi() {
    override var name = "GDMirrorbot"
    override var mainUrl = "https://gdmirrorbot.nl"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val host = getBaseUrl(app.get(url).url)
        val embedId = url.substringAfterLast("/")
        val postData = mapOf("sid" to embedId)

        val responseJson = app.post("$host/embedhelper.php", data = postData).text
        val jsonElement = JsonParser.parseString(responseJson)
        if (!jsonElement.isJsonObject) return

        val root = jsonElement.asJsonObject
        val siteUrls = root["siteUrls"]?.asJsonObject ?: return
        val siteFriendlyNames = root["siteFriendlyNames"]?.asJsonObject

        val decodedMresult: JsonObject = when {
            root["mresult"]?.isJsonObject == true -> {
                root["mresult"]?.asJsonObject!!
            }
            root["mresult"]?.isJsonPrimitive == true -> {
                val mresultBase64 = root["mresult"]?.asString ?: return
                try {
                    val jsonStr = base64Decode(mresultBase64)
                    JsonParser.parseString(jsonStr).asJsonObject
                } catch (e: Exception) {
                    Log.e("Error:", "Failed to decode mresult base64: $e")
                    return
                }
            }
            else -> return
        }

        val commonKeys = siteUrls.keySet().intersect(decodedMresult.keySet())

        for (key in commonKeys) {
            val base = siteUrls[key]?.asString?.trimEnd('/') ?: continue
            val path = decodedMresult[key]?.asString?.trimStart('/') ?: continue
            val fullUrl = "$base/$path"

            val friendlyName = siteFriendlyNames?.get(key)?.asString ?: key

            try {
                when (friendlyName) {
                    "EarnVids" -> {
                        VidhideExtractor().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    "StreamHG" -> {
                        VidHidePro().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    "RpmShare", "UpnShare", "StreamP2p" -> {
                        VidStack().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    else -> {
                        loadExtractor(fullUrl, referer ?: mainUrl, subtitleCallback, callback)
                    }
                }
            } catch (_: Exception) {
                Log.e("Error:", "Failed to extract from $friendlyName at $fullUrl")
                continue
            }
        }

    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let { "${it.scheme}://${it.host}" }
    }
}



open class AWSStream : ExtractorApi() {
    override val name = "AWSStream"
    override val mainUrl = "https://z.awstream.net"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        if (url.contains("/video/")) {
            val extractedHash = url.substringAfterLast("/")
            val m3u8Url = "$API/player/index.php?data=$extractedHash&do=getVideo"
            Log.d("Phisher",m3u8Url)
            val header= mapOf("x-requested-with" to "XMLHttpRequest")
            val formdata= mapOf("hash" to extractedHash,"r" to "https://anime-world.co/")
            val response = app.post(m3u8Url, headers=header, data = formdata).parsedSafe<Response>()
            response?.videoSource?.let { m3u8 ->
                callback(
                    newExtractorLink(
                        name,
                        name,
                        url = m3u8,
                        type = ExtractorLinkType.M3U8
                    ) {
                        this.referer = ""
                        this.quality = Qualities.P1080.value
                    }
                )

                subtitleCallback.invoke(
                    newSubtitleFile(
                        "English",
                        "$API/subs/m3u8/$extractedHash/subtitles-eng.vtt"
                    )
                )
            }
        }
    }
}

data class Response(
    val hls: Boolean,
    val videoImage: String,
    val videoSource: String,
    val securedLink: String,
    val downloadLinks: List<Any?>,
    val attachmentLinks: List<Any?>,
    val ck: String,
)







/*

class GDMirrorbot : ExtractorApi() {
    override var name = "GDMirrorbot"
    override var mainUrl = "https://gdmirrorbot.nl"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        Log.d("Phisher",url)
        val host = getBaseUrl(app.get(url).url)
        val embed = url.substringAfterLast("/")
        val data = mapOf("sid" to embed)
        val jsonString = app.post("$host/embedhelper.php", data = data).toString()
        val jsonElement: JsonElement = JsonParser.parseString(jsonString)
        if (!jsonElement.isJsonObject) {
            Log.e("Error:", "Unexpected JSON format: Response is not a JSON object")
            return
        }
        val jsonObject = jsonElement.asJsonObject
        val siteUrls = jsonObject["siteUrls"]?.takeIf { it.isJsonObject }?.asJsonObject
        val mresult = jsonObject["mresult"]?.takeIf { it.isJsonObject }?.asJsonObject
        val siteFriendlyNames = jsonObject["siteFriendlyNames"]?.takeIf { it.isJsonObject }?.asJsonObject
        if (siteUrls == null || siteFriendlyNames == null || mresult == null) {
            return
        }
        val commonKeys = siteUrls.keySet().intersect(mresult.keySet())
        commonKeys.forEach { key ->
            val siteName = siteFriendlyNames[key]?.asString
            if (siteName == null) {
                Log.e("Error:", "Skipping key: $key because siteName is null")
                return@forEach
            }
            val siteUrl = siteUrls[key]?.asString
            val resultUrl = mresult[key]?.asString
            if (siteUrl == null || resultUrl == null) {
                Log.e("Error:", "Skipping key: $key because siteUrl or resultUrl is null")
                return@forEach
            }
            val href = siteUrl + resultUrl
            loadExtractor(href, subtitleCallback, callback)
        }

    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }
}
 */


================================================
FILE: Animexin/build.gradle.kts
================================================
// use an integer for version numbers
version = 9


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Anime and Movies"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl = "https://animexin.dev/wp-content/uploads/2020/06/animexinv1.png"

    isCrossPlatform = true
}



================================================
FILE: Animexin/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Animexin/src/main/kotlin/com/Animexin/Animexin.kt
================================================
package com.Animexin

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import org.jsoup.Jsoup

class Animexin : MainAPI() {
    override var mainUrl              = "https://animexin.dev"
    override var name                 = "Animexin"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime)

    override val mainPage = mainPageOf(
        "anime/?status=ongoing&order=update" to "Recently Updated",
        "anime/?status=ongoing&order&order=popular" to "Popular",
        "anime/?" to "Donghua",
        "anime/?status=&type=movie&page=" to "Movies",
        "anime/?sub=raw" to "Anime (RAW)",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}&page=$page").documentLarge
        val home     = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.bsx > a").attr("title")
        val href      = fixUrl(this.select("div.bsx > a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.bsx > a img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val document = app.get("${mainUrl}/page/$page/?s=$query").documentLarge
        val results = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }.toNewSearchResponseList()
        return results
    }

    @Suppress("SuspiciousIndentation")
    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("h1.entry-title")?.text()?.trim().toString()
        val href=document.selectFirst("div.eplister > ul > li a")?.attr("href") ?:""
        val poster = document.select("div.thumb img").attr("src").ifEmpty { document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString() }
        val description = document.selectFirst("div.entry-content")?.text()?.trim()
        val type=document.selectFirst(".spe")?.text().toString()
        val tvtag=if (type.contains("Movie")) TvType.Movie else TvType.TvSeries
        return if (tvtag == TvType.TvSeries) {
            val episodeRegex = Regex("(\\d+)")

            val episodes = document.select("div.eplister > ul > li").map { info ->
                val href1 = info.select("a").attr("href")
                val posterr = info.selectFirst("a img")?.attr("src") ?: ""

                val epText = info.selectFirst("div.epl-num")?.text().orEmpty()
                val epnum = episodeRegex.find(epText)?.groupValues?.get(1)?.toIntOrNull()

                newEpisode(href1) {
                    this.episode = epnum
                    this.name = epnum?.let { "Episode $it" } ?: epText
                    this.posterUrl = posterr
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes.reversed()) {
                this.posterUrl = poster
                this.plot = description
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select(".mobius option").forEach { server->
            val base64 = server.attr("value")
            val decoded=base64Decode(base64)
            val doc = Jsoup.parse(decoded)
            val href=doc.select("iframe").attr("src")
            val url=Http(href)
            loadExtractor(url,subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: Animexin/src/main/kotlin/com/Animexin/AnimexinProvider.kt
================================================
package com.Animexin

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Dailymotion
import com.lagradost.cloudstream3.extractors.Okrulink

@CloudstreamPlugin
class AnimexinProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Animexin())
        registerExtractorAPI(Vtbe())
        registerExtractorAPI(waaw())
        registerExtractorAPI(wishfast())
        registerExtractorAPI(FileMoonSx())
        registerExtractorAPI(Dailymotion())
        registerExtractorAPI(Okrulink())
    }
}


================================================
FILE: Animexin/src/main/kotlin/com/Animexin/Extractor.kt
================================================
package com.Animexin


import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlin.text.Regex

open class Vtbe : ExtractorApi() {
    override var name = "Vtbe"
    override var mainUrl = "https://vtbe.to"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
        val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
        JsUnpacker(extractedpack).unpack()?.let { unPacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.Unknown.value
                    }

                )
            }
        }
        return null
    }
}

class wishfast : StreamWishExtractor() {
    override var mainUrl = "https://wishfast.top"
    override var name = "StreamWish"
}

class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class FileMoonSx : Filesim() {
    override val mainUrl = "https://filemoon.sx"
    override val name = "FileMoonSx"
}

fun Http(url: String): String {
    return if (url.startsWith("//")) {
        "https:$url"
    } else {
        url
    }
}


================================================
FILE: Animez/build.gradle.kts
================================================
// use an integer for version numbers
version = 10


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Animes"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","Anime","AnimeMovie")
    iconUrl="https://raw.githubusercontent.com/phisher98/cloudstream-extensions-phisher/refs/heads/master/Animez/icon.png"

    isCrossPlatform = true
}



================================================
FILE: Animez/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Animez/src/main/kotlin/com/animez/Animez.kt
================================================
package com.animez

import android.annotation.SuppressLint
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDubStatus
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element

open class Animez : MainAPI() {
    override var mainUrl = "https://animeyy.com"
    override var name = "Animez"
    override val hasMainPage = true
    override var lang = "en"
    override val supportedTypes = setOf(
        TvType.Anime,
        TvType.AnimeMovie,
        TvType.OVA
    )

    override val mainPage = mainPageOf(
        "?act=search&f[status]=all&f[sortby]=lastest-chap&&pageNum=" to "Recent Episode Added",
        "?act=searchadvance&f[min_num_chapter]=1&f[status]=In%20process&f[sortby]=top-manga&&pageNum=" to "Trending",
        "?act=searchadvance&f[min_num_chapter]=1&f[status]=In%20process&f[sortby]=lastest-manga&&pageNum=" to "Latest Update",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}$page").documentLarge
        val home = document.select("article").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.selectFirst("h2")?.text() ?:""
        val href = fixUrl(mainUrl+this.selectFirst("a")!!.attr("href"))
        val posterUrl = fixUrlNull(this.select("img").last()?.getImageAttr())
        val num= this.selectFirst("span.mli-eps")!!.text().toIntOrNull()
        return newAnimeSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            posterHeaders = mapOf("Referer" to mainUrl)
            addDubStatus(num != null, num != null, num, num)
        }

    }

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val document = app.get("$mainUrl/?act=search&f[keyword]=$query&&pageNum=$page").documentLarge
        return document.select("article").map {
            it.toSearchResult()
        }.toNewSearchResponseList()
    }


    private fun getStatus(t: String): ShowStatus {
        return when (t) {
            "Finished Airing" -> ShowStatus.Completed
            "Updating" -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }

    @SuppressLint("SuspiciousIndentation")
    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.select("article.TPost.Single h2").text().trim()
        val poster = document.select("meta[property=og:image]").attr("content")
        val tags = document.select("div.mvici-left > ul > li:nth-child(4) a").map { it.text() }
        val year = Regex(",\\s?(\\d+)").find(
            document.select("span.date").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val hrefm= mainUrl+document.select("ul.version-chap li a").attr("href")
        val tvType = if (document.select("ul.version-chap li").size > 1) TvType.TvSeries else TvType.Movie
        val description = document.selectFirst("meta[property=og:description]")?.attr("content")?.trim()
        val trailer = document.selectFirst("div.embed iframe")?.attr("src")
        val rating = document.selectFirst("div.mrt5.mrb10 > span > span:nth-child(1)")?.text()
        val status=document.select("div.mvici-left > ul > li:nth-child(2)").text().substringAfter(":").trim()
        val recommendations = document.select("div.TPostMv").map {
            val recName = it.selectFirst("a")!!.attr("title").removeSuffix("/").split("/").last()
            val recHref = mainUrl+it.selectFirst("a")!!.attr("href")
            val recPosterUrl = it.selectFirst("img")?.getImageAttr()
            newAnimeSearchResponse(recName, recHref, TvType.Anime) {
                this.posterUrl = recPosterUrl
                posterHeaders = mapOf("Referer" to mainUrl)
            }
        }

        return if (tvType == TvType.TvSeries) {
            val subEpisodes = mutableListOf<Episode>()
            val dubEpisodes = mutableListOf<Episode>()
            val regex = Regex("""load_list_chapter\((\d+)\)""")
            val lastPageNum = document.select("#nav_list_chapter_id_detail a.page-link")
                .mapNotNull { regex.find(it.attr("onclick"))?.groupValues?.get(1)?.toIntOrNull() }
                .maxOrNull()
                if (lastPageNum != null) {
                    run {
                    val malid = document.select("h2.SubTitle").attr("data-manga").takeIf { it.isNotEmpty() }
                    if (!malid.isNullOrEmpty()) {
                        coroutineScope {
                            val jobs = (lastPageNum downTo 1).map { page ->
                                async(Dispatchers.IO) {
                                    try {
                                        val rawres = app.get("$mainUrl/?act=ajax&code=load_list_chapter&manga_id=$malid&page_num=$page&chap_id=0&keyword=").text
                                        val listChapHtml = JSONObject(rawres).getString("list_chap")
                                        val parsedHtml: Document = Jsoup.parse(listChapHtml)

                                        parsedHtml.select("li.wp-manga-chapter a").forEach { element ->
                                            val href = element.attr("href").trim()
                                            val episodeName = element.text().trim()
                                            val episode = episodeName.filter { it.isDigit() }.toIntOrNull()

                                            val episodeObj = newEpisode(href) {
                                                this.name = "Episode ${episodeName.substringBefore("-")}"
                                                this.season = 1
                                                this.episode = episode
                                            }

                                            synchronized(subEpisodes) {
                                                if (episodeName.contains("dub", ignoreCase = true)) {
                                                    dubEpisodes += episodeObj
                                                } else {
                                                    subEpisodes += episodeObj
                                                }
                                            }
                                        }
                                    } catch (e: Exception) {
                                        e.printStackTrace()
                                    }
                                }
                            }
                            jobs.awaitAll() // Wait for all requests to complete
                        }
                    }
                }
            }
            else {
                document.select("ul.version-chap li").amap {
                    val href = it.select("a").attr("href")
                    val name = it.select("a").text().trim()
                    val image = it.selectFirst("div.imagen > img")?.getImageAttr()
                    val episode = it.select("div.numerando").text().replace(" ", "").split("-").last().toIntOrNull() ?: name.toIntOrNull()
                    val season = it.select("div.numerando").text().replace(" ", "").split("-").first().toIntOrNull() ?: 1
                    val episodeObj = newEpisode(href) {
                        this.name = "Episode ${
                            if (name.contains(
                                    "dub",
                                    ignoreCase = true
                                )
                            ) name.substringBefore("-") else name
                        }"
                        this.season = season
                        this.episode = episode
                        this.posterUrl = image
                    }
                    if (name.contains("dub", ignoreCase = true)) {
                        dubEpisodes += episodeObj
                    } else {
                        subEpisodes += episodeObj
                    }
                }
            }
            newAnimeLoadResponse(title, url, TvType.Anime) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                posterHeaders = mapOf("Referer" to mainUrl)
                addTrailer(trailer)
                addEpisodes(DubStatus.Subbed, subEpisodes.reversed())
                addEpisodes(DubStatus.Dubbed, dubEpisodes.reversed())
                this.showStatus = getStatus(status)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, hrefm) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                posterHeaders = mapOf("Referer" to mainUrl)
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        val token=document.select("iframe").attr("src").substringAfter("/embed/")
        document.select("#list_sv a").map {
            val host=it.attr("data-link")
            val m3u8="$host/anime/$token"
            val headers = mapOf(
                "referer" to m3u8,
            )
            M3u8Helper.generateM3u8(
                name,
                m3u8,
                m3u8,
                headers = headers
            ).forEach(callback)
        }
        return true
    }

    private fun Element.getImageAttr(): String {
        return when {
            this.hasAttr("data-src") -> this.attr("abs:data-src")
            this.hasAttr("data-lazy-src") -> this.attr("abs:data-lazy-src")
            this.hasAttr("srcset") -> this.attr("abs:srcset").substringBefore(" ")
            else -> this.attr("abs:src")
        }
    }
}



================================================
FILE: Animez/src/main/kotlin/com/animez/AnimezProvider.kt
================================================
package com.animez

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.BasePlugin

@CloudstreamPlugin
class AnimezProvider : BasePlugin() {
    override fun load() {
        registerMainAPI(Animez())
    }
}


================================================
FILE: Aniworld/build.gradle.kts
================================================
// use an integer for version numbers
version = 8


cloudstream {
    language = "de"
    // All of these properties are optional, you can safely remove them

    description = "Include: Serienstream"
    authors = listOf("Phisher98,Hexated")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "OVA",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=aniworld.to&sz=%size%"
}


================================================
FILE: Aniworld/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.phisher98"/>


================================================
FILE: Aniworld/src/main/kotlin/com/Aniworld/Aniworld.kt
================================================
package com.Aniworld

import com.Aniworld.AniworldPlugin.ByseSX
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.AnimeSearchResponse
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.DoodLaExtractor
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject
import org.json.JSONTokener
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element

open class Aniworld : MainAPI() {
    override var mainUrl = "https://aniworld.to"
    override var name = "Aniworld"
    override val hasMainPage = true
    override var lang = "de"

    override val supportedTypes = setOf(
        TvType.Anime,
        TvType.AnimeMovie,
        TvType.OVA
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val isTvSeries = name.equals("Serienstream", ignoreCase = true)
        val requesturl = if (isTvSeries) "$mainUrl/beliebte-serien" else mainUrl

        val document = app.get(requesturl).documentLarge

        val item = arrayListOf<HomePageList>()
        document.select("div.carousel,div.mb-5").map { ele ->
            val header = ele.selectFirst("h2,h3")?.text() ?: return@map
            val home = ele.select("div.coverListItem,div.col-6").mapNotNull {
                it.toSearchResult()
            }
            if (home.isNotEmpty()) item.add(HomePageList(header, home))
        }
        return newHomePageResponse(item)
    }

    override suspend fun search(query: String): List<SearchResponse> {

        val isTvSeries = name.equals("Serienstream", ignoreCase = true)

        if (isTvSeries) {
            return app
                .get("https://serienstream.to/api/search/suggest?term=$query")
                .parsedSafe<SerienstreamSearch>()
                ?.shows
                ?.map {
                    newAnimeSearchResponse(
                        it.name.replace(Regex("</?em>"), ""),
                        fixUrl(it.url),
                        TvType.TvSeries
                    ) {
                        posterUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/aniworld.jpg"
                    }
                }
                ?: emptyList()
        }


        val json = app.post(
            "$mainUrl/ajax/search",
            data = mapOf("keyword" to query),
            referer = "$mainUrl/search",
            headers = mapOf(
                "x-requested-with" to "XMLHttpRequest"
            )
        )
        return tryParseJson<List<AnimeSearch>>(json.text)?.filter {
            !it.link.contains("episode-") && it.link.contains(
                "/stream"
            )
        }?.map {
            newAnimeSearchResponse(
                it.title?.replace(Regex("</?em>"), "") ?: "",
                fixUrl(it.link),
                TvType.Anime
            ) {
                this.posterUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/aniworld.jpg"
            }
        } ?: throw ErrorLoadingException()

    }

    @Suppress("LABEL_NAME_CLASH")
    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).documentLarge
        val imdbid = document.selectFirst("div.series-title > a")?.attr("data-imdb") ?: document
            .selectFirst("p a[href^='https://www.imdb.com/title/']")
            ?.attr("href")
            ?.substringAfter("/title/")
            ?.substringBefore("/")

        val isTvSeries = name.equals("Serienstream", ignoreCase = true)
        val jsonObject: JSONObject? =
            if (!isTvSeries && imdbid?.isNotBlank() == true) {
                runCatching {
                    val response =
                        app.get("https://api.ani.zip/mappings?imdb_id=$imdbid").text

                    val value = JSONTokener(response).nextValue()
                    value as? JSONObject
                }.getOrNull()
            } else null

        val mappings = jsonObject?.optJSONObject("mappings")
        val malidId: Int? = mappings?.optInt("mal_id")?.takeIf { mappings.has("mal_id") }
        val anilistid: Int? = mappings?.optInt("anilist_id")?.takeIf { mappings.has("anilist_id") }
        val title = document.selectFirst("div.series-title span,div.row h1")?.text() ?: return null
        val imdbBGPoster: String? = imdbid.takeIf { it?.isNotBlank() == true }?.let { "https://images.metahub.space/background/medium/$it/img" }

        val poster: String? = if (!isTvSeries) {
            jsonObject?.optJSONArray("images")
                ?.let { images ->
                    (0 until images.length())
                        .map { images.getJSONObject(it) }
                        .firstOrNull { it.optString("coverType") == "Fanart" }
                        ?.optString("url")
                }
                ?: fixUrlNull(document.selectFirst("div.seriesCoverBox img")?.attr("data-src"))
        } else {
            fixUrlNull(document.selectFirst("div.col-3 img")?.attr("data-src"))?.takeIf { it.isNotBlank() } ?: document.selectFirst("div.col-3 img")?.attr("src")
        }

        val tags = document.select("div.genres li a,li.series-group:has(strong:contains(Genre)) a").map { it.text() }
        val year = document.selectFirst("span[itemprop=startDate] a")?.text()?.toIntOrNull()
        val description = document.select("p.seri_des,span.description-text").text()
        val actor = document.select("li:contains(Schauspieler:) ul li a").map { it.select("span").text() }

        val episodes = mutableListOf<Episode>()
        document.select("div#stream > ul:first-child li,#season-nav ul:first-child li").forEach { ele ->
            val pageLink = ele.selectFirst("a")?.attr("href") ?: return@forEach
            val seasonno = if ("-" in pageLink) { pageLink.substringAfterLast("-").toIntOrNull() ?: 0 } else { 0 }
            val epsDocument = app.get(fixUrl(pageLink)).documentLarge

            epsDocument.select("#season$seasonno tr,tr.episode-row").forEach { eps ->
                val epno = eps.select("td > meta").attr("content").toIntOrNull() ?: eps.attr("data-episode-season-id")
                    .toIntOrNull() ?: eps.selectFirst("th.episode-number-cell")?.text()?.trim()
                    ?.toIntOrNull() ?: return@forEach

                val epname = eps.selectFirst("td.seasonEpisodeTitle span")?.text() ?: eps
                        .selectFirst(".episode-title-ger")?.text()?.trim()?.ifBlank { "Episode $epno"  }

                val href = fixUrlNull(eps.selectFirst("td.seasonEpisodeTitle a")?.attr("href")) ?: eps
                    .attr("onclick")
                    .substringAfter("window.location='", "")
                    .substringBefore("'")
                    .takeIf { it.isNotBlank() }
                    ?.let(::fixUrl)
                val epposter = "https://episodes.metahub.space/$imdbid/$seasonno/$epno/w780.jpg"
                episodes.add(
                    newEpisode(href) {
                        this.name = epname
                        this.season = seasonno
                        this.episode = epno
                        this.posterUrl = epposter
                    }
                )
            }
        }

        return newAnimeLoadResponse(title, url, TvType.Anime) {
            engName = title
            posterUrl = poster
            backgroundPosterUrl = imdbBGPoster
            this.year = year
            addEpisodes(DubStatus.Subbed, episodes)
            addActors(actor)
            if (!isTvSeries) {
                addMalId(malidId)
                addAniListId(anilistid)
            }
            addImdbId(imdbid)
            plot = description
            this.tags = tags
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document
            .select("div.hosterSiteVideo ul li, #episode-links button.link-box")
            .mapNotNull { el ->

                when (el.tagName()) {

                    "li" -> {
                        val lang = el.attr("data-lang-key").takeIf { it.isNotBlank() } ?: return@mapNotNull null
                        val link = el.attr("data-link-target").takeIf { it.isNotBlank() } ?: return@mapNotNull null
                        val name = el.selectFirst("h4")?.text()?.trim().orEmpty()

                        Triple(lang, fixUrl(link), name)
                    }

                    "button" -> {
                        val lang = el.attr("data-language-label").takeIf { it.isNotBlank() } ?: return@mapNotNull null
                        val link = el.attr("data-play-url").takeIf { it.isNotBlank() } ?: return@mapNotNull null
                        val name = el.attr("data-provider-name").ifBlank {
                            el.selectFirst("span")?.text()?.trim().orEmpty()
                        }

                        Triple(lang, fixUrl(link), name)
                    }

                    else -> null
                }
            }
            .filter { it.third != "Vidoza" }
            .amap { (langKey, link, providerName) ->
                val response = app.get(link, allowRedirects = false)
                val redirectUrl = response.headers["Location"] ?: return@amap

                val lang = langKey.getLanguage(document) ?: langKey
                val name = "$providerName [$lang]"

                if (redirectUrl.contains("filemoon")) {
                    FileMoon().getUrl(redirectUrl, name, subtitleCallback, callback)
                } else {
                    loadCustomExtractor(name, redirectUrl, "", subtitleCallback, callback)
                }
            }

        return true
    }

    fun Element.toSearchResult(): AnimeSearchResponse? {
        val href = fixUrlNull(this.selectFirst("a")?.attr("href")) ?: return null
        val title = this.selectFirst("h3")?.text()?.takeIf { it.isNotBlank() }
            ?: this.selectFirst("img")?.attr("alt").orEmpty()
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("data-src")?.takeIf { it.isNotBlank() } ?: this.selectFirst("img")?.attr("src"))
        return newAnimeSearchResponse(title, href, TvType.Anime) {
            this.posterUrl = posterUrl
        }
    }

    private fun String.getLanguage(document: Document): String? {
        return document.selectFirst("div.changeLanguageBox img[data-lang-key=$this]")?.attr("title")
            ?.removePrefix("mit")?.trim()
    }

    private data class AnimeSearch(
        @JsonProperty("link") val link: String,
        @JsonProperty("title") val title: String? = null,
    )

    data class SerienstreamSearch(
        val shows: List<Show>,
        val people: List<Any?>,
        val genres: List<Any?>,
    )

    data class Show(
        val name: String,
        val url: String,
    )
}

class Dooood : DoodLaExtractor() {
    override var mainUrl = "https://urochsunloath.com"
}

class FileMoon : ByseSX() {
    override var mainUrl = "https://filemoon.to"
    override var name = "FileMoon"
}

suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


================================================
FILE: Aniworld/src/main/kotlin/com/Aniworld/AniworldPlugin.kt
================================================
package com.Aniworld

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.extractors.Vidmoly
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import java.net.URI
import java.nio.charset.StandardCharsets
import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.SecretKeySpec

@CloudstreamPlugin
class AniworldPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Aniworld())
        registerMainAPI(Serienstream())
        registerExtractorAPI(Dooood())
        registerExtractorAPI(Vidmoly())
        registerExtractorAPI(FileMoon())
    }

    open class ByseSX : ExtractorApi() {
        override var name = "Byse"
        override var mainUrl = "https://byse.sx"
        override val requiresReferer = true

        private fun b64UrlDecode(s: String): ByteArray {
            val fixed = s.replace('-', '+').replace('_', '/')
            val pad = (4 - fixed.length % 4) % 4
            return base64DecodeArray(fixed + "=".repeat(pad))
        }

        private fun getBaseUrl(url: String): String {
            return URI(url).let { "${it.scheme}://${it.host}" }
        }

        private fun getCodeFromUrl(url: String): String {
            val path = URI(url).path ?: ""
            return path.trimEnd('/').substringAfterLast('/')
        }

        private suspend fun getDetails(mainUrl: String): DetailsRoot? {
            val base = getBaseUrl(mainUrl)
            val code = getCodeFromUrl(mainUrl)
            val url = "$base/api/videos/$code/embed/details"
            return app.get(url).parsedSafe<DetailsRoot>()
        }

        private suspend fun getPlayback(mainUrl: String): Pair<PlaybackRoot, String>? {
            val details = getDetails(mainUrl) ?: return null
            val embedFrameUrl = details.embedFrameUrl
            val embedBase = getBaseUrl(embedFrameUrl)
            val code = getCodeFromUrl(embedFrameUrl)
            val playbackUrl = "$embedBase/api/videos/$code/embed/playback"

            val headers = mapOf(
                "accept" to "*/*",
                "accept-language" to "en-US,en;q=0.5",
                "priority" to "u=1, i",
                "referer" to embedFrameUrl,
                "x-embed-parent" to mainUrl.replace("/d/", "/e/")
            )

            val root = app.post(
                playbackUrl,
                headers = headers
            ).parsedSafe<PlaybackRoot>() ?: return null

            return root to embedFrameUrl
        }


        private fun buildAesKey(playback: Playback): ByteArray {
            val p1 = b64UrlDecode(playback.keyParts[0])
            val p2 = b64UrlDecode(playback.keyParts[1])
            return p1 + p2
        }

        private fun decryptPlayback(playback: Playback): String? {
            val keyBytes = buildAesKey(playback)
            val ivBytes = b64UrlDecode(playback.iv)
            val cipherBytes = b64UrlDecode(playback.payload)

            val cipher = Cipher.getInstance("AES/GCM/NoPadding")
            val spec = GCMParameterSpec(128, ivBytes)
            val secretKey = SecretKeySpec(keyBytes, "AES")
            cipher.init(Cipher.DECRYPT_MODE, secretKey, spec)

            val plainBytes = cipher.doFinal(cipherBytes)
            var jsonStr = String(plainBytes, StandardCharsets.UTF_8)

            if (jsonStr.startsWith("\uFEFF")) jsonStr = jsonStr.substring(1)

            val root = try {
                tryParseJson<PlaybackDecrypt>((jsonStr))
            } catch (_: Exception) {
                return null
            }

            return root?.sources?.firstOrNull()?.url
        }


        override suspend fun getUrl(
            url: String,
            referer: String?,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            val (playbackRoot, m3u8referer) = getPlayback(url) ?: return

            val streamUrl  = decryptPlayback(playbackRoot.playback) ?: return


            val headers = mapOf("Referer" to m3u8referer)
            M3u8Helper.generateM3u8(
                "$referer",
                streamUrl,
                m3u8referer,
                headers = headers
            ).forEach(callback)
        }
    }

    data class DetailsRoot(
        val id: Long,
        val code: String,
        val title: String,
        @JsonProperty("poster_url")
        val posterUrl: String,
        val description: String,
        @JsonProperty("created_at")
        val createdAt: String,
        @JsonProperty("owner_private")
        val ownerPrivate: Boolean,
        @JsonProperty("embed_frame_url")
        val embedFrameUrl: String,
    )

    data class PlaybackRoot(
        val playback: Playback,
    )

    data class Playback(
        val algorithm: String,
        val iv: String,
        val payload: String,
        @JsonProperty("key_parts")
        val keyParts: List<String>,
        @JsonProperty("expires_at")
        val expiresAt: String,
        @JsonProperty("decrypt_keys")
        val decryptKeys: DecryptKeys,
        val iv2: String,
        val payload2: String,
    )

    data class DecryptKeys(
        @JsonProperty("edge_1")
        val edge1: String,
        @JsonProperty("edge_2")
        val edge2: String,
        @JsonProperty("legacy_fallback")
        val legacyFallback: String,
    )

    data class PlaybackDecrypt(
        val sources: List<PlaybackDecryptSource>,
    )

    data class PlaybackDecryptSource(
        val quality: String,
        val label: String,
        @JsonProperty("mime_type")
        val mimeType: String,
        val url: String,
        @JsonProperty("bitrate_kbps")
        val bitrateKbps: Long,
        val height: Any?,
    )

}


================================================
FILE: Aniworld/src/main/kotlin/com/Aniworld/Serienstream.kt
================================================
package com.Aniworld

import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse

class Serienstream : Aniworld() {
    override var mainUrl = "https://serienstream.to"
    override var name = "Serienstream"
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        "genre/action" to "Action",
        "genre/comedy" to "Comedy",
        "genre/drama" to "Drama",
        "genre/k-drama" to "Drama",
        "genre/thriller" to "Thriller",
        "genre/krimi" to "Krimi",
        "genre/mystery" to "Mystery",
        "genre/abenteuer" to "Abenteuer",
        "genre/fantasy" to "Fantasy",
        "genre/science-fiction" to "Sci-Fi",
        "genre/horror" to "Horror",
        "genre/western" to "Western",
        "genre/romantik" to "Romantik",
        "genre/dramedy" to "Dramedy",
        "genre/familie" to "Familie",
        "genre/telenovela" to "Telenovela",
        "genre/Sitcom" to "Sitcom",
        "genre/reality-tv" to "Reality TV",
        "genre/dokusoap" to "Doku-Soap",
        "genre/dokumentation" to "Dokumentation",
        "genre/anime" to "Anime",
        "genre/animation" to "Animation",
        "genre/Zeichentrick" to "Zeichentrick",
        "genre/kinderserie" to "Kinderserie",
        "genre/history" to "Historie"
    )


    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}?page=$page").document

        val items = arrayListOf<HomePageList>()

        val home = document.select("div.col-6").mapNotNull {
            it.toSearchResult()
        }

        if (home.isNotEmpty()) {
            items.add(
                HomePageList(
                    name = request.name,
                    list = home
                )
            )
        }

        return newHomePageResponse(items)
    }

    override suspend fun load(url: String): LoadResponse? {
        return super.load(url).apply { this?.type = TvType.TvSeries }
    }
}


================================================
FILE: BanglaPlex/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "BanglaPlex"
    language    = "bn"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")

    iconUrl="https://www.google.com/s2/favicons?domain=banglaplex.top&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: BanglaPlex/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: BanglaPlex/src/main/kotlin/com/BanglaPlex/BanglaPlex.kt
================================================
package com.BanglaPlex

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import kotlinx.coroutines.runBlocking

class Banglaplex : MainAPI() {
    override var mainUrl: String = runBlocking {
        BanglaPlexProvider.getDomains()?.banglaplex ?: "https://banglaplex.top"
    }
    override var name                 = "Banglaplex"
    override val hasMainPage          = true
    override var lang                 = "bn"
    override val supportedTypes       = setOf(TvType.Movie,TvType.TvSeries)

    override val mainPage = mainPageOf(
        "#hot" to "Trending",
        "genre/bollywood-movies" to "Bollywood",
        "genre/hollywood-movies" to "Hollywood",
        "genre/south-indian-movies" to "South Indian Movies",
        "genre/bollywood-series" to "Bollywood Series",
        "genre/dual-audio-movies" to "Dual Audio Movies",
        "genre/korean-web-series" to "Korean Web Series",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        val res=app.get("$mainUrl/${request.data}.html")
        if (res.code==200) {
            if (page == 1) {
                val document = app.get("$mainUrl/${request.data}.html").documentLarge
                val home = document.select("div.movie-container > div.col-md-2")
                    .mapNotNull { it.toSearchResult() }

                return newHomePageResponse(
                    list = HomePageList(
                        name = request.name,
                        list = home,
                        isHorizontalImages = false
                    ),
                    hasNext = true
                )
            } else {
                val newpagenumber = page * 12
                val document = app.get("$mainUrl/${request.data}/$newpagenumber.html").documentLarge
                val home = document.select("div.movie-container > div.col-md-2")
                    .mapNotNull { it.toSearchResult() }

                return newHomePageResponse(
                    list = HomePageList(
                        name = request.name,
                        list = home,
                        isHorizontalImages = false
                    ),
                    hasNext = true
                )
            }
        }
        return null
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = fixTitle(this.select("div.movie-img > div.movie-title > h3 >a").text()).trim()
        val href      = fixUrl(this.select("div.movie-img > div.movie-title > h3 >a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div > div.latest-movie-img-container").attr("style")).toString().substringAfter("url('").substringBefore("')")

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String,page: Int): SearchResponseList {
        val newpagenumber=page*12
        val document = app.get("${mainUrl}/search?q=$query&per_page=$newpagenumber").documentLarge
        val results = document.select("div.movie-container > div.col-md-2").mapNotNull { it.toSearchResult() }
        return results.toNewSearchResponseList()
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("meta[property=og:title]")?.attr("content")?.trim().toString().substringBefore(" | Watch Online")
        val poster      = document.select("#info > div > div > img").attr("src")
        val description = document.selectFirst("meta[property=og:description]")?.attr("content")?.trim()

        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl = poster
            this.plot      = description
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select("div.video-embed-container > iframe").attr("src").let {
            loadExtractor(it,mainUrl,subtitleCallback, callback) }
        val downloadURLs=document.select("#download a ").attr("href")
         if (downloadURLs.isNotEmpty())
         {
            val tokenres= app.get(downloadURLs).documentLarge
            val csrftoken=tokenres.selectFirst("form input")?.attr("name")
            val csrftokenvakue=tokenres.selectFirst("form input")?.attr("name")
            app.post(downloadURLs, data = mapOf("$csrftoken" to "$csrftokenvakue")).documentLarge.select("div.row > div.col-sm-8 > a").amap {
                val href=it.attr("href")
                if (href.contains("xcloud",ignoreCase = true))
                {
                    Xcloud().getUrl(href,"",subtitleCallback,callback)
                }
                loadExtractor(href,subtitleCallback,callback)
            }
        }
        return true
    }
}


================================================
FILE: BanglaPlex/src/main/kotlin/com/BanglaPlex/BanglaPlexProvider.kt
================================================
package com.BanglaPlex

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.StreamTape
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class BanglaPlexProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Banglaplex())
        registerExtractorAPI(Rpmvid())
        registerExtractorAPI(Plextream())
        registerExtractorAPI(Iplayerhls())
        registerExtractorAPI(StreamwishHG())
        registerExtractorAPI(StreamTape())
        registerExtractorAPI(XcloudC())
        registerExtractorAPI(Xcloud())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("banglaplex")
            val banglaplex: String,
        )
    }
}


================================================
FILE: BanglaPlex/src/main/kotlin/com/BanglaPlex/Extractors.kt
================================================
package com.BanglaPlex

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.Vtbe
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.fixUrl
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink

class Iplayerhls : Vtbe() {
    override var name = "Iplayerhls"
    override var mainUrl = "https://iplayerhls.com"
}

class StreamwishHG : StreamWishExtractor() {
    override val mainUrl = "https://hglink.to"
}

class Rpmvid : VidStack() {
    override var name = "Rpmvid"
    override var mainUrl = "https://bpx.rpmvid.site"
}

class Plextream : ExtractorApi() {
    override val name = "Plextream"
    override val mainUrl = "https://plextream.work"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val iframeScript = app.get(url).documentLarge.selectFirst("script:containsData(videoUrls)")?.data() ?: return
        val regex = Regex("""(\w+)\s*:\s*['"](https://[^'"]+)['"]""")
        val matches = regex.findAll(iframeScript)
        matches.forEach { match ->
            val serverName = match.groupValues[1]
            val videoUrl = match.groupValues[2]
            Log.d("Phisher","$serverName $videoUrl")
            when (serverName.lowercase()) {
                "rpmshare", "upnshare", "streamp2p" -> {
                    VidStack().getUrl(videoUrl, referer, subtitleCallback, callback)
                }
                else -> {
                    loadExtractor(videoUrl, subtitleCallback, callback)
                }
            }
        }
    }
}


class XcloudC : Xcloud() {
    override var name = "XCloud"
    override var mainUrl = "https://xcloud.click"
}

open class Xcloud : ExtractorApi() {
    override val name = "XCloud"
    override val mainUrl = "https://xcloud.forum"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val document = app.get(url).documentLarge
        val directBtn = document.select("div.vd a.btn-primary")
            .firstOrNull { it.text().contains("Generate Direct", ignoreCase = true) }
            ?: return
        val linksDoc = app.get(fixUrl(directBtn.attr("href"))).documentLarge
        val iframe=linksDoc.select("iframe").attr("src")
        linksDoc.select("h2 a.btn").forEach { link ->
            callback.invoke(
                newExtractorLink(
                    this.name,
                    this.name,
                    fixUrl(link.attr("href")),
                ) { this.quality = quality }
            )
            callback.invoke(
                newExtractorLink(
                    this.name,
                    this.name,
                    iframe,
                ) { this.quality = quality }
            )
        }
    }
}




================================================
FILE: Cinemacity/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    description = "Watch Movies & TvSeries (Multi-Lang/Audio)"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    language = "en"
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Cinemacity.png"

    isCrossPlatform = false
}



================================================
FILE: Cinemacity/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest/>


================================================
FILE: Cinemacity/src/main/kotlin/com/Cinemacity/Cinemacity.kt
================================================
package com.Cinemacity

import android.util.Log
import com.google.gson.Gson
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONArray
import org.json.JSONObject
import org.jsoup.nodes.Element


class Cinemacity : MainAPI() {
    override var mainUrl = "https://cinemacity.cc"
    override var name = "CinemaCity"
    override var lang = "en"
    override val hasMainPage = true
    override val hasDownloadSupport = false
    override val hasQuickSearch = false
    override val supportedTypes = setOf(
        TvType.Movie, TvType.TvSeries
    )
    companion object
    {
        val headers = mapOf(
            "Cookie" to base64Decode("ZGxlX3VzZXJfaWQ9MzI3Mjk7IGRsZV9wYXNzd29yZD04OTQxNzFjNmE4ZGFiMThlZTU5NGQ1YzY1MjAwOWEzNTs=")
        )
        private const val TMDBIMAGEBASEURL = "https://image.tmdb.org/t/p/original"
        private const val cinemeta_url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta"
    }

    fun parseCredits(jsonText: String?): List<ActorData> {
        if (jsonText.isNullOrBlank()) return emptyList()
        val list = ArrayList<ActorData>()
        val root = JSONObject(jsonText)
        val castArr = root.optJSONArray("cast") ?: return list
        for (i in 0 until castArr.length()) {
            val c = castArr.optJSONObject(i) ?: continue
            val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
            val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { "$TMDBIMAGEBASEURL$it" }
            val character = c.optString("character").takeIf { it.isNotBlank() }
            val actor = Actor(name, profile)
            list += ActorData(actor, roleString = character)
        }
        return list
    }

    override val mainPage = mainPageOf(
        "movies" to "Movies",
        "tv-series" to "TV Series",
        "xfsearch/genre/animation" to "Animation",
        "xfsearch/genre/documentary" to "Documentary",
    )

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val doc = if (page==1) app.get("$mainUrl/${request.data}").document
        else app.get("$mainUrl/${request.data}/page/$page").document

        val home = doc.select("div.dar-short_item").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(request.name, home, true)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.children().firstOrNull { it.tagName() == "a" }?.ownText()?.substringBefore("(")?.trim().orEmpty()
        val href = fixUrl(this.children().firstOrNull { it.tagName() == "a" }?.attr("href") ?: "")
        val posterUrl = fixUrlNull(this.select("div.dar-short_bg a ").attr("href"))
        val score = this.selectFirst("span.rating-color")?.ownText()
        val quality = this
            .selectFirst("div.dar-short_bg.e-cover > div span:nth-child(2) > a")
            ?.text()
            ?.takeIf { it.isNotBlank() }
            ?.let { if (it.contains("TS", true)) "TS" else "HD" }
            ?: run {
                if (
                    this.selectFirst("div.dar-short_bg.e-cover > div > span")
                        ?.text()
                        ?.contains("TS", true) == true
                ) "TS" else "HD"
            }

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.score = Score.from10(score)
            this.quality = getQualityFromString(quality)
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val doc = app.get("$mainUrl/index.php?do=search&subaction=search&search_start=$page&full_search=0&story=$query").document
        val res = doc.select("div.dar-short_item").mapNotNull { it.toSearchResult() }
        return res.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val page = app.get(url, headers)
        val doc = page.document

        val ogTitle = doc.selectFirst("meta[property=og:title]")?.attr("content").orEmpty()
        val title = ogTitle.substringBefore("(").trim()
        val poster = doc.selectFirst("meta[property=og:image]")?.attr("content").orEmpty()
        val bgposter = doc.selectFirst("div.dar-full_bg a")?.attr("href")
        val trailer = doc.select("div.dar-full_bg.e-cover > div").attr("data-vbg")

        val audioLanguages = doc
            .select("li")
            .firstOrNull {
                it.selectFirst("span")?.text()
                    ?.equals("Audio language", ignoreCase = true) == true
            }
            ?.select("span:eq(1) a")
            ?.map { it.text().trim() }
            ?.filter { it.isNotEmpty() }
            ?.joinToString(", ")

        val descriptions = doc.selectFirst("#about div.ta-full_text1")?.text()


        val recommendation = doc.select("div.ta-rel > div.ta-rel_item").map {
            val title = it.select("a").text().substringBefore("(").trim()
            val href = fixUrl(it.selectFirst("> div > a")?.attr("href") ?: "")
            val score = it.select("span.rating-color1").text()
            val posterUrl=it.selectFirst("div > a")?.attr("href")

            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.score = Score.from10(score)
            }
        }

        val year = ogTitle.substringAfter("(", "").substringBefore(")").toIntOrNull()
        var contenttype = doc.select("div.dar-full_meta > span:nth-child(5) > a").text()

        val tvtype = if (url.contains("/movies/", true)) TvType.Movie else TvType.TvSeries
        val tmdbmetatype = if (tvtype == TvType.TvSeries) "tv" else "movie"

        var genre: List<String>? = null
        var background: String? = null
        var description: String? = null


        val imdbId = doc
            .select("div.ta-full_rating1 > div")
            .mapNotNull { it.attr("onclick") }
            .firstNotNullOfOrNull { Regex("tt\\d+").find(it)?.value }

        val tmdbId = imdbId?.let { id ->
            runCatching {
                val obj = JSONObject(
                    app.get(
                        "https://api.themoviedb.org/3/find/$id" +
                                "?api_key=1865f43a0549ca50d341dd9ab8b29f49" +
                                "&external_source=imdb_id"
                    ).textLarge
                )

                obj.optJSONArray("movie_results")?.optJSONObject(0)?.optInt("id")?.takeIf { it != 0 }
                    ?: obj.optJSONArray("tv_results")?.optJSONObject(0)?.optInt("id")?.takeIf { it != 0 }
            }.getOrNull()?.toString()
        }

        val logoPath = imdbId?.let {
            "https://live.metahub.space/logo/medium/$it/img"
        }

        val creditsJson = tmdbId?.let {
            runCatching {
                app.get(
                    "https://api.themoviedb.org/3/$tmdbmetatype/$it/credits" +
                            "?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US"
                ).textLarge
            }.getOrNull()
        }

        val castList = parseCredits(creditsJson)
        val typeset = if (tvtype == TvType.TvSeries) "series" else "movie"

        val responseData = imdbId?.takeIf { it.isNotBlank() }?.let {
            val text = app.get("$cinemeta_url/$typeset/$it.json").text
            if (text.startsWith("{")) Gson().fromJson(text, ResponseData::class.java) else null
        }

        responseData?.meta?.let {
            description = it.description ?: descriptions
            background = it.background ?: poster
            genre = it.genres
        }

        val epMetaMap: Map<String, ResponseData.Meta.EpisodeDetails> =
            responseData?.meta?.videos
                ?.filter { it.season != null && it.episode != null }
                ?.associateBy { "${it.season}:${it.episode}" }
                ?: emptyMap()


        /* ---------------- PlayerJS parsing ---------------- */

        val playerScript = doc
            .select("script:containsData(atob)")
            .getOrNull(1)
            ?.data()
            ?: error("PlayerJS not found; only torrent links available")

        val decodedPlayer = base64Decode(
            playerScript.substringAfter("atob(\"").substringBefore("\")")
        )

        val playerJson = JSONObject(
            decodedPlayer
                .substringAfter("new Playerjs(")
                .substringBeforeLast(");")
        )


        /* ---------------- SAFE file parsing ---------------- */

        val rawFile = playerJson.opt("file")
            ?: error("PlayerJS: missing file field")

        val fileArray: JSONArray = when (rawFile) {
            is JSONArray -> rawFile
            is String -> {
                val value = rawFile.trim()

                when {
                    value.startsWith("[") && value.endsWith("]") ->
                        JSONArray(value)

                    value.startsWith("{") && value.endsWith("}") ->
                        JSONArray().apply { put(JSONObject(value)) }

                    value.isNotBlank() ->
                        JSONArray().apply {
                            put(JSONObject().apply {
                                put("file", value)
                            })
                        }

                    else -> error("PlayerJS: empty file string")
                }
            }
            else -> error("PlayerJS: unsupported file type")
        }


        val seasonRegex = Regex("Season\\s*(\\d+)", RegexOption.IGNORE_CASE)
        val episodeRegex = Regex("Episode\\s*(\\d+)", RegexOption.IGNORE_CASE)

        val episodeList = mutableListOf<Episode>()

        val movieHrefs: String? = fileArray.optJSONObject(0)
                ?.takeIf { !it.has("folder") }
                ?.optString("file")
                ?.takeIf { it.isNotBlank() }

        val movieSubtitleTracks = parseSubtitles(
            when {
                playerJson.opt("subtitle") is String ->
                    playerJson.optString("subtitle")
                fileArray.optJSONObject(0)?.opt("subtitle") is String ->
                    fileArray.optJSONObject(0)?.optString("subtitle")
                else -> null
            }
        )

        val moviejson = movieHrefs?.let {
            JSONObject().apply {
                put("streamUrl", it)
                put("subtitleTracks", movieSubtitleTracks)
            }.toString()
        }

        if (tvtype == TvType.TvSeries) {
            for (i in 0 until fileArray.length()) {
                val seasonJson = fileArray.getJSONObject(i)

                val seasonNumber = seasonRegex
                    .find(seasonJson.optString("title"))
                    ?.groupValues?.get(1)?.toIntOrNull()
                    ?: continue

                val episodes = seasonJson.optJSONArray("folder") ?: continue
                for (j in 0 until episodes.length()) {
                    val epJson = episodes.getJSONObject(j)

                    val episodeNumber = episodeRegex
                        .find(epJson.optString("title"))
                        ?.groupValues?.get(1)?.toIntOrNull()
                        ?: continue

                    val streamUrls = mutableListOf<String>()

                    epJson.optString("file")
                        .takeIf { it.isNotBlank() }
                        ?.let { streamUrls += it }

                    epJson.optJSONArray("folder")?.let { sources ->
                        for (k in 0 until sources.length()) {
                            sources.optJSONObject(k)
                                ?.optString("file")
                                ?.takeIf { it.isNotBlank() }
                                ?.let { streamUrls += it }
                        }
                    }

                    if (streamUrls.isEmpty()) continue

                    val metaKey = "$seasonNumber:$episodeNumber"
                    val epMeta = epMetaMap[metaKey]

                    val epSubtitleTracks =
                        parseSubtitles(epJson.optString("subtitle"))

                    val epjson = JSONObject().apply {
                        put("streams", JSONArray(streamUrls))
                        put("subtitleTracks", epSubtitleTracks)
                    }.toString()

                    episodeList += newEpisode(epjson) {
                        this.season = seasonNumber
                        this.episode = episodeNumber
                        this.name = epMeta?.title ?: "S${seasonNumber}E${episodeNumber}"
                        this.description = epMeta?.overview
                        this.posterUrl = epMeta?.thumbnail
                        addDate(epMeta?.released)
                    }
                }
            }
            return newTvSeriesLoadResponse(
                responseData?.meta?.name ?: title,
                url,
                TvType.TvSeries,
                episodeList
            ) {
                this.backgroundPosterUrl = background ?: bgposter
                this.posterUrl = poster
                try { this.logoUrl = logoPath } catch(_:Throwable){}
                this.year = year ?: responseData?.meta?.year?.toIntOrNull()
                this.plot = buildString {
                    append(description ?: descriptions)
                    if (!audioLanguages.isNullOrBlank()) {
                        append(" — Audio: ")
                        append(audioLanguages)
                    }
                }
                this.recommendations = recommendation
                this.tags = genre
                this.actors = castList
                this.score = Score.from10(responseData?.meta?.imdbRating)
                this.contentRating = responseData?.meta?.appExtras?.certification
                addImdbId(imdbId)
                addTMDbId(tmdbId)
                addTrailer(trailer)
            }
        }

        responseData?.meta?.appExtras?.certification?.let { Log.d("Phisher", it) }

        return newMovieLoadResponse(
            responseData?.meta?.name ?: title,
            url,
            TvType.Movie,
            moviejson
        ) {
            this.backgroundPosterUrl = background ?: bgposter
            this.posterUrl = poster
            try { this.logoUrl = logoPath } catch(_:Throwable){}
            this.year = year ?: responseData?.meta?.year?.toIntOrNull()
            this.plot = buildString {
                append(description ?: descriptions)
                if (!audioLanguages.isNullOrBlank()) {
                    append(" — Audio: ")
                    append(audioLanguages)
                }
            }
            this.recommendations = recommendation
            this.tags = genre
            this.actors = castList
            this.contentRating = responseData?.meta?.appExtras?.certification
            this.score = Score.from10(responseData?.meta?.imdbRating)
            addImdbId(imdbId)
            addTMDbId(tmdbId)
            addTrailer(trailer)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val obj = JSONObject(data)

        obj.optJSONArray("subtitleTracks")?.let { subs ->
            for (i in 0 until subs.length()) {
                val s = subs.getJSONObject(i)
                subtitleCallback(
                    newSubtitleFile(
                        s.getString("language"),
                        s.getString("subtitleUrl")
                    )
                )
            }
        }

        val streamUrls = mutableListOf<String>()

        obj.optJSONArray("streams")?.let { arr ->
            for (i in 0 until arr.length()) {
                arr.optString(i)
                    .takeIf { it.isNotBlank() }
                    ?.let { streamUrls += it }
            }
        }

        if (streamUrls.isEmpty()) {
            obj.optString("streamUrl")
                .takeIf { it.isNotBlank() }
                ?.let { streamUrls += it }
        }

        if (streamUrls.isEmpty()) return false

        streamUrls.forEach { url ->
            callback(
                newExtractorLink(
                    name,
                    name,
                    url,
                    INFER_TYPE
                ) {
                    referer = mainUrl
                    quality = extractQuality(url)
                }
            )
        }

        return true
    }


    fun extractQuality(url: String): Int {
        return when {
            url.contains("2160p") -> Qualities.P2160.value
            url.contains("1440p") -> Qualities.P1440.value
            url.contains("1080p") -> Qualities.P1080.value
            url.contains("720p")  -> Qualities.P720.value
            url.contains("480p")  -> Qualities.P480.value
            url.contains("360p")  -> Qualities.P360.value
            else -> Qualities.Unknown.value
        }
    }

    fun parseSubtitles(raw: String?): JSONArray {
        val tracks = JSONArray()
        if (raw.isNullOrBlank()) return tracks

        raw.split(",").forEach { entry ->
            val match = Regex("""\[(.+?)](https?://.+)""").find(entry.trim())
            if (match != null) {
                tracks.put(
                    JSONObject().apply {
                        put("language", match.groupValues[1])
                        put("subtitleUrl", match.groupValues[2])
                    }
                )
            }
        }
        return tracks
    }

}


================================================
FILE: Cinemacity/src/main/kotlin/com/Cinemacity/CinemacityPlugin.kt
================================================
package com.Cinemacity

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin


@CloudstreamPlugin
class CinemacityPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(Cinemacity())
    }
}


================================================
FILE: Cinemacity/src/main/kotlin/com/Cinemacity/Utils.kt
================================================
package com.Cinemacity

import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName

data class ResponseData(
    val meta: Meta? = null
) {

    data class Meta(
        val id: String? = null,
        val type: String? = null,
        val name: String? = null,
        @JsonProperty("imdb_id")
        val imdbId: String? = null,

        val slug: String? = null,

        val director: String? = null,
        val writer: String? = null,

        val description: String? = null,
        val year: String? = null,
        val releaseInfo: String? = null,
        val released: String? = null,
        val runtime: String? = null,
        val status: String? = null,
        val country: String? = null,
        val imdbRating: String? = null,
        val genres: List<String>? = null,
        val poster: String? = null,
        @JsonProperty("_rawPosterUrl")
        val rawPosterUrl: String? = null,

        val background: String? = null,
        val logo: String? = null,

        val videos: List<EpisodeDetails>? = null,
        val trailers: List<Trailer>? = null,
        val trailerStreams: List<TrailerStream>? = null,
        val links: List<Link>? = null,
        val behaviorHints: BehaviorHints? = null,
        @SerializedName("app_extras")
        val appExtras: AppExtras? = null
    ) {

        data class BehaviorHints(
            val defaultVideoId: Any? = null,
            val hasScheduledVideos: Boolean? = null
        )

        data class Link(
            val name: String? = null,
            val category: String? = null,
            val url: String? = null
        )

        data class Trailer(
            val source: String? = null,
            val type: String? = null,
            val name: String? = null
        )

        data class TrailerStream(
            val ytId: String? = null,
            val title: String? = null
        )

        data class EpisodeDetails(
            val id: String? = null,
            val title: String? = null,
            val season: Int? = null,
            val episode: Int? = null,
            val thumbnail: String? = null,
            val overview: String? = null,
            val released: String? = null,
            val available: Boolean? = null,
            val runtime: String? = null
        )

        data class AppExtras(
            val cast: List<Cast>? = null,
            val directors: List<Any?>? = null,
            val writers: List<Any?>? = null,
            val seasonPosters: List<String?>? = null,
            val certification: String? = null
        )

        data class Cast(
            val name: String? = null,
            val character: String? = null,
            val photo: String? = null
        )
    }
}


================================================
FILE: Coflix/build.gradle.kts
================================================
// use an integer for version numbers
version = 11


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Movies,Series and Anime French Extension "
    language    = "fr"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Coflix.png"

    isCrossPlatform = true
}



================================================
FILE: Coflix/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Coflix/src/main/kotlin/com/Coflix/Coflix.kt
================================================
package com.Coflix

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

class Coflix : MainAPI() {
    override var mainUrl              = "https://coflix.si"
    override var name                 = "Coflix"
    override val hasMainPage          = true
    override var lang                 = "fr"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.TvSeries)
    private  val coflixAPI             = "$mainUrl/wp-json/apiflix/v1"

    override val mainPage = mainPageOf(
        "movies" to "Movies",
        "series" to "Series",
        "doramas" to "Doramas",
        "animes" to "Animes",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val res = app.get("$coflixAPI/options/?years=&post_type=${request.data}&genres=&page=$page&sort=1").parsedSafe<Response>()
        val home= res?.results?.map { it.toSearchResult() }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home!!,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Result.toSearchResult(): SearchResponse {
        val title     = this.name
        val href      = fixUrl(this.url)
        val posterUrl = fetchImageUrl(this.path)
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    private fun Search2.toSearchResult(): SearchResponse {
        val title     = this.title
        val href      = fixUrl(this.url)
        val posterUrl = fetchImageUrl(this.image)
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    private fun fetchImageUrl(html: String): String? {
        val document: Document = Jsoup.parse(html)
        val imgElement = document.selectFirst("img")
        val src = imgElement?.attr("src")
        return if (src?.startsWith("//") == true) {
            "https:$src"
        } else {
            src
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query)

    override suspend fun search(query: String): List<SearchResponse> {
        val json = app.get("$mainUrl/suggest.php?query=$query").toString().toJson()
        val objectMapper = jacksonObjectMapper()
        val parsedResponse: Search = objectMapper.readValue(json)
        val response = mutableListOf<SearchResponse>()
        parsedResponse.forEach { searchItem ->
            try {
                val searchResponse = searchItem.toSearchResult()
                response.add(searchResponse)
            } catch (e: Exception) {
                Log.e("Error mapping search result for:", "$searchItem $e")
            }
        }
        return response
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("meta[property=og:title]")?.attr("content")?.substringBeforeLast("En") ?: "Unknown"
        var poster = fixUrl(document.select("img.TPostBg").attr("src"))
        if (poster.isEmpty())
        {
            poster= fetchImageUrl(document.select("div.title-img img").toString())!!
        }
        val description = document.selectFirst("div.summary.link-co p")?.text()
        val type=if (url.contains("film")) TvType.Movie else TvType.TvSeries
        val imdbUrl=document.selectFirst("p.dtls a:contains(IMDb)")?.attr("href")
        val TMDbid=document.selectFirst("p.dtls a:contains(TMDb)")?.attr("href")?.substringAfterLast("/")
        val tags=document.select("div.meta.df.aic.fww a").map { it.text() }
        return if (type==TvType.TvSeries)
        {
            val episodes = mutableListOf<Episode>()
            document.select("section.sc-seasons ul li input")
                .mapNotNull { input ->
                    val dataseason = input.attr("data-season")
                    val dataid = input.attr("post-id")

                    if (dataseason.isBlank() || dataid.isBlank()) return@mapNotNull null

                    val epRes = try {
                        app.get("$coflixAPI/series/$dataid/$dataseason").parsedSafe<EpRes>()
                    } catch (_: Exception) {
                        null
                    }

                    epRes?.episodes?.map { ep ->
                        val season = ep.season.toIntOrNull()
                        val epnumber = ep.number.toIntOrNull()
                        val eptitle = ep.title
                        val epposter = fetchImageUrl(ep.image)
                        val ephref = ep.links

                        newEpisode(ephref) {
                            this.name = eptitle
                            this.season = season
                            this.episode = epnumber
                            this.posterUrl = epposter
                        }
                    }
                }.flatten().let { episodes.addAll(it) }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
                this.tags = tags
                addImdbUrl(imdbUrl)
                addTMDbId(TMDbid)
            }
        }
        else newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
                this.tags = tags
                addImdbUrl(imdbUrl)
                addTMDbId(TMDbid)
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val referer = getBaseUrl(mainUrl)
        val iframe = app.get(data).documentLarge.select("div.embed iframe").attr("src")
        val doc= app.get(iframe,referer = referer ).documentLarge
        val lis = doc.select("li[onclick]")
        lis.amap { li ->
            val onclick = li.attr("onclick")
            val base64encoded = onclick
                .substringAfter("showVideo('")
                .substringBefore("',")
                .trim()

            if (base64encoded.isNotEmpty()) {
                try {
                    val url = base64Decode(base64encoded)
                    loadExtractor(url,referer, subtitleCallback, callback)
                } catch (_: IllegalArgumentException) {
                }
            }
        }
        return true
    }

    private suspend fun getBaseUrl(url: String): String {
        return app.get(url).url
    }

}



================================================
FILE: Coflix/src/main/kotlin/com/Coflix/CoflixProvider.kt
================================================
package com.Coflix

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Vidmoly
import com.lagradost.cloudstream3.extractors.Voe

@CloudstreamPlugin
class CoflixProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Coflix())
        registerExtractorAPI(Voe())
        registerExtractorAPI(wishonly())
        registerExtractorAPI(FileMoonSx())
        registerExtractorAPI(waaw())
        registerExtractorAPI(VidHideplus())
        registerExtractorAPI(darkibox())
        registerExtractorAPI(Vidmoly())
        registerExtractorAPI(Videzz())
        registerExtractorAPI(Uqload())
        registerExtractorAPI(Vidguardto2())
        registerExtractorAPI(CoflixUPN())
        registerExtractorAPI(Mivalyo())
        registerExtractorAPI(Voe())
    }
}


================================================
FILE: Coflix/src/main/kotlin/com/Coflix/Extractor.kt
================================================
package com.Coflix

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.Vidguardto
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.HlsPlaylistParser
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONObject

open class darkibox : ExtractorApi() {
    override var name = "Darkibox"
    override var mainUrl = "https://darkibox.com"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
            val response = app.get(url).toString()
            Regex("""sources:\s*\[\{src:\s*"(.*?)"""").find(response)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.P1080.value
                    }
                )
            }
        return null
    }
}

open class Videzz : ExtractorApi() {
    override var name = "Videzz"
    override var mainUrl = "https://videzz.net"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
            val mp4 = app.get(url,referer=mainUrl).documentLarge.select("#vplayer > #player source").attr("src")
            return listOf(
                newExtractorLink(
                    this.name,
                    this.name,
                    url = mp4,
                    type = INFER_TYPE
                ) {
                    this.referer = referer ?: ""
                    this.quality = Qualities.P1080.value
                }
            )
    }
}

class VidHideplus : VidhideExtractor() {
    override var mainUrl = "https://vidhideplus.com"
}


class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class wishonly : StreamWishExtractor() {
    override var mainUrl = "https://wishonly.site"
}

class FileMoonSx : Filesim() {
    override val mainUrl = "https://filemoon.sx"
    override val name = "FileMoonSx"
}

class Vidguardto2 : Vidguardto() {
    override val mainUrl = "https://listeamed.net"
}

class CoflixUPN : VidStack() {
    override var mainUrl = "https://coflix.upn.one"
}

class Mivalyo : VidhideExtractor() {
    override var mainUrl = "https://mivalyo.com"
}


class Uqload : ExtractorApi() {
    override val name = "Uqload"
    override val mainUrl = "https://uqload.cx"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val html = app.get(url, headers = mapOf("User-Agent" to "Mozilla/5.0")).text
        val srcRegex = Regex("""sources\s*:\s*\[\s*["']([^"']+)["']""")
        val videoUrl = srcRegex.find(html)?.groupValues?.get(1)
        if (videoUrl != null) {
            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    videoUrl,
                    INFER_TYPE
                )
                {
                    this.referer = referer ?: mainUrl
                }
            )
        }
    }
}


class Veev : ExtractorApi() {
    override val name = "Veev"
    override val mainUrl = "https://veev.to"
    override val requiresReferer = false

    private val pattern =
        Regex("""(?://|\.)(?:veev|kinoger|poophq|doods)\.(?:to|pw|com)/[ed]/([0-9A-Za-z]+)""")

    companion object {
        const val DEFAULT_UA =
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0"
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val mediaId = pattern.find(url)?.groupValues?.get(1)
            ?: return
        val pageUrl = "$mainUrl/e/$mediaId"
        val html = app.get(
            pageUrl,
            headers = mapOf("User-Agent" to DEFAULT_UA)
        ).text

        val encRegex = Regex("""[.\s'](?:fc|_vvto\[[^]]*)(?:['\]]*)?\s*[:=]\s*['"]([^'"]+)""")
        val foundValues = encRegex.findAll(html).map { it.groupValues[1] }.toList()

        if (foundValues.isEmpty()) return

        for (f in foundValues.reversed()) {
            val ch = veevDecode(f)
            if (ch == f) continue

            val dlUrl = "$mainUrl/dl?op=player_api&cmd=gi&file_code=$mediaId&r=$mainUrl&ch=$ch&ie=1"
            val responseText = app.get(dlUrl, headers = mapOf("User-Agent" to DEFAULT_UA)).text

            val json = try {
                JSONObject(responseText)
            } catch (_: Exception) {
                continue
            }
            val file = json.optJSONObject("file") ?: continue

            if (file.optString("file_status") != "OK") continue

            val dv = file.getJSONArray("dv").getJSONObject(0).getString("s")
            val decoded = decodeUrl(veevDecode(dv), buildArray(ch)[0])

            val fileMimeType = file.optString("file_mime_type", "")

            callback.invoke(
                newExtractorLink(
                    name,
                    name,
                    decoded,
                    INFER_TYPE
                )
                {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
            return
        }
    }

    fun String.toExoPlayerMimeType(): String {
        return when (this.lowercase()) {
            "video/x-matroska", "video/webm" -> HlsPlaylistParser.MimeTypes.VIDEO_MATROSKA
            "video/mp4" -> HlsPlaylistParser.MimeTypes.VIDEO_MP4
            "application/x-mpegurl", "application/vnd.apple.mpegurl" -> HlsPlaylistParser.MimeTypes.APPLICATION_M3U8
            "video/avi" -> HlsPlaylistParser.MimeTypes.VIDEO_AVI
            else -> ""
        }
    }

    private fun veevDecode(etext: String): String {
        val result = StringBuilder()
        val lut = HashMap<Int, String>()
        var n = 256
        var c = etext[0].toString()
        result.append(c)

        for (char in etext.drop(1)) {
            val code = char.code
            val nc = if (code < 256) char.toString() else lut[code] ?: (c + c[0])
            result.append(nc)
            lut[n++] = c + nc[0]
            c = nc
        }
        return result.toString()
    }

    private fun jsInt(x: Char): Int = x.digitToIntOrNull() ?: 0

    private fun buildArray(encoded: String): List<List<Int>> {
        val result = mutableListOf<List<Int>>()
        val it = encoded.iterator()
        fun nextIntOrZero(): Int = if (it.hasNext()) jsInt(it.nextChar()) else 0
        var count = nextIntOrZero()
        while (count != 0) {
            val row = mutableListOf<Int>()
            repeat(count) {
                row.add(nextIntOrZero())
            }
            result.add(row.reversed())
            count = nextIntOrZero()
        }
        return result
    }


    private fun decodeUrl(encoded: String, rules: List<Int>): String {
        var text = encoded
        for (r in rules) {
            if (r == 1) text = text.reversed()
            val arr = text.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
            text = arr.toString(Charsets.UTF_8).replace("dXRmOA==", "")
        }
        return text
    }
}



================================================
FILE: Coflix/src/main/kotlin/com/Coflix/Parser.kt
================================================
package com.Coflix

import com.fasterxml.jackson.annotation.JsonProperty


data class Response(
    val res: String,
    val results: List<Result>,
    val next: Boolean,
    val page: String,
    val total: Long,
    val genres: String,
    val years: String,
    val sort: String,
)

data class Result(
    val uuid: Long,
    val name: String,
    val ranking: Any?,
    val url: String,
    val path: String,
    val ts: String,
    val release: String,
    val director: String,
    val casts: String,
    val slug: String,
    val excerpt: String,
)


data class EpRes(
    @JsonProperty("post_id")
    val postId: String,
    val title: String,
    val episodes: List<Episode>,
)

data class Episode(
    val id: Long,
    val title: String,
    val number: String,
    val season: String,
    val links: String,
    val image: String,
)

typealias Search = List<Search2>

data class Search2(
    @JsonProperty("ID")
    val id: Long,
    val title: String,
    val excerpt: String,
    val url: String,
    @JsonProperty("post_type")
    val postType: String,
    val year: String,
    val rating: String,
    val image: String,
    val director: String,
    val cast: String?,
)



================================================
FILE: Desicinemas/build.gradle.kts
================================================
// use an integer for version numbers
version = 7


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Movie",
        "TvSeries"
    )

    iconUrl = "https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://desicinemas.to&size=%size%"

    isCrossPlatform = true
}



================================================
FILE: Desicinemas/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/BollyzoneProvider.kt
================================================
package com.Desicinemas

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.nodes.Element

class BollyzoneProvider : DesicinemasProvider() {
    override val supportedTypes = setOf(
        TvType.TvSeries
    )
    override var lang = "hi"
    override var mainUrl = "https://www.bollyzone.to"
    override var name = "Bollyzone"

    override val mainPage = mainPageOf(
        "$proxy?url=$mainUrl/tv-channels/" to "Series",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = if (page == 1) request.data else "${request.data}page/$page/"
        val doc = app.get(url, referer = "$mainUrl/").documentLarge

        val homePageList = mutableListOf<HomePageList>()

        val headers = doc.select("h2.Title").filter {
            it.text().contains("Shows", ignoreCase = true)
        }
        for (header in headers) {
            val sectionName = header.selectFirst("a")?.text()?.trim() ?: continue
            val movieListDiv = header.nextElementSiblings()
                .firstOrNull { it.tagName() == "div" && it.hasClass("MovieListTop") } ?: continue
            val list = movieListDiv.toHomePageList(sectionName)
            homePageList.add(list)
        }
        val hasNext = homePageList.any { it.list.isNotEmpty() }
        return newHomePageResponse(homePageList, hasNext)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$proxy?url=$mainUrl/?s=$query"
        val doc = app.get(url, referer = "$mainUrl/").documentLarge

        val items = doc.select(".MovieList li").mapNotNull {
            it.toHomePageResult()
        }
        return items
    }

    private fun Element.toHomePageList(name: String): HomePageList {
        val items = select("div.TPostMv")
            .mapNotNull {
                it.toHomePageResult()
            }
        return HomePageList(name, items)
    }

    private fun Element.toHomePageResult(): SearchResponse? {
        val title = selectFirst("h2.Title")?.text()?.trim() ?: return null
        val href = fixUrlNull(selectFirst("a")?.attr("href")) ?: return null
        val img = selectFirst("img")
        val posterUrl ="$proxy?url=" + fixUrlNull(img?.getImageAttr())

        return newAnimeSearchResponse(title, href) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get("$proxy?url=$url", referer = mainUrl, timeout = 10000).documentLarge

        // Handle single movie under "series"
        if (url.contains("/series/")) {
            val title = doc.selectFirst("h1")?.text()?.trim() ?: return null
            val posterUrl = fixUrlNull(doc.selectFirst(".Image img")?.getImageAttr())

            return newTvSeriesLoadResponse(title, url, TvType.Movie, listOf(newEpisode(url) { name = title })) {
                this.posterUrl = posterUrl
                plot = doc.selectFirst(".Description p")?.text()
                tags = doc.select(".Genre a").map { it.text() }
            }
        }

        // Handle TV series
        val title = doc.select("meta[property=og:title]").attr("content")
        val posterUrl = "$proxy?url=" + doc.selectFirst("div.Image img")?.getImageAttr()
        val description = doc.select("meta[property=og:description]").attr("content")
        val tags = doc.select(".Genre a").map { it.text() }.distinct()

        val lastPageNumber = doc.select("section > nav > div > a")
            .mapNotNull { it.text().toIntOrNull() }
            .maxOrNull() ?: 1

        val dateRegex = Regex("""\b\d{1,2}(st|nd|rd|th)?\s+(January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{4}\b""")

        val episodes = (1..lastPageNumber).flatMap { page ->
            val pageUrl = "$proxy?url=$url/page/$page/"
            val pageDoc = app.get(pageUrl, referer = mainUrl, timeout = 10000).documentLarge

            pageDoc.select("ul.MovieList li").mapNotNull { element ->
                val epUrl = fixUrlNull(element.select("a").attr("href")) ?: return@mapNotNull null
                val titleText = element.selectFirst("a h2")?.text()?.trim()
                val match = titleText?.let { dateRegex.find(it) }
                val epName = match?.value ?: titleText ?: "Episode"
                val epPoster = element.select("img").attr("src")

                newEpisode(epUrl) {
                    name = epName
                    this.posterUrl = "$proxy?url=$epPoster"
                }
            }
        }.toMutableList()

        return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
            this.posterUrl = posterUrl
            this.plot = description
            this.tags = tags
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get("${proxy}?url=${data}", referer = mainUrl).documentLarge.select(".MovieList .OptionBx").amap {
            val name = it.select("p.AAIco-dns").text()
            val link = it.select("a").attr("href")
            val headers = mapOf(
                "referer" to mainUrl,
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0",
                "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language" to "en-US,en;q=0.5",
                "Connection" to "keep-alive",
                "Cache-Control" to "no-cache"
            )
            val src = app.get(link, headers = headers).documentLarge
            val iframe=src.selectFirst("#Proceed a[href]")?.attr("href").orEmpty()
            val iframeURL = resolveIframeSrc(iframe) ?: src.selectFirst("IFRAME")?.attr("src") ?: return@amap
            loadCustomExtractor(name,iframeURL,mainUrl,subtitleCallback, callback)
        }
        return true
    }

    private fun Element.getImageAttr(): String {
        return when {
            this.hasAttr("data-src") -> this.attr("data-src")
            this.hasAttr("src") -> this.attr("src")
            else -> this.attr("src")
        }
    }
}



================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/DesicinemasPlugin.kt
================================================
package com.Desicinemas

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class DesicinemasPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        val provider = DesicinemasProvider()
        registerMainAPI(provider)
        registerMainAPI(BollyzoneProvider())
        registerExtractorAPI(Tvlogyflow((provider.name)))
        registerExtractorAPI(Tellygossips((provider.name)))
        registerExtractorAPI(Tvlogyflow((provider.name)))
    }
}





================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/DesicinemasProvider.kt
================================================
package com.Desicinemas

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.nodes.Element

open class DesicinemasProvider : MainAPI() {
    override val supportedTypes = setOf(TvType.Movie)
    override var lang = "hi"
    override var mainUrl = "https://desicinemas.to"
    override var name = "Desicinemas"
    override val hasMainPage = true
    val proxy="https://desicinemas.phisherdesicinema.workers.dev/"
    override val mainPage = mainPageOf(
        "$proxy?url=https://desicinemas.to/" to "Home",
        "$proxy?url=https://desicinemas.to/category/punjabi/" to "Punjabi",
        "$proxy?url=https://desicinemas.to/category/bollywood/" to "Bollywood",
        "$proxy?url=https://desicinemas.to/category/hindi-dubbed/" to "Hindi Dubbed"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        val url = if (page == 1 || request.name == "Home") request.data else "${request.data}page/$page/"
        val doc = app.get(url, referer = mainUrl, timeout = 10000).documentLarge

        val homePages = listOfNotNull(
            doc.selectFirst(".MovieListTop")?.toHomePageList("Most popular").takeIf { request.name == "Home" },
            doc.selectFirst("#home-movies-post")?.toHomePageList("Latest Movies").takeIf { request.name == "Home" },
            doc.selectFirst(".MovieList")?.toHomePageList(request.name).takeIf { request.name != "Home" }
        )

        return newHomePageResponse(homePages, request.name != "Home" && homePages.isNotEmpty())
    }

    private fun Element.toHomePageList(name: String) =
        HomePageList(name, select("li, .TPostMv").mapNotNull { it.toHomePageResult() })

    private fun Element.toHomePageResult(): SearchResponse? {
        val title = selectFirst("h2")?.text()?.trim() ?: return null
        val href = fixUrlNull(selectFirst("a")?.attr("href")) ?: return null
        val posterUrl = fixUrlNull(selectFirst("img")?.attr("data-src"))

        return newAnimeSearchResponse(title, href) { this.posterUrl = posterUrl }
    }

    override suspend fun search(query: String) =
        app.get("$proxy?url=$mainUrl/?s=$query", referer = mainUrl).documentLarge
            .select(".MovieList li").mapNotNull { it.toHomePageResult() }

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get("$proxy?url=$url", referer = mainUrl, timeout = 10000).documentLarge
        val title = doc.selectFirst("h1")?.text()?.trim() ?: return null
        val posterUrl = fixUrlNull(doc.select(".Image img").attr("src"))

        return newTvSeriesLoadResponse(title, url, TvType.Movie, listOf(newEpisode(url) { name = title })) {
            this.posterUrl = posterUrl
            plot = doc.selectFirst(".Description p")?.text()
            tags = doc.select(".Genre a").map { it.text() }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get("${proxy}?url=${data}", referer = mainUrl).documentLarge.select(".MovieList .OptionBx").amap {
            val name = it.select("p.AAIco-dns").text()
            val link = it.select("a").attr("href")
            val headers = mapOf(
                "referer" to mainUrl,
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:139.0) Gecko/20100101 Firefox/139.0",
                "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
                "Accept-Language" to "en-US,en;q=0.5",
                "Connection" to "keep-alive",
                "Cache-Control" to "no-cache"
            )
            val src = app.get(link, headers = headers).documentLarge
            val iframe=src.select("iframe").attr("src")
            loadCustomExtractor(name,iframe,mainUrl,subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/Tellygossips.kt
================================================
package com.Desicinemas

//import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

class Tellygossips(private val source:String) : ExtractorApi() {
    override val mainUrl = "https://flow.tellygossips.net"
    override val name = "Tellygossips"
    override val requiresReferer = false
    private val referer = "http://tellygossips.net/"
    private val configRegex = "var config = ([\\s\\S]*?);".toRegex()

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get(url, referer = this.referer).documentLarge
        val configStr = doc.select("script")
            .map { it.data() }
            .firstOrNull { it.contains("var config = ") }
            ?.let { configRegex.find(it.trim())?.groupValues?.get(1) } ?: return
        val config = tryParseJson<Config>(configStr) ?: return
        for (link in config.sources) {
            callback(
                newExtractorLink(
                    "$name $source",
                    name,
                    url = link.file ?: link.src ?: continue,
                    ExtractorLinkType.M3U8
                ) {
                    this.referer = ""
                    this.quality = Qualities.Unknown.value
                    this.headers = headers
                }
            )
        }
    }

    data class Config(
        val sources: List<VideoLink>,
    )

    data class VideoLink(
        val file: String?,
        val src: String?,
        val label: String,
        val type: String,
    )

}


================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/Tvlogy.kt
================================================
package com.Desicinemas

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

class Tvlogyflow(val source:String) : ExtractorApi() {
    override val mainUrl = "https://flow.tvlogy.to"
    override val name = "Tvlogy"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get("https://proxy.phisher2.workers.dev/?url=$url", referer = mainUrl).text
        if (doc.contains(".m3u8")) {
            Regex("\"src\":\"(.*?)\",\"").find(doc)?.groupValues?.get(1)?.let {
                callback(
                    newExtractorLink(
                        "$name $source",
                        name,
                        url = it,
                        type = INFER_TYPE
                    ) {
                        this.referer = url
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        } else {
            val encoded = doc.substringAfter("JuicyCodes.Run(\"").substringBefore("\");")
                .replace("\"", "")
                .replace("+", "")
                .replace("\\s".toRegex(), "")
            val script = base64Decode(encoded)
            val unpacked = JsUnpacker(script).unpack().toString()

            val matches = Regex("file\":\\s*\"(.*?)\"").findAll(unpacked)
            matches.forEach { match ->
                val matched = match.groupValues[1]
                Log.d("Phisher",matched.toString())

                when {
                    !matched.contains(".vtt") -> {
                        generateM3u8(
                            name,
                            url,
                            mainUrl
                        ).forEach(callback)
                    }

                    matched.contains(".vtt") -> {
                        subtitleCallback(newSubtitleFile("Subtitles", url))
                    }
                }
            }
        }

    }
}



class Tvlogy(private val source:String) : ExtractorApi() {
    override val mainUrl = "https://tvlogy.to"
    override val name = "Tvlogy"
    override val requiresReferer = true


    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val id = url.substringAfter("data=")
        val data = mapOf(
            "hash" to id,
            "r" to "http%3A%2F%2Ftellygossips.net%2F"
        )
        val headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        val meta = app.post("$url&do=getVideo", headers = headers, referer = referer, data = data)
            .parsedSafe<MetaData>() ?: return

        callback(
            newExtractorLink(
                "$name $source",
                name,
                url = meta.videoSource,
                ExtractorLinkType.M3U8
            ) {
                this.referer = url
                this.quality = Qualities.Unknown.value
            }
        )
    }

    data class MetaData(
        val hls: Boolean,
        val videoSource: String
    )

}


================================================
FILE: Desicinemas/src/main/kotlin/com/Desicinemas/Utils.kt
================================================
package com.Desicinemas

import com.fasterxml.jackson.core.json.JsonReadFeature
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.lagradost.nicehttp.Requests
import com.lagradost.nicehttp.ResponseParser
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import java.net.URI
import kotlin.reflect.KClass

val JSONParser = object : ResponseParser {
    val mapper: ObjectMapper = jacksonObjectMapper()
        .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        .configure(JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS.mappedFeature(), true)
        .configure(JsonReadFeature.ALLOW_UNQUOTED_FIELD_NAMES.mappedFeature(), true)
        .configure(JsonReadFeature.ALLOW_TRAILING_COMMA.mappedFeature(), true)

    override fun <T : Any> parse(text: String, kClass: KClass<T>): T {
        return mapper.readValue(text, kClass.java)
    }

    override fun <T : Any> parseSafe(text: String, kClass: KClass<T>): T? {
        return try {
            mapper.readValue(text, kClass.java)
        } catch (_: Exception) {
            null
        }
    }

    override fun writeValueAsString(obj: Any): String {
        return mapper.writeValueAsString(obj)
    }
}

val app = Requests(responseParser = JSONParser).apply {
    defaultHeaders = mapOf("User-Agent" to USER_AGENT)
}


inline fun <reified T : Any> tryParseJson(text: String): T? {
    return try {
        return JSONParser.parse(text, T::class)
    } catch (e: Exception) {
        e.printStackTrace()
        null
    }
}

suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        link.name == "VidSrc" -> Qualities.P1080.value
                        link.type == ExtractorLinkType.M3U8 -> link.quality
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


suspend fun resolveIframeSrc(initialUrl: String): String? {
    return try {
        val initialResponse = app.get(initialUrl, allowRedirects = false)

        val refreshUrl = initialResponse.documentLarge
            .selectFirst("meta[http-equiv=refresh]")
            ?.attr("content")
            ?.substringAfter("url=")
            ?.removeSurrounding("'", "'")
            ?.trim()
            .takeIf { !it.isNullOrEmpty() }
            ?: run {
                println("⚠️ No refresh meta tag found")
                return null
            }

        val refreshResponse = app.get(refreshUrl, allowRedirects = false)
        val cookieHeader = refreshResponse.headers["set-cookie"].orEmpty()
        val redirectBaseUrl = getBaseUrl(refreshUrl)
        val finalResponse = app.get(redirectBaseUrl, headers = mapOf("cookie" to cookieHeader))
        val iframeSrc = finalResponse.documentLarge.selectFirst("iframe")?.attr("src")
        println("✅ Found iframe src: $iframeSrc")
        iframeSrc
    } catch (e: Exception) {
        println("❌ Error resolving iframe: ${e.message}")
        e.printStackTrace()
        null
    }
}
private fun getBaseUrl(url: String): String {
    return try {
        URI(url).let { "${it.scheme}://${it.host}" }
    } catch (_: Exception) {
        ""
    }
}






================================================
FILE: docs/README-StremioAddon.md
================================================
# Stremio Addon Extension

The **Stremio Addon Extension** is an **experimental Cloudstream extension** that allows users to add and manage **multiple Stremio stream addon links** directly from the extension settings.

> ⚠️ This extension is experimental and does not provide a full Stremio-like experience.

---

## Features

- Add **unlimited Stremio stream addon links**
- Settings-based management UI
- View all added links in a list
- Delete links at any time
- Saved links are used to load available streaming sources

---

## How It Works

1. The extension provides a **settings screen**
2. Users can:
   - Add new Stremio addon links
   - View all saved links
   - Delete existing links
3. All saved links are used automatically when loading streams

---

## Read This Before Installing ⚠️

- This is **not a full Stremio replacement**
- Streaming depends entirely on the addon
- Catalogue-only addons will:
  - Load metadata
  - Show **“No link found”** during playback

---



================================================
FILE: docs/README-StremioX.md
================================================
# StremioX Extension

StremioX is an **experimental Cloudstream extension** that provides two separate modes for working with Stremio addons:

- **StremioX**
- **StremioC**

Each mode serves a different purpose and should be used accordingly.

> ⚠️ Experimental feature. Do not expect a full Stremio-like experience.

---

## Available Modes

### 1. StremioX (Stream Addons)

**StremioX** is used for managing **Stremio stream addons**.

#### Features

- Add multiple Stremio **stream addon** links
- Unlimited number of links supported
- Simple UI with two actions:
  - **Add Link**
  - **List Links**
- When adding a link:
  - Enter a **name**
  - Paste the **addon URL**
  - Save
- Saved links:
  - Are used to load available streams
  - Can be viewed and deleted anytime

#### Notes

- Streaming availability depends on the addon

---

### 2. StremioC (Catalogue Addons)

**StremioC** manages **Stremio catalogue addons** and retrieves both **metadata and streams directly from the addon URL**.

#### Features

- Add Stremio **catalogue addon** URLs
- Each added addon:
  - Appears as a separate provider under Extensions
  - Uses the saved **name** as the provider name
- When adding a catalogue addon:
  - Enter a **name**
  - Paste the **addon URL**
  - Save
- Added catalogue addons:
  - Are listed for easy management
  - Can be deleted at any time
- **Stream handling**:
  - Streams are fetched from the addon itself
  - If the addon does not provide streams, the system **automatically falls back to torrent links**

#### Notes

- Catalogue addons provide **metadata only**
- Episode playback will show:
  > **No link found**
- This mode is intended for **browsing only**

---

## Limitations ⚠️

- This extension is experimental
- Not a replacement for native Stremio
- Catalogue addons do not provide playable links

---

## Disclaimer

This extension does **not host or distribute any content**.  
All data is loaded from user-supplied Stremio addon URLs.

Use at your own risk.



================================================
FILE: docs/ULTIMA_SYNC_SETUP.md
================================================
# 🔄 Ultima Cross Device Watch Sync Setup Guide

> ⚠️ **Important:** This setup requires creating a **private GitHub project** and generating a **personal access token (PAT)**.

---

## 🚀 Step-by-Step Instructions

### 1. Log In to GitHub
- Go to [https://github.com](https://github.com) and sign in to your account.

### 2. Create a New Private Project
- Create a **new private GitHub project** (any template works).
- Note the project number (usually formatted like `#1`, `#2`, etc.).

### 3. Generate a Personal Access Token
- Navigate to: [https://github.com/settings/tokens/new](https://github.com/settings/tokens/new)  
  *(Or: Settings → Developer Settings → Personal Access Tokens → Tokens (Classic) → Generate new token)*
- Set the **expiration** to `No expiration`.
- Select **"Project"** scope with **"Full control of projects"** permission.
- Click **Generate token**.
- 🔐 **Copy and save the token** — it won't be shown again.

---

## 🔧 Configure Ultima

### 4. Open Ultima Settings
- Go to **`Ultima Settings → Cross Device Watch Sync → Login Data`**.

### 5. Fill in the Following:
- **Token**: Paste your GitHub personal access token.
- **Project number**: Enter the project number (e.g., `#1`).
- **Device name**: Choose a unique name for this device.

### 6. Repeat on Other Devices
- Repeat steps 4–5 on any other devices you want to sync, using a **different device name** for each one.

---

## 🔁 Sync Behavior

- Enable **"Sync this device"** on the main device you want to sync content **from**.
- Synced content will appear on all other devices **with Ultima installed and configured** using the same GitHub credentials.

---

## 📱 Device Management

- View linked devices:  
  Go to **Ultima Settings → Cross Device Watch Sync**.
  
- To enable sync history for a device:  
  Toggle the switch next to its name to view its synced content on Ultima’s homepage.

- Don’t forget to **click the Save icon 💾** in the top-right corner after making changes.

---

## ⚠️ Important Notes

- For synced content to **play properly** across devices:
  - Each device must have **the same list of extensions installed**.
  - Configurations of those extensions should **match exactly**.

---



================================================
FILE: Donghuastream/build.gradle.kts
================================================
// use an integer for version numbers
version = 14


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Contains SeaTV (Chinese)"
    language    = "zh"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Anime")
    iconUrl="https://raw.githubusercontent.com/Kohi-den/extensions-source/927f9c68fd64ce52f6212ae633d0f0585eca3545/src/en/donghuastream/res/mipmap-xxxhdpi/ic_launcher.png"

    isCrossPlatform = true
}



================================================
FILE: Donghuastream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Donghuastream/src/main/kotlin/com/Donghuastream/Donghuastream.kt
================================================
package com.Donghuastream


import com.lagradost.api.Log
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.httpsify
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

open class Donghuastream : MainAPI() {
    override var mainUrl              = "https://donghuastream.org"
    override var name                 = "Donghuastream"
    override val hasMainPage          = true
    override var lang                 = "zh"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Anime)

    override val mainPage = mainPageOf(
        "anime/?status=&type=&order=update&page=" to "Recently Updated",
        "anime/?status=completed&type=&order=update" to "Completed",
        "anime/?status=&type=special&sub=&order=update" to "Special Anime",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}$page").documentLarge
        val home     = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.bsx > a").attr("title")
        val href      = fixUrl(this.select("div.bsx > a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.bsx a img").attr("data-src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/page/$i/?s=$query").documentLarge

            val results = document.select("div.listupd > article").mapNotNull { it.toSearchResult() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("h1.entry-title")?.text()?.trim().toString()
        val href=document.selectFirst(".eplister li > a")?.attr("href") ?:""
        var poster = document.select("div.ime > img").attr("data-src")
        val description = document.selectFirst("div.entry-content")?.text()?.trim()
        val type=document.selectFirst(".spe")?.text().toString()
        val tvtag=if (type.contains("Movie")) TvType.Movie else TvType.TvSeries
        return if (tvtag == TvType.TvSeries) {
            val Eppage= document.selectFirst(".eplister li > a")?.attr("href") ?:""
            val doc= app.get(Eppage).documentLarge
            val episodes=doc.select("div.episodelist > ul > li").map { info->
                        val href1 = info.select("a").attr("href")
                        val episode = info.select("a span").text().substringAfter("-").substringBeforeLast("-")
                        val posterr=info.selectFirst("a img")?.attr("data-src") ?:""
                        newEpisode(href1)
                        {
                            this.name=episode.replace(title,"",ignoreCase = true)
                            this.episode=episode.toIntOrNull()
                            this.posterUrl=posterr
                        }
            }
            if (poster.isEmpty())
            {
                poster=document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
            }
            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes.reversed()) {
                this.posterUrl = poster
                this.plot = description
            }
        } else {
            if (poster.isEmpty())
            {
                poster=document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
            }
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val html = app.get(data).documentLarge

        val options = html.select("option[data-index]")

        for (option in options) {
            val base64 = option.attr("value")
            if (base64.isBlank()) continue
            val label = option.text().trim()
            val decodedHtml = try {
                base64Decode(base64)
            } catch (_: Exception) {
                Log.w("Error", "Base64 decode failed: $base64")
                continue
            }

            val iframeUrl = Jsoup.parse(decodedHtml).selectFirst("iframe")?.attr("src")?.let(::httpsify)
            if (iframeUrl.isNullOrEmpty()) continue
            when {
                "vidmoly" in iframeUrl -> {
                    val cleanedUrl = "http:" + iframeUrl.substringAfter("=\"").substringBefore("\"")
                    loadExtractor(cleanedUrl, referer = iframeUrl, subtitleCallback, callback)
                }
                iframeUrl.endsWith(".mp4") -> {
                    callback(
                        newExtractorLink(
                            label,
                            label,
                            url = iframeUrl,
                            INFER_TYPE
                        ) {
                            this.referer = ""
                            this.quality = getQualityFromName(label)
                        }
                    )
                }
                else -> {
                    loadExtractor(iframeUrl, referer = iframeUrl, subtitleCallback, callback)
                }
            }
        }

        return true
    }
}



================================================
FILE: Donghuastream/src/main/kotlin/com/Donghuastream/Donghuastreamparser.kt
================================================
package com.Donghuastream

import com.fasterxml.jackson.annotation.JsonProperty

data class Root(
    val status: String,
    @JsonProperty("server_time")
    val serverTime: String,
    val query: Query,
    @JsonProperty("embed_link")
    val embedLink: String,
    @JsonProperty("download_link")
    val downloadLink: String,
    @JsonProperty("request_link")
    val requestLink: String,
    val title: String,
    val poster: String,
    val sources: List<Source>,
    val tracks: List<Track>,
)

data class Query(
    val source: String,
    val id: String,
    val alt: String,
)

data class Source(
    val file: String,
    val type: String,
    val label: String,
    val default: Boolean,
)

data class Track(
    val file: String,
    val label: String,
    val default: Boolean?,
)



================================================
FILE: Donghuastream/src/main/kotlin/com/Donghuastream/DonghuastreamProvider.kt
================================================
package com.Donghuastream

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Dailymotion
import com.lagradost.cloudstream3.extractors.Geodailymotion

@CloudstreamPlugin
class DonghuastreamProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Donghuastream())
        registerMainAPI(SeaTV())
        registerExtractorAPI(Vtbe())
        registerExtractorAPI(waaw())
        registerExtractorAPI(wishfast())
        registerExtractorAPI(FileMoonSx())
        registerExtractorAPI(Dailymotion())
        registerExtractorAPI(Geodailymotion())
        registerExtractorAPI(Ultrahd())
        registerExtractorAPI(Rumble())
        registerExtractorAPI(PlayStreamplay())
    }
}


================================================
FILE: Donghuastream/src/main/kotlin/com/Donghuastream/Extractor.kt
================================================
package com.Donghuastream


import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.httpsify
import com.lagradost.cloudstream3.utils.newExtractorLink

open class Vtbe : ExtractorApi() {
    override var name = "Vtbe"
    override var mainUrl = "https://vtbe.to"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
        val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
        JsUnpacker(extractedpack).unpack()?.let { unPacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        }
        return null
    }
}

class wishfast : StreamWishExtractor() {
    override var mainUrl = "https://wishfast.top"
    override var name = "StreamWish"
}

class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class FileMoonSx : Filesim() {
    override val mainUrl = "https://filemoon.sx"
    override val name = "FileMoonSx"
}


open class Ultrahd : ExtractorApi() {
    override var name = "Ultrahd Streamplay"
    override var mainUrl = "https://ultrahd.streamplay.co.in"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
            val response = app.get(url,referer=mainUrl).documentLarge
            val extractedpack =response.toString()
            Regex("\\\$\\.\\s*ajax\\(\\s*\\{\\s*url:\\s*\"(.*?)\"").find(extractedpack)?.groupValues?.get(1)?.let { link ->
                app.get(link).parsedSafe<Root>()?.sources?.map {
                    val m3u8= httpsify( it.file)
                    if (m3u8.contains(".mp4"))
                    {
                        callback.invoke(
                            newExtractorLink(
                                "Ultrahd Streamplay",
                                "Ultrahd Streamplay",
                                url = m3u8,
                                INFER_TYPE
                            ) {
                                this.referer = ""
                                this.quality = getQualityFromName("")
                            }
                        )
                    }
                    else
                    {
                        M3u8Helper.generateM3u8(
                            this.name,
                            m3u8,
                            "$referer",
                        ).forEach(callback)
                    }
                }
                app.get(link).parsedSafe<Root>()?.tracks?.map {
                    val langurl=it.file
                    val lang=it.label
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            lang,  // Use label for the name
                            langurl     // Use extracted URL
                        )
                    )
                }
            }
    }
}

class Rumble : ExtractorApi() {
    override var name = "Rumble"
    override var mainUrl = "https://rumble.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val response = app.get(url, referer = referer ?: "$mainUrl/")
        val document = response.documentLarge

        val playerScript = document.selectFirst("script:containsData(jwplayer)")?.data()
            ?: return

        // Extract sources (mp4 or m3u8)
        val sourceRegex = """"file"\s*:\s*"(https:[^"]+\.(?:mp4|m3u8)[^"]*)"""".toRegex()
        val sources = sourceRegex.findAll(playerScript)

        for ((index, source) in sources.withIndex()) {
            val index = index + 1
            val fileUrl = source.groupValues[1].replace("\\/", "/")
            if (fileUrl.contains(".mp4"))
            {
                callback.invoke(
                    newExtractorLink(
                        name,
                        "$name Video Server $index",
                        url = fileUrl,
                        INFER_TYPE
                    ) {
                        this.referer = ""
                        this.quality = getQualityFromName("")
                    }
                )
            } else M3u8Helper.generateM3u8(name, fileUrl, mainUrl).forEach(callback)
        }

        // Extract subtitle tracks
        val trackRegex = """"file"\s*:\s*"(https:[^"]+\.vtt[^"]*)"\s*,\s*"label"\s*:\s*"([^"]+)"""".toRegex()
        val tracks = trackRegex.findAll(playerScript)

        for (track in tracks) {
            val fileUrl = track.groupValues[1].replace("\\/", "/")
            val label = track.groupValues[2]

            subtitleCallback.invoke(
                newSubtitleFile(label, fileUrl)
            )
        }
    }
}

open class PlayStreamplay : ExtractorApi() {
    override var name = "All sub player"
    override var mainUrl = "https://play.streamplay.co.in"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get(url, timeout = 10000).documentLarge
        val packedScript = doc.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data() ?: return
        val evalRegex = Regex("""eval\(.*?\)\)\)""", RegexOption.DOT_MATCHES_ALL)
        val packedCode = evalRegex.find(packedScript)?.value ?: return
        val unpackedJs = JsUnpacker(packedCode).unpack() ?: return
        val token = Regex("""kaken="(.*?)"""").find(unpackedJs)?.groupValues?.getOrNull(1) ?: return
        val apiUrl = "$mainUrl/api/?$token"
        val response = app.get(apiUrl, timeout = 10000).parsedSafe<Response>() ?: return

        val m3u8Url = response.sources.find { it.file.isNotBlank() }?.file
        if (!m3u8Url.isNullOrEmpty()) {
            val headers = mapOf(
                "pragma" to "no-cache",
                "priority" to "u=0, i",
                "sec-ch-ua" to "\"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"138\", \"Google Chrome\";v=\"138\"",
                "sec-ch-ua-mobile" to "?0",
                "sec-ch-ua-platform" to "\"Windows\"",
                "sec-fetch-dest" to "document",
                "sec-fetch-mode" to "navigate",
                "sec-fetch-site" to "none",
                "sec-fetch-user" to "?1",
                "upgrade-insecure-requests" to "1",
                "user-agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
            )
            M3u8Helper.generateM3u8(name, m3u8Url, mainUrl, headers = headers).forEach(callback)
        }

        response.tracks.forEach { subtitle ->
            subtitleCallback(
                newSubtitleFile(
                    lang = subtitle.label,
                    url = subtitle.file
                )
            )
        }
    }

    data class Response(
        val query: Query,
        val status: String,
        val message: String,
        @JsonProperty("embed_url")
        val embedUrl: String,
        @JsonProperty("download_url")
        val downloadUrl: String,
        val title: String,
        val poster: String,
        val filmstrip: String,
        val sources: List<Source>,
        val tracks: List<Track>,
    )

    data class Query(
        val source: String,
        val id: String,
        val download: String,
    )

    data class Source(
        val file: String,
        val type: String,
        val label: String,
        val default: Boolean,
    )

    data class Track(
        val file: String,
        val label: String,
        val default: Boolean?,
    )

}




================================================
FILE: Donghuastream/src/main/kotlin/com/Donghuastream/SeaTV.kt
================================================
package com.Donghuastream

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.httpsify
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.Jsoup


open class SeaTV : Donghuastream() {
    override var mainUrl              = "https://seatv-24.xyz"
    override var name                 = "SeaTV"
    override val hasMainPage          = true
    override var lang                 = "zh"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Anime)

    override val mainPage = mainPageOf(
        "anime/?status=&type=&order=update&page=" to "Recently Updated",
        "anime/?status=completed&type=&order=update" to "Completed",
        "anime/?status=upcoming&type=&sub=&order=" to "Upcoming",
    )

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select(".mobius option").amap { server ->
            val base64 = server.attr("value").takeIf { it.isNotEmpty() }
            val doc = base64?.let { base64Decode(it).let(Jsoup::parse) }
            val iframeUrl = doc?.select("iframe")?.attr("src")?.let(::httpsify)
            val metaUrl = doc?.select("meta[itemprop=embedUrl]")?.attr("content")?.let(::httpsify)
            val url = iframeUrl?.takeIf { it.isNotEmpty() } ?: metaUrl.orEmpty()
            if (url.isNotEmpty()) {
                when {
                    url.contains("vidmoly") -> {
                        val newUrl = url.substringAfter("=\"").substringBefore("\"")
                        val link = "http:$newUrl"
                        loadExtractor(link, referer = url, subtitleCallback, callback)
                    }
                    url.endsWith("mp4") -> {
                        callback.invoke(
                            newExtractorLink(
                                "All Sub Player",
                                "All Sub Player",
                                url = url,
                                INFER_TYPE
                            ) {
                                this.referer = ""
                                this.quality = getQualityFromName("")
                            }
                        )
                    }
                    else -> {
                        loadExtractor(url, referer = url, subtitleCallback, callback)
                    }
                }
            }
        }
        return true
    }
}


================================================
FILE: DoraBash/build.gradle.kts
================================================
// use an integer for version numbers
version = 4


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Doremon Show in Hindi"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://dorabash.in/wp-content/uploads/2025/11/20210525_121800-6.png"

    isCrossPlatform = false
}



================================================
FILE: DoraBash/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: DoraBash/src/main/kotlin/com/DoraBash/DoraBash.kt
================================================
package com.DoraBash

import android.util.Log
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.utils.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class DoraBash : MainAPI() {
    override var mainUrl = "https://dorabash.in"
    override var name = "DoraBash"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    override val mainPage = mainPageOf(
        "anime-type/tv" to "Seasons",
        "anime-type/movie" to "Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}").documentLarge
        val home = document.select("article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private suspend fun Element.toSearchResult(): SearchResponse {
        val title = this.select("h3 a").attr("title").substringAfter("Doraemon")
        val href = fixUrl(this.select("h3 > a").attr("href"))
        val sourceURL = app.get(href).document.select("div.anime-data h4 a").attr("href")
        val posterUrl = fixUrlNull(this.select("img").attr("src"))
        return newMovieSearchResponse(title.capitalize(), sourceURL, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val title = doc.select("meta[property=og:title]").attr("content").substringBeforeLast("-").trim()
        val backgroundposter = doc.select("main div.absolute img").attr("src")
        val description = doc.selectFirst("div.mb-6 > section > p:nth-child(1)")?.text()?.trim()
        val poster = doc.select("meta[property=og:image]").attr("content").trim()
        val rating = doc.select("div.flex.flex-wrap.justify-center.lg\\:justify-start.gap-1.lg\\:gap-2.mb-4.text-sm.font-semibold span:nth-child(1)").text()
        val year = doc.select("div.flex.flex-wrap.justify-center.lg\\:justify-start.gap-1.lg\\:gap-2.mb-4.text-sm.font-semibold span:nth-child(4)").text()
        val contentRating = doc.select("div.flex.flex-wrap.justify-center.lg\\:justify-start.gap-1.lg\\:gap-2.mb-4.text-sm.font-semibold span:nth-child(7)").text()
        val duration = doc.select("div.flex.flex-wrap.justify-center.lg\\:justify-start.gap-1.lg\\:gap-2.mb-4.text-sm.font-semibold span:nth-child(8)").text()

        val type = doc.select("div.flex.flex-wrap.justify-center.lg\\:justify-start.gap-1.lg\\:gap-2.mb-4.text-sm.font-semibold span:nth-child(2)").text()
        val tvtag = if (type.contains("Movie",ignoreCase = true)) TvType.Movie else TvType.TvSeries
        return if (tvtag == TvType.TvSeries) {
            val seasonId = doc.selectFirst("#seasonContent")?.attr("data-season")

            val episodes = app.get("$mainUrl/wp-admin/admin-ajax.php?action=get_episodes&anime_id=$seasonId&page=1&order=desc").parsed<EpJson>().data.episodes.map { ep ->
                newEpisode(ep.url) {
                    this.episode = ep.metaNumber.toIntOrNull()
                    this.name = ep.number
                    this.posterUrl = ep.thumbnail
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundposter
                this.score = Score.from10(rating)
                this.year = year.toIntOrNull()
                this.duration = duration.toIntOrNull()
                this.contentRating = contentRating
                this.plot = description
            }

        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url.replace("series","watch")) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundposter
                this.score = Score.from10(rating)
                this.year = year.toIntOrNull()
                this.duration = duration.toIntOrNull()
                this.contentRating = contentRating
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge

        document.select("div.player-selection").forEach { container ->

            val type = when {
                container.hasClass("player-dub") -> "DUB"
                container.hasClass("player-sub") -> "SUB"
                else -> return@forEach
            }

            container.select("span[data-embed-id]").forEach { span ->
                val raw = span.attr("data-embed-id")
                val parts = raw.split(":", limit = 2)
                if (parts.size != 2) return@forEach
                val name = base64Decode(parts[0]).replace(type, ignoreCase = true, newValue = "")
                val url  = base64Decode(parts[1])
                Log.d("DoraBash","$name $type $url")
                loadCustomExtractor(
                    "$name $type",
                    url,
                    url,
                    subtitleCallback,
                    callback
                )
            }
        }

        return true
    }
    suspend fun loadCustomExtractor(
        name: String? = null,
        url: String,
        referer: String? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        quality: Int? = null,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        name ?: link.source,
                        name ?: link.name,
                        link.url,
                    ) {
                        this.quality = when {
                            else -> quality ?: link.quality
                        }
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }

}




================================================
FILE: DoraBash/src/main/kotlin/com/DoraBash/DoraBashParser.kt
================================================
package com.DoraBash

import com.fasterxml.jackson.annotation.JsonProperty

data class EpJson(
    val success: Boolean,
    val data: Data,
)

data class Data(
    val episodes: List<Episode>,
    @JsonProperty("max_episodes_page")
    val maxEpisodesPage: Long,
    val message: String,
)

data class Episode(
    val number: String,
    val thumbnail: String,
    val title: String,
    val duration: String,
    val released: String,
    @JsonProperty("tmdb_fetch_episode")
    val tmdbFetchEpisode: Long,
    val id: Long,
    val type: String,
    val url: String,
    @JsonProperty("post_title")
    val postTitle: String,
    @JsonProperty("meta_number")
    val metaNumber: String,
)


================================================
FILE: DoraBash/src/main/kotlin/com/DoraBash/DoraBashProvider.kt
================================================
package com.DoraBash

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.FileMoon

@CloudstreamPlugin
class DoraBashProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(DoraBash())
        registerExtractorAPI(Vtbe())
        registerExtractorAPI(waaw())
        registerExtractorAPI(wishfast())
        registerExtractorAPI(FileMoonIN())
        registerExtractorAPI(FileMoon())
    }
}


================================================
FILE: DoraBash/src/main/kotlin/com/DoraBash/Extractor.kt
================================================
package com.DoraBash


import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

open class Vtbe : ExtractorApi() {
    override var name = "Vtbe"
    override var mainUrl = "https://vtbe.to"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
        val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
        JsUnpacker(extractedpack).unpack()?.let { unPacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        INFER_TYPE
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        }
        return null
    }
}

class wishfast : StreamWishExtractor() {
    override var mainUrl = "https://wishfast.top"
    override var name = "StreamWish"
}

class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class FileMoonIN : Filesim() {
    override val mainUrl = "https://filemoon.in"
    override val name = "FileMoonSx"
}


================================================
FILE: DramaFull/build.gradle.kts
================================================
// use an integer for version numbers
version = 1

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Kdramas and Movies"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Movie",
    )

    requiresResources = true
    language = "en"

    iconUrl = "https://www.google.com/s2/favicons?domain=dramafull.cc&sz=%size%"

    isCrossPlatform = true
}


================================================
FILE: DramaFull/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: DramaFull/src/main/kotlin/com/dramafull/DramaFull.kt
================================================
package com.dramafull

import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageData
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

class DramaFull : MainAPI() {
    override var mainUrl = "https://dramafull.cc"
    override var name = "DramaFull"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie,TvType.TvSeries,TvType.AsianDrama)

    override val mainPage: List<MainPageData>
        get() {
            val basePages = mutableListOf(
                MainPageData("Recently Added", "-1:1"),
                MainPageData("TV-Shows", "1:3"),
                MainPageData("Movies", "2:4"),
                MainPageData("Most Watched", "-1:5")
            )

            // Only add adult sections if adult mode is enabled
            if (settingsForProvider.enableAdult) {
                basePages.addAll(
                    listOf(
                        MainPageData("Adult Recently Added", "-1:1:adult"),
                        MainPageData("Adult Movies", "2:6:adult"),
                        MainPageData("Adult TV-Shows", "1:3:adult"),
                        MainPageData("Adult Most Watched", "-1:5:adult"),
                        )
                )
            }

            return basePages
        }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val (type, sort, adultFlag) = request.data.split(":").let {
            val t = it.getOrNull(0) ?: "-1"
            val s = it.getOrNull(1)?.toIntOrNull() ?: 1
            val a = it.getOrNull(2) ?: "normal"
            Triple(t, s, a)
        }

        val isAdultSection = adultFlag == "adult"

        val jsonPayload = """{
        "page": $page,
        "type": "$type",
        "country": -1,
        "sort": $sort,
        "adult": ${settingsForProvider.enableAdult},
        "adultOnly": $isAdultSection,
        "ignoreWatched": false,
        "genres": [],
        "keyword": ""
        }""".trimIndent()

        val payload = jsonPayload.toRequestBody("application/json".toMediaType())

        val home = app.post("$mainUrl/api/filter", requestBody = payload)
            .parsedSafe<Home>()
            ?.data
            ?.mapNotNull  { it.toSearchResult() }
            ?: emptyList()

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Daum.toSearchResult(): SearchResponse? {
        if (!settingsForProvider.enableAdult && this.isAdult.toInt() == 1) {
            return null
        }
        val title = this.name
        val href = "$mainUrl/film/${this.slug}"
        val poster = mainUrl + this.image
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = poster
        }
    }

    override suspend fun search(query: String): List<SearchResponse>? {
        val url = "$mainUrl/api/live-search/$query"
        return app.get(url)
            .parsedSafe<Search>()
            ?.data
            ?.mapNotNull { it.toSearchResult() }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).documentLarge
        val title = doc.selectFirst("div.right-info h1")?.text() ?: "UnKnown"
        val poster = fixUrlNull(doc.selectFirst("meta[property=og:image]")?.attr("content")) ?: ""
        val genre = doc.select("div.genre-list a").map { it.text() }
        val year = title.substringAfterLast("(").substringBefore(")").toIntOrNull()
        val descript = doc.selectFirst("div.right-info p.summary-content")?.text()
        val type = if (doc.select("div.tab-content.episode-button").isNotEmpty()) TvType.TvSeries else TvType.Movie
        val href= doc.select("div.last-episode a").attr("href")

        val recs = doc.select("div.film_list-wrap div.flw-item").mapNotNull {
            val a = it.select("img")
            val title = a.attr("alt")
            val aImg = a.attr("data-src")
            val href = it.select("a").attr("href")
            newMovieSearchResponse(title, href, TvType.Movie)
            {
                this.posterUrl = aImg
            }
        }


        if (type == TvType.TvSeries)
        {
            val episodes= doc.select("div.episode-item a").map {
                val title = it.text().substringBefore("(").trim()
                val epno = title.toIntOrNull()
                val href=it.attr("href")

                newEpisode(href)
                {
                    this.name = "Episode $title"
                    this.episode = epno
                }

            }
            return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes)
            {
                this.year = year
                this.tags = genre
                this.posterUrl = poster
                this.plot = descript
                this.recommendations = recs
            }
        }
        else
        {
            return newMovieLoadResponse(title, url, TvType.Movie, href)
            {
                this.year = year
                this.tags = genre
                this.posterUrl = poster
                this.plot = descript
                this.recommendations = recs
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).documentLarge
        val script = doc.select("script:containsData(signedUrl)").firstOrNull()?.toString() ?: return false
        val signedUrl = Regex("""window\.signedUrl\s*=\s*"(.+?)"""").find(script)?.groupValues?.get(1)?.replace("\\/","/") ?: return false

        val res = app.get(signedUrl).text
        val resJson = JSONObject(res)
        val videoSource = resJson.optJSONObject("video_source") ?: return false
        val qualities = videoSource.keys().asSequence().toList()
            .sortedByDescending { it.toIntOrNull() ?: 0 }
        val bestQualityKey = qualities.firstOrNull() ?: return false
        val bestQualityUrl = videoSource.optString(bestQualityKey)


        callback(
            newExtractorLink(
                name,
                name,
                bestQualityUrl
            )
        )

        val subJson = resJson.optJSONObject("sub")
        subJson?.optJSONArray(bestQualityKey)?.let { array ->
            for (i in 0 until array.length()) {
                subtitleCallback(newSubtitleFile("English", mainUrl+array.getString(i)))
            }
        }
        return true
    }

}


================================================
FILE: DramaFull/src/main/kotlin/com/dramafull/DramaFullParser.kt
================================================
package com.dramafull

import com.fasterxml.jackson.annotation.JsonProperty

data class Home(
    @JsonProperty("current_page")
    val currentPage: Long,
    val data: List<Daum>,
    @JsonProperty("first_page_url")
    val firstPageUrl: String,
    val from: Long,
    @JsonProperty("last_page")
    val lastPage: Long,
    @JsonProperty("last_page_url")
    val lastPageUrl: String,
    val links: List<Link>,
    @JsonProperty("next_page_url")
    val nextPageUrl: String,
    val path: String,
    @JsonProperty("per_page")
    val perPage: Long,
    @JsonProperty("prev_page_url")
    val prevPageUrl: Any?,
    val to: Long,
    val total: Long,
)

data class Daum(
    @JsonProperty("is_adult")
    val isAdult: Long,
    val name: String,
    val slug: String,
    val image: String,
)

data class Link(
    val url: String?,
    val label: String,
    val active: Boolean,
)


data class Search(
    val data: List<Daum>,
    val success: Boolean,
)


================================================
FILE: DramaFull/src/main/kotlin/com/dramafull/DramaFullPlugin.kt
================================================
package com.dramafull

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class DramaFullPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DramaFull())
    }
}


================================================
FILE: DudeFilms/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    description = "Watch Movies & TvSeries (Multi-Lang)"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    language = "hi"
    iconUrl = "https://dudefilms.media/wp-content/uploads/2020/06/cropped-cropped-DudeFilms-LOGO-v02-1.png"

    isCrossPlatform = false
}



================================================
FILE: DudeFilms/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest/>


================================================
FILE: DudeFilms/src/main/kotlin/com/dudefilms/dudefilms.kt
================================================
package com.dudefilms

import com.google.gson.Gson
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element


class Dudefilms : MainAPI() {
    override var mainUrl = "https://dudefilms.archi"
    override var name = "Dudefilms"
    override var lang = "hi"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val hasQuickSearch = false
    override val supportedTypes = setOf(
        TvType.Movie, TvType.TvSeries
    )
    companion object
    {
        private val cinemeta_url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta"
    }

    override val mainPage = mainPageOf(
        "" to "HomePage",
        "category/bollywood" to "Bollywood",
        "category/hollywood" to "Hollywood",
        "category/gujarati" to "Gujarati",
        "category/southindian" to "South Indian",
        "category/webseries" to "Web Series",
        "category/adult/" to "Adult",
    )

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val doc = if (page==1) app.get("$mainUrl/${request.data}").document else app.get("$mainUrl/${request.data}page/$page").document

        val home = doc.select("div.simple-grid-grid-post").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(request.name, home, true)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = cleanTitle(this.selectFirst("h3")?.text())
        val href = fixUrl(this.select("h3 a").attr("href"))
        val posterUrl = fixUrlNull(this.select("img").let {
            img -> img.attr("data-src").takeIf { it.isNotBlank() }
            ?: img.attr("src") })

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getSearchQuality(title)
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val doc = app.get("$mainUrl/page/$page/?s=$query").document
        val res = doc.select("div.simple-grid-grid-post").mapNotNull { it.toSearchResult() }
        return res.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document

        val title = doc.select("#movie_title > a").text()
        val poster = doc.select("meta[property=og:image]").attr("content")
        val plot = doc.selectFirst(".kno-rdesc .kno-rdesc")?.text()
        val descriptions = doc.selectFirst("#summary")?.ownText()
        val typeraw = doc.select("h1.post-title a").text()
        var year = doc.select("#movie_title > a > small").text().toIntOrNull()

        val tvtype =
            if (typeraw.contains("movie", ignoreCase = true)) TvType.Movie
            else TvType.TvSeries

        var genre: List<String>? = null
        var background: String? = null
        var description: String? = null
        var cast: List<String> = emptyList()

        val hrefs = doc.select("a.maxbutton")
            .amap { element ->
                app.get(element.absUrl("href"))
                    .document
                    .select("a.maxbutton")
                    .mapNotNull { it.absUrl("href").takeIf(String::isNotBlank) }
            }
            .flatten()
            .toJson()

        val imdbId = doc
            .select("div span a[href*='imdb.com']")
            .attr("href")
            .substringAfterLast("/")

        val typeset = if (tvtype == TvType.TvSeries) "series" else "movie"

        val responseData = if (imdbId.isNotEmpty()) {
            val jsonResponse = app.get("$cinemeta_url/$typeset/$imdbId.json").text
            if (jsonResponse.startsWith("{")) {
                Gson().fromJson(jsonResponse, ResponseData::class.java)
            } else null
        } else null

        if (responseData != null) {
            description = responseData.meta?.description ?: descriptions
            cast = responseData.meta?.appExtras?.cast?.mapNotNull { it.name } ?: emptyList()
            background = responseData.meta?.background ?: poster
            genre = responseData.meta?.genres
            year = responseData.meta?.year?.substringBefore("-")?.toIntOrNull()
        }

        if (tvtype == TvType.TvSeries) {

            val episodeUrlMap = mutableMapOf<Pair<Int, Int>, MutableList<String>>()

            doc.select("h4").forEach h4Loop@{ h4 ->

                val seasonNumber = Regex("""\bSeason\s*(\d+)\b""", RegexOption.IGNORE_CASE)
                    .find(h4.text())
                    ?.groupValues
                    ?.get(1)
                    ?.toIntOrNull()
                    ?: return@h4Loop

                var sibling = h4.nextElementSibling()

                while (sibling != null && sibling.tagName() == "p") {

                    sibling.select("a.maxbutton")
                        .filterNot(::isBlockedButton)
                        .forEach seasonBtnLoop@{ seasonButton ->

                            val seasonPageUrl = seasonButton.absUrl("href")
                            if (seasonPageUrl.isBlank()) return@seasonBtnLoop

                            val seasonPageDoc = app.get(seasonPageUrl).document

                            seasonPageDoc.select("a.maxbutton-ep").forEach epLoop@{ epButton ->

                                val epUrl = epButton.absUrl("href")
                                if (epUrl.isBlank()) return@epLoop

                                val episodeNumber = Regex(
                                    """(?:Episode|Ep|E)\s*(\d+)""",
                                    RegexOption.IGNORE_CASE
                                )
                                    .find(epButton.text())
                                    ?.groupValues
                                    ?.get(1)
                                    ?.toIntOrNull()
                                    ?: return@epLoop

                                val key = seasonNumber to episodeNumber
                                episodeUrlMap.getOrPut(key) { mutableListOf() }.add(epUrl)
                            }
                        }

                    sibling = sibling.nextElementSibling()
                }
            }

            val episodes = episodeUrlMap.map { (key, urls) ->
                val (seasonNumber, episodeNumber) = key

                val metaEpisode = responseData?.meta?.videos
                    ?.firstOrNull {
                        it.season == seasonNumber && it.episode == episodeNumber
                    }

                newEpisode(urls.toJson()) {
                    this.name = metaEpisode?.title
                    this.season = seasonNumber
                    this.episode = episodeNumber
                    this.posterUrl = metaEpisode?.thumbnail
                    this.description = metaEpisode?.overview
                    addDate(metaEpisode?.released)
                }
            }

            return newTvSeriesLoadResponse(
                responseData?.meta?.name ?: title,
                url,
                TvType.TvSeries,
                episodes
            ) {
                this.backgroundPosterUrl = background ?: poster
                this.posterUrl = poster
                this.year = responseData?.meta?.year?.toIntOrNull() ?: year
                this.plot = description ?: plot
                this.tags = genre
                addActors(cast)
                this.score = Score.from10(responseData?.meta?.imdbRating)
                addImdbId(imdbId)
            }
        }

        return newMovieLoadResponse(
            responseData?.meta?.name ?: title,
            url,
            TvType.Movie,
            hrefs
        ) {
            this.backgroundPosterUrl = background ?: poster
            this.posterUrl = poster
            this.year = responseData?.meta?.year?.toIntOrNull() ?: year
            this.plot = description ?: plot
            this.tags = genre
            addActors(cast)
            this.score = Score.from10(responseData?.meta?.imdbRating)
            addImdbId(imdbId)
        }
    }




    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links: List<String> = tryParseJson<List<String>>(data) ?: emptyList()
        links.amap {
            loadExtractor(it,"",subtitleCallback,callback)
        }
        return true
    }
}


================================================
FILE: DudeFilms/src/main/kotlin/com/dudefilms/dudefilmsPlugin.kt
================================================
package com.dudefilms

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.app


@CloudstreamPlugin
class DudefilmsPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(Dudefilms())
        registerExtractorAPI(GDFlix())
        registerExtractorAPI(HUBCDN())
        registerExtractorAPI(Hubstream())
        registerExtractorAPI(Hubcdnn())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(PixelDrainDev())
        registerExtractorAPI(Hubdrive())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("HDHUB4u")
            val HDHUB4u: String,
        )
    }
}


================================================
FILE: DudeFilms/src/main/kotlin/com/dudefilms/Extractors.kt
================================================
package com.dudefilms

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.PixelDrain
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.FormBody
import org.json.JSONObject
import java.net.URI

class Hubstream : VidStack() {
    override var mainUrl = "https://hubstream.*"
}

class Hubcdnn : ExtractorApi() {
    override val name = "Hubcdn"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        app.get(url).documentLarge.toString().let {
            val encoded = Regex("r=([A-Za-z0-9+/=]+)").find(it)?.groups?.get(1)?.value
            if (!encoded.isNullOrEmpty()) {
                val m3u8 = base64Decode(encoded).substringAfterLast("link=")
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = m3u8,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = url
                        this.quality = Qualities.Unknown.value
                    }
                )
            } else {
                Log.e("Error", "Encoded URL not found")
            }


        }
    }
}

class PixelDrainDev : PixelDrain(){
    override var mainUrl = "https://pixeldrain.dev"
}

class Hubdrive : ExtractorApi() {
    override val name = "Hubdrive"
    override val mainUrl = "https://hubdrive.space"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val href=app.get(url, timeout = 2000).documentLarge.select(".btn.btn-primary.btn-user.btn-success1.m-1").attr("href")
        if (href.contains("hubcloud",ignoreCase = true)) HubCloud().getUrl(href,"HubDrive",subtitleCallback,callback)
        else loadExtractor(href,"HubDrive",subtitleCallback, callback)
    }
}

class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override val mainUrl = "https://hubcloud.foo"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()
            Log.d("Phisher",label)
            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }

                 */
                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }
}



class HUBCDN : ExtractorApi() {
    override val name = "HUBCDN"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get(url).documentLarge
        val scriptText = doc.selectFirst("script:containsData(var reurl)")?.data()

        val encodedUrl = Regex("reurl\\s*=\\s*\"([^\"]+)\"")
            .find(scriptText ?: "")
            ?.groupValues?.get(1)
            ?.substringAfter("?r=")

        val decodedUrl = encodedUrl?.let { base64Decode(it) }?.substringAfterLast("link=")


        if (decodedUrl != null) {
            callback(
                newExtractorLink(
                    this.name,
                    this.name,
                    decodedUrl,
                    INFER_TYPE,
                )
                {
                    this.quality=Qualities.Unknown.value
                }
            )
        }
    }
}

class GDFlix : ExtractorApi() {
    override val name = "GDFlix"
    override val mainUrl = "https://*.gdflix.*"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val source = ""
        val newUrl = try {
            app.get(url)
                .documentLarge
                .selectFirst("meta[http-equiv=refresh]")
                ?.attr("content")
                ?.substringAfter("url=")
        } catch (e: Exception) {
            Log.e("Error", "Failed to fetch redirect: ${e.localizedMessage}")
            return
        } ?: url

        val document = app.get(newUrl).documentLarge
        val fileName = document.select("ul > li.list-group-item:contains(Name)").text()
            .substringAfter("Name : ")
        val fileSize = document.select("ul > li.list-group-item:contains(Size)").text()
            .substringAfter("Size : ")

        document.select("div.text-center a").amap { anchor ->
            val text = anchor.select("a").text()

            when {
                text.contains("DIRECT DL",ignoreCase = true) -> {
                    val link = anchor.attr("href")
                    callback.invoke(
                        newExtractorLink("$source GDFlix[Direct]", "$source GDFlix[Direct] [$fileSize]", link) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }

                text.contains("Index Links",ignoreCase = true) -> {
                    try {
                        val link = anchor.attr("href")
                        app.get("https://new6.gdflix.dad$link").documentLarge
                            .select("a.btn.btn-outline-info").amap { btn ->
                                val serverUrl = "https://new6.gdflix.dad" + btn.attr("href")
                                app.get(serverUrl).documentLarge
                                    .select("div.mb-4 > a").amap { sourceAnchor ->
                                        val sourceurl = sourceAnchor.attr("href")
                                        callback.invoke(
                                            newExtractorLink("$source GDFlix[Index]", "$source GDFlix[Index] [$fileSize]", sourceurl) {
                                                this.quality = getIndexQuality(fileName)
                                            }
                                        )
                                    }
                            }
                    } catch (e: Exception) {
                        Log.d("Index Links", e.toString())
                    }
                }

                text.contains("DRIVEBOT",ignoreCase = true) -> {
                    try {
                        val driveLink = anchor.attr("href")
                        val id = driveLink.substringAfter("id=").substringBefore("&")
                        val doId = driveLink.substringAfter("do=").substringBefore("==")
                        val baseUrls = listOf("https://drivebot.sbs", "https://drivebot.cfd")

                        baseUrls.amap { baseUrl ->
                            val indexbotLink = "$baseUrl/download?id=$id&do=$doId"
                            val indexbotResponse = app.get(indexbotLink, timeout = 100L)

                            if (indexbotResponse.isSuccessful) {
                                val cookiesSSID = indexbotResponse.cookies["PHPSESSID"]
                                val indexbotDoc = indexbotResponse.documentLarge

                                val token = Regex("""formData\.append\('token', '([a-f0-9]+)'\)""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val postId = Regex("""fetch\('/download\?id=([a-zA-Z0-9/+]+)'""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val requestBody = FormBody.Builder()
                                    .add("token", token)
                                    .build()

                                val headers = mapOf("Referer" to indexbotLink)
                                val cookies = mapOf("PHPSESSID" to "$cookiesSSID")

                                val downloadLink = app.post(
                                    "$baseUrl/download?id=$postId",
                                    requestBody = requestBody,
                                    headers = headers,
                                    cookies = cookies,
                                    timeout = 100L
                                ).text.let {
                                    Regex("url\":\"(.*?)\"").find(it)?.groupValues?.get(1)?.replace("\\", "").orEmpty()
                                }

                                callback.invoke(
                                    newExtractorLink("$source GDFlix[DriveBot]", "$source GDFlix[DriveBot] [$fileSize]", downloadLink) {
                                        this.referer = baseUrl
                                        this.quality = getIndexQuality(fileName)
                                    }
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.d("DriveBot", e.toString())
                    }
                }

                text.contains("Instant DL",ignoreCase = true) -> {
                    try {
                        val instantLink = anchor.attr("href")
                        val link = app.get(instantLink, allowRedirects = false)
                            .headers["location"]?.substringAfter("url=").orEmpty()

                        callback.invoke(
                            newExtractorLink("$source GDFlix[Instant Download]", "$source GDFlix[Instant Download] [$fileSize]", link) {
                                this.quality = getIndexQuality(fileName)
                            }
                        )
                    } catch (e: Exception) {
                        Log.d("Instant DL", e.toString())
                    }
                }


                text.contains("GoFile",ignoreCase = true) -> {
                    try {
                        app.get(anchor.attr("href")).documentLarge
                            .select(".row .row a").amap { gofileAnchor ->
                                val link = gofileAnchor.attr("href")
                                if (link.contains("gofile")) {
                                    Gofile().getUrl(link, "", subtitleCallback, callback)
                                }
                            }
                    } catch (e: Exception) {
                        Log.d("Gofile", e.toString())
                    }
                }

                text.contains("PixelDrain",ignoreCase = true) || text.contains("Pixel",ignoreCase = true)-> {
                    callback.invoke(
                        newExtractorLink(
                            "$source GDFlix[Pixeldrain]",
                            "$source GDFlix[Pixeldrain] [$fileSize]",
                            anchor.attr("href"),
                        ) { this.quality = quality }
                    )
                }

                else -> {
                    Log.d("Error", "No Server matched")
                }
            }
        }

        // Cloudflare backup links
        try {
            val types = listOf("type=1", "type=2")
            types.map { type ->
                val sourceurl = app.get("${newUrl.replace("file", "wfile")}?$type")
                    .documentLarge.select("a.btn-success").attr("href")

                if (source.isNotEmpty()) {
                    callback.invoke(
                        newExtractorLink("$source GDFlix[CF]", "$source GDFlix[CF] [$fileSize]", sourceurl) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }
            }
        } catch (e: Exception) {
            Log.d("CF", e.toString())
        }
    }
}


class Gofile : ExtractorApi() {
    override val name = "Gofile"
    override val mainUrl = "https://gofile.io"
    override val requiresReferer = false
    private val mainApi = "https://api.gofile.io"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        try {
            val id = Regex("/(?:\\?c=|d/)([\\da-zA-Z-]+)").find(url)?.groupValues?.get(1) ?: return
            val responseText = app.post("$mainApi/accounts").text
            val json = JSONObject(responseText)
            val token = json.getJSONObject("data").getString("token")

            val globalJs = app.get("$mainUrl/dist/js/global.js").text
            val wt = Regex("""appdata\.wt\s*=\s*["']([^"']+)["']""")
                .find(globalJs)?.groupValues?.getOrNull(1) ?: return

            val responseTextfile = app.get(
                "$mainApi/contents/$id?wt=$wt",
                headers = mapOf("Authorization" to "Bearer $token")
            ).text

            val fileDataJson = JSONObject(responseTextfile)

            val data = fileDataJson.getJSONObject("data")
            val children = data.getJSONObject("children")
            val firstFileId = children.keys().asSequence().first()
            val fileObj = children.getJSONObject(firstFileId)

            val link = fileObj.getString("link")
            val fileName = fileObj.getString("name")
            val fileSize = fileObj.getLong("size")

            val sizeFormatted = if (fileSize < 1024L * 1024 * 1024) {
                "%.2f MB".format(fileSize / 1024.0 / 1024)
            } else {
                "%.2f GB".format(fileSize / 1024.0 / 1024 / 1024)
            }

            callback.invoke(
                newExtractorLink(
                    "Gofile",
                    "Gofile [$sizeFormatted]",
                    link
                ) {
                    this.quality = getQuality(fileName)
                    this.headers = mapOf("Cookie" to "accountToken=$token")
                }
            )
        } catch (e: Exception) {
            Log.e("Gofile", "Error occurred: ${e.message}")
        }
    }

    private fun getQuality(fileName: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(fileName ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}


================================================
FILE: DudeFilms/src/main/kotlin/com/dudefilms/Utils.kt
================================================
package com.dudefilms

import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.SearchQuality
import org.jsoup.nodes.Element
import java.text.Normalizer

fun cleanTitle(raw: String?): String {
    val regex = Regex("""S(\d+)[Ee](\d+)(?:-(\d+))?""")
    val match = regex.find(raw ?: "") ?: return raw!!.trim()

    val season = match.groupValues[1].toInt()
    val epStart = match.groupValues[2].toInt()
    val epEnd = match.groupValues.getOrNull(3)?.takeIf { it.isNotEmpty() }?.toInt()

    val showName = raw?.substringBefore(match.value)!!.trim()
    val year = Regex("""\((\d{4})\)""").find(raw)?.groupValues?.get(1)

    val titleBase = if (year != null) showName else showName
    val episodes = if (epEnd != null) "Episodes $epStart–$epEnd" else "Episode $epStart"

    return "$titleBase Season $season | $episodes"
}

data class ResponseData(
    val meta: Meta? = null
) {

    data class Meta(
        val id: String? = null,
        val type: String? = null,
        val name: String? = null,
        @JsonProperty("imdb_id")
        val imdbId: String? = null,

        val slug: String? = null,

        val director: String? = null,
        val writer: String? = null,

        val description: String? = null,
        val year: String? = null,
        val releaseInfo: String? = null,
        val released: String? = null,
        val runtime: String? = null,
        val status: String? = null,
        val country: String? = null,
        val imdbRating: String? = null,
        val genres: List<String>? = null,
        val poster: String? = null,
        @JsonProperty("_rawPosterUrl")
        val rawPosterUrl: String? = null,

        val background: String? = null,
        val logo: String? = null,

        val videos: List<EpisodeDetails>? = null,
        val trailers: List<Trailer>? = null,
        val trailerStreams: List<TrailerStream>? = null,
        val links: List<Link>? = null,
        val behaviorHints: BehaviorHints? = null,
        @SerializedName("app_extras")
        val appExtras: AppExtras? = null
    ) {

        data class BehaviorHints(
            val defaultVideoId: Any? = null,
            val hasScheduledVideos: Boolean? = null
        )

        data class Link(
            val name: String? = null,
            val category: String? = null,
            val url: String? = null
        )

        data class Trailer(
            val source: String? = null,
            val type: String? = null,
            val name: String? = null
        )

        data class TrailerStream(
            val ytId: String? = null,
            val title: String? = null
        )

        data class EpisodeDetails(
            val id: String? = null,
            val title: String? = null,
            val season: Int? = null,
            val episode: Int? = null,
            val thumbnail: String? = null,
            val overview: String? = null,
            val released: String? = null,
            val available: Boolean? = null,
            val runtime: String? = null
        )

        data class AppExtras(
            val cast: List<Cast>? = null,
            val directors: List<Any?>? = null,
            val writers: List<Any?>? = null,
            val seasonPosters: List<String?>? = null,
            val certification: String? = null
        )

        data class Cast(
            val name: String? = null,
        )
    }
}

fun isBlockedButton(a: Element): Boolean {
    val text = a.selectFirst("span.mb-text")
        ?.text()
        ?.lowercase()
        ?: a.text().lowercase()

    return listOf("zipfile", "torrent", "rar", "7z").any { text.contains(it) }
}


/**
 * Determines the search quality based on the presence of specific keywords in the input string.
 *
 * @param check The string to check for keywords.
 * @return The corresponding `SearchQuality` enum value, or `null` if no match is found.
 */
fun getSearchQuality(check: String?): SearchQuality? {
    val s = check ?: return null
    val u = Normalizer.normalize(s, Normalizer.Form.NFKC).lowercase()
    val patterns = listOf(
        Regex("\\b(4k|ds4k|uhd|2160p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.FourK,

        // CAM / THEATRE SOURCES FIRST
        Regex("\\b(hdts|hdcam|hdtc)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HdCam,
        Regex("\\b(camrip|cam[- ]?rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip,
        Regex("\\b(cam)\\b", RegexOption.IGNORE_CASE) to SearchQuality.Cam,

        // WEB / RIP
        Regex("\\b(web[- ]?dl|webrip|webdl)\\b", RegexOption.IGNORE_CASE) to SearchQuality.WebRip,

        // BLURAY
        Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,

        // RESOLUTIONS
        Regex("\\b(1440p|qhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,
        Regex("\\b(1080p|fullhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,
        Regex("\\b(720p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.SD,

        // GENERIC HD LAST
        Regex("\\b(hdrip|hdtv)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,

        Regex("\\b(dvd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.DVD,
        Regex("\\b(hq)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HQ,
        Regex("\\b(rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip
    )


    for ((regex, quality) in patterns) if (regex.containsMatchIn(u)) return quality
    return null
}


================================================
FILE: Fibwatch/build.gradle.kts
================================================
// use an integer for version numbers
version = 2

cloudstream {
    // All of these properties are optional, you can safely remove any of them.

    language = "hi"
    authors = listOf("Phisher98")

    /**
     * Status int as one of the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta-only
     **/
    status = 1 // Will be 3 if unspecified

    tvTypes = listOf(
        "Movie",
        "TvSeries"

    )
    iconUrl = "https://f.pondit.xyz/fibwatch-logo.png"

    isCrossPlatform = false
}



================================================
FILE: Fibwatch/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Fibwatch/src/main/kotlin/com/fibwatch/Fibtoon.kt
================================================
package com.Fibwatch

import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf

class Fibtoon : Fibwatch() {
    override var mainUrl = "https://fibtoon.top"
    override var name = "FibToon"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true

    override val supportedTypes = setOf(
        TvType.AnimeMovie,
        TvType.Anime
    )

    override val mainPage = mainPageOf(
        "videos/top" to "Top Videos",
        "videos/latest" to "Latest Videos",
    )
}


================================================
FILE: Fibwatch/src/main/kotlin/com/fibwatch/Fibwatch.kt
================================================
package com.Fibwatch

import android.util.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.withContext
import org.jsoup.nodes.Element
import kotlin.collections.mapNotNull
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit


open class Fibwatch : MainAPI() {
    override var mainUrl = "https://fibwatch.biz"
    override var name = "FibWatch"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true

    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override val mainPage = mainPageOf(
        "videos/trending" to "Trending Videos",
        "videos/top" to "Top Videos",
        "videos/latest" to "Latest Videos",
        "videos/category/1" to "Bangla–Kolkata Movies",
        "videos/category/852" to "Bangla Dubbed",
        "videos/category/3" to "Web Series",
        "videos/category/4" to "Hindi Movies",
        "videos/category/5" to "Hindi Dubbed Movies",
        "videos/category/9" to "Horror Movies",
        "videos/category/6" to "Tamil & Telugu Movies",
        "videos/category/11" to "Kannada Movies",
        "videos/category/10" to "Malayalam Movies",
        "videos/category/8" to "English Movies",
        "videos/category/12" to "Korean Movies",
        "videos/category/13" to "Marathi Movies",
        "videos/category/7" to "Cartoon Movies",
        "videos/category/853" to "Mixed Content",
        "videos/category/854" to "TV Shows",
        "videos/category/855" to "Natok",
        "videos/category/other" to "Other"
    )


    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}?page_id=$page").document
        val home = document.select("div.video-thumb").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = cleanTitle(this.selectFirst("p.hptag")?.text() ?: this.selectFirst("div.video-thumb img")?.attr("alt"))
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val document = app.get("$mainUrl/search?keyword=$query&page_id=$page").document
        return document.select("div.video-thumb").mapNotNull { it.toSearchResult() }.toNewSearchResponseList()
    }

    override suspend fun load(url: String): LoadResponse = withContext(Dispatchers.IO) {
        val document = app.get(url).document

        val rawTitle = document.selectFirst("meta[property=og:title]")?.attr("content") ?: "Unknown"
        val title = rawTitle.substringBefore("S0")
        val poster = document.selectFirst("""meta[property="og:image"]""")?.attr("content")
        val description = document.selectFirst("meta[property=og:description]")?.attr("content") ?: "Unknown"
        val rawTitleLower = rawTitle.lowercase()

        // precompiled/simple regex checks (local, no external helpers)
        val sxeRegex = Regex("""s\d{1,2}e\d{1,3}""")
        val seasonRegex = Regex("""\bs\d{1,2}\b""")
        val episodeRegex = Regex("""\be\d{1,3}\b""")

        val tvType = when {
            sxeRegex.containsMatchIn(rawTitleLower) -> TvType.TvSeries
            seasonRegex.containsMatchIn(rawTitleLower) -> TvType.TvSeries
            episodeRegex.containsMatchIn(rawTitleLower) -> TvType.TvSeries
            else -> TvType.Movie
        }

        val videoId = document.selectFirst("input#video-id")?.attr("value")?.takeIf { it.isNotBlank() }

        val toLoadItem: (String?, String?, Boolean) -> LoadItem = { r, u, s ->
            LoadItem(quality = r?.trim().orEmpty(), url = u?.trim().orEmpty(), selected = s)
        }

        val dedupeByUrl: (List<LoadItem>) -> List<LoadItem> = { list ->
            val seen = LinkedHashSet<String>()
            list.filter { seen.add(it.url) }
        }

        val links: Links? = runCatching {
            if (videoId != null) app.get("$mainUrl/ajax/resolution_switcher.php?video_id=$videoId").parsedSafe<Links>() else null
        }.getOrNull()

        val currentRaw = links?.current
            ?.mapNotNull { c -> c.url?.trim().takeIf { it?.isNotEmpty() == true }?.let { toLoadItem(c.res, it, c.selected) } }
            ?: emptyList()

        val popupRaw = links?.popup
            ?.mapNotNull { p -> p.url?.trim().takeIf { it?.isNotEmpty() == true }?.let { toLoadItem(p.res, it, p.selected) } }
            ?: emptyList()

        val currentList = dedupeByUrl(currentRaw)
        val popupList = dedupeByUrl(popupRaw.filter { item -> currentList.none { it.url == item.url } })

        var out = LoadlinksOut(status = links?.status ?: "error", current = currentList, popup = popupList)
        if (out.current.isEmpty() && out.popup.isEmpty()) {
            try {
                val downloadEl = document.selectFirst("a.hidden-button.buttonDownloadnew")
                val dlUrl = downloadEl?.attr("onclick")
                    ?.substringAfter("url=", "")
                    ?.substringBefore("',", "")
                    ?.takeIf { it.isNotBlank() }

                if (!dlUrl.isNullOrBlank()) {
                    val normalized = dlUrl.trim()
                    val dlItem = toLoadItem(null, normalized, false) // quality = null
                    val current = dedupeByUrl(listOf(dlItem))
                    out = LoadlinksOut(status = out.status, current = current, popup = emptyList())
                }
            } catch (_: Throwable) {
                // ignore and keep original epOut
            }
        }


        val recommendations = document
            .select("div.col-md-4.no-padding-left.mobile div.videos-list.pt_mn_wtch_rlts_prnt .video-wrapper")
            .mapNotNull { it.toSearchResult()
            }

        if (tvType == TvType.TvSeries) {
            val data: EpisodesResponse? = runCatching {
                if (videoId != null) app.get("$mainUrl/ajax/episodes.php?video_id=$videoId").parsedSafe<EpisodesResponse>() else null
            }.getOrNull()

            val episodesList = data?.episodes.orEmpty()
            if (episodesList.isEmpty()) {
                return@withContext newTvSeriesLoadResponse(title, url, TvType.TvSeries, emptyList()) {
                    this.posterUrl = poster
                    this.plot = description
                    this.tags = document.select("div.tags-list a[rel='tag']").map { it.text() }
                    this.recommendations = recommendations
                }
            }
            // bounded concurrency to avoid overload
            val semaphore = Semaphore(6)
            val episodes = coroutineScope {
                episodesList.map { ep ->
                    async {
                        semaphore.withPermit {
                            try {
                                val epUrl = ep.url?.trim().orEmpty()
                                if (epUrl.isEmpty()) return@withPermit null

                                val epTitle = ep.title?.trim().orEmpty()
                                val lower = epTitle.lowercase()

                                var season: Int? = null
                                var episodeNum: Int? = null

                                Regex("""s(\d{1,2})e(\d{1,3})(?:-(\d{1,3}))?""").find(lower)?.let { m ->
                                    season = m.groupValues[1].toIntOrNull()
                                    episodeNum = m.groupValues[2].toIntOrNull()
                                } ?: run {
                                    Regex("""\bs(\d{1,2})\b""").find(lower)?.let { m -> season = m.groupValues[1].toIntOrNull() }
                                    Regex("""\be(\d{1,3})\b""").find(lower)?.let { m -> episodeNum = m.groupValues[1].toIntOrNull() }
                                }

                                val allqualities = runCatching { app.get(fixUrl(epUrl)).document }.getOrNull() ?: return@withPermit null

                                val shouldRequestResSwitcher = allqualities.select("div.available-res:contains(Available in Other Parts:)").isNotEmpty()

                                val innerVideoId = allqualities.selectFirst("input#video-id")?.attr("value")?.takeIf { it.isNotBlank() }

                                val epLinks: Links? = runCatching {
                                    if (shouldRequestResSwitcher && innerVideoId != null) {
                                        app.get("$mainUrl/ajax/resolution_switcher.php?video_id=$innerVideoId").parsedSafe<Links>()
                                    } else null
                                }.getOrNull()

                                val epCurrentRaw = epLinks?.current
                                    ?.mapNotNull { c -> c.url?.trim().takeIf { it?.isNotEmpty() == true }?.let { toLoadItem(c.res, it, c.selected) } }
                                    ?: emptyList()

                                val epPopupRaw = epLinks?.popup
                                    ?.mapNotNull { p -> p.url?.trim().takeIf { it?.isNotEmpty() == true }?.let { toLoadItem(p.res, it, p.selected) } }
                                    ?: emptyList()

                                val epCurrentList = dedupeByUrl(epCurrentRaw)
                                val epPopupList = dedupeByUrl(epPopupRaw.filter { item -> epCurrentList.none { it.url == item.url } })

                                var epOut = LoadlinksOut(status = epLinks?.status ?: "error", current = epCurrentList, popup = epPopupList)

                                if (epOut.current.isEmpty() && epOut.popup.isEmpty()) {
                                    try {
                                        val downloadEl = allqualities.selectFirst("a.hidden-button.buttonDownloadnew")
                                        val dlUrl = downloadEl?.attr("onclick")
                                                ?.substringAfter("url=", "")
                                                ?.substringBefore("',", "")
                                                ?.takeIf { it.isNotBlank() }

                                        if (!dlUrl.isNullOrBlank()) {
                                            val normalized = dlUrl.trim()
                                            val dlItem = toLoadItem(null, normalized, false) // quality = null
                                            val current = dedupeByUrl(listOf(dlItem))
                                            epOut = LoadlinksOut(status = epLinks?.status ?: "success", current = current, popup = emptyList())
                                        }
                                    } catch (_: Throwable) {
                                        // ignore and keep original epOut
                                    }
                                }

                                newEpisode(epOut.toJson()) {
                                    this.name = epTitle
                                    season?.let { this.season = it }
                                    episodeNum?.let { this.episode = it }
                                    this.posterUrl = poster
                                }
                            } catch (_: Throwable) {
                                null
                            }
                        }
                    }
                }.awaitAll().filterNotNull()
            }


            return@withContext newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
                this.tags = document.select("div.tags-list a[rel='tag']").map { it.text() }
                this.recommendations = recommendations
            }
        } else {
            return@withContext newMovieLoadResponse(title, url, TvType.Movie, out.toJson()) {
                this.posterUrl = poster
                this.plot = description
                this.tags = document.select("div.tags-list a[rel='tag']").map { it.text() }
                this.recommendations = recommendations
            }
        }
    }




    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = tryParseJson<LoadlinksOut>(data) ?: return true

        val currentUrls = loadData.current.map { it.url.trim() }.toSet()
        val combined = ArrayList<LoadItem>(loadData.current.size + loadData.popup.size)

        combined += loadData.current
        combined += loadData.popup.filter { it.url.trim() !in currentUrls }

        for (item in combined) {

            val url = item.url.trim()
            if (url.isEmpty()) continue

            val isDirectMedia = url.contains(".mkv", true) ||
                    url.contains(".mp4", true) ||
                    url.contains(".m3u8", true)

            val finalUrl = if (isDirectMedia) {
                url
            } else {
                runCatching {
                    val doc = app.get(fixUrl(url)).document
                    val onclick = doc.selectFirst("a.hidden-button.buttonDownloadnew")
                        ?.attr("onclick") ?: return@runCatching null

                    onclick.substringAfter("url=")
                        .substringBefore("',")
                        .trim()
                        .takeIf { it.isNotEmpty() }
                }.getOrNull()
            }


            if (finalUrl.isNullOrEmpty()) {
                Log.w(name, "no download url for $url")
                continue
            }

            callback.invoke(
                newExtractorLink(
                    mainUrl,
                    this.name,
                    url = finalUrl
                ) {
                    this.quality = getQualityFromName(item.quality)
                }
            )
        }

        return true
    }
}









================================================
FILE: Fibwatch/src/main/kotlin/com/fibwatch/fibWatchDrama.kt
================================================
package com.Fibwatch

import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf

class Fibwatchdrama : Fibwatch() {
    override var mainUrl = "https://fibwatchdrama.xyz"
    override var name = "FibWatch Drama"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true

    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "videos/top" to "Top Videos",
        "videos/latest" to "Latest Videos",
    )
}


================================================
FILE: Fibwatch/src/main/kotlin/com/fibwatch/FibwatchPlugin.kt
================================================
package com.Fibwatch

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin


@CloudstreamPlugin
class FibwatchPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(Fibwatch())
        registerMainAPI(Fibwatchdrama())
        registerMainAPI(Fibtoon())
    }
}



================================================
FILE: Fibwatch/src/main/kotlin/com/fibwatch/Utils.kt
================================================
package com.Fibwatch

fun cleanTitle(raw: String?): String {
    val regex = Regex("""S(\d+)[Ee](\d+)(?:-(\d+))?""")
    val match = regex.find(raw ?: "") ?: return raw!!.trim()

    val season = match.groupValues[1].toInt()
    val epStart = match.groupValues[2].toInt()
    val epEnd = match.groupValues.getOrNull(3)?.takeIf { it.isNotEmpty() }?.toInt()

    val showName = raw?.substringBefore(match.value)!!.trim()
    val year = Regex("""\((\d{4})\)""").find(raw)?.groupValues?.get(1)

    val titleBase = if (year != null) showName else showName
    val episodes = if (epEnd != null) "Episodes $epStart–$epEnd" else "Episode $epStart"

    return "$titleBase Season $season | $episodes"
}


data class Links(
    val status: String?,
    val current: List<Current> = emptyList(),
    val popup: List<Popup> = emptyList(),
)

data class Current(
    val res: String?,
    val url: String?,
    val selected: Boolean = false,
)

data class Popup(
    val res: String?,
    val url: String?,
    val selected: Boolean = false,
)

data class LoadItem(
    val quality: String,
    val url: String,
    val selected: Boolean = false
)

data class LoadlinksOut(
    val status: String,
    val current: List<LoadItem>,
    val popup: List<LoadItem>
)

data class EpisodesResponse(
    val status: String?,
    val episodes: List<EpisodeItem>?
)

data class EpisodeItem(
    val ep_key: String?,
    val display: String?,
    val title: String?,
    val url: String?,
    val is_current: Boolean?
)

data class EpisodeInfo(
    val season: Int?,
    val episodeStart: Int?,
    val episodeEnd: Int?
)

fun parseSeasonEpisode(title: String): EpisodeInfo {
    val t = title.lowercase()

    // Case: S01E05 or S1E5 or S01E05-08
    val full = Regex("""s(\d{1,2})e(\d{1,3})(?:-(\d{1,3}))?""").find(t)
    if (full != null) {
        val season = full.groupValues[1].toInt()
        val epStart = full.groupValues[2].toInt()
        val epEnd = full.groupValues[3].takeIf { it.isNotBlank() }?.toInt()
        return EpisodeInfo(season, epStart, epEnd)
    }

    // Case: S01
    val seasonOnly = Regex("""s(\d{1,2})\b""").find(t)
    if (seasonOnly != null) {
        val season = seasonOnly.groupValues[1].toInt()
        return EpisodeInfo(season, null, null)
    }

    // Case: E05
    val epOnly = Regex("""e(\d{1,3})\b""").find(t)
    if (epOnly != null) {
        val episode = epOnly.groupValues[1].toInt()
        return EpisodeInfo(null, episode, null)
    }

    return EpisodeInfo(null, null, null)
}




================================================
FILE: Filmycab/build.gradle.kts
================================================
// use an integer for version numbers
version = 5

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "FilmyCab"
    language = "hi"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    iconUrl = "https://i.postimg.cc/CMkB4PXk/Filmy-Cab.png"
    isCrossPlatform = true
}



================================================
FILE: Filmycab/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Filmycab/src/main/kotlin/com/Filmycab/Extractor.kt
================================================
package com.Filmycab


import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.FormBody
import org.json.JSONObject
import java.net.URI
import java.net.URLDecoder
import java.nio.charset.StandardCharsets


class Filesdl : ExtractorApi() {
    override val name            = "Filesdl"
    override val mainUrl         = "https://new6.filesdl.site"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit) {
        val res = app.get(url).documentLarge
        val titleText = res.select("div.title").text()
        val qualityRegex = Regex("(\\d{3,4}p)", RegexOption.IGNORE_CASE)
        val quality = qualityRegex.find(titleText)?.value ?: "Unknown"
        res.select("div.container a").map {
            val source = it.text()
            val href = it.attr("href")
            when {

                source.contains("Hubcloud", ignoreCase = true) -> HubCloud().getUrl(href,"FilmyCab",subtitleCallback,callback)

                source.contains("GDFLIX", ignoreCase = true) -> GDFlix().getUrl(href,"",subtitleCallback,callback)

                source.contains("Gofile", ignoreCase = true) -> Gofile().getUrl(href,"",subtitleCallback,callback)

                source.contains("Direct Download", ignoreCase = true) || source.contains("Ultra FastDL", ignoreCase = true) -> {
                    val response = app.get(href, allowRedirects = false)
                    val redirectUrl = response.headers["location"] ?: href
                    callback(
                        newExtractorLink(
                            "[FastDL]",
                            "FilmyCab [FastDL]",
                            redirectUrl,
                            INFER_TYPE
                        ) {
                            this.quality = getQualityFromName(quality)
                        }
                    )
                }
            }
        }
    }
}

class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override val mainUrl = "https://hubcloud.foo"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()
            Log.d("Phisher",label)
            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }

                 */
                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }
}

class GDFlix : ExtractorApi() {
    override val name = "GDFlix"
    override val mainUrl = "https://*.gdflix.*"
    override val requiresReferer = false

    private suspend fun getLatestUrl(): String {
        val url = JSONObject(
            app.get("https://raw.githubusercontent.com/SaurabhKaperwan/Utils/refs/heads/main/urls.json").text
        ).optString("gdflix")
        if(url.isNullOrEmpty()) {
            return mainUrl
        }
        return url
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val latestUrl = getLatestUrl()
        val newUrl = url.replace(mainUrl, latestUrl)
        val document = app.get(newUrl).documentLarge
        val fileName = document.select("ul > li.list-group-item:contains(Name)").text()
            .substringAfter("Name : ")
        val fileSize = document.select("ul > li.list-group-item:contains(Size)").text()
            .substringAfter("Size : ")
        val quality = getIndexQuality(fileName)

        document.select("div.text-center a").amap { anchor ->
            val text = anchor.select("a").text()
            val link = anchor.attr("href")

            when {
                text.contains("DIRECT DL") -> {
                    callback.invoke(
                        newExtractorLink("GDFlix[Direct]", "GDFlix[Direct] $fileName[$fileSize]", link) {
                            this.quality = quality
                        }
                    )
                }

                text.contains("CLOUD DOWNLOAD [R2]") -> {
                    val link = URLDecoder.decode(link.substringAfter("url="), StandardCharsets.UTF_8.toString())
                    callback.invoke(
                        newExtractorLink("GDFlix[Cloud]", "GDFlix[Cloud] $fileName[$fileSize]", link) {
                            this.quality = quality
                        }
                    )
                }

                text.contains("pixeldra", ignoreCase = true) || text.contains("pixel", ignoreCase = true) -> {
                    val baseUrlLink = getBaseUrl(link)
                    val finalURL = if (link.contains("download", true)) link
                    else "$baseUrlLink/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "GDFlix Pixeldrain",
                            "GDFlix Pixeldrain $fileName[$fileSize]",
                            finalURL
                        ) { this.quality = quality }
                    )
                }

                text.contains("Index Links") -> {
                    try {
                        app.get("$latestUrl$link").documentLarge
                            .select("a.btn.btn-outline-info").amap { btn ->
                                val serverUrl = latestUrl + btn.attr("href")
                                app.get(serverUrl).documentLarge
                                    .select("div.mb-4 > a").amap { sourceAnchor ->
                                        val source = sourceAnchor.attr("href")
                                        callback.invoke(
                                            newExtractorLink("GDFlix[Index]", "GDFlix[Index] $fileName[$fileSize]", source) {
                                                this.quality = quality
                                            }
                                        )
                                    }
                            }
                    } catch (e: Exception) {
                        Log.d("Index Links", e.toString())
                    }
                }

                text.contains("DRIVEBOT") -> {
                    try {
                        val driveLink = link
                        val id = driveLink.substringAfter("id=").substringBefore("&")
                        val doId = driveLink.substringAfter("do=").substringBefore("==")
                        val baseUrls = listOf("https://drivebot.sbs", "https://indexbot.site")

                        baseUrls.amap { baseUrl ->
                            val indexbotLink = "$baseUrl/download?id=$id&do=$doId"
                            val indexbotResponse = app.get(indexbotLink, timeout = 100L)

                            if (indexbotResponse.isSuccessful) {
                                val cookiesSSID = indexbotResponse.cookies["PHPSESSID"]
                                val indexbotDoc = indexbotResponse.documentLarge

                                val token = Regex("""formData\.append\('token', '([a-f0-9]+)'\)""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val postId = Regex("""fetch\('/download\?id=([a-zA-Z0-9/+]+)'""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val requestBody = FormBody.Builder()
                                    .add("token", token)
                                    .build()

                                val headers = mapOf("Referer" to indexbotLink)
                                val cookies = mapOf("PHPSESSID" to "$cookiesSSID")

                                val downloadLink = app.post(
                                    "$baseUrl/download?id=$postId",
                                    requestBody = requestBody,
                                    headers = headers,
                                    cookies = cookies,
                                    timeout = 100L
                                ).text.let {
                                    Regex("url\":\"(.*?)\"").find(it)?.groupValues?.get(1)?.replace("\\", "").orEmpty()
                                }

                                callback.invoke(
                                    newExtractorLink("GDFlix[DriveBot]", "GDFlix[DriveBot] $fileName[$fileSize]", downloadLink) {
                                        this.referer = baseUrl
                                        this.quality = quality
                                    }
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.d("DriveBot", e.toString())
                    }
                }

                text.contains("Instant DL") -> {
                    try {
                        val instantLink = link
                        val link = app.get(instantLink, allowRedirects = false)
                            .headers["location"]?.substringAfter("url=").orEmpty()

                        callback.invoke(
                            newExtractorLink("GDFlix[Instant Download]", "GDFlix[Instant Download] $fileName[$fileSize]", link) {
                                this.quality = quality
                            }
                        )
                    } catch (e: Exception) {
                        Log.d("Instant DL", e.toString())
                    }
                }
                text.contains("GoFile") -> {
                    try {
                        app.get(link).documentLarge
                            .select(".row .row a").amap { gofileAnchor ->
                                val link = gofileAnchor.attr("href")
                                if (link.contains("gofile")) {
                                    Gofile().getUrl(link, "", subtitleCallback, callback)
                                }
                            }
                    } catch (e: Exception) {
                        Log.d("Gofile", e.toString())
                    }
                }

                else -> {
                    Log.d("Error", "No Server matched")
                }
            }
        }
    }
    fun getBaseUrl(url: String): String {
        return try {
            URI(url).let { "${it.scheme}://${it.host}" }
        } catch (_: Exception) {
            ""
        }
    }
}

class Gofile : ExtractorApi() {
    override val name = "Gofile"
    override val mainUrl = "https://gofile.io"
    override val requiresReferer = false
    private val mainApi = "https://api.gofile.io"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        try {
            val id = Regex("/(?:\\?c=|d/)([\\da-zA-Z-]+)").find(url)?.groupValues?.get(1) ?: return
            val responseText = app.post("$mainApi/accounts").text
            val json = JSONObject(responseText)
            val token = json.getJSONObject("data").getString("token")

            val globalJs = app.get("$mainUrl/dist/js/global.js").text
            val wt = Regex("""appdata\.wt\s*=\s*["']([^"']+)["']""")
                .find(globalJs)?.groupValues?.getOrNull(1) ?: return

            val responseTextfile = app.get(
                "$mainApi/contents/$id?wt=$wt",
                headers = mapOf("Authorization" to "Bearer $token")
            ).text

            val fileDataJson = JSONObject(responseTextfile)

            val data = fileDataJson.getJSONObject("data")
            val children = data.getJSONObject("children")
            val firstFileId = children.keys().asSequence().first()
            val fileObj = children.getJSONObject(firstFileId)

            val link = fileObj.getString("link")
            val fileName = fileObj.getString("name")
            val fileSize = fileObj.getLong("size")

            val sizeFormatted = if (fileSize < 1024L * 1024 * 1024) {
                "%.2f MB".format(fileSize / 1024.0 / 1024)
            } else {
                "%.2f GB".format(fileSize / 1024.0 / 1024 / 1024)
            }

            callback.invoke(
                newExtractorLink(
                    "Gofile",
                    "Gofile [$sizeFormatted]",
                    link
                ) {
                    this.quality = getQuality(fileName)
                    this.headers = mapOf("Cookie" to "accountToken=$token")
                }
            )
        } catch (e: Exception) {
            Log.e("Gofile", "Error occurred: ${e.message}")
        }
    }

    private fun getQuality(fileName: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(fileName ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}


================================================
FILE: Filmycab/src/main/kotlin/com/Filmycab/Filmycab.kt
================================================
package com.Filmycab

import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import kotlinx.coroutines.runBlocking
import org.jsoup.nodes.Element

class Filmycab : MainAPI() {
    override var mainUrl: String = runBlocking {
        FilmycabProvider.getDomains()?.Filmycab ?: "https://filmycab.casa"
    }
    override var name = "FilmyCab"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Cartoon)

    override val mainPage = mainPageOf(
        "" to "Homepage",
        "page-cat/6/Animation-Movies.html" to "Animation Movies",
        "page-cat/5/Web-Series.html" to "Web Series",
        "page-cat/12/Bengali-Movies.html" to "Bengali Movies",
        "page-cat/11/Bhojpuri-Movies.html" to "Bhojpuri Movies",
        "page-cat/1/Bollywood-Movies.html" to "Bollywood Movies",
        "page-cat/9/Gujarati-Movies.html" to "Gujarati Movies",
        "page-cat/7/Hindi-HQ-Dub-Movies.html" to "Hindi HQ Dub Movies",
        "page-cat/4/Hollywood-Movies.html" to "Hollywood Movies",
        "page-cat/8/Marathi-Movies.html" to "Marathi Movies",
        "page-cat/10/Odia-Movie.html" to "Odia Movie",
        "page-cat/3/Punjabi-Movies.html" to "Punjabi Movies",
        "page-cat/2/South-Movies.html" to "South Movies",
    )



    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = try {
            app.get("$mainUrl/${request.data}/?to-page=$page").documentLarge
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch main page: ${e.message}")
        }
        val items = document.select("div.thumb").mapNotNull { it.toSearchResult() }

        if (items.size < 4) {
            return newHomePageResponse(emptyList(), hasNext = false)
        }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = items,
                isHorizontalImages = false),
            hasNext = true
        )
    }


    private fun Element.toSearchResult(): SearchResponse? {
        val aTag = selectFirst("a") ?: return null
        val img = selectFirst("img") ?: return null
        val href = fixUrl(aTag.attr("href"))
        val title = img.attr("alt").substringBefore("(").trim()
        val lang = selectFirst("div.lang")?.text()?.trim()?.takeIf { it.isNotEmpty() }
        val fullTitle = if (lang != null) "$title [$lang]" else title
        val posterUrl = fixUrlNull(img.attr("src"))
        val quality = selectFirst("div.quality")?.text()
        return newMovieSearchResponse(fullTitle, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getQualityFromString(quality)
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val document = app.get("${mainUrl}/site-search.html?to-search=$query&to-page=$page").documentLarge
        val results = document.select("div.thumb").mapNotNull { it.toSearchResult() }.toNewSearchResponseList()
        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("div.l1:contains(Name:)")?.ownText()?.substringBefore("(") ?: "Unknown Title"
        val href = document.selectFirst("div.dlbtn a")?.attr("href") ?: ""
        val poster = document.select("div.thumbb > img").attr("src")
        val backgroundPoster = document.selectFirst("div.cover img")?.attr("src") ?: poster
        val actors = document
            .selectFirst("div.l1:contains(Starcast:)")
            ?.text()
            ?.substringAfter("Starcast:", "")
            ?.split(",", " and ")
            ?.map { it.trim() }
            ?.filter { it.isNotEmpty() }
            ?: emptyList()
        val genres = document
            .selectFirst("div.l1:contains(Genre:)")
            ?.text()
            ?.substringAfter("Genre:", "")
            ?.split(",", " and ")
            ?.map { it.trim() }
            ?.filter { it.isNotEmpty() }
            ?: emptyList()
        val year = document.selectFirst("div.l1:contains(Release Date:)")?.ownText()?.trim()?.toIntOrNull()
        val description = document.selectFirst("div.l1:contains(Summary:)")?.text()?.trim()
        val typedetails = document.select("div.l1:contains(Name:)").text()
        val tvtag = if (typedetails.contains("Series",ignoreCase = true)) TvType.TvSeries else TvType.Movie


        val recommendations = document.select("div.thumb").mapNotNull { it.toSearchResult() }

        return if (tvtag == TvType.TvSeries) {
            newMovieLoadResponse(title, url, TvType.TvSeries,href) {
                this.posterUrl = poster
                this.year = year
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.tags = genres
                this.recommendations = recommendations
                addActors(actors)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.year = year
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.tags = genres
                this.recommendations = recommendations
                addActors(actors)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document.select("div.dlink a").forEach {
            val href= it.attr("href")
            if (href.contains("filesdl"))
            {
                Filesdl().getUrl(href,"",subtitleCallback,callback)
            }
            else loadExtractor(href,"",subtitleCallback,callback)
        }
        return true
    }
}




================================================
FILE: Filmycab/src/main/kotlin/com/Filmycab/FilmycabProvider.kt
================================================
package com.Filmycab

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class FilmycabProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Filmycab())
        registerExtractorAPI(Filesdl())
        registerExtractorAPI(GDFlix())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(Gofile())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("Filmycab")
            val Filmycab: String,
        )
    }
}


================================================
FILE: Filmyfiy/build.gradle.kts
================================================
// use an integer for version numbers
version = 2

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Filmyfiy"
    language = "hi"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    iconUrl = "https://image.linkmake.in/images/files/afaa901b76bc48d57a346319423035dd384208.png"
    isCrossPlatform = true
}



================================================
FILE: Filmyfiy/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Filmyfiy/src/main/kotlin/com/Filmyfiy/Extractor.kt
================================================
package com.Filmyfiy


import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.FormBody
import org.json.JSONObject
import java.net.URI
import java.net.URLDecoder
import java.nio.charset.StandardCharsets


class Filesdl : ExtractorApi() {
    override val name            = "Filesdl"
    override val mainUrl         = "https://new6.filesdl.site"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit) {
        val res = app.get(url).documentLarge
        val titleText = res.select("div.title").text()
        val qualityRegex = Regex("(\\d{3,4}p)", RegexOption.IGNORE_CASE)
        val quality = qualityRegex.find(titleText)?.value ?: "Unknown"
        res.select("div.container a").map {
            val source = it.text()
            val href = it.attr("href")
            when {

                source.contains("Hubcloud", ignoreCase = true) -> HubCloud().getUrl(href,"Filmyfiy",subtitleCallback,callback)

                source.contains("GDFLIX", ignoreCase = true) -> GDFlix().getUrl(href,"Filmyfiy",subtitleCallback,callback)

                source.contains("Gofile", ignoreCase = true) -> Gofile().getUrl(href,"Filmyfiy",subtitleCallback,callback)

                source.contains("Direct Download", ignoreCase = true) || source.contains("Ultra FastDL", ignoreCase = true) || source.contains("Fast Cloud-02", ignoreCase = true) -> {
                    val response = app.get(href, allowRedirects = false)
                    val redirectUrl = response.headers["location"] ?: href
                    callback(
                        newExtractorLink(
                            "Direct Download",
                            "Filmyfiy [Direct Download]",
                            redirectUrl,
                            INFER_TYPE
                        ) {
                            this.quality = getQualityFromName(quality)
                        }
                    )
                }

                source.contains("Fast Cloud", ignoreCase = true) -> {
                    callback(
                        newExtractorLink(
                            "Fast Cloud",
                            "Filmyfiy [Fast Cloud]",
                            href,
                            INFER_TYPE
                        ) {
                            this.quality = getQualityFromName(quality)
                        }
                    )
                }
            }
        }
    }
}

class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override val mainUrl = "https://hubcloud.foo"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()
            Log.d("Phisher",label)
            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }

                 */
                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }
}

class GDFlix : ExtractorApi() {
    override val name = "GDFlix"
    override val mainUrl = "https://*.gdflix.*"
    override val requiresReferer = false

    private suspend fun getLatestUrl(): String {
        val url = JSONObject(
            app.get("https://raw.githubusercontent.com/SaurabhKaperwan/Utils/refs/heads/main/urls.json").text
        ).optString("gdflix")
        if(url.isNullOrEmpty()) {
            return mainUrl
        }
        return url
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val latestUrl = getLatestUrl()
        val newUrl = url.replace(mainUrl, latestUrl)
        val document = app.get(newUrl).documentLarge
        val fileName = document.select("ul > li.list-group-item:contains(Name)").text()
            .substringAfter("Name : ")
        val fileSize = document.select("ul > li.list-group-item:contains(Size)").text()
            .substringAfter("Size : ")
        val quality = getIndexQuality(fileName)

        document.select("div.text-center a").amap { anchor ->
            val text = anchor.select("a").text()
            val link = anchor.attr("href")

            when {
                text.contains("DIRECT DL") -> {
                    callback.invoke(
                        newExtractorLink("GDFlix[Direct]", "GDFlix[Direct] $fileName[$fileSize]", link) {
                            this.quality = quality
                        }
                    )
                }

                text.contains("CLOUD DOWNLOAD [R2]") -> {
                    val link = URLDecoder.decode(link.substringAfter("url="), StandardCharsets.UTF_8.toString())
                    callback.invoke(
                        newExtractorLink("GDFlix[Cloud]", "GDFlix[Cloud] $fileName[$fileSize]", link) {
                            this.quality = quality
                        }
                    )
                }

                text.contains("pixeldra", ignoreCase = true) || text.contains("pixel", ignoreCase = true) -> {
                    val baseUrlLink = getBaseUrl(link)
                    val finalURL = if (link.contains("download", true)) link
                    else "$baseUrlLink/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "GDFlix Pixeldrain",
                            "GDFlix Pixeldrain $fileName[$fileSize]",
                            finalURL
                        ) { this.quality = quality }
                    )
                }

                text.contains("Index Links") -> {
                    try {
                        app.get("$latestUrl$link").documentLarge
                            .select("a.btn.btn-outline-info").amap { btn ->
                                val serverUrl = latestUrl + btn.attr("href")
                                app.get(serverUrl).documentLarge
                                    .select("div.mb-4 > a").amap { sourceAnchor ->
                                        val source = sourceAnchor.attr("href")
                                        callback.invoke(
                                            newExtractorLink("GDFlix[Index]", "GDFlix[Index] $fileName[$fileSize]", source) {
                                                this.quality = quality
                                            }
                                        )
                                    }
                            }
                    } catch (e: Exception) {
                        Log.d("Index Links", e.toString())
                    }
                }

                text.contains("DRIVEBOT") -> {
                    try {
                        val driveLink = link
                        val id = driveLink.substringAfter("id=").substringBefore("&")
                        val doId = driveLink.substringAfter("do=").substringBefore("==")
                        val baseUrls = listOf("https://drivebot.sbs", "https://indexbot.site")

                        baseUrls.amap { baseUrl ->
                            val indexbotLink = "$baseUrl/download?id=$id&do=$doId"
                            val indexbotResponse = app.get(indexbotLink, timeout = 100L)

                            if (indexbotResponse.isSuccessful) {
                                val cookiesSSID = indexbotResponse.cookies["PHPSESSID"]
                                val indexbotDoc = indexbotResponse.documentLarge

                                val token = Regex("""formData\.append\('token', '([a-f0-9]+)'\)""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val postId = Regex("""fetch\('/download\?id=([a-zA-Z0-9/+]+)'""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val requestBody = FormBody.Builder()
                                    .add("token", token)
                                    .build()

                                val headers = mapOf("Referer" to indexbotLink)
                                val cookies = mapOf("PHPSESSID" to "$cookiesSSID")

                                val downloadLink = app.post(
                                    "$baseUrl/download?id=$postId",
                                    requestBody = requestBody,
                                    headers = headers,
                                    cookies = cookies,
                                    timeout = 100L
                                ).text.let {
                                    Regex("url\":\"(.*?)\"").find(it)?.groupValues?.get(1)?.replace("\\", "").orEmpty()
                                }

                                callback.invoke(
                                    newExtractorLink("GDFlix[DriveBot]", "GDFlix[DriveBot] $fileName[$fileSize]", downloadLink) {
                                        this.referer = baseUrl
                                        this.quality = quality
                                    }
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.d("DriveBot", e.toString())
                    }
                }

                text.contains("Instant DL") -> {
                    try {
                        val instantLink = link
                        val link = app.get(instantLink, allowRedirects = false)
                            .headers["location"]?.substringAfter("url=").orEmpty()

                        callback.invoke(
                            newExtractorLink("GDFlix[Instant Download]", "GDFlix[Instant Download] $fileName[$fileSize]", link) {
                                this.quality = quality
                            }
                        )
                    } catch (e: Exception) {
                        Log.d("Instant DL", e.toString())
                    }
                }
                text.contains("GoFile") -> {
                    try {
                        app.get(link).documentLarge
                            .select(".row .row a").amap { gofileAnchor ->
                                val link = gofileAnchor.attr("href")
                                if (link.contains("gofile")) {
                                    Gofile().getUrl(link, "", subtitleCallback, callback)
                                }
                            }
                    } catch (e: Exception) {
                        Log.d("Gofile", e.toString())
                    }
                }

                else -> {
                    Log.d("Error", "No Server matched")
                }
            }
        }
    }
    fun getBaseUrl(url: String): String {
        return try {
            URI(url).let { "${it.scheme}://${it.host}" }
        } catch (_: Exception) {
            ""
        }
    }
}

class Gofile : ExtractorApi() {
    override val name = "Gofile"
    override val mainUrl = "https://gofile.io"
    override val requiresReferer = false
    private val mainApi = "https://api.gofile.io"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        try {
            val id = Regex("/(?:\\?c=|d/)([\\da-zA-Z-]+)").find(url)?.groupValues?.get(1) ?: return
            val responseText = app.post("$mainApi/accounts").text
            val json = JSONObject(responseText)
            val token = json.getJSONObject("data").getString("token")

            val globalJs = app.get("$mainUrl/dist/js/global.js").text
            val wt = Regex("""appdata\.wt\s*=\s*["']([^"']+)["']""")
                .find(globalJs)?.groupValues?.getOrNull(1) ?: return

            val responseTextfile = app.get(
                "$mainApi/contents/$id?wt=$wt",
                headers = mapOf("Authorization" to "Bearer $token")
            ).text

            val fileDataJson = JSONObject(responseTextfile)

            val data = fileDataJson.getJSONObject("data")
            val children = data.getJSONObject("children")
            val firstFileId = children.keys().asSequence().first()
            val fileObj = children.getJSONObject(firstFileId)

            val link = fileObj.getString("link")
            val fileName = fileObj.getString("name")
            val fileSize = fileObj.getLong("size")

            val sizeFormatted = if (fileSize < 1024L * 1024 * 1024) {
                "%.2f MB".format(fileSize / 1024.0 / 1024)
            } else {
                "%.2f GB".format(fileSize / 1024.0 / 1024 / 1024)
            }

            callback.invoke(
                newExtractorLink(
                    "Gofile",
                    "Gofile [$sizeFormatted]",
                    link
                ) {
                    this.quality = getQuality(fileName)
                    this.headers = mapOf("Cookie" to "accountToken=$token")
                }
            )
        } catch (e: Exception) {
            Log.e("Gofile", "Error occurred: ${e.message}")
        }
    }

    private fun getQuality(fileName: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(fileName ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}


================================================
FILE: Filmyfiy/src/main/kotlin/com/Filmyfiy/Filmyfiy.kt
================================================
package com.Filmyfiy

import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.getDurationFromString
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import kotlinx.coroutines.runBlocking
import org.jsoup.nodes.Element

class Filmyfiy : MainAPI() {
    override var mainUrl: String = runBlocking {
        FilmyfiyProvider.getDomains()?.Filmyfiy ?: "https://www.filmyfiy.mov"
    }
    override var name = "Filmyfiy"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Cartoon)

    override val mainPage = mainPageOf(
        "" to "Homepage",
        "page-3/10/All-Time-Best-Bollywood-Hindi-Movies" to "Bollywood Movies",
        "page-3/42/Web-Series" to "Web Series",
        "page-3/58/HQ-Dubbed-Movies-UnCut" to "HQ Dubbed Movies",
        "page-3/11/South-Hindi-Dubbed-Movies-Collection" to "South Hindi Dubbed Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = try {
            app.get("$mainUrl/${request.data}/$page").document
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch main page: ${e.message}")
        }
        val items = document.select("tr").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = items,
                isHorizontalImages = false),
            hasNext = true
        )
    }


    private fun Element.toSearchResult(): SearchResponse? {
        val aTag = selectFirst("td[align=left] a:has(b), td[align=left] a:not(:has(img))")
            ?: return null
        val img = selectFirst("img") ?: return null

        val href = fixUrl(aTag.attr("href"))
        val rawText = aTag.text().trim()

        val title = rawText.substringBefore("(").trim()

        val lang = rawText
            .substringAfter("(", "")
            .substringBefore(")")
            .takeIf { it.isNotBlank() }

        val fullTitle = lang?.let { "$title [$it]" } ?: title

        val posterUrl = fixUrlNull(img.attr("src"))
        val qualityText = selectFirst("div.quality")?.text()

        return newMovieSearchResponse(fullTitle, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getQualityFromString(qualityText)
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val document = app.get("${mainUrl}/site-1.html?to-search=$query").documentLarge
        val results = document.select("div.A2").mapNotNull { el ->
                val aTag = el.selectFirst("a:has(b), a:not(:has(img))") ?: return@mapNotNull null
                val img = el.selectFirst("img") ?: return@mapNotNull null

                val href = fixUrl(aTag.attr("href"))
                val rawText = aTag.text().trim()

                val title = rawText.substringBefore("(").trim()
                val extra = rawText
                    .substringAfter("(", "")
                    .substringBefore(")")
                    .takeIf { it.isNotBlank() }

                val fullTitle = extra?.let { "$title [$it]" } ?: title
                val posterUrl = fixUrlNull(img.attr("src"))

                newMovieSearchResponse(fullTitle, href, TvType.Movie) {
                    this.posterUrl = posterUrl
                }
            }.toNewSearchResponseList()
        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("div.fname:contains(Name:) > div")?.text()?.substringBefore("(")?.trim() ?: "Unknown Title"
        val href = document.selectFirst("div.dlbtn a")?.attr("href") ?: ""
        val poster = document.select("div.movie-thumb img").attr("src")
        val backgroundPoster = document.selectFirst("div.cover img")?.attr("src") ?: poster
        val actors =document
            .selectFirst("div.fname:contains(Starcast:) > div")
            ?.text()
            ?.split(",", " and ")
            ?.map { it.trim() }
            ?.filter { it.isNotEmpty() }
            ?: emptyList()

        val genres = document
            .selectFirst("div.fname:contains(Genre:) > div")
            ?.text()
            ?.split(",", " and ")
            ?.map { it.trim() }
            ?.filter { it.isNotEmpty() }
            ?: emptyList()

        val year = document.selectFirst("div.fname:contains(Release Date:) > div")?.text()?.trim()?.toIntOrNull()
        val duration = document.selectFirst("div.fname:contains(Duration:) > div")?.text()?.trim()
        val description = document.selectFirst("div.fname:contains(Description:) > div")?.text()?.trim()
        val tvtag = if (Regex("""(?i)\b(s(eason)?\s*\d{1,2})\b""").containsMatchIn(url)) TvType.TvSeries else TvType.Movie


        val recommendations = document.select("tr").mapNotNull { it.toSearchResult() }

        return if (tvtag == TvType.TvSeries) {
            newMovieLoadResponse(title, url, TvType.TvSeries,href) {
                this.posterUrl = poster
                this.year = year
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.duration = getDurationFromString(duration)
                this.tags = genres
                this.recommendations = recommendations
                addActors(actors)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.year = year
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.duration = getDurationFromString(duration)
                this.tags = genres
                this.recommendations = recommendations
                addActors(actors)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document.select("div.dlink.dl a").forEach {
            val href= it.attr("href")
            if (href.contains("filesdl"))
            {
                Filesdl().getUrl(href,"",subtitleCallback,callback)
            }
            else loadExtractor(href,"",subtitleCallback,callback)
        }
        return true
    }
}




================================================
FILE: Filmyfiy/src/main/kotlin/com/Filmyfiy/FilmyfiyProvider.kt
================================================
package com.Filmyfiy

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class FilmyfiyProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Filmyfiy())
        registerExtractorAPI(Filesdl())
        registerExtractorAPI(GDFlix())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(Gofile())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("Filmyfiy")
            val Filmyfiy: String,
        )
    }
}


================================================
FILE: Fivemovierulz/build.gradle.kts
================================================
version = 4


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

    description = "Movies & Series"
    authors = listOf("darkdemon","Dilip")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie"
    )

    iconUrl = "https://i.ibb.co/SwQRhsn/20241016-074942.jpg"

    isCrossPlatform = true
}



================================================
FILE: Fivemovierulz/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />



================================================
FILE: Fivemovierulz/src/main/kotlin/com/darkdemon/Extractor.kt
================================================
package com.darkdemon
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidhideExtractor

class Filelion : VidhideExtractor() {
    override var mainUrl = "https://vidhidepro.com"
}


class mivalyo : VidhideExtractor() {
    override var name = "Mivalyo"
    override var mainUrl = "https://mivalyo.com"
}

class StreamwishHG : StreamWishExtractor() {
    override val mainUrl = "https://hglink.to"
}


================================================
FILE: Fivemovierulz/src/main/kotlin/com/darkdemon/FivemovierulzPlugin.kt
================================================
package com.darkdemon

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class FivemovierulzPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerExtractorAPI(Filelion())
        registerMainAPI(FivemovierulzProvider())
        registerExtractorAPI(StreamwishHG())
        registerExtractorAPI(mivalyo())
    }
}



================================================
FILE: Fivemovierulz/src/main/kotlin/com/darkdemon/FivemovierulzProvider.kt
================================================
package com.darkdemon

import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class FivemovierulzProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://5movierulz.gripe"
    override var name = "5movierulz"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
    )

    override val mainPage = mainPageOf(
        "$mainUrl/category/featured/page/" to "Latest",
        "$mainUrl/category/bollywood-featured/page/" to "Bollywood",
        "$mainUrl/language/hindi-dubbed/page/" to "Hindi Dubbed",
        "$mainUrl/category/hollywood-featured/page/" to "Hollywood"
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).documentLarge
        val home = document.select("#main .cont_display").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title =
            this.selectFirst("a")?.attr("title")?.trim()?.substringBefore("(") ?: return null
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("src"))

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge

        return document.select("#main .cont_display").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).documentLarge

        val title = document.selectFirst("h2.entry-title")?.text()?.trim()?.substringBefore("(")
            ?: return null
        val poster = fixUrlNull(document.selectFirst(".entry-content img")?.attr("src"))
        val tags =
            document.select("div.entry-content > p:nth-child(5)").text().substringAfter("Genres:")
                .substringBefore("Country:").split(",").map { it }
        val yearRegex = Regex("""\d{4}""")
        val year = yearRegex.find(
            document.select("h2.entry-title").text()
        )?.groupValues?.getOrNull(0)?.toIntOrNull()
        val description = document.select("div.entry-content > p:nth-child(6)").text().trim()
        val actors =
            document.select("div.entry-content > p:nth-child(5)").text()
                .substringAfter("Starring by:")
                .substringBefore("Genres:").split(",").map { it }

        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl = poster
            this.year = year
            this.plot = description
            this.tags = tags
            addActors(actors)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge

        val links = document.select("p a")
            .filter { it.text().contains("watch online", ignoreCase = true) }
            .mapNotNull { it.attr("href") }
            .filter { it.isNotBlank() }

        for (link in links) {
            Log.d("Phisher",link)
            loadExtractor(
                link,
                "$mainUrl/",
                subtitleCallback,
                callback
            )
        }

        return links.isNotEmpty()
    }
}



================================================
FILE: FourKHDHub/build.gradle.kts
================================================
// use an integer for version numbers
version = 28


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "4K Movies Extension by HDHUB4U"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/4KHDHUB-Bright-Logo.png"

    isCrossPlatform = false
}



================================================
FILE: FourKHDHub/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: FourKHDHub/src/main/kotlin/com/fourKHDHub/Extractor.kt
================================================
package com.fourKHDHub

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.PixelDrain
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.runBlocking
import java.net.URI


class HdStream4u : VidHidePro() {
    override var mainUrl = "https://hdstream4u.*"
}

class Hubstream : VidStack() {
    override var mainUrl = "https://hubstream.*"
}

class Hubstreamdad : Hblinks() {
    override var mainUrl = "https://hblinks.*"
}

open class Hblinks : ExtractorApi() {

    override val name = "Hblinks"
    override val mainUrl = "https://hblinks.*"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val elements = runCatching {
            app.get(url).documentLarge
                .select("h3 a, h5 a, div.entry-content p a")
        }.getOrElse {
            Log.e(name, "Failed to load page: ${it.message}")
            return
        }

        elements.forEach { el ->
            val href = el.absUrl("href")
                .ifBlank { el.attr("href") }
                .trim()

            if (href.isEmpty()) return@forEach

            val lower = href.lowercase()

            when {
                "hubdrive" in lower -> Hubdrive().getUrl(href, name, subtitleCallback, callback)
                "hubcloud" in lower -> HubCloud().getUrl(href, name, subtitleCallback, callback)
                "hubcdn" in lower -> HUBCDN().getUrl(href, name, subtitleCallback, callback)
                else ->
                    loadSourceNameExtractor(
                        name,
                        href,
                        "",
                        Qualities.Unknown.value,
                        subtitleCallback,
                        callback
                    )
            }
        }
    }
}


class Hubcdnn : ExtractorApi() {

    override val name = "Hubcdn"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val html = runCatching {
            app.get(url).documentLarge.toString()
        }.getOrElse {
            Log.e(name, "Failed to load page: ${it.message}")
            return
        }

        val encoded = Regex("r=([A-Za-z0-9+/=]+)")
            .find(html)
            ?.groupValues
            ?.getOrNull(1)
            .orEmpty()

        if (encoded.isEmpty()) {
            Log.e(name, "Encoded URL not found")
            return
        }

        val m3u8 = runCatching {
            base64Decode(encoded).substringAfterLast("link=")
        }.getOrElse {
            Log.e(name, "Failed to decode base64")
            return
        }

        callback(
            newExtractorLink(
                name,
                name,
                m3u8,
                ExtractorLinkType.M3U8
            ) {
                this.referer = url
                this.quality = Qualities.Unknown.value
            }
        )
    }
}


class PixelDrainDev : PixelDrain(){
    override var mainUrl = "https://pixeldrain.dev"
}

class Hubdrive : ExtractorApi() {
    override val name = "Hubdrive"
    override val mainUrl = "https://hubdrive.space"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val href=app.get(url, timeout = 5000L).documentLarge.select(".btn.btn-primary.btn-user.btn-success1.m-1").attr("href")
        if (href.contains("hubcloud",ignoreCase = true)) HubCloud().getUrl(href,"HubDrive",subtitleCallback,callback)
        else loadExtractor(href,"HubDrive",subtitleCallback, callback)
    }
}


class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override var mainUrl: String = runBlocking {
        FourKHDHubProvider.getDomains()?.hubcloud ?: "https://hubcloud.foo"
    }
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()

            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }

                 */

                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }
}

class HUBCDN : ExtractorApi() {
    override val name = "HUBCDN"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get(url).documentLarge
        val scriptText = doc.selectFirst("script:containsData(var reurl)")?.data()

        val encodedUrl = Regex("reurl\\s*=\\s*\"([^\"]+)\"")
            .find(scriptText ?: "")
            ?.groupValues?.get(1)
            ?.substringAfter("?r=")

        val decodedUrl = encodedUrl?.let { base64Decode(it) }?.substringAfterLast("link=")


        if (decodedUrl != null) {
            callback(
                newExtractorLink(
                    this.name,
                    this.name,
                    decodedUrl,
                    INFER_TYPE,
                )
                {
                    this.quality=Qualities.Unknown.value
                }
            )
        }
    }
}




================================================
FILE: FourKHDHub/src/main/kotlin/com/fourKHDHub/FourKHDHub.kt
================================================
package com.fourKHDHub

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.LoadResponse.Companion.addSimklId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import kotlinx.coroutines.runBlocking
import org.json.JSONObject
import org.jsoup.nodes.Element

class FourKHDHub : MainAPI() {
    override var mainUrl: String = runBlocking {
        FourKHDHubProvider.getDomains()?.n4khdhub ?: "https://4khdhub.dad"
    }
    override var name                 = "4K HDHUB"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.TvSeries)


    companion object
    {
        const val TMDBAPI = "https://wild-surf-4a0d.phisher1.workers.dev"
        const val TMDB_API_KEY = "1865f43a0549ca50d341dd9ab8b29f49"
        private const val SIMKL = "https://api.simkl.com"
        const val TMDBIMAGEBASEURL = "https://image.tmdb.org/t/p/original"

    }

    override val mainPage = mainPageOf(
        "" to "Home",
        "category/movies" to "Latest Movies",
        "category/hindi-movies" to "Hindi Movies",
        "category/english-movies" to "English Movies",
        "category/series" to "Latest Episodes",
        "category/korean-series" to "Korean Series",
        "category/netflix" to "Netflix",
        "category/amazon_prime_video" to "Amazon Prime Video",
        "category/jiohotstar" to "JioHotstar",
        "category/disney" to "Disney+",
        "category/Apple_TV" to "Apple TV+",
        "category/anime" to "Anime",
        "category/2160p-HDR" to "4K HDR",
        "category/imdb" to "Top IMDb"
    )


    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = "$mainUrl/${request.data}/page/$page"
        val document = app.get(url).documentLarge
        val results = document.select("div.card-grid a").mapNotNull {
                it.toSearchResult()
        }
        return newHomePageResponse(request.name, results)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3")?.text() ?: return null
        val href = this.attr("href")
        val posterUrl = this.select("img").attr("src")
        val tags = select("span.movie-card-format").map { it.text() }
        val quality = getSearchQuality(tags)
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        val results = document.select("div.card-grid a").mapNotNull {
            it.toSearchResult()
        }
        return results
    }

    @RequiresApi(Build.VERSION_CODES.N)
    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("h1.page-title")?.text()?.substringBefore("(")?.trim().toString()
        val poster = document.select("meta[property=og:image]").attr("content")
        val tags = document.select("div.mt-2 span.badge").map { it.text() }
        val year = document.selectFirst("div.mt-2 span")?.text()?.toIntOrNull()
        val tvType = if ("Movies" in tags) TvType.Movie else TvType.TvSeries
        val isMovie = tvType == TvType.Movie
        val tmdbId = runCatching { fetchtmdb(title,isMovie) }.getOrNull()

        val hrefs: List<String> = document.select("div.download-item a").eachAttr("href")

        val description = document.selectFirst("div.content-section p.mt-4")?.text()?.trim()
        val trailer = document.selectFirst("#trailer-btn")?.attr("data-trailer-url")

        val recommendations = document.select("div.card-grid-small a").mapNotNull {
            it.toSearchResult()
        }

        var tmdbTitle: String? = null
        var tmdbOverview: String? = null
        var tmdbYear: Int? = null
        var tmdbRating: Double? = null
        var tmdbPoster: String? = null
        var tmdbBackdrop: String? = null
        var tmdbActors: List<ActorData> = emptyList()

        if (tmdbId != null) {
            val type = if (tvType == TvType.Movie) "movie" else "tv"
            val tmdbJson = runCatching {
                JSONObject(
                    app.get("$TMDBAPI/$type/$tmdbId?api_key=$TMDB_API_KEY&append_to_response=credits")
                        .textLarge
                )
            }.getOrNull()

            if (tmdbJson != null) {
                tmdbTitle = tmdbJson.optString("title").ifBlank { tmdbJson.optString("name").ifBlank { null } }
                tmdbOverview = tmdbJson.optString("overview").takeIf { it.isNotBlank() }
                val date = tmdbJson.optString("release_date").ifBlank { tmdbJson.optString("first_air_date") }
                tmdbYear = date.takeIf { it.isNotBlank() }?.substringBefore("-")?.toIntOrNull()
                tmdbRating = tmdbJson.optDouble("vote_average").takeIf { it != 0.0 }
                tmdbPoster = tmdbJson.optString("poster_path").takeIf { it.isNotBlank() }?.let { TMDBIMAGEBASEURL + it }
                tmdbBackdrop = tmdbJson.optString("backdrop_path").takeIf { it.isNotBlank() }?.let { TMDBIMAGEBASEURL + it }

                tmdbActors = buildList {
                    tmdbJson.optJSONObject("credits")
                        ?.optJSONArray("cast")
                        ?.let { arr ->
                            for (i in 0 until arr.length()) {
                                val obj = arr.optJSONObject(i) ?: continue
                                val name = obj.optString("name").takeIf { it.isNotBlank() } ?: obj.optString("original_name").takeIf { it.isNotBlank() }
                                if (name.isNullOrBlank()) continue
                                val profile = obj.optString("profile_path").takeIf { it.isNotBlank() }?.let { TMDBIMAGEBASEURL + it }
                                val character = obj.optString("character").takeIf { it.isNotBlank() }
                                add(ActorData(Actor(name, profile), roleString = character))
                            }
                        }
                }
            }
        }

        val fixedTitle = tmdbTitle ?: title
        val fixedPoster = tmdbPoster ?: poster
        val fixedBackdrop = tmdbBackdrop ?: poster
        val fixedPlot = tmdbOverview ?: description
        val fixedYear = tmdbYear ?: year
        val finalActorsFromTmdb = tmdbActors

        return if (tvType == TvType.TvSeries) {
            val tvSeriesEpisodes = mutableListOf<Episode>()
            val episodesMap = mutableMapOf<Pair<Int, Int>, MutableList<String>>()
            val maxEpisodePerSeason = mutableMapOf<Int, Int>()
            val imdbIdFromSeries = tmdbId?.let { id ->
                runCatching {
                    val url = "$TMDBAPI/tv/$id/external_ids?api_key=$TMDB_API_KEY"
                    JSONObject(app.get(url).textLarge).optString("imdb_id").takeIf { it.isNotBlank() }
                }.getOrNull()
            }

            val logoPath = imdbIdFromSeries?.let {
                "https://live.metahub.space/logo/medium/$it/img"
            }


            val simklIdseries = imdbIdFromSeries?.let { imdb ->
                runCatching {
                    JSONObject(app.get("$SIMKL/tv/$imdb?client_id=${BuildConfig.SIMKL_CLIENT_ID}").text)
                        .optJSONObject("ids")?.optInt("simkl")?.takeIf { it != 0 }
                }.getOrNull()
            }

            document.select("div.episodes-list div.season-item").forEach { seasonElement ->
                val seasonText = seasonElement.select("div.episode-number").text()
                val season = Regex("""S?([1-9][0-9]*)""").find(seasonText)?.groupValues?.get(1)?.toIntOrNull()
                    ?: return@forEach

                seasonElement.select("div.episode-download-item").forEach { episodeItem ->
                    val episodeText = episodeItem.select("div.episode-file-info span.badge-psa").text()
                    val episode = Regex("""Episode-0*([1-9][0-9]*)""").find(episodeText)?.groupValues?.get(1)?.toIntOrNull()
                        ?: return@forEach

                    val hrefsForEp = episodeItem.select("a").mapNotNull { it.attr("href").takeIf { it.isNotBlank() } }
                    if (hrefsForEp.isNotEmpty()) {
                        val key = season to episode
                        episodesMap.getOrPut(key) { mutableListOf() }.addAll(hrefsForEp)
                        maxEpisodePerSeason[season] = maxOf(maxEpisodePerSeason.getOrDefault(season, 0), episode)
                    }
                }
            }

            val tmdbSeasonCache = mutableMapOf<Int, JSONObject?>()
            if (tmdbId != null) {
                val seasonsToFetch = episodesMap.keys.map { it.first }.distinct()
                for (s in seasonsToFetch) {
                    tmdbSeasonCache[s] = runCatching {
                        JSONObject(app.get("$TMDBAPI/tv/$tmdbId/season/$s?api_key=$TMDB_API_KEY").text)
                    }.getOrNull()
                }
            }


            episodesMap.toSortedMap(compareBy({ it.first }, { it.second })).forEach { (seasonEpisode, hrefsList) ->
                val (season, episode) = seasonEpisode

                var epName: String? = null
                var epOverview: String? = null
                var epThumb: String? = null
                var epAir: String? = null
                var epRating: Double? = null

                tmdbSeasonCache[season]?.optJSONArray("episodes")?.let { arr ->
                    for (i in 0 until arr.length()) {
                        val epObj = arr.optJSONObject(i) ?: continue
                        if (epObj.optInt("episode_number") == episode) {
                            epName = epObj.optString("name").takeIf { it.isNotBlank() }
                            epOverview = epObj.optString("overview").takeIf { it.isNotBlank() }
                            epThumb = epObj.optString("still_path").takeIf { it.isNotBlank() }?.let { TMDBIMAGEBASEURL + it }
                            epAir = epObj.optString("air_date").takeIf { it.isNotBlank() }
                            epRating = epObj.optDouble("vote_average").takeIf { !it.isNaN() && it > 0.0 }
                            break
                        }
                    }
                }

                tvSeriesEpisodes += newEpisode(hrefsList.distinct()) {
                    this.season = season
                    this.episode = episode
                    this.name = epName ?: "Episode $episode"
                    this.posterUrl = epThumb
                    this.description = epOverview
                    addDate(epAir)
                    this.score = safeScoreFrom10(epRating)
                }
            }

            document.select("div.download-item").forEach { item ->
                val headerText = item.select("div.flex-1.text-left.font-semibold").text()

                val season = Regex("""S([0-9]+)""").find(headerText)?.groupValues?.get(1)?.toIntOrNull()
                    ?: return@forEach

                val size = Regex("""(\d+(?:\.\d+)?\s*GB)""").find(headerText)?.groupValues?.get(1) ?: "Unknown Size"
                val quality = Regex("""(\d{3,4}p)""").find(headerText)?.groupValues?.get(1) ?: "Unknown Quality"

                val hrefList = item.select("a").mapNotNull { it.attr("href").takeIf { it.isNotBlank() } }

                val fileTitle = item.select("div.file-title").text()
                    .replace(Regex("""\[[^]]*]"""), "")
                    .replace(Regex("""\(.+?\)"""), "")

                if (hrefList.isNotEmpty()) {
                    var nextEpisode = maxEpisodePerSeason.getOrDefault(season, 0) + 1

                    var epName: String? = null
                    var epOverview: String? = null
                    var epThumb: String? = null
                    var epAir: String? = null
                    var epRating: Double? = null

                    tmdbSeasonCache[season]?.optJSONArray("episodes")?.let { arr ->
                        for (i in 0 until arr.length()) {
                            val epObj = arr.optJSONObject(i) ?: continue
                            if (epObj.optInt("episode_number") == nextEpisode) {
                                epName = epObj.optString("name").takeIf { it.isNotBlank() }
                                epOverview = epObj.optString("overview").takeIf { it.isNotBlank() }
                                epThumb = epObj.optString("still_path").takeIf { it.isNotBlank() }?.let { TMDBIMAGEBASEURL + it }
                                epAir = epObj.optString("air_date").takeIf { it.isNotBlank() }
                                epRating = epObj.optDouble("vote_average").takeIf { !it.isNaN() && it > 0.0 }
                                break
                            }
                        }
                    }

                    tvSeriesEpisodes += newEpisode(hrefList.distinct()) {
                        this.season = season
                        this.episode = nextEpisode
                        this.name = epName ?: "S${season.toString().padStart(2, '0')} – $fileTitle [$quality, $size]".trim()
                        this.posterUrl = epThumb
                        this.description = epOverview
                        addDate(epAir)
                        this.score = safeScoreFrom10(epRating)

                    }

                    nextEpisode++
                    maxEpisodePerSeason[season] = nextEpisode - 1
                }
            }

            newTvSeriesLoadResponse(fixedTitle, url, TvType.TvSeries, tvSeriesEpisodes) {
                this.posterUrl = fixedPoster
                this.backgroundPosterUrl = fixedBackdrop
                try { this.logoUrl = logoPath } catch(_:Throwable){}
                this.year = fixedYear
                this.plot = fixedPlot
                this.tags = tags
                this.recommendations = recommendations
                this.actors = finalActorsFromTmdb
                this.score = safeScoreFrom10(tmdbRating)
                addTrailer(trailer)
                addSimklId(simklIdseries)
            }
        } else {
            val imdbIdFromMovie = tmdbId?.let { id ->
                runCatching {
                    val url = "$TMDBAPI/movie/$id/external_ids?api_key=$TMDB_API_KEY"
                    JSONObject(app.get(url).textLarge).optString("imdb_id").takeIf { it.isNotBlank() }
                }.getOrNull()
            }

            val logoPath = imdbIdFromMovie?.let {
                "https://live.metahub.space/logo/medium/$it/img"
            }

            val simklIdMovie = imdbIdFromMovie?.let { imdb ->
                runCatching {
                    JSONObject(app.get("$SIMKL/movies/$imdb?client_id=${BuildConfig.SIMKL_CLIENT_ID}").text)
                        .optJSONObject("ids")?.optInt("simkl")?.takeIf { it != 0 }
                }.getOrNull()
            }

            val movieCreditsJsonText = tmdbId?.let { id ->
                runCatching {
                    app.get("${TMDBAPI}/movie/$id/credits?api_key=$TMDB_API_KEY&language=en-US").textLarge
                }.getOrNull()
            }
            val movieCastList = parseCredits(movieCreditsJsonText)
            val finalMovieActors = tmdbActors.ifEmpty { movieCastList }

            newMovieLoadResponse(fixedTitle, url, TvType.Movie, hrefs) {
                this.posterUrl = fixedPoster
                this.backgroundPosterUrl = fixedBackdrop
                try { this.logoUrl = logoPath } catch(_:Throwable){}
                this.year = fixedYear
                this.plot = fixedPlot
                this.tags = tags
                this.recommendations = recommendations
                this.actors = finalMovieActors
                this.score = safeScoreFrom10(tmdbRating)
                addTrailer(trailer)
                addSimklId(simklIdMovie)
            }
        }
    }

    private val LINK_REGEX =
        Regex("""https?://[^\s'",\]\[]+""", RegexOption.IGNORE_CASE)

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        if (data.isBlank()) return false

        val hubCloud = HubCloud()
        val hubDrive = Hubdrive()
        val hubCdn = Hubcdnn()

        LINK_REGEX.findAll(data)
            .map { it.value }
            .forEach { rawLink ->

                val resolvedLink = try {
                    if ("id=" in rawLink.lowercase())
                        getRedirectLinks(rawLink)
                    else
                        rawLink
                } catch (e: Exception) {
                    Log.e("Phisher", "Redirect failed for $rawLink — ${e.message}")
                    return@forEach
                }

                if (resolvedLink.isBlank()) {
                    Log.e("Extractor", "Resolved link is empty for $rawLink")
                    return@forEach
                }

                val lower = resolvedLink.lowercase()

                when {
                    "hubcloud" in lower -> {
                        hubCloud.getUrl(
                            resolvedLink,
                            name,
                            subtitleCallback,
                            callback
                        )
                    }

                    "hubdrive" in lower -> {
                        hubDrive.getUrl(
                            resolvedLink,
                            name,
                            subtitleCallback,
                            callback
                        )
                    }

                    "hubcdn" in lower -> {
                        hubCdn.getUrl(
                            resolvedLink,
                            name,
                            subtitleCallback,
                            callback
                        )
                    }

                    else -> {
                        loadExtractor(
                            resolvedLink,
                            name,
                            subtitleCallback,
                            callback
                        )
                    }
                }
            }

        return true
    }
}



================================================
FILE: FourKHDHub/src/main/kotlin/com/fourKHDHub/FourKHDHubProvider.kt
================================================
package com.fourKHDHub

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class FourKHDHubProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(FourKHDHub())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(HdStream4u())
        registerExtractorAPI(Hubstream())
        registerExtractorAPI(Hubstreamdad())
        registerExtractorAPI(Hubcdnn())
        registerExtractorAPI(PixelDrainDev())
        registerExtractorAPI(HUBCDN())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("4khdhub")
            val n4khdhub: String,
            @JsonProperty("hubcloud")
            val hubcloud: String,
        )
    }
}


================================================
FILE: FourKHDHub/src/main/kotlin/com/fourKHDHub/Utils.kt
================================================
package com.fourKHDHub

import android.util.Base64
import com.fourKHDHub.FourKHDHub.Companion.TMDBAPI
import com.fourKHDHub.FourKHDHub.Companion.TMDBIMAGEBASEURL
import com.fourKHDHub.FourKHDHub.Companion.TMDB_API_KEY
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchQuality
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject
import java.net.URLEncoder
import java.text.Normalizer

private val REDIRECT_REGEX =
    Regex("s\\('o','([A-Za-z0-9+/=]+)'|ck\\('_wp_http_\\d+','([^']+)'")

suspend fun getRedirectLinks(url: String): String {
    val html = runCatching {
        app.get(url).text
    }.getOrElse {
        Log.e("Error", "Failed to load redirect page: ${it.message}")
        return ""
    }

    // Faster than buildString + forEach
    val combined = StringBuilder(128)
    for (m in REDIRECT_REGEX.findAll(html)) {
        m.groups[1]?.value?.let(combined::append)
            ?: m.groups[2]?.value?.let(combined::append)
    }

    if (combined.isEmpty()) return ""

    return runCatching {
        val decoded = base64Decode(
            pen(
                base64Decode(
                    base64Decode(combined.toString())
                )
            )
        )

        val json = JSONObject(decoded)

        val encodedUrl = base64Decode(json.optString("o"))
        if (encodedUrl.isNotBlank()) return@runCatching encodedUrl.trim()

        val data = encode(json.optString("data"))
        val wp = json.optString("blog_url")
        if (wp.isBlank() || data.isBlank()) return@runCatching ""

        app.get("$wp?re=$data")
            .documentLarge
            .body()
            .text()
            .trim()
    }.getOrElse {
        Log.e("Error", "Error processing redirect: ${it.message}")
        ""
    }
}

fun encode(value: String): String =
    if (value.isEmpty()) "" else String(Base64.decode(value, Base64.DEFAULT))

fun pen(value: String): String {
    val out = StringBuilder(value.length)
    for (c in value) {
        out.append(
            when (c) {
                in 'A'..'Z' -> ((c - 'A' + 13) % 26 + 'A'.code).toChar()
                in 'a'..'z' -> ((c - 'a' + 13) % 26 + 'a'.code).toChar()
                else -> c
            }
        )
    }
    return out.toString()
}


suspend fun fetchtmdb(title: String, isMovie: Boolean): Int? {
    val url =
        "${TMDBAPI}/search/multi?api_key=${TMDB_API_KEY}&query=" +
                URLEncoder.encode(title, "UTF-8")

    val json = JSONObject(app.get(url).text)
    val results = json.optJSONArray("results") ?: return null

    val targetType = if (isMovie) "movie" else "tv"

    for (i in 0 until results.length()) {
        val item = results.optJSONObject(i) ?: continue

        if (item.optString("media_type") != targetType) continue

        val resultTitle = if (isMovie)
            item.optString("title")
        else
            item.optString("name")

        if (resultTitle.equals(title, ignoreCase = true)) {
            return item.optInt("id")
        }
    }
    return null
}


fun parseCredits(jsonText: String?): List<ActorData> {
    if (jsonText.isNullOrBlank()) return emptyList()
    val list = ArrayList<ActorData>()
    val root = JSONObject(jsonText)
    val castArr = root.optJSONArray("cast") ?: return list
    for (i in 0 until castArr.length()) {
        val c = castArr.optJSONObject(i) ?: continue
        val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
        val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { "$TMDBIMAGEBASEURL$it" }
        val character = c.optString("character").takeIf { it.isNotBlank() }
        val actor = Actor(name, profile)
        list += ActorData(actor, roleString = character)
    }
    return list
}

fun getSearchQuality(tags: List<String>): SearchQuality {
    if (tags.isEmpty()) return SearchQuality.HD
    val text = Normalizer.normalize(tags.joinToString(" "), Normalizer.Form.NFKC).lowercase()
    val patterns = listOf(
        Regex("\\b(4k|ds4k|uhd|2160p)\\b") to SearchQuality.FourK,
        Regex("\\b(1440p|qhd)\\b") to SearchQuality.BlueRay,
        Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b") to SearchQuality.BlueRay,
        Regex("\\b(1080p|fullhd)\\b") to SearchQuality.HD,
        Regex("\\b(720p)\\b") to SearchQuality.SD,
        Regex("\\b(web[- ]?dl|webrip|webdl)\\b") to SearchQuality.WebRip,
        Regex("\\b(hdrip|hdtv)\\b") to SearchQuality.HD,
        Regex("\\b(camrip|cam[- ]?rip)\\b") to SearchQuality.CamRip,
        Regex("\\b(hdts|hdcam|hdtc)\\b") to SearchQuality.HdCam,
        Regex("\\b(cam)\\b") to SearchQuality.Cam,
        Regex("\\b(dvd)\\b") to SearchQuality.DVD,
        Regex("\\b(hq)\\b") to SearchQuality.HQ,
        Regex("\\b(rip)\\b") to SearchQuality.CamRip
    )
    for ((regex, quality) in patterns) if (regex.containsMatchIn(text)) return quality

    return SearchQuality.HD
}

suspend fun loadSourceNameExtractor(
    source: String,
    url: String,
    referer: String? = null,
    quality: Int? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    "${link.source} $source",
                    "${link.source} $source",
                    link.url,
                ) {
                    this.quality = quality ?: link.quality
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}

fun safeScoreFrom10(value: Double?): Score? {
    return value?.takeIf { !it.isNaN() && it > 0.0 }?.let {
        Score.from10(it)
    }
}




================================================
FILE: Funmovieslix/build.gradle.kts
================================================
// use an integer for version numbers
version = 3


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Indonesia Source"
    language    = "id"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Funmovieslix.png"

    isCrossPlatform = true
}



================================================
FILE: Funmovieslix/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Funmovieslix/src/main/kotlin/com/Funmovieslix/Extractors.kt
================================================
package com.Funmovieslix

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONObject


class Ryderjet : VidhideExtractor() {
    override var mainUrl = "https://ryderjet.com"
}

class Dhtpre : VidhideExtractor() {
    override var mainUrl = "https://dhtpre.com"
}


class Vidhideplus : VidhideExtractor() {
    override var mainUrl = "https://vidhideplus.com"
}


//Thanks to https://github.com/VVytai/jdownloader_mirror/blob/main/svn_trunk/src/jd/plugins/hoster/LixstreamCom.java
class VideyV2 : ExtractorApi() {
    override var name = "Videy"
    override var mainUrl = "https://videy.tv"
    override val requiresReferer = false

    private val apiBase = "https://api.lixstreamingcaio.com/v2"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val sid = url.substringAfterLast("/")
        Log.d("Phisher", "sid=$sid")

        val infoRes = app.post(
            "$apiBase/s/home/resources/$sid",
            data = mapOf(),
            headers = mapOf("Content-Type" to "application/json")
        ).text

        val info = runCatching { JSONObject(infoRes) }.getOrNull() ?: return
        val suid = info.optString("suid") ?: return
        val files = info.optJSONArray("files") ?: return
        if (files.length() == 0) return
        val file = files.optJSONObject(0) ?: return
        val fid = file.optString("id") ?: return
        val assetRes = app.get("$apiBase/s/assets/f?id=$fid&uid=$suid").text
        val asset = runCatching { JSONObject(assetRes) }.getOrNull() ?: return
        val encryptedUrl = asset.optString("url")
        if (encryptedUrl.isNullOrEmpty()) {
            Log.e("Error:", "No encrypted url found")
            return
        }
        val key = "GNgN1lHXIFCQd8hSEZIeqozKInQTFNXj".toByteArray(Charsets.UTF_8)
        val iv = "2Xk4dLo38c9Z2Q2a".toByteArray(Charsets.UTF_8)
        val cipher = javax.crypto.Cipher.getInstance("AES/CBC/PKCS5Padding")
        cipher.init(
            javax.crypto.Cipher.DECRYPT_MODE,
            javax.crypto.spec.SecretKeySpec(key, "AES"),
            javax.crypto.spec.IvParameterSpec(iv)
        )
        val decrypted = runCatching {
            val decoded = base64DecodeArray(encryptedUrl)
            String(cipher.doFinal(decoded), Charsets.UTF_8)
        }.getOrNull() ?: return
        callback.invoke(
            newExtractorLink(
                this.name,
                this.name,
                decrypted,
                if (decrypted.endsWith(".mp4")) ExtractorLinkType.VIDEO else ExtractorLinkType.M3U8
            )
            {
                this.referer = url
                this.quality = Qualities.P1080.value
            }
        )
    }
}



================================================
FILE: Funmovieslix/src/main/kotlin/com/Funmovieslix/Funmovieslix.kt
================================================
package com.Funmovieslix

import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchQuality
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class Funmovieslix : MainAPI() {
    override var mainUrl = "https://funmovieslix.com"
    override var name = "Funmovieslix"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    override val mainPage = mainPageOf(
        "category/action" to "Action Category",
        "category/science-fiction" to "Sci-Fi Category",
        "category/drama" to "Drama Category",
        "category/kdrama" to "KDrama",
        "category/crime" to "Crime Category",
        "category/fantasy" to "Fantasy Category",
        "category/mystery" to "Mystery Category",
        "category/comedy" to "Comedy Category",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page").documentLarge
        val home = document.select("#gmr-main-load div.movie-card").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("h3").text()
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl = this.select("a img").firstOrNull()?.let { img ->
            val srcSet = img.attr("srcset")
            val bestUrl = if (srcSet.isNotBlank()) {
                srcSet.split(",")
                    .map { it.trim() }
                    .maxByOrNull { it.substringAfterLast(" ").removeSuffix("w").toIntOrNull() ?: 0 }
                    ?.substringBefore(" ")
            } else {
                img.attr("src")
            }

            fixUrlNull(bestUrl?.replace(Regex("-\\d+x\\d+"), ""))
        }
        val searchQuality = getSearchQuality(this)
        val score=this.select("div.rating-stars").text().substringAfter("(").substringBefore(")")
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = searchQuality
            this.score=Score.from10(score)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
            val document = app.get("${mainUrl}?s=$query").documentLarge
            val results =document.select("#gmr-main-load div.movie-card").mapNotNull { it.toSearchResult() }
        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title =document.select("meta[property=og:title]").attr("content").substringBefore("(").substringBefore("-").trim()
        val poster = document.select("meta[property=og:image]").attr("content")
        val description = document.select("div.desc-box p,div.entry-content p").text()
        val actors=document.select("div.cast-grid a").map { it.text() }
        val type = if (url.contains("tv")) TvType.TvSeries else TvType.Movie
        val trailer = document.select("meta[itemprop=embedUrl]").attr("content")
        val genre = document.select("div.gmr-moviedata:contains(Genre) a,span.badge").map { it.text() }
        val year =document.select("div.gmr-moviedata:contains(Year) a").text().toIntOrNull()
        val recommendation = document.select("div.movie-grid div").mapNotNull {
            val recName = it.select("p").text()
            val recHref = it.select("a").attr("href")
            val img = it.selectFirst("img")
            val srcSet = img?.attr("srcset").orEmpty()
            val bestUrl = if (srcSet.isNotBlank()) {
                srcSet.split(",")
                    .map { s -> s.trim() }
                    .maxByOrNull { s -> s.substringAfterLast(" ").removeSuffix("w").toIntOrNull() ?: 0 }
                    ?.substringBefore(" ")
            } else {
                img?.attr("src")
            }
            val recPosterUrl = fixUrlNull(bestUrl?.replace(Regex("-\\d+x\\d+"), ""))
            newMovieSearchResponse(recName, recHref, TvType.Movie) {
                this.posterUrl = recPosterUrl
            }
        }

        return if (type == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            document.select("div.gmr-listseries a").forEach { info ->
                    if (info.text().contains("All episodes", ignoreCase = true)) return@forEach
                    val text=info.text()
                    val season = Regex("S(\\d+)").find(text)?.groupValues?.get(1)?.toIntOrNull()
                    val ep=Regex("Eps(\\d+)").find(text)?.groupValues?.get(1)?.toIntOrNull()
                    val name = "Episode $ep"
                    val href = info.attr("href")
                    episodes.add(
                        newEpisode(href)
                        {
                            this.episode=ep
                            this.name=name
                            this.season=season
                        }
                    )
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genre
                this.year = year
                addTrailer(trailer)
                addActors(actors)
                this.recommendations=recommendation
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genre
                this.year = year
                addTrailer(trailer)
                addActors(actors)
                this.recommendations=recommendation
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge

        // 1. Get all <script> tags that contain "embeds"
        val scriptContent = document.select("script")
            .map { it.data() }
            .firstOrNull { it.contains("const embeds") }
            ?: return false

        val regex = Regex("""https:\\/\\/[^"]+""")
        val urls = regex.findAll(scriptContent)
            .map { it.value.replace("\\/", "/").replace("\\", "") } // unescape \/ → / and remove \
            .toList()
        urls.forEach { url ->
            loadExtractor(url,subtitleCallback,callback)
        }
        return true
    }

    fun getSearchQuality(parent: Element): SearchQuality {
        val qualityText = parent.select("div.quality-badge").text().uppercase()

        return when {
            qualityText.contains("HDTS") -> SearchQuality.HdCam
            qualityText.contains("HDCAM") -> SearchQuality.HdCam
            qualityText.contains("CAM") -> SearchQuality.Cam
            qualityText.contains("HDRIP") -> SearchQuality.WebRip
            qualityText.contains("WEBRIP") -> SearchQuality.WebRip
            qualityText.contains("WEB-DL") -> SearchQuality.WebRip
            qualityText.contains("BLURAY") -> SearchQuality.BlueRay
            qualityText.contains("4K") -> SearchQuality.FourK
            qualityText.contains("HD") -> SearchQuality.HD
            else -> SearchQuality.HD
        }
    }

}




================================================
FILE: Funmovieslix/src/main/kotlin/com/Funmovieslix/FunmovieslixProvider.kt
================================================
package com.Funmovieslix

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.FileMoonIn
import com.lagradost.cloudstream3.extractors.FilemoonV2

@CloudstreamPlugin
class FunmovieslixProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Funmovieslix())
        registerExtractorAPI(Ryderjet())
        registerExtractorAPI(FilemoonV2())
        registerExtractorAPI(Dhtpre())
        registerExtractorAPI(FileMoonIn())
        registerExtractorAPI(Vidhideplus())
        registerExtractorAPI(VideyV2())
    }
}


================================================
FILE: Goojara/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Movies and Series (Mostly 720p)"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://www.google.com/s2/favicons?domain=goojara.to/&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: Goojara/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Goojara/src/main/kotlin/com/Goojara/Extractor.kt
================================================
package com.Goojara

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.APIHolder.getCaptchaToken
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.Vidguardto
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.HlsPlaylistParser
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.FormBody
import org.json.JSONObject
import java.net.URI

class Stre4mpay : VidhideExtractor() {
    override var mainUrl = "https://stre4mpay.one"
}

class Streamplay : ExtractorApi() {
    override val name = "Streamplay"
    override val mainUrl = "https://streamplay.to"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val request = app.get(url, referer = referer)
        val redirectUrl = request.url
        val mainServer = URI(redirectUrl).let {
            "${it.scheme}://${it.host}"
        }
        val key = redirectUrl.substringAfter("embed-").substringBefore(".html")
        val token =
            request.document.select("script").find { it.data().contains("sitekey:") }?.data()
                ?.substringAfterLast("sitekey: '")?.substringBefore("',")?.let { captchaKey ->
                    getCaptchaToken(
                        redirectUrl,
                        captchaKey,
                        referer = "$mainServer/"
                    )
                } ?: throw ErrorLoadingException("can't bypass captcha")
        app.post(
            "$mainServer/player-$key-488x286.html", data = mapOf(
                "op" to "embed",
                "token" to token
            ),
            referer = redirectUrl,
            headers = mapOf(
                "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                "Content-Type" to "application/x-www-form-urlencoded"
            )
        ).document.select("script").find { script ->
            script.data().contains("eval(function(p,a,c,k,e,d)")
        }?.let {
            val data = getAndUnpack(it.data()).substringAfter("sources=[").substringBefore(",desc")
                .replace("file", "\"file\"")
                .replace("label", "\"label\"")
            tryParseJson<List<Source>>("[$data}]")?.map { res ->
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        res.file ?: return@map null,
                        INFER_TYPE
                    )
                    {
                        this.referer ="$mainServer/"
                        this.quality = when (res.label) {
                            "HD" -> Qualities.P720.value
                            "SD" -> Qualities.P480.value
                            else -> Qualities.Unknown.value
                        }
                        this.headers=mapOf(
                            "Range" to "bytes=0-"
                        )
                    }
                )
            }
        }

    }

    data class Source(
        @JsonProperty("file") val file: String? = null,
        @JsonProperty("label") val label: String? = null,
    )

}

class Wootly : ExtractorApi() {
    override var name = "Wootly"
    override var mainUrl = "https://www.wootly.ch"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val iframe = app.get(url).documentLarge.select("iframe").attr("src")
        val body = FormBody.Builder()
            .add("qdfx", "1")
            .build()

        val iframeResp = app.post(iframe, requestBody = body)
        val iframeHtml = iframeResp.textLarge
        val vdRegex = Regex("""var\s+vd\s*=\s*["']([^"']+)["']""")
        val tkRegex = Regex("""tk\s*=\s*["']([^"']+)["']""")
        val vd = vdRegex.find(iframeHtml)?.groupValues?.get(1)
        val tk = tkRegex.find(iframeHtml)?.groupValues?.get(1)

        if (vd.isNullOrBlank() || tk.isNullOrBlank()) {
            return null
        }
        val iframeurl=app.get("https://web.wootly.ch/grabm?t=$tk&id=$vd").text

        return listOf(
            newExtractorLink(
                this.name,
                this.name,
                url = iframeurl,
                type = INFER_TYPE
            ) {
                this.referer = referer ?: ""
                this.quality = Qualities.P720.value
            }
        )
    }
}


================================================
FILE: Goojara/src/main/kotlin/com/Goojara/Goojara.kt
================================================
package com.Goojara

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import okhttp3.FormBody
import org.json.JSONObject
import org.jsoup.nodes.Element
import java.util.regex.Pattern

class Goojara : MainAPI() {
    override var mainUrl              = "https://ww1.goojara.to"
    override var name                 = "Goojara"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = false
    override val supportedTypes       = setOf(TvType.Movie,TvType.TvSeries)

    override val mainPage = mainPageOf(
        "watch-movies-recent" to "Recently Updated Movies",
        "watch-series-recent" to "Recently Updated Series",
        "watch-movies-popular" to "Popular Movies",
        "watch-series-popular" to "Popular Series",
    )

    companion object
    {
        const val TMDBIMAGEBASEURL = "https://image.tmdb.org/t/p/original"
        val headers = mapOf("Cookie" to "aGooz=dg18hh2eittp5e7s53u0e6bloh; 98ef5a07=747ffc60ea65eb361a495f; _997e=CC3E288A8E177D1A15AC79C049BCE3162D678A00; 3d4930c4=6239ad831b7cfd09950432; _2252=8A4FEB904DF45EB188E25A7A89432E0E489A5ADA; 12cd410d=77da7901426e0f0c27e062; _3553=3DB01E776983EE4DACE282E616C9B7B4FB2E2D3D")
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val res = app.get("$mainUrl/${request.data}?p=$page").document
        val home= res.select("#xbrd > div:nth-child(4) a").map {
            it.toSearchResult()
        }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("span.mtl").text()
        val href = this.attr("href")
        val posterUrl = this.select("img").attr("data-src")
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }

    }

    //override suspend fun quickSearch(query: String): List<SearchResponse> = search(query,1).items

    private val DEFAULT_POSTER = "https://thumbs.dreamstime.com/b/cinema-poster-design-template-popcorn-box-disposable-cup-beverages-straw-film-strip-clapper-board-ticket-detailed-44098150.jpg"

    override suspend fun search(query: String, page: Int): SearchResponseList = coroutineScope {
        val url = "$mainUrl/xmre.php"

        val body = FormBody.Builder()
            .add("z", "Mwxxa3Vnaw")
            .add("x", "b3716e05ff")
            .add("q", query)
            .build()


        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
            "Accept" to "*/*",
            "Content-Type" to "application/x-www-form-urlencoded",
            "Referer" to mainUrl,
            "Cookie" to "aGooz=b2orla8fv69k6a7c31knrqkljg"
        )

        val results = app.post(
            url,
            requestBody = body,
            headers = headers
        ).document.select("li a")

        val concurrency = 10
        val sem = Semaphore(concurrency)

        val deferred = results.map { el ->
            async(Dispatchers.IO) {
                sem.withPermit {
                    try {
                        val href = el.attr("href").trim()
                        val title = el.text().trim()

                        val doc = app.get(fixUrl(href), headers = headers).document

                        val poster = doc.selectFirst("div.imrl img")?.attr("src")
                        val finalHref = doc.selectFirst("div.snfo h1 a")?.attr("href") ?: href


                        newMovieSearchResponse(
                            title,
                            fixUrl(finalHref),
                            TvType.Movie
                        ) {
                            this.posterUrl = poster ?: DEFAULT_POSTER
                        }
                    } catch (_: Exception) {
                        null
                    }
                }
            }
        }

        val responses = deferred.awaitAll().filterNotNull()
        return@coroutineScope responses.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val raw = document.selectFirst("div.marl h1")
            ?.text()
            ?.substringBefore("(")
            .orEmpty()

        val seasonRegex = Regex("""(Season\s*\d+|S\d+)""", RegexOption.IGNORE_CASE)
        val match = seasonRegex.find(raw)

        val title = if (match != null) {
            raw.take(match.range.first).trim()
        } else {
            raw.trim()
        }

        val poster = fixUrl(document.select("#poster img").attr("src"))
        val description = document.selectFirst("div.fimm p")?.text()
        val type = if (document.select("#sesh a.ste,#sesh button").isNotEmpty()) TvType.TvSeries else TvType.Movie
        val imdbid = document.selectFirst("#imdb")?.attr("data-ubv")?.substringBefore(",")
        val metatype = if (type == TvType.TvSeries) "series" else "movie"
        val tmdbmetatype = if (type == TvType.TvSeries) "tv" else "movie"

        val metares = app.get("https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta/$metatype/$imdbid.json").textLarge
        val tmdbId: String? = imdbid?.let { id ->
            runCatching {
                val json = app.get(
                    "https://api.themoviedb.org/3/find/$id?api_key=1865f43a0549ca50d341dd9ab8b29f49&external_source=imdb_id"
                ).textLarge

                val obj = JSONObject(json)

                obj.getJSONArray("movie_results")
                    .optJSONObject(0)
                    ?.optInt("id")
                    ?.takeIf { it != 0 }
                    ?.toString()
                    ?: obj.getJSONArray("tv_results")
                        .optJSONObject(0)
                        ?.optInt("id")
                        ?.takeIf { it != 0 }
                        ?.toString()
            }.getOrNull()
        }

        val movieCreditsJsonText = tmdbId?.let { id ->
            runCatching {
                app.get("https://api.themoviedb.org/3/$tmdbmetatype/$id/credits?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US").textLarge
            }.getOrNull()
        }
        val castList = parseCredits(movieCreditsJsonText)

        val metaJson = try {
            JSONObject(metares).optJSONObject("meta")
        } catch (_: Exception) {
            null
        }

        val metaPoster = metaJson?.optString("poster").takeUnless { it.isNullOrBlank() } ?: poster
        val metaBackground = metaJson?.optString("background").takeUnless { it.isNullOrBlank() }
        val metaDescription = metaJson?.optString("description") ?: description
        val metaGenres = metaJson?.optJSONArray("genres")?.let { arr ->
            (0 until arr.length()).mapNotNull { i -> arr.optString(i).takeIf { s -> s.isNotBlank() } }
        } ?: emptyList()

        val epMetaMap: Map<String, JSONObject> = metaJson?.optJSONArray("videos")?.let { vids ->
            val map = mutableMapOf<String, JSONObject>()
            for (i in 0 until vids.length()) {
                val v = vids.optJSONObject(i) ?: continue
                val s = v.optInt("season", -1)
                val e = v.optInt("episode", -1)
                if (s > 0 && e > 0) {
                    map["$s:$e"] = v
                }
            }
            map
        } ?: emptyMap()

        return if (type == TvType.TvSeries) {
            val href = document.select("#sesh a.ste").attr("href")
            val totalSeasons = href.substringAfter("?s=").toIntOrNull() ?: 1
            val episodes = mutableListOf<Episode>()

            for (seasonIndex in 1..totalSeasons) {
                val seasonHref = href.substringBefore("?s=") + "?s=$seasonIndex"
                val seasonDoc = app.get(seasonHref).document
                seasonDoc.select("div.seho")
                    .mapNotNull { input ->
                        val hrefEp = fixUrl(input.select("a").attr("href"))
                        val epnoText = input.select("span.sea").text().substringAfter("0").trim()
                        val epno = epnoText.toIntOrNull()

                        if (hrefEp.isBlank() || epno == null) return@mapNotNull null
                        val metaKey = "$seasonIndex:$epno"
                        val epMeta = epMetaMap[metaKey]
                        val epnameFromPage = input.select("a").text().takeIf { it.isNotBlank() }
                        val epTitle = epMeta?.optString("title")?.takeIf { it.isNotBlank() } ?: epnameFromPage
                        val epPosterFromMeta = epMeta?.optString("thumbnail")?.takeIf { it.isNotBlank() }?.let { fixUrl(it) }
                        val released = epMeta?.optString("released")?.takeIf { it.isNotBlank() }
                        val epOverview = epMeta?.optString("overview")?.takeIf { it.isNotBlank() }
                        episodes+=newEpisode(hrefEp) {
                            this.name = epTitle
                            this.season = seasonIndex
                            this.episode = epno
                            this.description = epOverview
                            if (epPosterFromMeta != null) this.posterUrl = epPosterFromMeta
                            addDate(released)
                        }
                    }
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = metaPoster
                this.plot = metaDescription
                if (metaGenres.isNotEmpty()) this.tags = metaGenres
                addImdbId(imdbid)
                this.backgroundPosterUrl = metaBackground
                this.actors = castList
            }
        } else newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl = metaPoster
            this.plot = metaDescription
            if (metaGenres.isNotEmpty()) this.tags = metaGenres
            addImdbId(imdbid)
            this.backgroundPosterUrl = metaBackground
            this.actors = castList

        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val initialResp = app.get(data, mapOf("Referer" to "https://www.goojara.to", "Cookie" to ""))
        val doc = initialResp.documentLarge
        val bodyHtml = doc.outerHtml()
        val setCookieHeader = initialResp.headers["Set-Cookie"] ?: initialResp.headers["set-cookie"] ?: ""
        val cookieMap = parseSetCookieHeaders(listOf(setCookieHeader))
        val randomPair = extract3chkPair(bodyHtml)
        val cookieHeader = buildCookieHeader(cookieMap["aGooz"], randomPair)
        doc.select("#drl a").forEach { element ->
            val href = element.attr("href")
            if (href.isEmpty()) return@forEach
            try {
                val redirectResp = app.get(href, mapOf("Referer" to "https://ww1.goojara.to", "Cookie" to cookieHeader), allowRedirects = false)
                val iframe = redirectResp.headers["location"] ?: redirectResp.headers["Location"] ?: return@forEach
                Log.d("Phisher", iframe)
                loadSourceNameExtractor("", iframe, "", Qualities.P720.value, subtitleCallback, callback)
            } catch (e: Exception) {
                Log.w("Phisher", "failed to fetch embed redirect: ${e.message}")
            }
        }
        return true
    }

    /** Parse multiple Set-Cookie header strings into a name->value map. */
    private fun parseSetCookieHeaders(headers: List<String>): Map<String, String> {
        val map = mutableMapOf<String, String>()
        val cookiePattern = Pattern.compile("^\\s*([^=;\\s]+)=([^;\\r\\n]*)")
        headers.filter { it.isNotBlank() }.forEach { h ->
            val matcher = cookiePattern.matcher(h)
            if (matcher.find()) {
                val name = matcher.group(1)
                val value = matcher.group(2)
                if (!name.isNullOrEmpty() && value != null) map[name] = value
            }
        }
        return map
    }

    /** Extract pair from _3chk('name','value') */
    private fun extract3chkPair(body: String): Pair<String, String>? {
        val p = Pattern.compile("_3chk\\(\\s*'([^']+)'\\s*,\\s*'([^']+)'")
        val m = p.matcher(body)
        return if (m.find()) Pair(m.group(1), m.group(2)) else null
    }

    /** Build Cookie header combining aGooz and the random cookie. Returns empty string if none. */
    private fun buildCookieHeader(aGooz: String?, random: Pair<String, String>?): String {
        val parts = mutableListOf<String>()
        if (!aGooz.isNullOrEmpty()) parts += "aGooz=$aGooz"
        if (random != null) parts += "${random.first}=${random.second}"
        return parts.joinToString("; ")
    }

    fun parseCredits(jsonText: String?): List<ActorData> {
        if (jsonText.isNullOrBlank()) return emptyList()
        val list = ArrayList<ActorData>()
        val root = JSONObject(jsonText)
        val castArr = root.optJSONArray("cast") ?: return list
        for (i in 0 until castArr.length()) {
            val c = castArr.optJSONObject(i) ?: continue
            val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
            val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { "$TMDBIMAGEBASEURL$it" }
            val character = c.optString("character").takeIf { it.isNotBlank() }
            val actor = Actor(name, profile)
            list += ActorData(actor, roleString = character)
        }
        return list
    }

    suspend fun loadSourceNameExtractor(
        source: String,
        url: String,
        referer: String? = null,
        quality: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        "${link.source} $source",
                        "${link.source} $source",
                        link.url,
                    ) {
                        this.quality = quality ?: link.quality
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }
}



================================================
FILE: Goojara/src/main/kotlin/com/Goojara/GoojaraProvider.kt
================================================
package com.Goojara

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class GoojaraProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Goojara())
        registerExtractorAPI(Wootly())
        registerExtractorAPI(Stre4mpay())
        registerExtractorAPI(Streamplay())
    }
}


================================================
FILE: Goojara/src/main/kotlin/com/Goojara/Parser.kt
================================================
package com.Coflix

import com.fasterxml.jackson.annotation.JsonProperty


data class Response(
    val res: String,
    val results: List<Result>,
    val next: Boolean,
    val page: String,
    val total: Long,
    val genres: String,
    val years: String,
    val sort: String,
)

data class Result(
    val uuid: Long,
    val name: String,
    val ranking: Any?,
    val url: String,
    val path: String,
    val ts: String,
    val release: String,
    val director: String,
    val casts: String,
    val slug: String,
    val excerpt: String,
)


data class EpRes(
    @JsonProperty("post_id")
    val postId: String,
    val title: String,
    val episodes: List<Episode>,
)

data class Episode(
    val id: Long,
    val title: String,
    val number: String,
    val season: String,
    val links: String,
    val image: String,
)

typealias Search = List<Search2>

data class Search2(
    @JsonProperty("ID")
    val id: Long,
    val title: String,
    val excerpt: String,
    val url: String,
    @JsonProperty("post_type")
    val postType: String,
    val year: String,
    val rating: String,
    val image: String,
    val director: String,
    val cast: String?,
)



================================================
FILE: gradle/wrapper/gradle-wrapper.properties
================================================
#Sat Oct 18 15:10:15 IST 2025
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.13-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



================================================
FILE: HDhub4u/build.gradle.kts
================================================
// use an integer for version numbers
version = 43


cloudstream {
    //description = "Movie website in Bangladesh"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    tvTypes = listOf(
        "Movie",
        "TvSeries",
        "Anime"
    )
    language = "hi"
//  https://t0.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://hdhub4u.gratis&size=64
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/HDHUB.png"

    isCrossPlatform = false
}



================================================
FILE: HDhub4u/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest/>


================================================
FILE: HDhub4u/src/main/kotlin/com/hdhub4u/Extractors.kt
================================================
package com.hdhub4u

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.PixelDrain
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.fixUrl
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.runBlocking
import java.net.URI
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class HdStream4u : VidHidePro() {
    override var mainUrl = "https://hdstream4u.com"
}

open class VidStack : ExtractorApi() {
    override var name = "Vidstack"
    override var mainUrl = "https://vidstack.io"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    )
    {
        val headers = mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0")
        val hash = url.substringAfterLast("#").substringAfter("/")
        val baseurl = getBaseUrl(url)

        val encoded = app.get("$baseurl/api/v1/video?id=$hash", headers = headers).text.trim()

        val key = "kiemtienmua911ca"
        val ivList = listOf("1234567890oiuytr", "0123456789abcdef")

        val decryptedText = ivList.firstNotNullOfOrNull { iv ->
            try {
                AesHelper.decryptAES(encoded, key, iv)
            } catch (_: Exception) {
                null
            }
        } ?: throw Exception("Failed to decrypt with all IVs")

        val m3u8 = Regex("\"source\":\"(.*?)\"").find(decryptedText)
            ?.groupValues?.get(1)
            ?.replace("\\/", "/") ?: ""
        val subtitlePattern = Regex("\"([^\"]+)\":\\s*\"([^\"]+)\"")
        val subtitleSection = Regex("\"subtitle\":\\{(.*?)\\}").find(decryptedText)?.groupValues?.get(1)

        subtitleSection?.let { section ->
            subtitlePattern.findAll(section).forEach { match ->
                val lang = match.groupValues[1]
                val rawPath = match.groupValues[2].split("#")[0]
                if (rawPath.isNotEmpty()) {
                    val path = rawPath.replace("\\/", "/")
                    val subUrl = "$mainUrl$path"
                    subtitleCallback(newSubtitleFile(lang, fixUrl(subUrl)))
                }
            }
        }


        callback.invoke(
            newExtractorLink(
                source = this.name,
                name = this.name,
                url = m3u8.replace("https","http"),
                type = ExtractorLinkType.M3U8
            ) {
                this.referer = url
                this.headers = mapOf("referer" to url,"Origin" to url.substringAfterLast("/"))
                this.quality = Qualities.Unknown.value
            }
        )

    }

    private fun getBaseUrl(url: String): String {
        return try {
            URI(url).let { "${it.scheme}://${it.host}" }
        } catch (e: Exception) {
            Log.e("Vidstack", "getBaseUrl fallback: ${e.message}")
            mainUrl
        }
    }
}

object AesHelper {
    private const val TRANSFORMATION = "AES/CBC/PKCS5PADDING"

    fun decryptAES(inputHex: String, key: String, iv: String): String {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        val secretKey = SecretKeySpec(key.toByteArray(Charsets.UTF_8), "AES")
        val ivSpec = IvParameterSpec(iv.toByteArray(Charsets.UTF_8))

        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
        val decryptedBytes = cipher.doFinal(inputHex.hexToByteArray())
        return String(decryptedBytes, Charsets.UTF_8)
    }

    private fun String.hexToByteArray(): ByteArray {
        check(length % 2 == 0) { "Hex string must have an even length" }
        return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }
}

class Hubstream : VidStack() {
    override var mainUrl = "https://hubstream.*"
}

class Hubstreamdad : Hblinks() {
    override var mainUrl = "https://hblinks.*"
}

open class Hblinks : ExtractorApi() {
    override val name = "Hblinks"
    override val mainUrl = "https://hblinks.*"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        app.get(url).documentLarge.select("h3 a,h5 a,div.entry-content p a").map {
            val lower = it.absUrl("href").ifBlank { it.attr("href") }
            val href = lower.lowercase()
            when {
                "hubdrive" in lower -> Hubdrive().getUrl(href, name, subtitleCallback, callback)
                "hubcloud" in lower -> HubCloud().getUrl(href, name, subtitleCallback, callback)
                "hubcdn" in lower -> HUBCDN().getUrl(href, name, subtitleCallback, callback)
                else -> loadSourceNameExtractor(name, href, "", Qualities.Unknown.value,subtitleCallback, callback)
            }
        }
    }
}

class Hubcdnn : ExtractorApi() {
    override val name = "Hubcdn"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        app.get(url).documentLarge.toString().let {
            val encoded = Regex("r=([A-Za-z0-9+/=]+)").find(it)?.groups?.get(1)?.value
            if (!encoded.isNullOrEmpty()) {
                val m3u8 = base64Decode(encoded).substringAfterLast("link=")
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = m3u8,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = url
                        this.quality = Qualities.Unknown.value
                    }
                )
            } else {
                Log.e("Error", "Encoded URL not found")
            }


        }
    }
}

class PixelDrainDev : PixelDrain(){
    override var mainUrl = "https://pixeldrain.dev"
}

class Hubdrive : ExtractorApi() {
    override val name = "Hubdrive"
    override val mainUrl = "https://hubdrive.space"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val href=app.get(url, timeout = 5000L).documentLarge.select(".btn.btn-primary.btn-user.btn-success1.m-1").attr("href")
        if (href.contains("hubcloud",ignoreCase = true)) HubCloud().getUrl(href,"HubDrive",subtitleCallback,callback)
        else loadExtractor(href,"HubDrive",subtitleCallback, callback)
    }
}

class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override var mainUrl: String = runBlocking {
        HDhub4uPlugin.getDomains()?.hubcloud ?: "https://hubcloud.foo"
    }
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()
            Log.d("Phisher",label)
            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }
                 */
                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }

}



class HUBCDN : ExtractorApi() {
    override val name = "HUBCDN"
    override val mainUrl = "https://hubcdn.*"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc = app.get(url).documentLarge
        val scriptText = doc.selectFirst("script:containsData(var reurl)")?.data()

        val encodedUrl = Regex("reurl\\s*=\\s*\"([^\"]+)\"")
            .find(scriptText ?: "")
            ?.groupValues?.get(1)
            ?.substringAfter("?r=")

        val decodedUrl = encodedUrl?.let { base64Decode(it) }?.substringAfterLast("link=")


        if (decodedUrl != null) {
            callback(
                newExtractorLink(
                    this.name,
                    this.name,
                    decodedUrl,
                    INFER_TYPE,
                )
                {
                    this.quality=Qualities.Unknown.value
                }
            )
        }
    }
}




================================================
FILE: HDhub4u/src/main/kotlin/com/hdhub4u/HDhub4uPlugin.kt
================================================
package com.hdhub4u

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.extractors.StreamTape
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.app


@CloudstreamPlugin
class HDhub4uPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(HDhub4uProvider())
        registerExtractorAPI(HdStream4u())
        registerExtractorAPI(StreamTape())
        registerExtractorAPI(Hblinks())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(Hubstream())
        registerExtractorAPI(Hubcdnn())
        registerExtractorAPI(Hubdrive())
        registerExtractorAPI(Hubstreamdad())
        registerExtractorAPI(HUBCDN())
        registerExtractorAPI(PixelDrainDev())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("hubcloud")
            val hubcloud: String,
            @JsonProperty("HDHUB4u")
            val HDHUB4u: String,
        )
    }
}


================================================
FILE: HDhub4u/src/main/kotlin/com/hdhub4u/HDhub4uProvider.kt
================================================
package com.hdhub4u

import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchQuality
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import kotlinx.coroutines.runBlocking
import org.json.JSONObject
import org.jsoup.nodes.Element
import org.jsoup.select.Elements
import java.text.Normalizer


class HDhub4uProvider : MainAPI() {
    override var mainUrl: String = runBlocking {
        HDhub4uPlugin.getDomains()?.HDHUB4u ?: "https://hdhub4u.rehab"
    }
    override var name = "HDHub4U"
    override var lang = "hi"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val hasQuickSearch = false
    override val supportedTypes = setOf(
        TvType.Movie, TvType.TvSeries ,TvType.Anime
    )
    companion object
    {
        const val TMDBAPIKEY = "1865f43a0549ca50d341dd9ab8b29f49"
        const val TMDBBASE = "https://image.tmdb.org/t/p/original"
        const val TMDBAPI = "https://wild-surf-4a0d.phisher1.workers.dev"
        const val TAG = "EpisodeParser"
    }

    override val mainPage = mainPageOf(
        "" to "Latest",
        "category/bollywood-movies/" to "Bollywood",
        "category/hollywood-movies/" to "Hollywood",
        "category/hindi-dubbed/" to "Hindi Dubbed",
        "category/south-hindi-movies/" to "South Hindi Dubbed",
        "category/category/web-series/" to "Web Series",
        "category/adult/" to "Adult",
    )
    private val headers = mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36 Edg/131.0.0.0","Cookie" to "xla=s4t")

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val doc = app.get(
            "$mainUrl/${request.data}page/$page/",
            cacheTime = 60,
            headers = headers,
            allowRedirects = true
        ).documentLarge
        val home = doc.select(".recent-movies > li.thumb").mapNotNull { toResult(it) }
        return newHomePageResponse(request.name, home, true)
    }

    private fun toResult(post: Element): SearchResponse {
        val titleText = post
            .select("figcaption:nth-child(2) > a:nth-child(1) > p:nth-child(1)")
            .text()
        val title = cleanTitle(titleText)
        val url = post.select("figure:nth-child(1) > a:nth-child(2)").attr("href")
        return newMovieSearchResponse(title, url, TvType.Movie) {
            this.posterUrl = post.select("figure:nth-child(1) > img:nth-child(1)").attr("src")
            this.quality = getSearchQuality(titleText)
        }
    }

    private fun Document.toSearchResult(): SearchResponse {
        return newMovieSearchResponse(
            name = postTitle,
            url = permalink,
            type = TvType.Movie
        ) {
            posterUrl = postThumbnail
        }
    }


    override suspend fun search(query: String, page: Int): SearchResponseList {
        val response = app.get(
            "https://search.pingora.fyi/collections/post/documents/search" +
                    "?q=$query" +
                    "&query_by=post_title,category" +
                    "&query_by_weights=4,2" +
                    "&sort_by=sort_by_date:desc" +
                    "&limit=15" +
                    "&highlight_fields=none" +
                    "&use_cache=true" +
                    "&page=$page",
            headers = headers,
            referer = mainUrl
        ).parsedSafe<Search>()

        return response?.hits!!.map { hit -> hit.document.toSearchResult() }.toNewSearchResponseList()
    }


    private fun extractLinksATags(aTags: Elements): List<String> {
        val allowedDomains = Regex("""https://(.*\.)?(hdstream4u|hubstream)\..*""")

        return aTags
            .mapNotNull { it.attr("href") }
            .filter { allowedDomains.containsMatchIn(it) }
            .distinct()
    }



    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url, cacheTime = 60, headers = headers).documentLarge
        var title = doc.select(
            ".page-body h2[data-ved=\"2ahUKEwjL0NrBk4vnAhWlH7cAHRCeAlwQ3B0oATAfegQIFBAM\"], " +
                    "h2[data-ved=\"2ahUKEwiP0pGdlermAhUFYVAKHV8tAmgQ3B0oATAZegQIDhAM\"]"
        ).text()
        val seasontitle = title
        val seasonNumber = Regex("(?i)\\bSeason\\s*(\\d+)\\b").find(seasontitle)?.groupValues?.get(1)?.toIntOrNull()

        val image = doc.select("meta[property=og:image]").attr("content")
        val plot = doc.selectFirst(".kno-rdesc .kno-rdesc")?.text()
        val tags = doc.select(".page-meta em").eachText().toMutableList()
        val poster = doc.select("main.page-body img.aligncenter").attr("src")
        val trailer = doc.selectFirst(".responsive-embed-container > iframe:nth-child(1)")?.attr("src")
            ?.replace("/embed/", "/watch?v=")

        val typeraw = doc.select("h1.page-title span").text()
        val tvtype = if (typeraw.contains("movie", ignoreCase = true)) TvType.Movie else TvType.TvSeries
        val isMovie = tvtype == TvType.Movie

        var actorData: List<ActorData> = emptyList()
        var genre: List<String>? = null
        var year = ""
        var background: String = image
        var description: String? = null

        val imdbUrl = doc.select("div span a[href*='imdb.com']").attr("href")
            .ifEmpty {
                val tmdbHref = doc.select("div span a[href*='themoviedb.org']").attr("href")
                val isTv = tmdbHref.contains("/tv/")
                val tmdbId = tmdbHref.substringAfterLast("/").substringBefore("-").substringBefore("?")

                if (tmdbId.isNotEmpty()) {
                    val type = if (isTv) "tv" else "movie"
                    val imdbId = app.get(
                        "$TMDBAPI/$type/$tmdbId/external_ids?api_key=$TMDBAPIKEY"
                    ).parsedSafe<IMDB>()?.imdbId
                    imdbId ?: ""
                } else {
                    ""
                }
            }

        var tmdbIdResolved = ""
        run {
            val tmdbHref = doc.select("div span a[href*='themoviedb.org']").attr("href")
            if (tmdbHref.isNotBlank()) {
                tmdbIdResolved = tmdbHref.substringAfterLast("/").substringBefore("-").substringBefore("?")
            }
        }

        if (tmdbIdResolved.isBlank() && imdbUrl.isNotBlank()) {
            val imdbIdOnly = imdbUrl.substringAfter("title/").substringBefore("/")

            try {
                val findJson = JSONObject(
                    app.get(
                        "$TMDBAPI/find/$imdbIdOnly" +
                                "?api_key=$TMDBAPIKEY&external_source=imdb_id"
                    ).text
                )

                tmdbIdResolved = if (isMovie) {
                    findJson
                        .optJSONArray("movie_results")
                        ?.optJSONObject(0)
                        ?.optInt("id")
                        ?.toString()
                        .orEmpty()
                } else {
                    findJson
                        .optJSONArray("tv_results")
                        ?.optJSONObject(0)
                        ?.optInt("id")
                        ?.toString()
                        .orEmpty()
                }
            } catch (_: Exception) {
                // ignore resolve errors
            }
        }



        val responseData: ResponseDataLocal? = if (tmdbIdResolved.isBlank()) null else runCatching {

            val type = if (tvtype == TvType.TvSeries) "tv" else "movie"
            val detailsText = app.get(
                "$TMDBAPI/$type/$tmdbIdResolved?api_key=$TMDBAPIKEY&append_to_response=credits,external_ids"
            ).text
            val detailsJson = if (detailsText.isNotBlank()) JSONObject(detailsText) else JSONObject()

            var metaName = detailsJson.optString("name")
                .takeIf { it.isNotBlank() }
                ?: detailsJson.optString("title").takeIf { it.isNotBlank() }
                ?: title

            if (seasonNumber != null && !metaName.contains("Season $seasonNumber", ignoreCase = true)) {
                metaName = "$metaName (Season $seasonNumber)"
            }

            val metaDesc = detailsJson.optString("overview").takeIf { it.isNotBlank() } ?: plot

            val yearRaw = detailsJson.optString("release_date").ifBlank { detailsJson.optString("first_air_date") }
            val metaYear = yearRaw.takeIf { it.isNotBlank() }?.take(4)
            val metaRating = detailsJson.optString("vote_average")

            val metaBackground = detailsJson.optString("backdrop_path")
                .takeIf { it.isNotBlank() }?.let { TMDBBASE + it } ?: image

            val imdbid = detailsJson
                .optJSONObject("external_ids")
                ?.optString("imdb_id")
                ?.takeIf { it.isNotBlank() }

            val logoPath = imdbid?.let {
                "https://live.metahub.space/logo/medium/$it/img"
            }
            val actorDataList = mutableListOf<ActorData>()

            //cast
            detailsJson.optJSONObject("credits")?.optJSONArray("cast")?.let { castArr ->
                for (i in 0 until castArr.length()) {
                    val c = castArr.optJSONObject(i) ?: continue
                    val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
                    val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { TMDBBASE + it }
                    val character = c.optString("character").takeIf { it.isNotBlank() }
                    val actor = Actor(name, profile)
                    actorDataList += ActorData(actor = actor, roleString = character)
                }
            }

            // genres
            val metaGenres = mutableListOf<String>()
            detailsJson.optJSONArray("genres")?.let { arr ->
                for (i in 0 until arr.length()) {
                    arr.optJSONObject(i)?.optString("name")?.takeIf { it.isNotBlank() }?.let(metaGenres::add)
                }
            }

            // episodes for TV season -> videos
            val videos = mutableListOf<VideoLocal>()
            if (tvtype == TvType.TvSeries && seasonNumber != null) {
                try {
                    val seasonText = app.get("$TMDBAPI/tv/$tmdbIdResolved/season/$seasonNumber?api_key=$TMDBAPIKEY").text
                    if (seasonText.isNotBlank()) {
                        val seasonJson = JSONObject(seasonText)
                        seasonJson.optJSONArray("episodes")?.let { epArr ->
                            for (i in 0 until epArr.length()) {
                                val ep = epArr.optJSONObject(i) ?: continue
                                val epNum = ep.optInt("episode_number")
                                val epName = ep.optString("name")
                                val epDesc = ep.optString("overview")
                                val epThumb = ep.optString("still_path").takeIf { it.isNotBlank() }?.let { TMDBBASE + it }
                                val epAir = ep.optString("air_date")
                                val epRating = ep.optString("vote_average").let { Score.from10(it.toString()) }

                                videos.add(
                                    VideoLocal(
                                        title = epName,
                                        season = seasonNumber,
                                        episode = epNum,
                                        overview = epDesc,
                                        thumbnail = epThumb,
                                        released = epAir,
                                        rating = epRating,
                                    )
                                )
                            }
                        }
                    }
                } catch (_: Exception) {
                    // ignore season fetch errors
                }
            }

            ResponseDataLocal(
                MetaLocal(
                    name = metaName,
                    description = metaDesc,
                    actorsData = actorDataList.ifEmpty { null },
                    year = metaYear,
                    background = metaBackground,
                    genres = metaGenres.ifEmpty { null },
                    videos = videos.ifEmpty { null },
                    rating = Score.from10(metaRating),
                    logo = logoPath
                )
            )
        }.getOrNull()

        if (responseData != null) {
            description = responseData.meta?.description ?: plot
            actorData = responseData.meta?.actorsData ?: emptyList()
            title = responseData.meta?.name ?: title
            year = responseData.meta?.year ?: ""
            background = responseData.meta?.background ?: image
            responseData.meta?.genres?.let { g ->
                genre = g
                for (gn in g) if (!tags.contains(gn)) tags.add(gn)
            }
            responseData.meta?.rating
        }

        if (tvtype == TvType.Movie) {
            val movieList = mutableListOf<String>()
            movieList.addAll(
                doc.select("h3 a:matches(480|720|1080|2160|4K), h4 a:matches(480|720|1080|2160|4K)")
                    .map { it.attr("href") } + extractLinksATags(doc.select(".page-body > div a"))
            )

            return newMovieLoadResponse(title, url, TvType.Movie, movieList) {
                this.backgroundPosterUrl = background
                try { this.logoUrl = responseData?.meta?.logo } catch(_:Throwable){}
                this.posterUrl = poster
                this.year = year.toIntOrNull()
                this.plot = description ?: plot
                this.tags = genre ?: tags
                this.actors = actorData
                this.score = responseData?.meta?.rating
                addTrailer(trailer)
                addImdbUrl(imdbUrl)
            }
        } else {
            val episodesData = mutableListOf<Episode>()
            val epLinksMap = mutableMapOf<Int, MutableList<String>>()
            val episodeRegex = Regex("EPiSODE\\s*(\\d+)", RegexOption.IGNORE_CASE)

            doc.select("h3, h4").forEach { element ->
                val episodeNumberFromTitle = episodeRegex.find(element.text())?.groupValues?.get(1)?.toIntOrNull()
                val baseLinks = element.select("a[href]").mapNotNull { it -> it.attr("href").takeIf { it.isNotBlank() } }

                val isDirectLinkBlock = element.select("a").any {
                    it.text().contains(Regex("1080|720|4K|2160", RegexOption.IGNORE_CASE))
                }
                val allEpisodeLinks = mutableSetOf<String>()

                if (isDirectLinkBlock) {
                    baseLinks.forEach { url ->
                        try {
                            val resolvedUrl = getRedirectLinks(url.trim())
                            val episodeDoc = app.get(resolvedUrl).documentLarge

                            episodeDoc.select("h5 a").forEach { linkElement ->
                                val text = linkElement.text()
                                val link = linkElement.attr("href").takeIf { it.isNotBlank() } ?: return@forEach
                                val epNum = Regex("Episode\\s*(\\d+)", RegexOption.IGNORE_CASE).find(text)?.groupValues?.get(1)?.toIntOrNull()

                                if (epNum != null) {
                                    epLinksMap.getOrPut(epNum) { mutableListOf() }.add(link)
                                } else {
                                    Log.w(TAG, "Could not parse episode number from: $text")
                                }
                            }
                        } catch (_: Exception) {
                            Log.e(TAG, "Error resolving direct link for URL: $url")
                        }
                    }
                } else if (episodeNumberFromTitle != null) {
                    if (element.tagName() == "h4") {
                        var nextElement = element.nextElementSibling()
                        while (nextElement != null && nextElement.tagName() != "hr") {
                            val siblingLinks = nextElement.select("a[href]").mapNotNull { it -> it.attr("href").takeIf { it.isNotBlank() } }
                            allEpisodeLinks.addAll(siblingLinks)
                            nextElement = nextElement.nextElementSibling()
                        }
                    }

                    if (baseLinks.isNotEmpty()) {
                        allEpisodeLinks.addAll(baseLinks)
                    }

                    if (allEpisodeLinks.isNotEmpty()) {
                        Log.d(TAG, "Adding links for episode $episodeNumberFromTitle: ${allEpisodeLinks.distinct()}")
                        epLinksMap.getOrPut(episodeNumberFromTitle) { mutableListOf() }.addAll(allEpisodeLinks.distinct())
                    }
                }
            }

            epLinksMap.forEach { (epNum, links) ->
                val info = responseData?.meta?.videos?.find { it.season == seasonNumber && it.episode == epNum }

                episodesData.add(
                    newEpisode(links) {
                        this.name = info?.title ?: "Episode $epNum"
                        this.season = seasonNumber
                        this.episode = epNum
                        this.posterUrl = info?.thumbnail
                        this.description = info?.overview
                        this.score = info?.rating
                        addDate(info?.released)
                    }
                )
            }

            return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodesData) {
                this.backgroundPosterUrl = background
                try { this.logoUrl = responseData?.meta?.logo } catch(_:Throwable){}
                this.posterUrl = poster
                this.year = year.toIntOrNull()
                this.plot = description ?: plot
                this.tags = genre ?: tags
                this.actors = actorData
                this.score = responseData?.meta?.rating
                addTrailer(trailer)
                addImdbUrl(imdbUrl)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val linksList: List<String> = data.removePrefix("[").removeSuffix("]").replace("\"", "").split(',', ' ').map { it.trim() }.filter { it.isNotBlank() }
        for (link in linksList) {
            try {
                val finalLink = if ("?id=" in link) {
                    getRedirectLinks(link)
                } else {
                    link
                }
                if (finalLink.contains("Hubdrive",ignoreCase = true))
                {
                    Hubdrive().getUrl(finalLink,"", subtitleCallback,callback)
                } else loadExtractor(finalLink, subtitleCallback, callback)
            } catch (e: Exception) {
                Log.e("Phisher", "Failed to process $link: ${e.message}")
            }
        }
        return true
    }



    /**
     * Determines the search quality based on the presence of specific keywords in the input string.
     *
     * @param check The string to check for keywords.
     * @return The corresponding `SearchQuality` enum value, or `null` if no match is found.
     */
    fun getSearchQuality(check: String?): SearchQuality? {
        val s = check ?: return null
        val u = Normalizer.normalize(s, Normalizer.Form.NFKC).lowercase()
        val patterns = listOf(
            Regex("\\b(4k|ds4k|uhd|2160p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.FourK,

            // CAM / THEATRE SOURCES FIRST
            Regex("\\b(hdts|hdcam|hdtc)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HdCam,
            Regex("\\b(camrip|cam[- ]?rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip,
            Regex("\\b(cam)\\b", RegexOption.IGNORE_CASE) to SearchQuality.Cam,

            // WEB / RIP
            Regex("\\b(web[- ]?dl|webrip|webdl)\\b", RegexOption.IGNORE_CASE) to SearchQuality.WebRip,

            // BLURAY
            Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,

            // RESOLUTIONS
            Regex("\\b(1440p|qhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,
            Regex("\\b(1080p|fullhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,
            Regex("\\b(720p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.SD,

            // GENERIC HD LAST
            Regex("\\b(hdrip|hdtv)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,

            Regex("\\b(dvd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.DVD,
            Regex("\\b(hq)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HQ,
            Regex("\\b(rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip
        )


        for ((regex, quality) in patterns) if (regex.containsMatchIn(u)) return quality
        return null
    }
}


================================================
FILE: HDhub4u/src/main/kotlin/com/hdhub4u/Utils.kt
================================================
package com.hdhub4u

import android.annotation.SuppressLint
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName
import com.lagradost.api.Log
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.json.JSONObject


suspend fun getRedirectLinks(url: String): String {
    val doc = app.get(url).toString()
    val regex = "s\\('o','([A-Za-z0-9+/=]+)'|ck\\('_wp_http_\\d+','([^']+)'".toRegex()
    val combinedString = buildString {
        regex.findAll(doc).forEach { matchResult ->
            val extractedValue = matchResult.groups[1]?.value ?: matchResult.groups[2]?.value
            if (!extractedValue.isNullOrEmpty()) append(extractedValue)
        }
    }
    return try {
        val decodedString = base64Decode(pen(base64Decode(base64Decode(combinedString))))
        val jsonObject = JSONObject(decodedString)
        val encodedurl = base64Decode(jsonObject.optString("o", "")).trim()
        val data = encode(jsonObject.optString("data", "")).trim()
        val wphttp1 = jsonObject.optString("blog_url", "").trim()
        val directlink = runCatching {
            app.get("$wphttp1?re=$data".trim()).documentLarge.select("body").text().trim()
        }.getOrDefault("").trim()

        encodedurl.ifEmpty { directlink }
    } catch (e: Exception) {
        Log.e("Error:", "Error processing links $e")
        "" // Return an empty string on failure
    }
}


@SuppressLint("NewApi")
fun encode(value: String): String {
    return String(android.util.Base64.decode(value, android.util.Base64.DEFAULT))
}

fun pen(value: String): String {
    return value.map {
        when (it) {
            in 'A'..'Z' -> ((it - 'A' + 13) % 26 + 'A'.code).toChar()
            in 'a'..'z' -> ((it - 'a' + 13) % 26 + 'a'.code).toChar()
            else -> it
        }
    }.joinToString("")
}

suspend fun loadSourceNameExtractor(
    source: String,
    url: String,
    referer: String? = null,
    quality: Int? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    "${link.source} $source",
                    "${link.source} $source",
                    link.url,
                ) {
                    this.quality = quality ?: link.quality
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}

data class IMDB(
    @SerializedName("imdb_id")
    val imdbId: String? = null
)

fun cleanTitle(raw: String): String {
    val name = raw.substringBefore("(").trim()
        .replace(Regex("""\s+"""), " ") // collapse extra spaces
        .replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }

    val seasonRegex = Regex("""Season\s*\d+""", RegexOption.IGNORE_CASE)
    val yearRegex = Regex("""\b(19|20)\d{2}\b""")

    val season = seasonRegex.find(raw)?.value?.replaceFirstChar { it.uppercase() }
    val year = yearRegex.find(raw)?.value

    val parts = mutableListOf<String>()
    if (season != null) parts += season
    if (year != null) parts += year

    return if (parts.isEmpty()) {
        name
    } else {
        name + parts.joinToString("") { " ($it)" }
    }
}


data class ResponseDataLocal(val meta: MetaLocal?)

data class MetaLocal(
    val name: String? = null,
    val description: String? = null,
    val actorsData: List<ActorData>? = null,
    val year: String? = null,
    val background: String? = null,
    val genres: List<String>? = null,
    val videos: List<VideoLocal>? = null,
    val rating: Score?,
    val logo: String?
)
data class VideoLocal(
    val title: String? = null,
    val season: Int? = null,
    val episode: Int? = null,
    val overview: String? = null,
    val thumbnail: String? = null,
    val released: String? = null,
    val rating: Score?
)

data class Search(
    @JsonProperty("facet_counts")
    val facetCounts: List<Any?>,
    val found: Long,
    val hits: List<Hit>,
    @JsonProperty("out_of")
    val outOf: Long,
    val page: Long,
    @JsonProperty("request_params")
    val requestParams: RequestParams,
    @JsonProperty("search_cutoff")
    val searchCutoff: Boolean,
    @JsonProperty("search_time_ms")
    val searchTimeMs: Long,
)

data class Hit(
    val document: Document,
    val highlight: Map<String, Any>,
    val highlights: List<Any?>,
    @JsonProperty("text_match")
    val textMatch: Long,
    @JsonProperty("text_match_info")
    val textMatchInfo: TextMatchInfo,
)

data class Document(
    val category: List<String>,
    val id: String,
    val permalink: String,
    @JsonProperty("post_date")
    val postDate: String,
    @JsonProperty("post_thumbnail")
    val postThumbnail: String,
    @JsonProperty("post_title")
    val postTitle: String,
    @JsonProperty("post_type")
    val postType: String,
    @JsonProperty("sort_by_date")
    val sortByDate: Long,
)

data class TextMatchInfo(
    @JsonProperty("best_field_score")
    val bestFieldScore: String,
    @JsonProperty("best_field_weight")
    val bestFieldWeight: Long,
    @JsonProperty("fields_matched")
    val fieldsMatched: Long,
    @JsonProperty("num_tokens_dropped")
    val numTokensDropped: Long,
    val score: String,
    @JsonProperty("tokens_matched")
    val tokensMatched: Long,
    @JsonProperty("typo_prefix_score")
    val typoPrefixScore: Long,
)

data class RequestParams(
    @JsonProperty("collection_name")
    val collectionName: String,
    @JsonProperty("first_q")
    val firstQ: String,
    @JsonProperty("per_page")
    val perPage: Long,
    val q: String,
)



================================================
FILE: HiAnime/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

version = 29

android {
    buildFeatures {
        buildConfig = true
    }

    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        buildConfigField("String", "WASMAPI", "\"${properties.getProperty("WASMAPI")}\"")
    }
}
dependencies {
    implementation("com.google.firebase:firebase-crashlytics-buildtools:3.0.6")
    implementation("androidx.appcompat:appcompat:1.7.1")
    implementation("com.google.android.material:material:1.13.0")
}


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    authors = listOf("Stormunblessed, KillerDogeEmpire,RowdyRushya,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Anime",
        "OVA",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=hianime.to&sz=%size%"
    requiresResources = true
    isCrossPlatform = false
}



================================================
FILE: HiAnime/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: HiAnime/src/main/kotlin/com/HiAnime/BottomSheet.kt
================================================
package com.HiAnime

import android.annotation.SuppressLint
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Toast
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig

class BottomFragment(private val plugin: HiAnimeProviderPlugin) : BottomSheetDialogFragment() {

    @SuppressLint("UseCompatLoadingForDrawables")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val id = plugin.resources!!.getIdentifier(
            "bottom_sheet_layout",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val layout = plugin.resources!!.getLayout(id)
        val view = inflater.inflate(layout, container, false)

        val outlineId = plugin.resources!!.getIdentifier(
            "outline",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )

        // Save button
        val saveIconId = plugin.resources!!.getIdentifier(
            "save_icon",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val saveBtn = view.findView<ImageView>("save")
        saveBtn.setImageDrawable(plugin.resources!!.getDrawable(saveIconId, null))
        saveBtn.background = plugin.resources!!.getDrawable(outlineId, null)
        saveBtn.setOnClickListener {
            context?.let { ctx ->
                AlertDialog.Builder(ctx)
                    .setTitle("Restart App?")
                    .setMessage("Save changes and restart the app?")
                    .setPositiveButton("Yes") { _, _ ->
                        restartApp(ctx)
                    }
                    .setNegativeButton("No") { dialog, _ ->
                        dialog.dismiss()
                        Toast.makeText(ctx, "Changes saved", Toast.LENGTH_SHORT).show()
                        dismiss()
                    }
                    .show()
            }
        }

        // Server selection radio buttons
        val serverGroup = view.findView<RadioGroup>("server_group")
        val radioBtnId = plugin.resources!!.getIdentifier(
            "radio_button",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        ServerList.entries.forEach { server ->
            val radioBtnLayout = plugin.resources!!.getLayout(radioBtnId)
            val radioBtnView = inflater.inflate(radioBtnLayout, container, false)
            val radioBtn = radioBtnView.findView<RadioButton>("radio_button")
            radioBtn.text = server.link.first
            radioBtn.isEnabled = server.link.second
            val newId = View.generateViewId()
            radioBtn.id = newId
            radioBtn.background = plugin.resources!!.getDrawable(outlineId, null)
            radioBtn.setOnClickListener {
                HiAnimeProviderPlugin.currentHiAnimeServer = radioBtn.text.toString()
                serverGroup.check(newId)
            }
            serverGroup.addView(radioBtnView)
            if (HiAnimeProviderPlugin.currentHiAnimeServer == server.link.first) {
                serverGroup.check(newId)
            }
        }

        return view
    }

    private fun <T : View> View.findView(name: String): T {
        val id = plugin.resources!!.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val dialog = super.onCreateDialog(savedInstanceState)
        (dialog as? BottomSheetDialog)?.behavior?.state = BottomSheetBehavior.STATE_EXPANDED
        return dialog
    }

    private fun restartApp(context: Context) {
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: HiAnime/src/main/kotlin/com/HiAnime/Extractor.kt
================================================
package com.HiAnime

import android.annotation.SuppressLint
import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import okhttp3.OkHttpClient
import okhttp3.Request
import java.net.URLEncoder

class Megacloud : ExtractorApi() {
    override val name = "Megacloud"
    override val mainUrl = "https://megacloud.blog"
    override val requiresReferer = false

    private val client = OkHttpClient()
    private val gson = Gson()

    private fun fetchUrl(url: String, headers: Map<String, String> = emptyMap()): String? {
        return try {
            val requestBuilder = Request.Builder().url(url)
            headers.forEach { (k, v) -> requestBuilder.addHeader(k, v) }

            client.newCall(requestBuilder.build()).execute().use { response ->
                if (response.isSuccessful) response.body.string() else null
            }
        } catch (e: Exception) {
            Log.e("Megacloud", "Network request failed: ${e.localizedMessage}")
            null
        }
    }

    @SuppressLint("NewApi")
    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val mainHeaders = mapOf(
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.5",
            "Accept-Encoding" to "gzip, deflate, br, zstd",
            "Origin" to mainUrl,
            "Referer" to "$mainUrl/",
            "Connection" to "keep-alive",
            "Pragma" to "no-cache",
            "Cache-Control" to "no-cache"
        )

        try {
            val headers = mapOf(
                "Accept" to "*/*",
                "X-Requested-With" to "XMLHttpRequest",
                "Referer" to mainUrl
            )

            val id = url.substringAfterLast("/").substringBefore("?")
            val responseText = fetchUrl(url, headers) ?: throw Exception("Failed to fetch page")

            val match1 = Regex("""\b[a-zA-Z0-9]{48}\b""").find(responseText)
            val match2 = Regex("""\b([a-zA-Z0-9]{16})\b.*?\b([a-zA-Z0-9]{16})\b.*?\b([a-zA-Z0-9]{16})\b""").find(responseText)
            val nonce = match1?.value ?: match2?.let { it.groupValues[1] + it.groupValues[2] + it.groupValues[3] }
            ?: throw Exception("Nonce not found")

            val apiUrl = "$mainUrl/embed-2/v3/e-1/getSources?id=$id&_k=$nonce"
            val responseJson = fetchUrl(apiUrl, headers) ?: throw Exception("Failed to fetch sources")
            val response = gson.fromJson(responseJson, MegacloudResponse::class.java)

            val encoded = response.sources.firstOrNull()?.file ?: throw Exception("No sources found")

            val keyJson = fetchUrl("https://raw.githubusercontent.com/yogesh-hacker/MegacloudKeys/refs/heads/main/keys.json")
            val key = keyJson?.let { gson.fromJson(it, Megakey::class.java)?.mega }

            val m3u8: String = if (encoded.contains(".m3u8")) {
                encoded
            } else {
                val decodeUrl =
                    "https://script.google.com/macros/s/AKfycbxHbYHbrGMXYD2-bC-C43D3njIbU-wGiYQuJL61H4vyy6YVXkybMNNEPJNPPuZrD1gRVA/exec"
                val fullUrl =
                    "$decodeUrl?encrypted_data=${URLEncoder.encode(encoded, "UTF-8")}" +
                            "&nonce=${URLEncoder.encode(nonce, "UTF-8")}" +
                            "&secret=${URLEncoder.encode(key ?: "", "UTF-8")}"

                val decryptedResponse = fetchUrl(fullUrl) ?: throw Exception("Failed to decrypt URL")
                Regex("\"file\":\"(.*?)\"").find(decryptedResponse)?.groupValues?.get(1)
                    ?: throw Exception("Video URL not found in decrypted response")
            }

            M3u8Helper.generateM3u8(name, m3u8, mainUrl, headers = mainHeaders).forEach(callback)

            response.tracks.forEach { track ->
                if (track.kind == "captions" || track.kind == "subtitles") {
                    subtitleCallback(newSubtitleFile(track.label, track.file))
                }
            }

        } catch (e: Exception) {
            Log.e("Megacloud", "Primary method failed: ${e.message}")
            // Optionally: fallback with WebViewResolver as in original code
        }
    }

    data class MegacloudResponse(
        val sources: List<Source>,
        val tracks: List<Track>,
        val encrypted: Boolean,
        val intro: Intro,
        val outro: Outro,
        val server: Long
    )

    data class Source(val file: String, val type: String)
    data class Track(val file: String, val label: String, val kind: String, val default: Boolean? = null)
    data class Intro(val start: Long, val end: Long)
    data class Outro(val start: Long, val end: Long)
    data class Megakey(val rabbit: String, val mega: String)
}


================================================
FILE: HiAnime/src/main/kotlin/com/HiAnime/HiAnime.kt
================================================
package com.HiAnime

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.ActorRole
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addKitsuId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addDubStatus
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.getDurationFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element
import java.net.URI
import okhttp3.OkHttpClient

class HiAnime : MainAPI() {
    override var mainUrl = HiAnimeProviderPlugin.currentHiAnimeServer
    override var name = "HiAnime"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val usesWebView = true
    override val supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)

    private fun Element.toSearchResult(): SearchResponse {
        val href = fixUrl(this.select("a").attr("href"))
        val title = this.select("h3.film-name").text()
        val subCount =
                this.selectFirst(".film-poster > .tick.ltr > .tick-sub")?.text()?.toIntOrNull()
        val dubCount =
                this.selectFirst(".film-poster > .tick.ltr > .tick-dub")?.text()?.toIntOrNull()

        val posterUrl = fixUrl(this.select("img").attr("data-src"))
        val type = getType(this.selectFirst("div.fd-infor > span.fdi-item")?.text() ?: "")

        return newAnimeSearchResponse(title, href, type) {
            this.posterUrl = posterUrl
            addDubStatus(dubCount != null, subCount != null, dubCount, subCount)
        }
    }

    private fun Element.getActorData(): ActorData? {
        var actor: Actor? = null
        var role: ActorRole? = null
        var voiceActor: Actor? = null
        val elements = this.select(".per-info")
        elements.forEachIndexed { index, actorInfo ->
            val name = actorInfo.selectFirst(".pi-name")?.text() ?: return null
            val image = actorInfo.selectFirst("a > img")?.attr("data-src") ?: return null
            when (index) {
                0 -> {
                    actor = Actor(name, image)
                    val castType = actorInfo.selectFirst(".pi-cast")?.text() ?: "Main"
                    role = ActorRole.valueOf(castType)
                }
                1 -> voiceActor = Actor(name, image)
                else -> {}
            }
        }
        return ActorData(actor ?: return null, role, voiceActor = voiceActor)
    }

    companion object {
        private val client = OkHttpClient()
        const val userAgent = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/70.0.3538.77 Chrome/70.0.3538.77 Safari/537.36"
        fun getType(t: String): TvType {
            return if (t.contains("OVA") || t.contains("Special")) TvType.OVA
            else if (t.contains("Movie")) TvType.AnimeMovie else TvType.Anime
        }

        fun getStatus(t: String): ShowStatus {
            return when (t) {
                "Finished Airing" -> ShowStatus.Completed
                "Currently Airing" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage =
            mainPageOf(
                    "$mainUrl/recently-updated?page=" to "Latest Episodes",
                    "$mainUrl/top-airing?page=" to "Top Airing",
                    "$mainUrl/filter?status=2&language=1&sort=recently_updated&page=" to "Recently Updated (SUB)",
                    "$mainUrl/filter?status=2&language=2&sort=recently_updated&page=" to "Recently Updated (DUB)",
                    "$mainUrl/recently-added?page=" to "New On HiAnime",
                    "$mainUrl/most-popular?page=" to "Most Popular",
                    "$mainUrl/most-favorite?page=" to "Most Favorite",
                    "$mainUrl/completed?page=" to "Latest Completed",
            )

    override suspend fun search(query: String,page: Int): SearchResponseList {
        val link = "$mainUrl/search?keyword=$query&page=$page"
        val res = app.get(link).documentLarge

        return res.select("div.flw-item").map { it.toSearchResult() }.toNewSearchResponseList()
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("${request.data}$page").document
        val items = document.select("div.flw-item").map { it.toSearchResult() }
        return newHomePageResponse(request.name, items)
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url.replace("watch/", "")).document

        val syncData = tryParseJson<ZoroSyncData>(document.selectFirst("#syncData")?.data())
        val syncMetaData = app.get("https://api.ani.zip/mappings?mal_id=${syncData?.malId}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)
        val title = document.selectFirst(".anisc-detail > .film-name")?.text().toString()
        val description = document.select("div.film-description > div").text().ifEmpty { document.select("div.film-description div").text() }
        val poster = document.select("#ani_detail div.film-poster img").attr("src")
        val genres = document.select("div.item.item-list:has(> span.item-head:contains(Genres)) a").map { it.text() }
        val backgroundposter = animeMetaData?.images?.find { it.coverType == "Fanart" }?.url
            ?: document.selectFirst(".anisc-poster img")?.attr("src")
        val animeId = URI(url).path.split("-").last()
        val kitsuid = animeMetaData?.mappings?.kitsuid

        val subCount = document.selectFirst(".anisc-detail .tick-sub")?.text()?.toIntOrNull()
        val dubCount = document.selectFirst(".anisc-detail .tick-dub")?.text()?.toIntOrNull()
        val dubEpisodes = emptyList<Episode>().toMutableList()
        val subEpisodes = emptyList<Episode>().toMutableList()
        val responseBody = app.get("$mainUrl/ajax/v2/episode/list/$animeId").body.string()
        val epRes = responseBody.stringParse<Response>()?.getDocument()
        val malId = syncData?.malId ?: "0"
        val anilistId = syncData?.aniListId ?: "0"


        epRes?.select(".ss-list > a[href].ssl-item.ep-item")?.forEachIndexed { index, ep ->
            val href = ep.attr("href").removePrefix("/")
            val episodeNum = ep.selectFirst(".ssli-order")?.text()?.toIntOrNull() ?: return@forEachIndexed
            val episodeKey = episodeNum.toString()

            // --- Helper to get best episode title ---
            fun resolveTitle(ep: Element, episodeKey: String): String {
                val titleMap = animeMetaData?.episodes?.get(episodeKey)?.title
                val jsonTitle = titleMap?.get("en")
                    ?: titleMap?.get("ja")
                    ?: titleMap?.get("x-jat")
                    ?: animeMetaData?.titles?.get("en")
                    ?: animeMetaData?.titles?.get("ja")
                    ?: animeMetaData?.titles?.get("x-jat")
                    ?: ""
                val attrTitle = ep.attr("title")
                return jsonTitle.ifBlank { attrTitle }
            }

            fun createEpisode(source: String): Episode {
                val metaEp = animeMetaData?.episodes?.get(episodeKey)
                return newEpisode("$source|$malId|$href") {
                    this.name = resolveTitle(ep, episodeKey)
                    this.episode = episodeNum
                    this.score = Score.from10(metaEp?.rating)
                    this.posterUrl = metaEp?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
                    this.description = metaEp?.overview ?: "No summary available"
                    this.addDate(metaEp?.airDateUtc)
                    this.runTime = metaEp?.runtime
                }
            }

            subCount?.let { if (index < it) subEpisodes += createEpisode("sub") }
            dubCount?.let { if (index < it) dubEpisodes += createEpisode("dub") }
        }
        val actors =
                document.select("div.block-actors-content div.bac-item").mapNotNull {
                    it.getActorData()
                }

        val recommendations =
                document.select("div.block_area_category div.flw-item").map { it.toSearchResult() }

        return newAnimeLoadResponse(title, url, TvType.Anime) {
            engName = title
            posterUrl = poster
            backgroundPosterUrl = backgroundposter
            this.tags = genres
            this.plot = description
            addEpisodes(DubStatus.Subbed, subEpisodes)
            addEpisodes(DubStatus.Dubbed, dubEpisodes)
            this.recommendations = recommendations
            this.actors = actors
            addMalId(malId.toIntOrNull())
            addAniListId(anilistId.toIntOrNull())
            try { addKitsuId(kitsuid) } catch(_:Throwable){}
            // adding info
            document.select(".anisc-info > .item").forEach { info ->
                val infoType = info.select("span.item-head").text().removeSuffix(":")
                when (infoType) {
                    "Overview" -> plot = info.selectFirst(".text")?.text() ?: description
                    "Japanese" -> japName = info.selectFirst(".name")?.text()
                    "Premiered" -> year = info.selectFirst(".name")?.text()?.substringAfter(" ")?.toIntOrNull()
                    "Duration" -> duration = getDurationFromString(info.selectFirst(".name")?.text())
                    "Status" -> showStatus = getStatus(info.selectFirst(".name")?.text().toString())
                    "Genres" -> tags = info.select("a").map { it.text() }
                    "MAL Score" -> score = Score.from10(info.selectFirst(".name")?.text())
                    else -> {}
                }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        try {
            val dubType = data.removePrefix("$mainUrl/").substringBefore("|").ifEmpty { "raw" }
            val hrefPart = data.substringAfterLast("|")
            val epId = hrefPart.substringAfter("ep=")
            val doc = app.get("$mainUrl/ajax/v2/episode/servers?episodeId=$epId")
                .parsed<Response>()
                .getDocument()
            val servers = doc.select(".server-item[data-type=$dubType][data-id], .server-item[data-type=raw][data-id]")
                .mapNotNull {
                    val id = it.attr("data-id")
                    val label = it.selectFirst("a.btn")?.text()?.trim()
                    if (id.isNotEmpty() && label != null) {
                        id to label
                    } else {
                        null
                    }
                }.distinctBy { it.first }
            servers.forEach { (id, label) ->
                val sourceurl = app.get("${mainUrl}/ajax/v2/episode/sources?id=$id").parsedSafe<EpisodeServers>()?.link
                if (sourceurl != null) {
                    loadCustomExtractor(
                        "HiAnime [$label]",
                        sourceurl,
                        "",
                        subtitleCallback,
                        callback,
                    )
                }
            }
            return true
        } catch (e: Exception) {
            Log.e("HiAnime", "Critical error in loadLinks: ${e.localizedMessage}")
            return false
        }
    }



    data class Response(
        @SerializedName("status") val status: Boolean,
        @SerializedName("html") val html: String
    ) {
        fun getDocument(): Document {
            return Jsoup.parse(html)
        }
    }

    private data class ZoroSyncData(
            @JsonProperty("mal_id") val malId: String?,
            @JsonProperty("anilist_id") val aniListId: String?,
    )

    // HiAnime Response

    data class HiAnimeResponse(
        val headers: HiAnimeHeaders,
        val intro: HiAnimeIntro,
        val outro: HiAnimeOutro,
        val sources: List<HiAnimeSource>,
        val subtitles: List<HiAnimeSubtitle>,
    )

    data class HiAnimeHeaders(
        @JsonProperty("Referer")
        val referer: String,
    )

    data class HiAnimeIntro(
        val start: Long,
        val end: Long,
    )

    data class HiAnimeOutro(
        val start: Long,
        val end: Long,
    )

    data class HiAnimeSource(
        val url: String,
        val isM3U8: Boolean,
        val type: String,
    )

    data class HiAnimeSubtitle(
        val url: String,
        val lang: String,
    )


    data class HiAnimeAPI(
        val sources: List<Source>,
        val tracks: List<Track>,
    )

    data class Source(
        val file: String,
        val type: String,
    )

    data class Track(
        val file: String,
        val label: String,
    )

    data class EpisodeServers(
        val type: String,
        val link: String,
        val server: Long,
        val sources: List<Any?>,
        val tracks: List<Any?>,
        val htmlGuide: String,
    )




    // Metadata
    @JsonIgnoreProperties(ignoreUnknown = true)
    data class MetaImage(
        @JsonProperty("coverType") val coverType: String?,
        @JsonProperty("url") val url: String?
    )

    @JsonIgnoreProperties(ignoreUnknown = true)
    data class MetaEpisode(
        @JsonProperty("episode") val episode: String?,
        @JsonProperty("airDateUtc") val airDateUtc: String?,  // Keeping only one field
        @JsonProperty("runtime") val runtime: Int?,     // Keeping only one field
        @JsonProperty("image") val image: String?,
        @JsonProperty("title") val title: Map<String, String>?,
        @JsonProperty("overview") val overview: String?,
        @JsonProperty("rating") val rating: String?,
        @JsonProperty("finaleType") val finaleType: String?
    )

    @JsonIgnoreProperties(ignoreUnknown = true)
    data class MetaAnimeData(
        @JsonProperty("titles") val titles: Map<String, String>?,
        @JsonProperty("images") val images: List<MetaImage>?,
        @JsonProperty("episodes") val episodes: Map<String, MetaEpisode>?,
        @JsonProperty("mappings") val mappings: MetaMappings? = null
    )


    @JsonIgnoreProperties(ignoreUnknown = true)
    data class MetaMappings(
        @JsonProperty("themoviedb_id") val themoviedbId: String? = null,
        @JsonProperty("thetvdb_id") val thetvdbId: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("mal_id") val malId: Int? = null,
        @JsonProperty("anilist_id") val anilistId: Int? = null,
        @JsonProperty("kitsu_id") val kitsuid: String? = null,
    )

    private fun parseAnimeData(jsonString: String): MetaAnimeData? {
        return try {
            val objectMapper = ObjectMapper()
            objectMapper.readValue(jsonString, MetaAnimeData::class.java)
        } catch (_: Exception) {
            null // Return null for invalid JSON instead of crashing
        }
    }

    private inline fun <reified T> String.stringParse(): T? {
        return try {
            Gson().fromJson(this, T::class.java)
        } catch (e: Exception) {
            e.printStackTrace()
            null // Return null if JSON parsing fails
        }
    }

    private suspend fun loadCustomExtractor(
        name: String? = null,
        url: String,
        referer: String? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        quality: Int? = null,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        name ?: link.source,
                        name ?: link.name,
                        link.url,
                    ) {
                        this.quality = when {
                            link.name == "VidSrc" -> Qualities.P1080.value
                            link.type == ExtractorLinkType.M3U8 -> link.quality
                            else -> quality ?: link.quality
                        }
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }

}



================================================
FILE: HiAnime/src/main/kotlin/com/HiAnime/HiAnimePlugin.kt
================================================
package com.HiAnime

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.AcraApplication.Companion.setKey
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin

enum class ServerList(val link: Pair<String, Boolean>) {
    HIANIMEZ_IS("https://hianimez.is" to true),
    BEST("https://hianime.to" to true),
    HIANIME_NZ("https://hianime.nz" to true),
    HIANIME_BZ("https://hianime.bz" to true),
    HIANIME_PE("https://hianime.pe" to true),
    HIANIME_CX("https://hianime.cx" to true),
    HIANIME_DO("https://hianime.do" to true),
}

@CloudstreamPlugin
class HiAnimeProviderPlugin : Plugin() {

    override fun load(context: Context) {
        registerMainAPI(HiAnime())
        registerExtractorAPI(Megacloud())
        this.openSettings = openSettings@{ ctx ->
            val activity = ctx as AppCompatActivity
            val frag = BottomFragment(this)
            frag.show(activity.supportFragmentManager, "")
        }
    }

    companion object {
        var currentHiAnimeServer: String
            get() = getKey("HIANIME_CURRENT_SERVER") ?: ServerList.BEST.link.first
            set(value) {
                setKey("HIANIME_CURRENT_SERVER", value)
            }
    }
}



================================================
FILE: HiAnime/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="2dp"
                android:bottomRightRadius="2dp"
                android:topLeftRadius="2dp"
                android:topRightRadius="2dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: HiAnime/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: HiAnime/src/main/res/layout/bottom_sheet_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="20dp">

            <TextView
                android:id="@+id/text1"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="HiAnime Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:background="#FFF"
                    android:padding="5dp"
                    android:contentDescription="Save changes" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:text="HiAnime Servers"
                android:textSize="17sp"
                android:textStyle="bold" />

            <RadioGroup
                android:id="@+id/server_group"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"/>

        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: HiAnime/src/main/res/layout/radio_button.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <RadioButton
        android:id="@+id/radio_button"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:paddingRight="5dp"
        android:text="test" />
</LinearLayout>



================================================
FILE: Hindmoviez/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    description = "Watch Movies & TvSeries (Multi-Lang)"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    language = "hi"
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/hindmoviez.png"

    isCrossPlatform = false
}



================================================
FILE: Hindmoviez/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest/>


================================================
FILE: Hindmoviez/src/main/kotlin/com/hindmoviez/hindmoviez.kt
================================================
package com.hindmoviez

import com.google.gson.Gson
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.runBlocking
import org.json.JSONObject
import org.jsoup.nodes.Element


class Hindmoviez : MainAPI() {
    override var mainUrl: String = runBlocking {
        HindmoviezPlugin.getDomains()?.hindmoviez ?: "https://hindmoviez.cafe"
    }
    override var name = "Hindmoviez"
    override var lang = "hi"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val hasQuickSearch = false
    override val supportedTypes = setOf(
        TvType.Movie, TvType.TvSeries
    )
    companion object
    {
        private const val cinemeta_url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta"
    }

    override val mainPage = mainPageOf(
        "" to "HomePage",
        "movies" to "Movies",
        "web-series" to "Web Series",
        "dramas/korean-drama" to "Korean Dramas",
        "dramas/chinese-drama" to "Chinese Dramas",
        "anime" to "Anime",
    )

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val doc = if (page==1) app.get("$mainUrl/${request.data}", timeout = 5000L).document else app.get("$mainUrl/${request.data}/page/$page", timeout = 5000L).document

        val home = doc.select("article").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(request.name, home, true)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = cleanTitle(this.selectFirst("div.entry-content img")?.attr("alt"))
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.entry-content img").let {
            img -> img.attr("data-src").takeIf { it.isNotBlank() }
            ?: img.attr("src") })

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getSearchQuality(title)
        }
    }


    override suspend fun search(query: String,page: Int): SearchResponseList {
        val doc = app.get("$mainUrl/page/$page/?s=$query").document
        val res = doc.select("article").mapNotNull { it.toSearchResult() }
        return res.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url, timeout = 10000).document

        var name: String? = null
        var imdbRating: String? = null
        var imdbId: String? = null
        var releaseYear: String? = null
        var docgenres: List<String> = emptyList()

        doc.select("ul > li").forEach { li ->
            val strongText = li.selectFirst("strong")?.text()?.trim() ?: return@forEach
            val key = strongText.substringBefore(":").trim()
            val value = strongText.substringAfter(":", "").trim()
            val tailText = li.ownText().trim()

            when (key) {
                "Name" -> name = tailText.ifEmpty { value }

                "IMDB Rating" -> {
                    imdbRating = value.substringBefore("/")
                    imdbId = li.selectFirst("a[href*=\"/title/tt\"]")
                        ?.attr("href")
                        ?.substringAfter("/title/")
                        ?.substringBefore("/")
                }

                "Release Year" -> releaseYear = tailText.ifEmpty { value }

                "Genre" -> {
                    val genreText = tailText.ifEmpty { value }
                    docgenres = genreText.split(",").map { it.trim() }
                }
            }
        }

        val title = name ?: "Unknown"
        val poster = doc.select("meta[property=og:image]").attr("content")
        val descriptions = doc.select("h3")
            .firstOrNull { it.text().contains("Storyline", ignoreCase = true) }
            ?.nextElementSibling()
            ?.takeIf { it.tagName() == "p" }
            ?.text()

        val typeraw = doc.select("h1.entry-title").text()
        val tvtype = if (typeraw.contains("Season", ignoreCase = true)) TvType.TvSeries else TvType.Movie

        var background: String? = null
        var description: String? = null

        val tmdbId = imdbId?.let { id ->
            runCatching {
                val obj = JSONObject(
                    app.get(
                        "https://api.themoviedb.org/3/find/$id" +
                                "?api_key=1865f43a0549ca50d341dd9ab8b29f49" +
                                "&external_source=imdb_id"
                    ).textLarge
                )

                obj.optJSONArray("movie_results")?.optJSONObject(0)?.optInt("id")?.takeIf { it != 0 }
                    ?: obj.optJSONArray("tv_results")?.optJSONObject(0)?.optInt("id")?.takeIf { it != 0 }
            }.getOrNull()?.toString()
        }

        val creditsJson = tmdbId?.let {
            val tmdbmetatype = if (tvtype == TvType.TvSeries) "tv" else "movie"
            runCatching {
                app.get(
                    "https://api.themoviedb.org/3/$tmdbmetatype/$it/credits" +
                            "?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US"
                ).textLarge
            }.getOrNull()
        }
        val castList = parseCredits(creditsJson)

        val hrefs = doc.select("a.maxbutton")
            .amap { element ->
                val listUrl = element.absUrl("href")
                if (listUrl.isBlank()) return@amap emptyList()

                app.get(listUrl).document
                    .select("div.entry-content a")
                    .mapNotNull { anchor ->
                        val href = anchor.absUrl("href")
                        href.takeIf(String::isNotBlank)
                    }
            }
            .flatten()
            .toJson()


        val typeset = if (tvtype == TvType.TvSeries) "series" else "movie"

        val responseData = if (imdbId?.isNotEmpty() == true) {
            val jsonResponse = app.get("$cinemeta_url/$typeset/$imdbId.json").text
            if (jsonResponse.startsWith("{")) {
                Gson().fromJson(jsonResponse, ResponseData::class.java)
            } else null
        } else null

        if (responseData != null) {
            description = responseData.meta?.description ?: descriptions
            background = responseData.meta?.background ?: poster
        }


        if (tvtype == TvType.TvSeries) {

            val episodeUrlMap = mutableMapOf<Pair<Int, Int>, MutableList<String>>()

            doc.select("h3").forEach seasonHeader@{ h3 ->

                val seasonNumber = Regex("""Season\s*(\d+)""", RegexOption.IGNORE_CASE)
                    .find(h3.text())
                    ?.groupValues
                    ?.get(1)
                    ?.toIntOrNull()
                    ?: return@seasonHeader

                val p = h3.nextElementSibling()
                if (p?.tagName() != "p") return@seasonHeader

                val episodeListUrl = p.selectFirst("a[href]")
                    ?.absUrl("href")
                    ?.takeIf { it.isNotBlank() }
                    ?: return@seasonHeader

                val episodeDoc = app.get(episodeListUrl).document
                episodeDoc.select("h3 > a").forEach episodeLoop@{ epAnchor ->
                    val episodeNumber = Regex("""Episode\s*(\d+)""", RegexOption.IGNORE_CASE)
                        .find(epAnchor.text())
                        ?.groupValues
                        ?.get(1)
                        ?.toIntOrNull()
                        ?: return@episodeLoop

                    val epUrl = epAnchor.absUrl("href")
                        .takeIf { it.isNotBlank() }
                        ?: return@episodeLoop

                    val key = seasonNumber to episodeNumber
                    episodeUrlMap.getOrPut(key) { mutableListOf() }.add(epUrl)
                }
            }

            val episodes = episodeUrlMap.map { (key, urls) ->
                val (seasonNumber, episodeNumber) = key

                val metaEpisode = responseData?.meta?.videos
                    ?.firstOrNull { it.season == seasonNumber && it.episode == episodeNumber }

                newEpisode(urls.toJson()) {
                    this.name = metaEpisode?.title
                    this.season = seasonNumber
                    this.episode = episodeNumber
                    this.posterUrl = metaEpisode?.thumbnail
                    this.description = metaEpisode?.overview
                    addDate(metaEpisode?.released)
                }
            }

            return newTvSeriesLoadResponse(
                responseData?.meta?.name ?: title,
                url,
                TvType.TvSeries,
                episodes
            ) {
                this.backgroundPosterUrl = background ?: poster
                this.posterUrl = poster
                this.year = releaseYear?.toIntOrNull()
                    ?: responseData?.meta?.year?.toIntOrNull()
                this.plot = description ?: plot
                this.tags = docgenres
                this.actors = castList
                try { this.logoUrl = responseData?.meta?.logo } catch (_: Throwable) {}
                this.score = Score.from10(imdbRating ?: responseData?.meta?.imdbRating)
                addImdbId(imdbId)
            }
        }

        return newMovieLoadResponse(
            responseData?.meta?.name ?: title,
            url,
            TvType.Movie,
            hrefs
        ) {
            this.backgroundPosterUrl = background ?: poster
            this.posterUrl = poster
            this.year = releaseYear?.toIntOrNull() ?: responseData?.meta?.year?.toIntOrNull()
            this.plot = description ?: plot
            this.tags = docgenres
            this.actors = castList
            try { this.logoUrl = responseData?.meta?.logo } catch(_:Throwable){}
            this.score = Score.from10(imdbRating ?: responseData?.meta?.imdbRating)
            addImdbId(imdbId)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links: List<String> = tryParseJson<List<String>>(data) ?: emptyList()
        links.amap { pageUrl ->
            val pageDoc = app.get(pageUrl).document
            pageDoc.select("a.btn").forEach { btn ->
                val btnUrl = btn.absUrl("href")
                if (btnUrl.isBlank()) return@forEach
                val name = pageDoc.selectFirst("div.container p:contains(Name:)")
                    ?.text()
                    ?.substringAfter("Name:")
                    ?.trim()
                    .orEmpty()


                val extractedSpecs = buildExtractedTitle(extractSpecs(name))

                val fileSize = pageDoc.selectFirst("div.container p:contains(Size:)")
                    ?.text()
                    ?.substringAfter("Size:")
                    ?.trim()
                    .orEmpty()

                val doc = app.get(btnUrl).document
                val quality = getIndexQuality(doc.select("div.container h2").text())

                doc.select("a.button").forEach { link ->
                    val servername = link.text()
                    val href = link.absUrl("href")
                    if (href.isNotBlank()) {
                        callback.invoke(
                            newExtractorLink(
                                servername,
                                "$name [HCloud] $extractedSpecs[$fileSize]",
                                href
                            )
                            {
                                this.referer = btnUrl
                                this.quality = quality
                            }
                        )
                    }
                }
            }
        }

        return true
    }
}


================================================
FILE: Hindmoviez/src/main/kotlin/com/hindmoviez/hindmoviezPlugin.kt
================================================
package com.hindmoviez

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.app


@CloudstreamPlugin
class HindmoviezPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(Hindmoviez())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("hindmoviez")
            val hindmoviez: String,
        )
    }
}


================================================
FILE: Hindmoviez/src/main/kotlin/com/hindmoviez/Utils.kt
================================================
package com.hindmoviez

import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.SearchQuality
import com.lagradost.cloudstream3.utils.Qualities
import org.json.JSONObject
import java.text.Normalizer

fun cleanTitle(raw: String?): String {
    val regex = Regex("""S(\d+)[Ee](\d+)(?:-(\d+))?""")
    val match = regex.find(raw ?: "") ?: return raw!!.trim()

    val season = match.groupValues[1].toInt()
    val epStart = match.groupValues[2].toInt()
    val epEnd = match.groupValues.getOrNull(3)?.takeIf { it.isNotEmpty() }?.toInt()

    val showName = raw?.substringBefore(match.value)!!.trim()
    val year = Regex("""\((\d{4})\)""").find(raw)?.groupValues?.get(1)

    val titleBase = if (year != null) showName else showName
    val episodes = if (epEnd != null) "Episodes $epStart–$epEnd" else "Episode $epStart"

    return "$titleBase Season $season | $episodes"
}

fun parseCredits(jsonText: String?): List<ActorData> {
    if (jsonText.isNullOrBlank()) return emptyList()
    val list = ArrayList<ActorData>()
    val root = JSONObject(jsonText)
    val castArr = root.optJSONArray("cast") ?: return list
    for (i in 0 until castArr.length()) {
        val c = castArr.optJSONObject(i) ?: continue
        val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
        val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { "https://image.tmdb.org/t/p/original$it" }
        val character = c.optString("character").takeIf { it.isNotBlank() }
        val actor = Actor(name, profile)
        list += ActorData(actor, roleString = character)
    }
    return list
}

data class ResponseData(
    val meta: Meta? = null
) {

    data class Meta(
        val id: String? = null,
        val type: String? = null,
        val name: String? = null,
        @JsonProperty("imdb_id")
        val imdbId: String? = null,

        val slug: String? = null,

        val director: String? = null,
        val writer: String? = null,

        val description: String? = null,
        val year: String? = null,
        val releaseInfo: String? = null,
        val released: String? = null,
        val runtime: String? = null,
        val status: String? = null,
        val country: String? = null,
        val imdbRating: String? = null,
        val genres: List<String>? = null,
        val poster: String? = null,
        @JsonProperty("_rawPosterUrl")
        val rawPosterUrl: String? = null,

        val background: String? = null,
        val logo: String? = null,

        val videos: List<EpisodeDetails>? = null,
        val trailers: List<Trailer>? = null,
        val trailerStreams: List<TrailerStream>? = null,
        val links: List<Link>? = null,
        val behaviorHints: BehaviorHints? = null,
        @SerializedName("app_extras")
        val appExtras: AppExtras? = null
    ) {

        data class BehaviorHints(
            val defaultVideoId: Any? = null,
            val hasScheduledVideos: Boolean? = null
        )

        data class Link(
            val name: String? = null,
            val category: String? = null,
            val url: String? = null
        )

        data class Trailer(
            val source: String? = null,
            val type: String? = null,
            val name: String? = null
        )

        data class TrailerStream(
            val ytId: String? = null,
            val title: String? = null
        )

        data class EpisodeDetails(
            val id: String? = null,
            val title: String? = null,
            val season: Int? = null,
            val episode: Int? = null,
            val thumbnail: String? = null,
            val overview: String? = null,
            val released: String? = null,
            val available: Boolean? = null,
            val runtime: String? = null
        )

        data class AppExtras(
            val cast: List<Cast>? = null,
            val directors: List<Any?>? = null,
            val writers: List<Any?>? = null,
            val seasonPosters: List<String?>? = null,
            val certification: String? = null
        )

        data class Cast(
            val name: String? = null,
            val character: String? = null,
            val photo: String? = null
        )
    }
}

/**
 * Determines the search quality based on the presence of specific keywords in the input string.
 *
 * @param check The string to check for keywords.
 * @return The corresponding `SearchQuality` enum value, or `null` if no match is found.
 */
fun getSearchQuality(check: String?): SearchQuality? {
    val s = check ?: return null
    val u = Normalizer.normalize(s, Normalizer.Form.NFKC).lowercase()
    val patterns = listOf(
        Regex("\\b(4k|ds4k|uhd|2160p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.FourK,

        // CAM / THEATRE SOURCES FIRST
        Regex("\\b(hdts|hdcam|hdtc)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HdCam,
        Regex("\\b(camrip|cam[- ]?rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip,
        Regex("\\b(cam)\\b", RegexOption.IGNORE_CASE) to SearchQuality.Cam,

        // WEB / RIP
        Regex("\\b(web[- ]?dl|webrip|webdl)\\b", RegexOption.IGNORE_CASE) to SearchQuality.WebRip,

        // BLURAY
        Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,

        // RESOLUTIONS
        Regex("\\b(1440p|qhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,
        Regex("\\b(1080p|fullhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,
        Regex("\\b(720p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.SD,

        // GENERIC HD LAST
        Regex("\\b(hdrip|hdtv)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,

        Regex("\\b(dvd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.DVD,
        Regex("\\b(hq)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HQ,
        Regex("\\b(rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip
    )


    for ((regex, quality) in patterns) if (regex.containsMatchIn(u)) return quality
    return null
}

fun buildExtractedTitle(extracted: Map<String, List<String>>): String {
    val orderedCategories = listOf("quality", "codec", "audio", "hdr", "language")

    val specs = orderedCategories
        .flatMap { extracted[it] ?: emptyList() }
        .distinct()
        .joinToString(" ")

    val size = extracted["size"]?.firstOrNull()

    return if (size != null) {
        "$specs [$size]"
    } else {
        specs
    }
}

val SPEC_OPTIONS = mapOf(
    "quality" to listOf(
        mapOf("value" to "BluRay", "label" to "BluRay"),
        mapOf("value" to "BluRay REMUX", "label" to "BluRay REMUX"),
        mapOf("value" to "BRRip", "label" to "BRRip"),
        mapOf("value" to "BDRip", "label" to "BDRip"),
        mapOf("value" to "WEB-DL", "label" to "WEB-DL"),
        mapOf("value" to "HDRip", "label" to "HDRip"),
        mapOf("value" to "DVDRip", "label" to "DVDRip"),
        mapOf("value" to "HDTV", "label" to "HDTV"),
        mapOf("value" to "CAM", "label" to "CAM"),
        mapOf("value" to "TeleSync", "label" to "TeleSync"),
        mapOf("value" to "SCR", "label" to "SCR"),
        mapOf("value" to "10bit", "label" to "10bit"),
        mapOf("value" to "8bit", "label" to "8bit"),
    ),
    "codec" to listOf(
        mapOf("value" to "x264", "label" to "x264"),
        mapOf("value" to "x265", "label" to "x265 (HEVC)"),
        mapOf("value" to "h.264", "label" to "H.264 (AVC)"),
        mapOf("value" to "h.265", "label" to "H.265 (HEVC)"),
        mapOf("value" to "hevc", "label" to "HEVC"),
        mapOf("value" to "avc", "label" to "AVC"),
        mapOf("value" to "mpeg-2", "label" to "MPEG-2"),
        mapOf("value" to "mpeg-4", "label" to "MPEG-4"),
        mapOf("value" to "vp9", "label" to "VP9")
    ),
    "audio" to listOf(
        mapOf("value" to "AAC", "label" to "AAC"),
        mapOf("value" to "AC3", "label" to "AC3 (Dolby Digital)"),
        mapOf("value" to "DTS", "label" to "DTS"),
        mapOf("value" to "DTS-HD MA", "label" to "DTS-HD MA"),
        mapOf("value" to "TrueHD", "label" to "Dolby TrueHD"),
        mapOf("value" to "Atmos", "label" to "Dolby Atmos"),
        mapOf("value" to "DD+", "label" to "DD+"),
        mapOf("value" to "Dolby Digital Plus", "label" to "Dolby Digital Plus"),
        mapOf("value" to "DTS Lossless", "label" to "DTS Lossless")
    ),
    "hdr" to listOf(
        mapOf("value" to "DV", "label" to "Dolby Vision"),
        mapOf("value" to "HDR10+", "label" to "HDR10+"),
        mapOf("value" to "HDR", "label" to "HDR"),
        mapOf("value" to "SDR", "label" to "SDR")
    ),
    "language" to listOf(
        mapOf("value" to "HIN", "label" to "Hindi🇮🇳"),
        mapOf("value" to "Hindi", "label" to "Hindi🇮🇳"),
        mapOf("value" to "Tamil", "label" to "Tamil🇮🇳"),
        mapOf("value" to "ENG", "label" to "English🇺🇸"),
        mapOf("value" to "English", "label" to "English🇺🇸"),
        mapOf("value" to "Korean", "label" to "Korean🇰🇷"),
        mapOf("value" to "KOR", "label" to "Korean🇰🇷"),
        mapOf("value" to "Japanese", "label" to "Japanese🇯🇵"),
        mapOf("value" to "Chinese", "label" to "Chinese🇨🇳"),
        mapOf("value" to "Telugu", "label" to "Telugu🇮🇳"),
    )
)

fun extractSpecs(inputString: String): Map<String, List<String>> {
    val results = mutableMapOf<String, List<String>>()

    SPEC_OPTIONS.forEach { (category, options) ->
        val matches = options.filter { option ->
            val value = option["value"] as String
            val regexPattern = "\\b${Regex.escape(value)}\\b".toRegex(RegexOption.IGNORE_CASE)
            regexPattern.containsMatchIn(inputString)
        }.map { it["label"] as String }

        results[category] = matches
    }

    val fileSizeRegex = """(\d+(?:\.\d+)?\s?(?:MB|GB))""".toRegex(RegexOption.IGNORE_CASE)
    val sizeMatch = fileSizeRegex.find(inputString)
    if (sizeMatch != null) {
        results["size"] = listOf(sizeMatch.groupValues[1])
    }

    return results.toMap()
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}



================================================
FILE: IdlixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    language = "id"
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
     authors = listOf("Hexated,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie",
        "Anime",
        "AsianDrama",
    )
    isCrossPlatform = true
    iconUrl = "https://t0.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=http://idlixian.com&size=16"
}


================================================
FILE: IdlixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.hexated"/>


================================================
FILE: IdlixProvider/src/main/kotlin/com/hexated/Extractor.kt
================================================
package com.hexated

import com.hexated.IdlixProvider.ResponseSource
import com.hexated.IdlixProvider.Tracks
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.newExtractorLink

class Jeniusplay : ExtractorApi() {
    override var name = "Jeniusplay"
    override var mainUrl = "https://jeniusplay.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val document = app.get(url, referer = referer).documentLarge
        val hash = url.split("/").last().substringAfter("data=")

        val m3uLink = app.post(
            url = "$mainUrl/player/index.php?data=$hash&do=getVideo",
            data = mapOf("hash" to hash, "r" to "$referer"),
            referer = referer,
            headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).parsed<ResponseSource>().videoSource

        callback.invoke(
            newExtractorLink(
                name,
                name,
                url = m3uLink,
                ExtractorLinkType.M3U8
            )
        )

        document.select("script").map { script ->
            if (script.data().contains("eval(function(p,a,c,k,e,d)")) {
                val subData =
                    getAndUnpack(script.data()).substringAfter("\"tracks\":[").substringBefore("],")
                AppUtils.tryParseJson<List<Tracks>>("[$subData]")?.map { subtitle ->
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            getLanguage(subtitle.label ?: ""),
                            subtitle.file
                        )
                    )
                }
            }
        }
    }


    private fun getLanguage(str: String): String {
        return when {
            str.contains("indonesia", true) || str
                .contains("bahasa", true) -> "Indonesian"
            else -> str
        }
    }
}


================================================
FILE: IdlixProvider/src/main/kotlin/com/hexated/IdlixProvider.kt
================================================
package com.hexated

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.extractors.helper.AesHelper
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element
import java.net.URI

class IdlixProvider : MainAPI() {
    override var mainUrl = "https://idlixian.com"
    private var directUrl = mainUrl
    override var name = "Idlix"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "$mainUrl/" to "Featured",
        "$mainUrl/trending/page/?get=movies" to "Trending Movies",
        "$mainUrl/trending/page/?get=tv" to "Trending TV Series",
        "$mainUrl/movie/page/" to "Movie Terbaru",
        "$mainUrl/tvseries/page/" to "TV Series Terbaru",
        "$mainUrl/network/amazon/page/" to "Amazon Prime",
        "$mainUrl/network/apple-tv/page/" to "Apple TV+ Series",
        "$mainUrl/network/disney/page/" to "Disney+ Series",
        "$mainUrl/network/HBO/page/" to "HBO Series",
        "$mainUrl/network/netflix/page/" to "Netflix Series",
    )

    private fun getBaseUrl(url: String): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = request.data.split("?")
        val nonPaged = request.name == "Featured" && page <= 1
        val req = if (nonPaged) {
            app.get(request.data)
        } else {
            app.get("${url.first()}$page/?${url.lastOrNull()}")
        }
        mainUrl = getBaseUrl(req.url)
        val document = req.documentLarge
        val home = (if (nonPaged) {
            document.select("div.items.featured article")
        } else {
            document.select("div.items.full article, div#archive-content article")
        }).mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun getProperLink(uri: String): String {
        return when {
            uri.contains("/episode/") -> {
                var title = uri.substringAfter("$mainUrl/episode/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvseries/$title"
            }

            uri.contains("/season/") -> {
                var title = uri.substringAfter("$mainUrl/season/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvseries/$title"
            }

            else -> {
                uri
            }
        }
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.selectFirst("h3 > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
        val href = getProperLink(this.selectFirst("h3 > a")!!.attr("href"))
        val posterUrl = this.select("div.poster > img").attr("src")
        val quality = getQualityFromString(this.select("span.quality").text())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val req = app.get("$mainUrl/search/$query")
        mainUrl = getBaseUrl(req.url)
        val document = req.documentLarge
        return document.select("div.result-item").map {
            val title =
                it.selectFirst("div.title > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
            val href = getProperLink(it.selectFirst("div.title > a")!!.attr("href"))
            val posterUrl = it.selectFirst("img")!!.attr("src")
            newMovieSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val request = app.get(url)
        directUrl = getBaseUrl(request.url)
        val document = request.documentLarge
        val title =
            document.selectFirst("div.data > h1")?.text()?.replace(Regex("\\(\\d{4}\\)"), "")
                ?.trim().toString()
        val images = document.select("div.g-item")

        val poster = images
            .shuffled()
            .firstOrNull()
            ?.selectFirst("a")
            ?.attr("href")
            ?: document.select("div.poster > img").attr("src")
        val tags = document.select("div.sgeneros > a").map { it.text() }
        val year = Regex(",\\s?(\\d+)").find(
            document.select("span.date").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (document.select("ul#section > li:nth-child(1)").text().contains("Episodes")
        ) TvType.TvSeries else TvType.Movie
        val description = document.select("p:nth-child(3)").text().trim()
        val trailer = document.selectFirst("div.embed iframe")?.attr("src")
        val rating = document.selectFirst("span.dt_rating_vgs")?.text()
        val actors = document.select("div.persons > div[itemprop=actor]").map {
            Actor(it.select("meta[itemprop=name]").attr("content"), it.select("img").attr("src"))
        }

        val recommendations = document.select("div.owl-item").map {
            val recName =
                it.selectFirst("a")!!.attr("href").removeSuffix("/").split("/").last()
            val recHref = it.selectFirst("a")!!.attr("href")
            val recPosterUrl = it.selectFirst("img")?.attr("src").toString()
            newTvSeriesSearchResponse(recName, recHref, TvType.TvSeries) {
                this.posterUrl = recPosterUrl
            }
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = document.select("ul.episodios > li").map {
                val href = it.select("a").attr("href")
                val name = fixTitle(it.select("div.episodiotitle > a").text().trim())
                val image = it.select("div.imagen > img").attr("src")
                val episode = it.select("div.numerando").text().replace(" ", "").split("-").last()
                    .toIntOrNull()
                val season = it.select("div.numerando").text().replace(" ", "").split("-").first()
                    .toIntOrNull()
                newEpisode(href)
                {
                        this.name=name
                        this.season=season
                        this.episode=episode
                        this.posterUrl=image
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from100(rating)
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from100(rating)
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val document = app.get(data).documentLarge
        val scriptRegex = """window\.idlixNonce=['"]([a-f0-9]+)['"].*?window\.idlixTime=(\d+).*?""".toRegex(RegexOption.DOT_MATCHES_ALL)
        val script = document.select("script:containsData(window.idlix)").toString()
        val match = scriptRegex.find(script)
        val idlixNonce = match?.groups?.get(1)?.value ?: ""
        val idlixTime = match?.groups?.get(2)?.value ?: ""

        document.select("ul#playeroptionsul > li").map {
                Triple(
                    it.attr("data-post"),
                    it.attr("data-nume"),
                    it.attr("data-type")
                )
            }.amap { (id, nume, type) ->
            val json = app.post(
                url = "$directUrl/wp-admin/admin-ajax.php",
                data = mapOf(
                    "action" to "doo_player_ajax", "post" to id, "nume" to nume, "type" to type, "_n" to idlixNonce, "_p" to id, "_t" to idlixTime
                ),
                referer = data,
                headers = mapOf("Accept" to "*/*", "X-Requested-With" to "XMLHttpRequest")
            ).parsedSafe<ResponseHash>() ?: return@amap
            val metrix = AppUtils.parseJson<AesData>(json.embed_url).m
            val password = createKey(json.key, metrix)
            val decrypted =
                AesHelper.cryptoAESHandler(json.embed_url, password.toByteArray(), false)
                    ?.fixBloat() ?: return@amap
            Log.d("Phisher",decrypted.toJson())

            when {
                !decrypted.contains("youtube") ->
                    loadExtractor(decrypted,directUrl,subtitleCallback,callback)
                else -> return@amap
            }

        }

        return true
    }

    private fun createKey(r: String, m: String): String {
        val rList = r.split("\\x").filter { it.isNotEmpty() }.toTypedArray()
        var n = ""
        var reversedM = m.split("").reversed().joinToString("")
        while (reversedM.length % 4 != 0) reversedM += "="
        val decodedBytes = try {
            base64Decode(reversedM)
        } catch (_: Exception) {
            return ""
        }
        val decodedM = String(decodedBytes.toCharArray())
        for (s in decodedM.split("|")) {
            try {
                val index = Integer.parseInt(s)
                if (index in rList.indices) {
                    n += "\\x" + rList[index]
                }
            } catch (_: Exception) {
            }
        }
        return n
    }

    private fun String.fixBloat(): String {
        return this.replace("\"", "").replace("\\", "")
    }

    data class ResponseSource(
        @JsonProperty("hls") val hls: Boolean,
        @JsonProperty("videoSource") val videoSource: String,
        @JsonProperty("securedLink") val securedLink: String?,
    )

    data class Tracks(
        @JsonProperty("kind") val kind: String?,
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String?,
    )

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("key") val key: String,
    )

    data class AesData(
        @JsonProperty("m") val m: String,
    )


}



================================================
FILE: IdlixProvider/src/main/kotlin/com/hexated/IdlixProviderPlugin.kt
================================================

package com.hexated

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class IdlixProviderPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(IdlixProvider())
        registerExtractorAPI(Jeniusplay())
    }
}


================================================
FILE: IPTVPlayer/build.gradle.kts
================================================
// use an integer for version numbers
version = 6


cloudstream {
    // All of these properties are optional, you can safely remove them
    language = "hi"
    description = "IPTV Player"
    authors = listOf("Phisher98,Adippe")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Live",
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/IPTV.png"

    isCrossPlatform = true
}



================================================
FILE: IPTVPlayer/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: IPTVPlayer/src/main/kotlin/com/Phisher98/IPTVPlayer.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newDrmExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.io.InputStream
import java.util.UUID

class IPTVPlayer : MainAPI() {
    override var lang = "hi"
    override var mainUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/main/15APR2024.m3u"
    override var name = "IPTV Player"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Live,
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val data = IptvPlaylistParser().parseM3U(app.get(mainUrl).text)
        return newHomePageResponse(data.items.groupBy{it.attributes["group-title"]}.map { group ->
            val title = group.key ?: ""
            val show = group.value.map { channel ->
                val streamurl = channel.url.toString()
                val channelname = channel.title.toString()
                val posterurl = channel.attributes["tvg-logo"].toString()
                val nation = channel.attributes["group-title"].toString()
                val key=channel.attributes["key"].toString()
                val keyid=channel.attributes["keyid"].toString()
                newLiveSearchResponse(channelname, LoadData(streamurl, channelname, posterurl, nation, key, keyid).toJson(), TvType.Live)
                {
                    this.posterUrl=posterurl
                    this.apiName
                    this.lang=channel.attributes["group-title"]
                }
            }
            HomePageList(
                title,
                show,
                isHorizontalImages = true
            )
        })
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val data = IptvPlaylistParser().parseM3U(app.get(mainUrl).text)
        return data.items.filter { it.title?.contains(query,ignoreCase = true) ?: false }.map { channel ->
                val streamurl = channel.url.toString()
                val channelname = channel.title.toString()
                val posterurl = channel.attributes["tvg-logo"].toString()
                val nation = channel.attributes["group-title"].toString()
                val key=channel.attributes["key"].toString()
                val keyid=channel.attributes["keyid"].toString()
            newLiveSearchResponse(channelname, LoadData(streamurl, channelname, posterurl, nation, key, keyid).toJson(), TvType.Live)
            {
                this.posterUrl=posterurl
                this.apiName
                this.lang=channel.attributes["group-title"]
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val data = parseJson<LoadData>(url)
        return newLiveStreamLoadResponse(data.title,data.url,url)
        {
            this.posterUrl=data.poster
            this.plot=data.nation
        }
    }
    data class LoadData(
        val url: String,
        val title: String,
        val poster: String,
        val nation: String,
        val key: String,
        val keyid: String,
    )
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        if (loadData.url.contains("mpd"))
        {
            callback.invoke(
                newDrmExtractorLink(
                    this.name,
                    this.name,
                    loadData.url,
                    INFER_TYPE,
                    UUID.randomUUID()
                )
                {
                    this.quality=Qualities.Unknown.value
                    this.key=loadData.key.trim()
                    this.kid=loadData.keyid.trim()
                }
            )
        }
            else
        if(loadData.url.contains("&e=.m3u"))
            {
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = loadData.url,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = ""
                        this.quality = Qualities.Unknown.value
                    }
                )

            }
        else
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    loadData.title,
                    url = loadData.url,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = Qualities.Unknown.value
                }
            )

        }
        return true
    }
}


data class Playlist(
    val items: List<PlaylistItem> = emptyList(),
)

data class PlaylistItem(
    val title: String? = null,
    val attributes: Map<String, String> = emptyMap(),
    val headers: Map<String, String> = emptyMap(),
    val url: String? = null,
    val userAgent: String? = null,
    val key: String? = null,
    val keyid: String? = null,
)


class IptvPlaylistParser {


    /**
     * Parse M3U8 string into [Playlist]
     *
     * @param content M3U8 content string.
     * @throws PlaylistParserException if an error occurs.
     */
    fun parseM3U(content: String): Playlist {
        return parseM3U(content.byteInputStream())
    }

    /**
     * Parse M3U8 content [InputStream] into [Playlist]
     *
     * @param input Stream of input data.
     * @throws PlaylistParserException if an error occurs.
     */
    @Throws(PlaylistParserException::class)
    fun parseM3U(input: InputStream): Playlist {
        val reader = input.bufferedReader()

        if (!reader.readLine().isExtendedM3u()) {
            throw PlaylistParserException.InvalidHeader()
        }

        val playlistItems = mutableListOf<PlaylistItem>()

        var currentTitle: String? = null
        var currentAttributes: Map<String, String> = emptyMap()
        var currentUserAgent: String? = null
        var currentReferrer: String? = null
        var currentHeaders: Map<String, String> = emptyMap()

        reader.forEachLine { line ->
            val trimmedLine = line.trim()
            if (trimmedLine.isEmpty()) return@forEachLine

            when {
                trimmedLine.startsWith(EXT_INF) -> {
                    currentTitle = trimmedLine.getTitle()
                    currentAttributes = trimmedLine.getAttributes()
                    // Reset fields in case the last item was incomplete
                    currentUserAgent = null
                    currentReferrer = null
                    currentHeaders = emptyMap()
                }

                trimmedLine.startsWith(EXT_VLC_OPT) -> {
                    val userAgent = trimmedLine.getTagValue("http-user-agent")
                    val referrer = trimmedLine.getTagValue("http-referrer")
                    currentUserAgent = userAgent ?: currentUserAgent
                    currentReferrer = referrer ?: currentReferrer
                    if (currentReferrer != null) {
                        currentHeaders = currentHeaders + mapOf("referrer" to currentReferrer!!)
                    }
                }

                !trimmedLine.startsWith("#") -> {
                    val url = trimmedLine.getUrl()
                    val uaParam = trimmedLine.getUrlParameter("user-agent")
                    val refParam = trimmedLine.getUrlParameter("referer")
                    val key = trimmedLine.getUrlParameter("key")
                    val keyid = trimmedLine.getUrlParameter("keyid")

                    val combinedUserAgent = uaParam ?: currentUserAgent
                    val ref = refParam ?: currentReferrer

                    val urlHeaders = if (ref != null) {
                        currentHeaders + mapOf("referrer" to ref)
                    } else currentHeaders

                    if (currentTitle != null) {
                        playlistItems.add(
                            PlaylistItem(
                                currentTitle ?: "",
                                attributes = currentAttributes,
                                url = url,
                                userAgent = combinedUserAgent,
                                headers = urlHeaders,
                                key = key,
                                keyid = keyid
                            )
                        )
                    }

                    // Reset state for next block
                    currentTitle = null
                    currentAttributes = emptyMap()
                    currentUserAgent = null
                    currentReferrer = null
                    currentHeaders = emptyMap()
                }
            }
        }

        return Playlist(playlistItems)
    }
    /**
     * Replace "" (quotes) from given string.
     */
    private fun String.replaceQuotesAndTrim(): String {
        return replace("\"", "").trim()
    }

    /**
     * Check if given content is valid M3U8 playlist.
     */
    private fun String.isExtendedM3u(): Boolean = startsWith(EXT_M3U)

    /**
     * Get title of media.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTINF:-1 tvg-id="1234" group-title="Kids" tvg-logo="url/to/logo", Title
     * ```
     * Result: Title
     */
    private fun String.getTitle(): String? {
        return split(",").lastOrNull()?.replaceQuotesAndTrim()
    }

    /**
     * Get media url.
     *
     * Example:-
     *
     * Input:
     * ```
     * https://example.com/sample.m3u8|user-agent="Custom"
     * ```
     * Result: https://example.com/sample.m3u8
     */
    private fun String.getUrl(): String? {
        return split("|").firstOrNull()?.replaceQuotesAndTrim()
    }

    /**
     * Get url parameters.
     *
     * Example:-
     *
     * Input:
     * ```
     * http://192.54.104.122:8080/d/abcdef/video.mp4|User-Agent=Mozilla&Referer=CustomReferrer
     * ```
     * Result will be equivalent to kotlin map:
     * ```Kotlin
     * mapOf(
     *   "User-Agent" to "Mozilla",
     *   "Referer" to "CustomReferrer"
     * )
     * ```
     */
  /*  private fun String.getUrlParameters(): Map<String, String> {
        val urlRegex = Regex("^(.*)\\|", RegexOption.IGNORE_CASE)
        val headersString = replace(urlRegex, "").replaceQuotesAndTrim()
        return headersString.split("&").mapNotNull {
            val pair = it.split("=")
            if (pair.size == 2) pair.first() to pair.last() else null
        }.toMap()
    }

   */

    /**
     * Get url parameter with key.
     *
     * Example:-
     *
     * Input:
     * ```
     * http://192.54.104.122:8080/d/abcdef/video.mp4|User-Agent=Mozilla&Referer=CustomReferrer
     * ```
     * If given key is `user-agent`, then
     *
     * Result: Mozilla
     */
    private fun String.getUrlParameter(key: String): String? {
        val urlRegex = Regex("^(.*)\\|", RegexOption.IGNORE_CASE)
        val keyRegex = Regex("$key=(\\w[^&]*)", RegexOption.IGNORE_CASE)
        val paramsString = replace(urlRegex, "").replaceQuotesAndTrim()
        return keyRegex.find(paramsString)?.groups?.get(1)?.value
    }

    /**
     * Get attributes from `#EXTINF` tag as Map<String, String>.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTINF:-1 tvg-id="1234" group-title="Kids" tvg-logo="url/to/logo", Title
     * ```
     * Result will be equivalent to kotlin map:
     * ```Kotlin
     * mapOf(
     *   "tvg-id" to "1234",
     *   "group-title" to "Kids",
     *   "tvg-logo" to "url/to/logo"
     *)
     * ```
     */
    private fun String.getAttributes(): Map<String, String> {
        val extInfRegex = Regex("(#EXTINF:.?[0-9]+)", RegexOption.IGNORE_CASE)
        val attributesString = replace(extInfRegex, "").replaceQuotesAndTrim().split(",").first()
        return attributesString.split(Regex("\\s")).mapNotNull {
            val pair = it.split("=")
            if (pair.size == 2) pair.first() to pair.last()
                .replaceQuotesAndTrim() else null
        }.toMap()
    }

    /**
     * Get value from a tag.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTVLCOPT:http-referrer=http://example.com/
     * ```
     * Result: http://example.com/
     */
    private fun String.getTagValue(key: String): String? {
        val keyRegex = Regex("$key=(.*)", RegexOption.IGNORE_CASE)
        return keyRegex.find(this)?.groups?.get(1)?.value?.replaceQuotesAndTrim()
    }

    companion object {
        const val EXT_M3U = "#EXTM3U"
        const val EXT_INF = "#EXTINF"
        const val EXT_VLC_OPT = "#EXTVLCOPT"
    }

}

/**
 * Exception thrown when an error occurs while parsing playlist.
 */
sealed class PlaylistParserException(message: String) : Exception(message) {

    /**
     * Exception thrown if given file content is not valid.
     */
    class InvalidHeader :
        PlaylistParserException("Invalid file header. Header doesn't start with #EXTM3U")

}



================================================
FILE: IPTVPlayer/src/main/kotlin/com/Phisher98/IPTVPlayerPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class IPTVPlayerPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(IPTVPlayer())
    }
}


================================================
FILE: Jellyfin/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

version = 3

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them
     description = "Jellyfin is a Free Software Media System that puts you in control of managing and streaming your media"
     authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
        "Cartoon",
        "AnimeMovie"
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/jellyfin.png"

    requiresResources = true
    isCrossPlatform = false

}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    implementation("com.google.android.material:material:1.12.0")
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: Jellyfin/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Jellyfin/src/main/kotlin/com/phisher98/Jellyfin.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.delay
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody

open class Jellyfin(sharedPref: SharedPreferences? = null) : MainAPI() {
    override var name = "Jellyfin"
    override val hasMainPage = true
    override val instantLinkLoading = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(
        TvType.Movie, TvType.TvSeries, TvType.Anime, TvType.Cartoon
    )

    private val url = sharedPref?.getString("url", null)
    private val username = sharedPref?.getString("username", null)
    private val password = sharedPref?.getString("password", null)

    private var cachedAuth: Authparser? = null
    private var lastAuthTime: Long = 0
    private val authCacheDuration = 30 * 60 * 1000 // 30 minutes

    private fun buildAuthHeader(token: String? = null): String {
        return buildString {
            append("""MediaBrowser Client="Jellyfin Web", Device="Chrome", DeviceId="Example", Version="10.10.7"""")
            if (!token.isNullOrEmpty()) append(""", Token="$token"""")
        }
    }

    private suspend fun getValidAuth(): Authparser {
        val currentTime = System.currentTimeMillis()
        if (cachedAuth != null && (currentTime - lastAuthTime) < authCacheDuration) {
            return cachedAuth!!
        }
        val newAuth = authenticateJellyfin(username, password, url)
            ?: throw Exception("Authentication failed. Check Jellyfin credentials.")
        cachedAuth = newAuth
        lastAuthTime = currentTime
        return newAuth
    }

    private suspend fun <T> withAuthRetry(
        retries: Int = 3,
        delayMillis: Long = 300L,
        block: suspend (Authparser) -> T
    ): T {
        repeat(retries - 1) {
            try {
                return block(getValidAuth())
            } catch (e: Exception) {
                val msg = e.message.orEmpty()
                Log.d("AuthRetry", "Auth attempt ${it + 1} failed: $msg")
                if (msg.contains("401") || msg.contains("403") || msg.contains("token", ignoreCase = true)) {
                    cachedAuth = null
                    lastAuthTime = 0
                } else {
                    throw e
                }
                delay(delayMillis)
            }
        }
        return block(getValidAuth())
    }

    private suspend fun authenticateJellyfin(
        username: String?, password: String?, url: String?
    ): Authparser? {
        val requestUrl = "$url/Users/authenticatebyname"
        val headers = mapOf(
            "Authorization" to buildAuthHeader(),
            "Content-Type" to "application/json",
            "User-Agent" to "Mozilla/5.0"
        )
        val jsonInput = """{"Username":"$username","Pw":"$password"}"""
        return app.post(requestUrl, requestBody = jsonInput.toRequestBody(), headers = headers).parsedSafe()
    }

    override val mainPage = mainPageOf("HomePage" to "HomePage")

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        if (username.isNullOrBlank() || password.isNullOrBlank() || url.isNullOrBlank()) {
            throw Exception("Please configure the extension with a valid URL, username, and password.")
        }

        return withAuthRetry { auth ->
            val headers = mapOf("Authorization" to buildAuthHeader(auth.accessToken))

            if (request.name.contains("HomePage")) {
                val api = "$url/UserViews?userId=${auth.user.id}"
                val userViews = app.get(api, headers).parsedSafe<Home>()
                    ?: throw Exception("Failed to load user views.")

                val homePageLists = userViews.items.mapNotNull { parentItem ->
                    val itemsApi = "$url/Users/${auth.user.id}/Items?ParentId=${parentItem.id}&SortOrder=Ascending"
                    val items = app.get(itemsApi, headers).parsedSafe<Home>()?.items.orEmpty()
                    if (items.isEmpty()) return@mapNotNull null
                    val list = items.map { toSearchResponseBase(it.id, it.name, it.type, auth.user.id) }
                    HomePageList(name = parentItem.name, list = list)
                }
                newHomePageResponse(homePageLists, hasNext = false)
            } else {
                throw Exception("Invalid homepage request.")
            }
        }
    }

    private fun toSearchResponseBase(id: String, name: String, typeStr: String?, userId: String): SearchResponse {
        val poster = "$url/Items/$id/Images/Primary"
        val type = when (typeStr?.lowercase()) {
            "tvshows", "shows", "series" -> TvType.TvSeries
            "movies", "movie" -> TvType.Movie
            else -> TvType.Movie
        }
        return newMovieSearchResponse(name, LoadData(name, poster, type, id, userId).toJson(), type) {
            this.posterUrl = poster
        }
    }

    override suspend fun quickSearch(query: String) = search(query)

    override suspend fun search(query: String): List<SearchResponse> {
        return withAuthRetry { auth ->
            val headers = mapOf(
                "Accept" to "application/json",
                "Authorization" to buildAuthHeader(auth.accessToken),
                "Content-Type" to "application/json"
            )
            val response = app.get(
                "$url/Items?userId=${auth.user.id}&limit=100&recursive=true&searchTerm=$query",
                headers = headers
            ).parsedSafe<SearchResult>()

            response?.items?.map { toSearchResponseBase(it.id, it.name, it.type, auth.user.id) } ?: emptyList()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val loadData = parseJson<LoadData>(url)
        val baseUrl = this.url ?: throw Exception("Jellyfin URL is not configured.")

        return withAuthRetry { auth ->
            val headers = mapOf(
                "Accept" to "application/json",
                "Authorization" to buildAuthHeader(auth.accessToken),
                "Content-Type" to "application/json"
            )

            val id = loadData.id
            val userId = loadData.userid
            val type = loadData.type
            val movieApi = "$baseUrl/Users/$userId/Items/$id"
            val moviefetch = app.get(movieApi, headers).parsedSafe<MovieMetadata>()

            if (type == TvType.TvSeries) {
                val parentId = app.get(movieApi, headers).parsedSafe<SeriesInfo>()?.id
                val seasons = app.get("$baseUrl/Shows/$parentId/Seasons?userId=$userId", headers)
                    .parsedSafe<SeasonResponse>()?.items.orEmpty()
                    .filter { it.name.contains("Season", ignoreCase = true) }
                    .map { it.id to it.name }

                val episodes = seasons.flatMap { (seasonId, _) ->
                    val episoderes = app.get(
                        "$baseUrl/Shows/$parentId/Episodes?seasonId=$seasonId&userId=$userId", headers
                    ).parsedSafe<EpisodeJson>()?.items.orEmpty()

                    episoderes.map { item ->
                        val season = Regex("""\d+""").find(item.seasonName ?: "")?.value?.toIntOrNull() ?: 1
                        newEpisode(item.id) {
                            this.name = item.name
                            this.episode = item.indexNumber
                            this.season = season
                            this.posterUrl = item.getPosterUrl(baseUrl)
                        }
                    }
                }

                newTvSeriesLoadResponse(loadData.name, url, type, episodes) {
                    this.posterUrl = loadData.posterurl
                    this.plot = moviefetch?.overview
                    this.tags = moviefetch?.genres
                    addActors(moviefetch?.people?.map { it.name })
                    addImdbId(moviefetch?.providerIds?.imdb)
                    addImdbId(moviefetch?.providerIds?.tmdb)
                    addImdbUrl(moviefetch?.externalUrls?.firstOrNull { it.name.equals("IMDb", true) }?.url)
                    addTrailer(moviefetch?.remoteTrailers?.firstOrNull { it.url.contains("youtube", true) }?.url)
                }
            } else {
                newMovieLoadResponse(loadData.name, url, type, id) {
                    this.posterUrl = loadData.posterurl
                    this.plot = moviefetch?.overview
                    this.tags = moviefetch?.genres
                    addActors(moviefetch?.people?.map { it.name })
                    addImdbId(moviefetch?.providerIds?.imdb)
                    addImdbId(moviefetch?.providerIds?.tmdb)
                    addImdbUrl(moviefetch?.externalUrls?.firstOrNull { it.name.equals("IMDb", true) }?.url)
                    addTrailer(moviefetch?.remoteTrailers?.firstOrNull { it.url.contains("youtube", true) }?.url)
                }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        return withAuthRetry { auth ->
            val streamUrl = fetchPlaybackInfo(data.substringAfter("/"), auth.user.id)
            callback(newExtractorLink(name, name, streamUrl, INFER_TYPE) {
                this.quality = getQualityFromName(streamUrl)
            })
            true
        }
    }

    private suspend fun fetchPlaybackInfo(id: String, userId: String): String {
        return withAuthRetry { auth ->
            val apiUrl = "$url/Items/$id/PlaybackInfo"
            val headers = mapOf(
                "Authorization" to buildAuthHeader(auth.accessToken),
                "Content-Type" to "application/json"
            )
            val body = """
            {
                "UserId": "$userId",
                "StartTimeTicks": 0,
                "IsPlayback": true,
                "AutoOpenLiveStream": true,
                "MediaSourceId": "$id"
            }
            """.trimIndent()

            val response = retryRequest {
                app.post(apiUrl, headers, requestBody = body.toRequestBody("application/json".toMediaType()))
                    .parsedSafe<LoadURL>()
            }

            val mediaSource = response?.mediaSources?.firstOrNull()
            val httpPath = mediaSource?.path

            if (
                httpPath != null &&
                httpPath.startsWith("http", ignoreCase = true) &&
                mediaSource.supportsDirectPlay &&
                mediaSource.protocol.equals("http", ignoreCase = true)
            ) {
                val redirectUrl = app.get(httpPath, allowRedirects = false).headers["location"] ?: ""
                return@withAuthRetry if (redirectUrl.isNotEmpty()) redirectUrl else httpPath
            }

            mediaSource?.transcodingUrl?.let { transcodingUrl ->
                return@withAuthRetry if (transcodingUrl.startsWith("http", ignoreCase = true)) {
                    transcodingUrl
                } else {
                    "$url$transcodingUrl"
                }
            }

            return@withAuthRetry "$url/Videos/$id/stream.mp4?Static=true&mediaSourceId=$id"
        }
    }

    private fun EpisodeItem.getPosterUrl(baseUrl: String): String? {
        return imageTags?.primary?.let { "$baseUrl/Items/$id/Images/Primary?tag=$it" }
    }

    private suspend fun <T> retryRequest(
        times: Int = 3,
        delayMillis: Long = 300L,
        block: suspend () -> T?
    ): T? {
        repeat(times - 1) {
            try {
                val result = block()
                if (result != null) return result
            } catch (e: Exception) {
                if (!e.message.orEmpty().contains("500")) throw e
            }
            delay(delayMillis)
        }
        return try { block() } catch (e: Exception) {
            if (e.message.orEmpty().contains("500")) null else throw e
        }
    }
}



================================================
FILE: Jellyfin/src/main/kotlin/com/phisher98/JellyfinParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.TvType


data class LoadData(
    val name: String,
    val posterurl: String,
    val type: TvType,
    val id: String,
    val userid: String,
)

//JellyFin


data class Authparser(
    @JsonProperty("AccessToken")
    val accessToken: String,
    @JsonProperty("ServerId")
    val serverId: String,
    @JsonProperty("User")
    val user: User,
)

data class User(
    @JsonProperty("Name")
    val name: String,
    @JsonProperty("ServerId")
    val serverId: String,
    @JsonProperty("Id")
    val id: String,
)

//Homepage

data class Home(
    @JsonProperty("Items")
    val items: List<HomeItem>,
    @JsonProperty("TotalRecordCount")
    val totalRecordCount: Long,
    @JsonProperty("StartIndex")
    val startIndex: Long
)

data class HomeItem(
    @JsonProperty("Name")
    val name: String,
    @JsonProperty("Id")
    val id: String,
    @JsonProperty("IsFolder")
    val isFolder: Boolean = false,
    @JsonProperty("Type")
    val type: String? = null,
    @JsonProperty("ProductionYear")
    val productionYear: Int? = null,
    @JsonProperty("PremiereDate")
    val premiereDate: String? = null,
    @JsonProperty("ImageTags")
    val imageTags: Map<String, String>? = null,
)

//LoadURL

data class LoadURL(
    @JsonProperty("MediaSources")
    val mediaSources: List<MediaSource>,
    @JsonProperty("PlaySessionId")
    val playSessionId: String,
)

data class MediaSource(
    @JsonProperty("TranscodingUrl")
    val transcodingUrl: String? = null,
    @JsonProperty("Path")
    val path: String? = null,
    @JsonProperty("SupportsDirectPlay")
    val supportsDirectPlay: Boolean = false,
    @JsonProperty("Protocol")
    val protocol: String = "",
    @JsonProperty("SupportsTranscoding")
    val supportsTranscoding: Boolean = false,
    @JsonProperty("SupportsDirectStream")
    val supportsDirectStream: Boolean = false,
    @JsonProperty("Id")
    val id: String? = null,
    @JsonProperty("Container")
    val container: String? = null,
    @JsonProperty("DefaultAudioStreamIndex")
    val defaultAudioStreamIndex: Int? = null
)

data class SeriesInfo(
    @JsonProperty("Id") val id: String,
    @JsonProperty("ParentId") val parentId: String?,
    @JsonProperty("Name") val name: String,
    @JsonProperty("Overview") val overview: String?,
    @JsonProperty("ProductionYear") val productionYear: Int?,
    @JsonProperty("ImageTags") val imageTags: ImageTags?,
    @JsonProperty("PrimaryImageAspectRatio") val primaryImageAspectRatio: Double?,
    @JsonProperty("People") val people: List<Person> = emptyList()
)

data class ImageTags(
    @JsonProperty("Primary")
    val primary: String?
)

data class Person(
    @JsonProperty("Name")
    val name: String,

    @JsonProperty("Role")
    val role: String,

    @JsonProperty("Type")
    val type: String
)

data class SeasonItem(
    @JsonProperty("Id") val id: String,
    @JsonProperty("Name") val name: String
)

data class SeasonResponse(
    @JsonProperty("Items") val items: List<SeasonItem> = emptyList()
)


//Episodes

data class EpisodeJson(
    @JsonProperty("Items")
    val items: List<EpisodeItem>? = emptyList()
)

data class EpisodeItem(
    @JsonProperty("Id")
    val id: String,
    @JsonProperty("Name")
    val name: String,
    @JsonProperty("IndexNumber")
    val indexNumber: Int? = null,
    @JsonProperty("SeasonName")
    val seasonName: String? = null,
    @JsonProperty("ImageTags")
    val imageTags: EpisodeImageTags? = null
)

data class EpisodeImageTags(
    @JsonProperty("Primary")
    val primary: String?
)

//Metadata
data class MovieMetadata(
    @JsonProperty("People")
    val people: List<MovieMetadataPerson> = emptyList(),

    @JsonProperty("Name")
    val name: String,

    @JsonProperty("OriginalTitle")
    val originalTitle: String,

    @JsonProperty("Overview")
    val overview: String,

    @JsonProperty("ProductionYear")
    val productionYear: Long,

    @JsonProperty("ProviderIds")
    val providerIds: ProviderIds,

    @JsonProperty("ExternalUrls")
    val externalUrls: List<ExternalUrl>,

    @JsonProperty("CommunityRating")
    val communityRating: Double,

    @JsonProperty("Genres")
    val genres: List<String>,

    @JsonProperty("Id")
    val id: String,

    @JsonProperty("ImageTags")
    val imageTags: MovieMetadataImageTags,

    @JsonProperty("RemoteTrailers")
    val remoteTrailers: List<RemoteTrailer>
)

data class ProviderIds(
    @JsonProperty("Tmdb")
    val tmdb: String? = null,

    @JsonProperty("Imdb")
    val imdb: String? = null,

    @JsonProperty("Tvdb")
    val tvdb: String? = null
)

data class ExternalUrl(
    @JsonProperty("Name")
    val name: String,

    @JsonProperty("Url")
    val url: String
)

data class MovieMetadataImageTags(
    @JsonProperty("Primary")
    val primary: String? = null
)

data class RemoteTrailer(
    @JsonProperty("Url")
    val url: String
)

data class MovieMetadataPerson(
    @JsonProperty("Name")
    val name: String,

    @JsonProperty("Id")
    val id: String,

    @JsonProperty("Role")
    val role: String,

    @JsonProperty("Type")
    val type: String,

    @JsonProperty("PrimaryImageTag")
    val primaryImageTag: String? = null,

    @JsonProperty("ImageBlurHashes")
    val imageBlurHashes: ImageBlurHashesWrapper? = null
)

data class ImageBlurHashesWrapper(
    @JsonProperty("Primary")
    val primary: Map<String, String> = emptyMap()
)

//Search

data class SearchResult(
    @JsonProperty("Items")
    val items: List<SearchItem>,

    @JsonProperty("TotalRecordCount")
    val totalRecordCount: Int,

    @JsonProperty("StartIndex")
    val startIndex: Int
)

data class SearchItem(
    @JsonProperty("Name")
    val name: String,

    @JsonProperty("Id")
    val id: String,

    @JsonProperty("ServerId")
    val serverId: String? = null,

    @JsonProperty("Type")
    val type: String? = null,

    @JsonProperty("ProductionYear")
    val productionYear: Int? = null,

    @JsonProperty("PremiereDate")
    val premiereDate: String? = null,

    @JsonProperty("ImageTags")
    val imageTags: SearchImageTags? = null,

    @JsonProperty("BackdropImageTags")
    val backdropImageTags: List<String>? = null,

    @JsonProperty("HasSubtitles")
    val hasSubtitles: Boolean? = null,

    @JsonProperty("RunTimeTicks")
    val runTimeTicks: Long? = null,

    @JsonProperty("MediaType")
    val mediaType: String? = null,

    @JsonProperty("IsFolder")
    val isFolder: Boolean = false,

    @JsonProperty("Container")
    val container: String? = null,

    @JsonProperty("CommunityRating")
    val communityRating: Double? = null,

    @JsonProperty("OfficialRating")
    val officialRating: String? = null,

    @JsonProperty("UserData")
    val userData: UserData? = null
)

data class SearchImageTags(
    @JsonProperty("Primary")
    val primary: String? = null,

    @JsonProperty("Logo")
    val logo: String? = null
)

data class UserData(
    @JsonProperty("PlaybackPositionTicks")
    val playbackPositionTicks: Long? = null,

    @JsonProperty("PlayCount")
    val playCount: Int? = null,

    @JsonProperty("IsFavorite")
    val isFavorite: Boolean? = null,

    @JsonProperty("Played")
    val played: Boolean? = null
)


================================================
FILE: Jellyfin/src/main/kotlin/com/phisher98/JellyfinPlugin.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.phisher98.settings.SettingsFragment
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin

@CloudstreamPlugin
class JellyfinPlugin: Plugin() {
    override fun load(context: Context) {
        val sharedPref = context.getSharedPreferences("SuperStream", Context.MODE_PRIVATE)
        registerMainAPI(Jellyfin(sharedPref))
        val activity = context as AppCompatActivity
        openSettings = {
            val frag = SettingsFragment(this, sharedPref)
            frag.show(activity.supportFragmentManager, "SettingsFragment")
        }
    }
}


================================================
FILE: Jellyfin/src/main/kotlin/com/phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.text.InputType
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.EditText
import android.widget.ImageView
import androidx.annotation.RequiresApi
import androidx.fragment.app.DialogFragment
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.phisher98.BuildConfig
import androidx.appcompat.app.AlertDialog
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.JellyfinPlugin
import androidx.core.content.edit

class SettingsFragment(
    plugin: JellyfinPlugin,
    private val sharedPref: SharedPreferences,
) : DialogFragment() {

    private val res = plugin.resources ?: throw Exception("Unable to read resources")
    private lateinit var URL: String
    private lateinit var Username: String
    private lateinit var Password: String

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Resources.NotFoundException("View ID $name not found.")
        return this.findViewById(id)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Resources.NotFoundException("Layout $name not found.")
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
            ?: throw Resources.NotFoundException("Drawable $name not found.")
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?,
    ): View? {
        val view = getLayout("settings_fragment", inflater, container)

        val saveButton = view.findView<Button>("saveCredentialsButton")
        val closeButton = view.findView<ImageView>("closeButton")
        val urlInput = view.findView<EditText>("urlInput")
        val usernameInput = view.findView<EditText>("usernameInput")
        val passwordInput = view.findView<EditText>("passwordInput")
        val toggleVisibility = view.findView<ImageView>("togglePasswordVisibility")
        val resetButton = view.findView<Button>("resetCredentialsButton")

        toggleVisibility.setImageDrawable(getDrawable("ic_visibility_off"))

        var isPasswordVisible = false

        toggleVisibility.setOnClickListener {
            isPasswordVisible = !isPasswordVisible

            if (isPasswordVisible) {
                passwordInput.inputType =
                    InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD
                toggleVisibility.setImageDrawable(getDrawable("ic_visibility"))
            } else {
                passwordInput.inputType =
                    InputType.TYPE_CLASS_TEXT or InputType.TYPE_TEXT_VARIATION_PASSWORD
                toggleVisibility.setImageDrawable(getDrawable("ic_visibility_off"))
            }

            // Preserve cursor position
            passwordInput.setSelection(passwordInput.text?.length ?: 0)
        }

        saveButton.makeTvCompatible()
        resetButton.makeTvCompatible()

        saveButton.setOnClickListener {
            // Get and trim values
            URL = urlInput.text.toString().trim()
            Username = usernameInput.text.toString().trim()
            Password = passwordInput.text.toString().trim()

            if (URL.isEmpty() || Username.isEmpty() || Password.isEmpty()) {
                showToast("Please fill all fields")
            } else {
                sharedPref.edit()?.apply {
                    putString("url", URL)
                    putString("username", Username)
                    putString("password", Password)
                    apply()
                }

                showToast("Credentials Saved")

                AlertDialog.Builder(requireContext())
                    .setTitle("Save & Reload")
                    .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                    .setPositiveButton("Yes") { _, _ ->
                        dismiss()
                        restartApp()
                    }
                    .setNegativeButton("No") { _, _ ->
                        dismiss()
                    }
                    .show()
            }
        }

        resetButton.setOnClickListener {
            sharedPref.edit { clear() }
            urlInput.setText("")
            usernameInput.setText("")
            passwordInput.setText("")
            showToast("Credentials reset")
            AlertDialog.Builder(requireContext())
                .setTitle("Save & Reload")
                .setMessage("Reset Completed. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No") { _, _ ->
                    dismiss()
                }
                .show()
        }



        closeButton.setOnClickListener {
            dismiss()
        }

        return view
    }

    override fun onStart() {
        super.onStart()
        (dialog as? BottomSheetDialog)?.behavior?.apply {
            state = BottomSheetBehavior.STATE_EXPANDED
            skipCollapsed = true
            isDraggable = false
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setStyle(STYLE_NO_TITLE, android.R.style.Theme_Material_Light_Dialog_Alert)
    }

    @SuppressLint("SetJavaScriptEnabled", "SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        // no-op
    }

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: Jellyfin/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: Jellyfin/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: Jellyfin/src/main/res/drawable/focusable_button_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Focused state -->
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <solid android:color="#03DAC5" /> <!-- Cyan on focus -->
            <corners android:radius="6dp" />
        </shape>
    </item>

    <!-- Default state -->
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#1E1E1E" /> <!-- Neutral background -->
            <corners android:radius="6dp" />
        </shape>
    </item>
</selector>



================================================
FILE: Jellyfin/src/main/res/drawable/focusable_input_bg.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <solid android:color="#2A2A2A" />
            <stroke android:width="2dp" android:color="#03DAC5" />
            <corners android:radius="6dp" />
        </shape>
    </item>
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#1E1E1E" />
            <corners android:radius="6dp" />
        </shape>
    </item>
</selector>



================================================
FILE: Jellyfin/src/main/res/drawable/ic_visibility.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="24dp" android:height="24dp" android:viewportWidth="960" android:viewportHeight="960" android:tint="@android:color/white">
    <path android:fillColor="@android:color/white" android:pathData="M480,640Q555,640 607.5,587.5Q660,535 660,460Q660,385 607.5,332.5Q555,280 480,280Q405,280 352.5,332.5Q300,385 300,460Q300,535 352.5,587.5Q405,640 480,640ZM480,568Q435,568 403.5,536.5Q372,505 372,460Q372,415 403.5,383.5Q435,352 480,352Q525,352 556.5,383.5Q588,415 588,460Q588,505 556.5,536.5Q525,568 480,568ZM480,760Q334,760 214,678.5Q94,597 40,460Q94,323 214,241.5Q334,160 480,160Q626,160 746,241.5Q866,323 920,460Q866,597 746,678.5Q626,760 480,760ZM480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460Q480,460 480,460ZM480,680Q593,680 687.5,620.5Q782,561 832,460Q782,359 687.5,299.5Q593,240 480,240Q367,240 272.5,299.5Q178,359 128,460Q178,561 272.5,620.5Q367,680 480,680Z"/>
</vector>


================================================
FILE: Jellyfin/src/main/res/drawable/ic_visibility_off.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:width="24dp" android:height="24dp" android:viewportWidth="960" android:viewportHeight="960" android:tint="@android:color/white">
    <path android:fillColor="@android:color/white" android:pathData="M644,532L586,474Q595,427 559,386Q523,345 466,354L408,296Q425,288 442.5,284Q460,280 480,280Q555,280 607.5,332.5Q660,385 660,460Q660,480 656,497.5Q652,515 644,532ZM772,658L714,602Q752,573 781.5,538.5Q811,504 832,460Q782,359 688.5,299.5Q595,240 480,240Q451,240 423,244Q395,248 368,256L306,194Q347,177 390,168.5Q433,160 480,160Q631,160 749,243.5Q867,327 920,460Q897,519 859.5,569.5Q822,620 772,658ZM792,904L624,738Q589,749 553.5,754.5Q518,760 480,760Q329,760 211,676.5Q93,593 40,460Q61,407 93,361.5Q125,316 166,280L56,168L112,112L848,848L792,904ZM222,336Q193,362 169,393Q145,424 128,460Q178,561 271.5,620.5Q365,680 480,680Q500,680 519,677.5Q538,675 558,672L522,634Q511,637 501,638.5Q491,640 480,640Q405,640 352.5,587.5Q300,535 300,460Q300,449 301.5,439Q303,429 306,418L222,336ZM541,429L541,429Q541,429 541,429Q541,429 541,429Q541,429 541,429Q541,429 541,429Q541,429 541,429Q541,429 541,429ZM390,504Q390,504 390,504Q390,504 390,504L390,504Q390,504 390,504Q390,504 390,504Q390,504 390,504Q390,504 390,504Z"/>
</vector>


================================================
FILE: Jellyfin/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: Jellyfin/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: Jellyfin/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: Jellyfin/src/main/res/layout/settings_fragment.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:fillViewport="true"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:padding="24dp">

        <!-- Header -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="16dp">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Login"
                android:textSize="22sp"
                android:textStyle="bold"
                android:textColor="#FFFFFF" />

            <ImageView
                android:id="@+id/closeButton"
                android:layout_width="40dp"
                android:layout_height="40dp"
                android:padding="8dp"
                android:layout_marginStart="8dp"
                android:layout_marginEnd="4dp"
                android:focusable="true"
                android:clickable="true"
                android:background="?android:attr/selectableItemBackgroundBorderless"
                android:contentDescription="Close"
                android:src="@android:drawable/ic_menu_close_clear_cancel"
                android:scaleType="centerInside" />
        </LinearLayout>

        <!-- Server URL -->
        <EditText
            android:id="@+id/urlInput"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Server URL"
            android:textColorHint="#BBBBBB"
            android:textColor="#FFFFFF"
            android:inputType="textUri"
            android:textSize="18sp"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:background="?android:attr/editTextBackground"
            android:focusable="true"
            android:focusableInTouchMode="true"
            android:nextFocusDown="@id/usernameInput" />

        <!-- Username -->
        <EditText
            android:id="@+id/usernameInput"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Username"
            android:textColorHint="#BBBBBB"
            android:textColor="#FFFFFF"
            android:inputType="textEmailAddress"
            android:textSize="18sp"
            android:padding="16dp"
            android:layout_marginBottom="12dp"
            android:background="?android:attr/editTextBackground"
            android:focusable="true"
            android:focusableInTouchMode="true"
            android:nextFocusDown="@id/passwordInput" />

        <!-- Password + Eye -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginBottom="16dp">

            <EditText
                android:id="@+id/passwordInput"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:hint="Password"
                android:textColorHint="#BBBBBB"
                android:textColor="#FFFFFF"
                android:inputType="textPassword"
                android:textSize="18sp"
                android:padding="16dp"
                android:background="?android:attr/editTextBackground"
                android:focusable="true"
                android:focusableInTouchMode="true"
                android:nextFocusRight="@id/togglePasswordVisibility"
                android:nextFocusDown="@id/saveCredentialsButton" />

            <ImageView
                android:id="@+id/togglePasswordVisibility"
                android:layout_width="48dp"
                android:layout_height="match_parent"
                android:padding="12dp"
                android:background="?android:attr/selectableItemBackground"
                android:contentDescription="Toggle Password Visibility"
                android:focusable="true"
                android:clickable="true"
                android:scaleType="centerInside"
                android:src="@android:drawable/ic_menu_view"
                android:nextFocusDown="@id/saveCredentialsButton" />
        </LinearLayout>

        <!-- Save Button -->
        <Button
            android:id="@+id/saveCredentialsButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="SAVE CREDENTIALS"
            android:textColor="#FFFFFF"
            android:textAllCaps="true"
            android:textStyle="bold"
            android:textSize="18sp"
            android:background="@android:drawable/btn_default"
            android:backgroundTint="#4285F4"
            android:padding="14dp"
            android:elevation="4dp"
            android:focusable="true"
            android:clickable="true"
            android:nextFocusUp="@id/passwordInput" />

        <Button
            android:id="@+id/resetCredentialsButton"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Reset CREDENTIALS"
            android:textColor="#FFFFFF"
            android:textAllCaps="true"
            android:textStyle="bold"
            android:textSize="18sp"
            android:background="@android:drawable/btn_default"
            android:backgroundTint="#4285F4"
            android:padding="14dp"
            android:elevation="4dp"
            android:focusable="true"
            android:clickable="true"
            android:nextFocusUp="@id/saveCredentialsButton" />
    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: Jellyfin/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="header_tw">Login</string>
    <string name="text_hint">Token</string>
    <string name="Text_Token">Get Token from Febbox</string>
    <string name="insert_token">Insert Token</string>
    <string name="save_token">Save Token</string>
    <string name="reset_token">Reset Token</string>
</resources>


================================================
FILE: Kartoons/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Kartoons (Cartoon & Animes)"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://kartoons.fun/logo.png"

    isCrossPlatform = true
}



================================================
FILE: Kartoons/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Kartoons/src/main/kotlin/com/Kartoons/Kartoons.kt
================================================
package com.Kartoons


import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import okhttp3.Interceptor
import okhttp3.ResponseBody.Companion.toResponseBody

class Kartoons() : MainAPI() {
    override var mainUrl              = base64Decode("aHR0cHM6Ly9hcGkua2FydG9vbnMuZnVu")
    override var name                 = "Kartoons"
    override val hasMainPage          = true
    override var lang                 = "hi"
    override val hasDownloadSupport   = false
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.Cartoon)

    override val mainPage = mainPageOf(
        "api/shows" to "Shows",
        "api/movies" to "Movies",
        "api/popularity/shows?limit=15&period=day" to "Popular Shows",
        "api/popularity/movies?limit=15&period=day" to "Popular Movies"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val res = app.get("$mainUrl/${request.data}/?page=$page&limit=20").parsed<Home>()
        val home = res.data?.map { it.toSearchResult() }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home!!,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Data.toSearchResult(): SearchResponse {
        val title = this.title!!
        val href = fixUrl("/api/${this.type}s/${this.slug}")
        val poster = this.image
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = poster
            this.score = Score.from10(rating)
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query)
    override suspend fun search(query: String): List<SearchResponse> {
        val res = app.get("${mainUrl}/api/search/suggestions?q=$query&limit=5").parsedSafeLarge<Search>()?.data?.map {
            newMovieSearchResponse(it.title,fixUrl("/api/${it.type}s/${it.id}"), TvType.Movie)
            {
                this.posterUrl = it.image
            }
        } ?: emptyList()
        return res
    }

    override suspend fun load(url: String): LoadResponse {
        val json = app.get(url).parsedSafeLarge<Load>() ?: throw ErrorLoadingException("Failed to parse JSON")
        val res = json.data ?: throw ErrorLoadingException("Failed to parse load response")
        val title = res.title.orEmpty()
        val description = res.description.orEmpty()
        val poster = res.image.orEmpty()
        val backgroundPoster = res.coverImage ?: res.hoverImage.orEmpty()
        val startYear = res.startYear?.toInt()
        val rating = Score.from10(res.rating ?: 0.0 )
        val tags = res.tags ?: emptyList()
        val href = "$mainUrl/api/movies/${res.id}/links"


        val tvtag = if (res.type?.contains("movie", ignoreCase = true) == true) {
            TvType.Movie
        } else {
            TvType.TvSeries
        }

        val recommendations = json.related.orEmpty().map { rel ->
            newMovieSearchResponse(rel.title.orEmpty(),"$mainUrl/api/${rel.type}s/${rel.slug}", type = TvType.Movie).apply {
                this.posterUrl = rel.image
            }
        }


        return if (tvtag == TvType.TvSeries) {
            val allSeasonDetails = fetchSeasonDetailsForShow(res, mainUrl)

            val episodesList = mutableListOf<Episode>()

            allSeasonDetails.forEach { season ->
                val seasonNumber = season.seasonNumber?.toInt() ?: return@forEach

                season.episodes.forEach { ep ->
                    episodesList += newEpisode("$mainUrl/api/shows/episode/${ep.id}/links") {
                        this.season = seasonNumber
                        this.episode = ep.episodeNumber?.toInt() ?: 0
                        this.name = ep.title.orEmpty()
                        this.posterUrl = ep.image
                        this.description = ep.description
                        this.runTime = ep.durationMinutes?.toInt()
                        addDate(ep.createdAt?.iso.toString())
                    }
                }
            }


            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodesList) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.year = startYear
                this.score = rating
                this.tags = tags
                this.recommendations = recommendations
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundPoster
                this.plot = description
                this.year = startYear
                this.score = rating
                this.tags = tags
                this.recommendations = recommendations
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = app.get(data).parsedSafe<Loadlinks>()?.data ?: return false
        res.links?.forEach { link ->
            val encoded = link.url ?: return@forEach

            val m3u8 = try {
                decryptAesCbcBase64Url(encoded)
            } catch (e: Exception) {
                Log.e(name, "Decryption failed for ${link.name}: ${e.message}")
                return@forEach
            }

            if (m3u8.isBlank()) return@forEach
            callback.invoke(
                newExtractorLink(
                    name,
                    link.name ?: name,
                    m3u8,
                    ExtractorLinkType.M3U8
                )
                {
                    this.referer = m3u8
                }
            )
        }
        return true
    }

    private val ENC_LINE_REGEX by lazy {
        Regex("""^enc\d+:.+""", RegexOption.IGNORE_CASE)
    }

    override fun getVideoInterceptor(extractorLink: ExtractorLink): Interceptor {
        return Interceptor { chain ->
            val request = chain.request()
            val url = request.url.toString()
            Log.d(name, "Request URL: $url")

            val response = chain.proceed(request)
            val body = response.body
            val contentType = body.contentType()

            // Detect playlist; skip everything else (segments, TS, MP4, etc.)
            val isPlaylistUrl =
                url.endsWith(".m3u8", ignoreCase = true) ||
                        url.contains("playlist", ignoreCase = true)

            val ctString = contentType?.toString() ?: ""
            val isPlaylistContentType =
                ctString.contains("mpegurl", ignoreCase = true) ||
                        ctString.contains("m3u8", ignoreCase = true)

            if (!isPlaylistUrl && !isPlaylistContentType) {
                Log.d(name, "Not a playlist response, skipping rewrite")
                return@Interceptor response
            }

            val originalText = try {
                body.string()
            } catch (e: Exception) {
                Log.e(name, "Failed to read playlist body: ${e.message}")
                return@Interceptor response
            }

            Log.d(name, "Original playlist:\n$originalText")

            if (!originalText.contains("enc", ignoreCase = true)) {
                Log.d(name, "No enc lines found, returning original playlist")
                return@Interceptor response.newBuilder()
                    .body(originalText.toResponseBody(contentType))
                    .build()
            }

            val rewritten = originalText
                .lineSequence()
                .joinToString("\n") { rawLine ->
                    val line = rawLine.trimEnd()
                    val trimmed = line.trimStart()

                    if (ENC_LINE_REGEX.matches(trimmed)) {
                        Log.d(name, "Found encrypted line: $trimmed")
                        val decrypted = decryptStream(trimmed)
                        Log.d(name, "Decrypted line: ${decrypted ?: "FAILED"}")
                        decrypted ?: line
                    } else {
                        line
                    }
                }

            Log.d(name, "Rewritten playlist:\n$rewritten")

            response.newBuilder()
                .body(rewritten.toResponseBody(contentType))
                .build()
        }
    }




}


private suspend fun fetchSeasonDetailsForShow(
    showData: LoadData,
    mainUrl: String
): List<SeasonEpisodes> = coroutineScope {
    val showSlug = showData.slug ?: return@coroutineScope emptyList()

    showData.seasons.orEmpty()
        .mapNotNull { season ->
            val seasonSlug = season.slug ?: return@mapNotNull null

            async {
                val seasonUrl = "$mainUrl/api/shows/$showSlug/season/$seasonSlug/all-episodes"

                val root = app.get(seasonUrl)
                    .parsedSafeLarge<EpisodesRoot>()

                root?.let {
                    SeasonEpisodes(
                        seasonNumber = it.season?.seasonNumber,
                        episodes = it.data.orEmpty()
                    )
                }
            }
        }
        .awaitAll()
        .filterNotNull()
}






================================================
FILE: Kartoons/src/main/kotlin/com/Kartoons/KartoonsParser.kt
================================================
package com.Kartoons

import com.fasterxml.jackson.annotation.JsonProperty

data class Home(
    val success: Boolean? = null,
    val data: List<Data>? = null,
)

data class Data(
    @get:JsonProperty("_id")
    val id: String? = null,
    val title: String? = null,
    val image: String? = null,
    val coverImage: String? = null,
    val hoverImage: String? = null,
    val releaseYear: Long? = null,
    val rating: Double? = null,
    val tags: List<String>? = null,
    val slug: String? = null,
    val type: String? = null,
)


data class Load(
    val success: Boolean? = null,
    val data: LoadData? = null,
    val related: List<Related>? = null,
    val watchHistory: List<Any?>? = null,
    val userRating: Any? = null,
    val totalRatings: Long? = null,
)

data class LoadData(
    @JsonProperty("_id")
    val id: String? = null,
    val title: String? = null,
    val description: String? = null,
    val image: String? = null,
    val coverImage: String? = null,
    val hoverImage: String? = null,
    val startYear: Long? = null,
    val endYear: Long? = null,
    val status: String? = null,
    val rating: Double? = null,
    val featured: Boolean? = null,
    val tags: List<String>? = null,
    val createdAt: CreatedAt? = null,
    val updatedAt: UpdatedAt? = null,
    val slug: String? = null,
    val seasons: List<Season>? = null,
    val viewCount: Long? = null,
    val type: String? = null,
)

data class CreatedAt(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class UpdatedAt(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class Season(
    @JsonProperty("_id")
    val id: String? = null,
    val seasonNumber: Long? = null,
    val title: String? = null,
    val releaseYear: Long? = null,
    val showId: String? = null,
    val createdAt: CreatedAt2? = null,
    val updatedAt: UpdatedAt2? = null,
    val slug: String? = null,
    val episodeCount: Long? = null,
)

data class CreatedAt2(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class UpdatedAt2(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class Related(
    @JsonProperty("_id")
    val id: String? = null,
    val title: String? = null,
    val image: String? = null,
    val startYear: Long? = null,
    val rating: Double? = null,
    val tags: List<String>? = null,
    val slug: String? = null,
    val type: String? = null,
)

//Load Shows Parser
data class SeasonEpisodes(
    val seasonNumber: Long?,
    val episodes: List<EpisodeItem>,
)


data class EpisodesRoot(
    val success: Boolean? = null,
    val data: List<EpisodeItem>? = null,
    val season: EpisodeSeasonMeta? = null,
    val show: EpisodeShowMeta? = null,
)

data class EpisodeItem(
    @JsonProperty("_id")
    val id: String? = null,
    val seasonId: String? = null,
    val episodeNumber: Long? = null,
    val title: String? = null,
    val description: String? = null,
    val image: String? = null,
    val duration: String? = null,
    val createdAt: EpisodeCreatedAt? = null,
    val updatedAt: EpisodeUpdatedAt? = null,
    val durationMinutes: Long? = null,
)

data class EpisodeCreatedAt(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class EpisodeUpdatedAt(
    val iso: String? = null,
    val timestamp: Double? = null,
    val timezone: String? = null,
)

data class EpisodeSeasonMeta(
    @JsonProperty("_id")
    val id: String? = null,
    val seasonNumber: Long? = null,
)

data class EpisodeShowMeta(
    @JsonProperty("_id")
    val id: String? = null,
    val title: String? = null,
)

// Search

data class Search(
    val success: Boolean,
    val data: List<SearchDaum>,
)

data class SearchDaum(
    val id: String,
    val title: String,
    val image: String,
    val year: Long,
    val type: String,
)

//Loadlinks

data class Loadlinks(
    val success: Boolean? = null,
    val data: LoadlinksData? = null,
)

data class LoadlinksData(
    val links: List<Link>? = null,
    val title: String? = null,
    val id: String? = null,
)

data class Link(
    val name: String? = null,
    val url: String? = null,
    val subtitles: List<Any?>? = null,
    @get:JsonProperty("_link_index")
    val linkIndex: Long? = null,
)


================================================
FILE: Kartoons/src/main/kotlin/com/Kartoons/KartoonsPlugin.kt
================================================
package com.Kartoons

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class KartoonsPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(Kartoons())
    }
}


================================================
FILE: Kartoons/src/main/kotlin/com/Kartoons/Utils.kt
================================================
package com.Kartoons

import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64DecodeArray
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import javax.crypto.Cipher
import javax.crypto.spec.GCMParameterSpec
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

//Link Decryptor

fun base64UrlToBytes(b64url: String): ByteArray {
    var s = b64url.replace('-', '+').replace('_', '/')
    val pad = s.length % 4
    if (pad != 0) {
        s += "=".repeat(4 - pad)
    }
    return base64DecodeArray(s)
}

fun deriveKeyBytes(secret: String): ByteArray {
    val fixed = secret.padEnd(32, ' ').substring(0, 32)
    return fixed.toByteArray(StandardCharsets.UTF_8)
}

fun stripPkcs7Padding(data: ByteArray): ByteArray {
    if (data.isEmpty()) return data
    val padValue = data.last().toInt() and 0xFF
    if (padValue !in 1..16) return data

    // Verify padding bytes
    for (i in 0 until padValue) {
        val b = data[data.size - 1 - i].toInt() and 0xFF
        if (b != padValue) {
            return data
        }
    }
    return data.copyOf(data.size - padValue)
}

/**
 * Generic decrypt:
 * - encryptedDataBase64Url = base64url( IV(16 bytes) || CIPHERTEXT )
 * - secretKeyString = the string used in JS before padEnd(32, " ")
 */

@Throws(IllegalArgumentException::class, Exception::class)
fun decryptAesCbcBase64Url(
    encryptedDataBase64Url: String,
): String {
    val secretKeyString = base64Decode("YmNhOWUwZGYxYTVhYmIzMjkwNmNhM2Y2M2FjMDRjZWY=")
    if (encryptedDataBase64Url.isEmpty() || secretKeyString.isEmpty()) {
        throw IllegalArgumentException("encrypted data and secret key must be provided")
    }

    // Derive key bytes in the same way as JS
    val keyBytes = deriveKeyBytes(secretKeyString)

    if (keyBytes.size != 32) {
        throw IllegalArgumentException("Key length ${keyBytes.size} != 32 bytes")
    }

    // Base64url decode
    val encryptedBytes = base64UrlToBytes(encryptedDataBase64Url)

    if (encryptedBytes.size <= 16) {
        throw IllegalArgumentException("Ciphertext too short: missing IV or data")
    }

    // Split IV + ciphertext
    val iv = encryptedBytes.copyOfRange(0, 16)
    val ciphertext = encryptedBytes.copyOfRange(16, encryptedBytes.size)

    // AES/CBC with manual PKCS7 unpadding
    val cipher = Cipher.getInstance("AES/CBC/NoPadding")
    val keySpec = SecretKeySpec(keyBytes, "AES")
    val ivSpec = IvParameterSpec(iv)
    cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec)

    val paddedPlaintext = cipher.doFinal(ciphertext)
    val plaintextBytes = stripPkcs7Padding(paddedPlaintext)

    return String(plaintextBytes, StandardCharsets.UTF_8)
}

//M3u8 Decryptor

private val STREAM_SECRET = base64Decode("cG1TMENBTUcxUnVxNDlXYk15aEUzZmgxc091TFlFTDlydEZhellZbGpWSTJqNEJQU29nNzNoVzdBN3hNaGNlSEQwaXdyUHJWVkRYTHZ4eVdy")

private fun deriveKeySha256(): ByteArray {
    val digest = MessageDigest.getInstance("SHA-256")
    return digest.digest(STREAM_SECRET.toByteArray(Charsets.UTF_8))
}

fun decryptStream(
    value: String?,
    prefix: String = "enc2:"
): String? {
    if (value.isNullOrEmpty()) {
        println("Error: empty input")
        return null
    }

    if (!value.startsWith(prefix)) {
        return value
    }

    return try {
        val rawB64url = value.substring(prefix.length)

        val blob = base64UrlToBytes(rawB64url)
        if (blob.size <= 12) {
            throw IllegalArgumentException("Ciphertext too short: need 12-byte IV + data")
        }

        val iv = blob.copyOfRange(0, 12)              // 12-byte IV
        val ctAndTag = blob.copyOfRange(12, blob.size) // ciphertext + 16-byte tag

        val keyBytes = deriveKeySha256()
        val keySpec = SecretKeySpec(keyBytes, "AES")

        //AES-GCM decrypt
        val cipher = Cipher.getInstance("AES/GCM/NoPadding")
        val gcmSpec = GCMParameterSpec(128, iv) // 128-bit auth tag
        cipher.init(Cipher.DECRYPT_MODE, keySpec, gcmSpec)
        val plainBytes = cipher.doFinal(ctAndTag)

        //UTF-8 decode
        String(plainBytes, Charsets.UTF_8)
    } catch (e: Exception) {
        println("Decryption failed: ${e.message}")
        null
    }
}


================================================
FILE: Kickassanime/build.gradle.kts
================================================
// use an integer for version numbers
version = 20


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
     authors = listOf("Phisher98,Hexated")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AnimeMovie",
        "Anime",
        "OVA",
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/KAA.png"

    isCrossPlatform = true
}


================================================
FILE: Kickassanime/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Kickassanime/src/main/kotlin/com/Kickassanime/Crypto.kt
================================================
package com.kickassanime
/*
 * Copyright (C) The Tachiyomi Open Source Project
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

// Thanks to Vlad on Stackoverflow: https://stackoverflow.com/a/63701411

import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.base64Encode
import java.security.MessageDigest
import java.util.Arrays
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

/**
 * Conforming with CryptoJS AES method
 */
@Suppress("unused")
object CryptoAES {

    private const val KEY_SIZE = 32 // 256 bits
    private const val IV_SIZE = 16 // 128 bits
    private const val SALT_SIZE = 8 // 64 bits
    private const val HASH_CIPHER = "AES/CBC/PKCS7PADDING"
    private const val HASH_CIPHER_FALLBACK = "AES/CBC/PKCS5PADDING"
    private const val AES = "AES"
    private const val KDF_DIGEST = "MD5"

    /**
     * Decrypt using CryptoJS defaults compatible method.
     * Uses KDF equivalent to OpenSSL's EVP_BytesToKey function
     *
     * http://stackoverflow.com/a/29152379/4405051
     * @param cipherText base64 encoded ciphertext
     * @param password passphrase
     */
    fun decrypt(cipherText: String, password: String): String {
        return try {
            val ctBytes = base64DecodeArray(cipherText)
            val saltBytes = Arrays.copyOfRange(ctBytes, SALT_SIZE, IV_SIZE)
            val cipherTextBytes = Arrays.copyOfRange(ctBytes, IV_SIZE, ctBytes.size)
            val md5 = MessageDigest.getInstance("MD5")
            val keyAndIV = generateKeyAndIV(KEY_SIZE, IV_SIZE, 1, saltBytes, password.toByteArray(Charsets.UTF_8), md5)
            decryptAES(
                cipherTextBytes,
                keyAndIV?.get(0) ?: ByteArray(KEY_SIZE),
                keyAndIV?.get(1) ?: ByteArray(IV_SIZE),
            )
        } catch (e: Exception) {
            ""
        }
    }

    fun decryptWithSalt(cipherText: String, salt: String, password: String): String {
        return try {
            val ctBytes = base64DecodeArray(cipherText)
            val md5: MessageDigest = MessageDigest.getInstance("MD5")
            val keyAndIV = generateKeyAndIV(
                KEY_SIZE,
                IV_SIZE,
                1,
                salt.decodeHex(),
                password.toByteArray(Charsets.UTF_8),
                md5,
            )
            decryptAES(
                ctBytes,
                keyAndIV?.get(0) ?: ByteArray(KEY_SIZE),
                keyAndIV?.get(1) ?: ByteArray(IV_SIZE),
            )
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Decrypt using CryptoJS defaults compatible method.
     *
     * @param cipherText base64 encoded ciphertext
     * @param keyBytes key as a bytearray
     * @param ivBytes iv as a bytearray
     */
    fun decrypt(cipherText: String, keyBytes: ByteArray, ivBytes: ByteArray): String {
        return try {
            val cipherTextBytes = base64DecodeArray(cipherText)
            decryptAES(cipherTextBytes, keyBytes, ivBytes)
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Encrypt using CryptoJS defaults compatible method.
     *
     * @param plainText plaintext
     * @param keyBytes key as a bytearray
     * @param ivBytes iv as a bytearray
     */
    fun encrypt(plainText: String, keyBytes: ByteArray, ivBytes: ByteArray): String {
        return try {
            val cipherTextBytes = plainText.toByteArray()
            encryptAES(cipherTextBytes, keyBytes, ivBytes)
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Decrypt using CryptoJS defaults compatible method.
     *
     * @param cipherTextBytes encrypted text as a bytearray
     * @param keyBytes key as a bytearray
     * @param ivBytes iv as a bytearray
     */
    private fun decryptAES(cipherTextBytes: ByteArray, keyBytes: ByteArray, ivBytes: ByteArray): String {
        return try {
            val cipher = try {
                Cipher.getInstance(HASH_CIPHER)
            } catch (e: Throwable) { Cipher.getInstance(HASH_CIPHER_FALLBACK) }
            val keyS = SecretKeySpec(keyBytes, AES)
            cipher.init(Cipher.DECRYPT_MODE, keyS, IvParameterSpec(ivBytes))
            cipher.doFinal(cipherTextBytes).toString(Charsets.UTF_8)
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Encrypt using CryptoJS defaults compatible method.
     *
     * @param plainTextBytes encrypted text as a bytearray
     * @param keyBytes key as a bytearray
     * @param ivBytes iv as a bytearray
     */
    private fun encryptAES(plainTextBytes: ByteArray, keyBytes: ByteArray, ivBytes: ByteArray): String {
        return try {
            val cipher = try {
                Cipher.getInstance(HASH_CIPHER)
            } catch (e: Throwable) { Cipher.getInstance(HASH_CIPHER_FALLBACK) }
            val keyS = SecretKeySpec(keyBytes, AES)
            cipher.init(Cipher.ENCRYPT_MODE, keyS, IvParameterSpec(ivBytes))
            base64Encode(cipher.doFinal(plainTextBytes))
        } catch (e: Exception) {
            ""
        }
    }

    /**
     * Generates a key and an initialization vector (IV) with the given salt and password.
     *
     * https://stackoverflow.com/a/41434590
     * This method is equivalent to OpenSSL's EVP_BytesToKey function
     * (see https://github.com/openssl/openssl/blob/master/crypto/evp/evp_key.c).
     * By default, OpenSSL uses a single iteration, MD5 as the algorithm and UTF-8 encoded password data.
     *
     * @param keyLength the length of the generated key (in bytes)
     * @param ivLength the length of the generated IV (in bytes)
     * @param iterations the number of digestion rounds
     * @param salt the salt data (8 bytes of data or `null`)
     * @param password the password data (optional)
     * @param md the message digest algorithm to use
     * @return an two-element array with the generated key and IV
     */
    private fun generateKeyAndIV(
        keyLength: Int,
        ivLength: Int,
        iterations: Int,
        salt: ByteArray,
        password: ByteArray,
        md: MessageDigest,
    ): Array<ByteArray?>? {
        val digestLength = md.digestLength
        val requiredLength = (keyLength + ivLength + digestLength - 1) / digestLength * digestLength
        val generatedData = ByteArray(requiredLength)
        var generatedLength = 0
        return try {
            md.reset()

            // Repeat process until sufficient data has been generated
            while (generatedLength < keyLength + ivLength) {
                // Digest data (last digest if available, password data, salt if available)
                if (generatedLength > 0) md.update(generatedData, generatedLength - digestLength, digestLength)
                md.update(password)
                md.update(salt, 0, SALT_SIZE)
                md.digest(generatedData, generatedLength, digestLength)

                // additional rounds
                for (i in 1 until iterations) {
                    md.update(generatedData, generatedLength, digestLength)
                    md.digest(generatedData, generatedLength, digestLength)
                }
                generatedLength += digestLength
            }

            // Copy key and IV into separate byte arrays
            val result = arrayOfNulls<ByteArray>(2)
            result[0] = generatedData.copyOfRange(0, keyLength)
            if (ivLength > 0) result[1] = generatedData.copyOfRange(keyLength, keyLength + ivLength)
            result
        } catch (e: Exception) {
            throw e
        } finally {
            // Clean out temporary data
            Arrays.fill(generatedData, 0.toByte())
        }
    }

    // Stolen from AnimixPlay(EN) / GogoCdnExtractor
    fun String.decodeHex(): ByteArray {
        check(length % 2 == 0) { "Must have an even length" }
        return chunked(2)
            .map { it.toInt(16).toByte() }
            .toByteArray()
    }
}


================================================
FILE: Kickassanime/src/main/kotlin/com/Kickassanime/GogoExtractor.kt
================================================
package com.kickassanime

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.mvvm.safe
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.nodes.Document
import java.net.URI
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

object GogoExtractor {

    /**
     * @param id base64Decode(show_id) + IV
     * @return the encryption key
     * */
    private fun getKey(id: String): String? {
        return safe {
            id.map {
                it.code.toString(16)
            }.joinToString("").substring(0, 32)
        }
    }

    // https://github.com/saikou-app/saikou/blob/3e756bd8e876ad7a9318b17110526880525a5cd3/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt#L60
    // No Licence on the function
    private fun cryptoHandler(
        string: String,
        iv: String,
        secretKeyString: String,
        encrypt: Boolean = true
    ): String {
        //println("IV: $iv, Key: $secretKeyString, encrypt: $encrypt, Message: $string")
        val ivParameterSpec = IvParameterSpec(iv.toByteArray())
        val secretKey = SecretKeySpec(secretKeyString.toByteArray(), "AES")
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        return if (!encrypt) {
            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)
            String(cipher.doFinal(base64DecodeArray(string)))
        } else {
            cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)
            base64Encode(cipher.doFinal(string.toByteArray()))
        }
    }

    /**
     * @param iframeUrl something like https://gogoplay4.com/streaming.php?id=XXXXXX
     * @param mainApiName used for ExtractorLink names and source
     * @param iv secret iv from site, required non-null if isUsingAdaptiveKeys is off
     * @param secretKey secret key for decryption from site, required non-null if isUsingAdaptiveKeys is off
     * @param secretDecryptKey secret key to decrypt the response json, required non-null if isUsingAdaptiveKeys is off
     * @param isUsingAdaptiveKeys generates keys from IV and ID, see getKey()
     * @param isUsingAdaptiveData generate encrypt-ajax data based on $("script[data-name='episode']")[0].dataset.value
     * */
    suspend fun extractVidstream(
        iframeUrl: String,
        mainApiName: String,
        callback: (ExtractorLink) -> Unit,
        iv: String?,
        secretKey: String?,
        secretDecryptKey: String?,
        // This could be removed, but i prefer it verbose
        isUsingAdaptiveKeys: Boolean,
        isUsingAdaptiveData: Boolean,
        // If you don't want to re-fetch the document
        iframeDocument: Document? = null
    ) = safeApiCall {
        // https://github.com/saikou-app/saikou/blob/3e756bd8e876ad7a9318b17110526880525a5cd3/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
        // No Licence on the following code
        // Also modified of https://github.com/jmir1/aniyomi-extensions/blob/master/src/en/gogoanime/src/eu/kanade/tachiyomi/animeextension/en/gogoanime/extractors/GogoCdnExtractor.kt
        // License on the code above  https://github.com/jmir1/aniyomi-extensions/blob/master/LICENSE

        if ((iv == null || secretKey == null || secretDecryptKey == null) && !isUsingAdaptiveKeys)
            return@safeApiCall

        val id = Regex("id=([^&]+)").find(iframeUrl)!!.value.removePrefix("id=")

        var document: Document? = iframeDocument
        val foundIv =
            iv ?: (document ?: app.get(iframeUrl).documentLarge.also { document = it })
                .select("""div.wrapper[class*=container]""")
                .attr("class").split("-").lastOrNull() ?: return@safeApiCall
        val foundKey = secretKey ?: getKey(base64Decode(id) + foundIv) ?: return@safeApiCall
        val foundDecryptKey = secretDecryptKey ?: foundKey

        val uri = URI(iframeUrl)
        val mainUrl = "https://" + uri.host

        val encryptedId = cryptoHandler(id, foundIv, foundKey)
        val encryptRequestData = if (isUsingAdaptiveData) {
            // Only fetch the document if necessary
            val realDocument = document ?: app.get(iframeUrl).documentLarge
            val dataEncrypted =
                realDocument.select("script[data-name='episode']").attr("data-value")
            val headers = cryptoHandler(dataEncrypted, foundIv, foundKey, false)
            "id=$encryptedId&alias=$id&" + headers.substringAfter("&")
        } else {
            "id=$encryptedId&alias=$id"
        }

        val jsonResponse =
            app.get(
                "$mainUrl/encrypt-ajax.php?$encryptRequestData",
                headers = mapOf("X-Requested-With" to "XMLHttpRequest")
            )
        val dataencrypted =
            jsonResponse.text.substringAfter("{\"data\":\"").substringBefore("\"}")
        val datadecrypted = cryptoHandler(dataencrypted, foundIv, foundDecryptKey, false)
        val sources = AppUtils.parseJson<GogoSources>(datadecrypted)

        suspend fun invokeGogoSource(
            source: GogoSource,
            sourceCallback: (ExtractorLink) -> Unit
        ) {
            if (source.file.contains(".m3u8")) {
                M3u8Helper.generateM3u8(
                    mainApiName,
                    source.file,
                    mainUrl,
                    headers = mapOf("Origin" to "https://plyr.link")
                ).forEach(sourceCallback)
            } else {
                sourceCallback.invoke(
                    newExtractorLink(
                        mainApiName,
                        mainApiName,
                        url = source.file
                    ) {
                        this.referer = mainUrl
                        this.quality = getQualityFromName(source.label)
                    }
                )
            }
        }

        sources.source?.forEach {
            invokeGogoSource(it, callback)
        }
        sources.sourceBk?.forEach {
            invokeGogoSource(it, callback)
        }
    }

    data class GogoSources(
        @JsonProperty("source") val source: List<GogoSource>?,
        @JsonProperty("sourceBk") val sourceBk: List<GogoSource>?,
        //val track: List<Any?>,
        //val advertising: List<Any?>,
        //val linkiframe: String
    )

    data class GogoSource(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("default") val default: String? = null
    )
}



================================================
FILE: Kickassanime/src/main/kotlin/com/Kickassanime/Kickassanime.kt
================================================
package com.kickassanime

import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.Gson
import com.kickassanime.CryptoAES.decodeHex
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import org.jsoup.Jsoup
import java.security.MessageDigest
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.net.URLEncoder
import java.util.Calendar

class Kickassanime : MainAPI() {
    override var mainUrl = "https://kaa.to"
    override var name = "Kickassanime"
    override val hasMainPage = true
    override var lang = "en"
    override val hasQuickSearch =  true
    override val hasDownloadSupport = true

    override val supportedSyncNames = setOf(
        SyncIdName.MyAnimeList,
        SyncIdName.Anilist
    )

    override val supportedTypes = setOf(
        TvType.Anime,
        TvType.AnimeMovie,
        TvType.OVA
    )

    companion object {
        var mainUrl = "https://kaa.to"
        fun getStatus(t: String): ShowStatus {
            return when (t) {
                "finished_airing" -> ShowStatus.Completed
                "currently_airing" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage = mainPageOf(
        "filters=${generateFilterWithCurrentYear()}" to "Airing",
        "$mainUrl/api/show/trending" to "Trending",
        "$mainUrl/api/show/popular" to "Popular Animes",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse? {
        val url=if (request.data.startsWith("filter"))
        {
            "${mainUrl}/api/anime?page=$page&${request.data}"
        }
        else
        {
            "${request.data}?page=$page"
        }
        val home = app.get(url).parsedSafe<ResponseHome>()?.result?.map { media ->
            media.toSearchResponse()
        }
        return home?.let { newHomePageResponse(request.name, it) }
    }

    private fun getProperAnimeLink(uri: String): String {
        return when {
            uri.contains("/episode") -> fixUrl(uri.substringBeforeLast("/"))
            else -> fixUrl(uri)
        }
    }

    private fun Result.toSearchResponse(): SearchResponse {
        val href = getProperAnimeLink(this.slug)
        val title = (this.titleEn ?: this.title).replace("\"","")
        val posterUrl = getImageUrl(this.poster.hq)
        return newAnimeSearchResponse(title, href, TvType.Anime) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query,1).items

    override suspend fun search(query: String,page: Int): SearchResponseList {
val json = """
{   "page": "$page",
    "query": "$query"
}
""".trimIndent()
        val host = app.get(mainUrl, allowRedirects = false).headers["location"]
        val mediaType = "application/json".toMediaType()
        val requestBody = json.toRequestBody(mediaType)
        val headers= mapOf(
            "Accept" to "*/*",
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
            "Content-Type" to "application/json",
            "x-origin" to "kickass-anime.ru"
        )
        val res=app.post("${host}api/fsearch", requestBody = requestBody, headers = headers).toString()
        return tryParseJson<Search>(res)?.result?.map {
            it.toSearchResponse()
        }?.toNewSearchResponseList() ?: throw ErrorLoadingException("Invalid Json reponse")
    }

    private fun SearchResult.toSearchResponse(): SearchResponse {
        val title=this.titleEn ?: this.title
        val poster= getImageUrl(this.poster.hq)
        val href="${mainUrl}/${this.slug}"
        return newAnimeSearchResponse(
            title,
            href,
            TvType.TvSeries,
        ) {
            this.posterUrl=poster
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val showName = url.substringAfter(mainUrl)
        val loadJson = app.get("$mainUrl/api/show/$showName").parsedSafe<loadres>()

        val title = loadJson?.titleEn.takeUnless { it.isNullOrEmpty() } ?: loadJson?.title ?: "Unknown"
        val poster = loadJson?.banner?.hq?.let(::getBannerUrl) ?: loadJson?.poster?.hq?.let(::getImageUrl)
        val description = loadJson?.synopsis
        val tags = loadJson?.genres
        val status = getStatus(loadJson?.status ?: "")

        val episodesJson = app.get("$mainUrl/api/show$showName/episodes?ep=1&lang=ja-JP").toString()
        val episodes = parseJsonToEpisodes(episodesJson).mapNotNull { epJson ->
            val epNumber = epJson.episode_number.toString().substringBefore(".").toIntOrNull() ?: return@mapNotNull null
            newEpisode("$mainUrl/api/show$showName/episode/ep-$epNumber-${epJson.slug}") {
                name = epJson.title
                episode = epNumber
                posterUrl = getThumbnailUrl(epJson.thumbnail.hq)
            }
        }

        return newTvSeriesLoadResponse(title, url, TvType.Anime, episodes).apply {
            name = title
            posterUrl = poster
            backgroundPosterUrl = poster
            plot = description
            this.tags = tags
            showStatus = status
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).parsedSafe<ServersRes>()?.servers?.amap{ it ->
            if(it.name.contains("VidStreaming")) {
                val host = getBaseUrl(it.src)
                val headers = mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
                val key = "e13d38099bf562e8b9851a652d2043d3".toByteArray()
                val query = it.src.substringAfter("?id=").substringBefore("&")
                val html = app.get(it.src).toString()

                //If HTML have m3u8
                if (html.contains(".m3u8", ignoreCase = true)) {
                    val match = Regex("""(https?:)?//[^\s"'<>]+\.m3u8""", RegexOption.IGNORE_CASE)
                        .find(html)

                    val videoheaders = mapOf(
                        "Accept" to "*/*",
                        "Accept-Language" to "en-US,en;q=0.5",
                        "Origin" to host,
                        "Sec-Fetch-Dest" to "empty",
                        "Sec-Fetch-Mode" to "cors",
                        "Sec-Fetch-Site" to "cross-site"
                    )

                    match?.value?.let { url ->
                        val m3u8Url = if (url.startsWith("//")) "https:$url" else url
                        callback.invoke(
                            newExtractorLink(
                                "VidStreaming",
                                "VidStreaming",
                                m3u8Url,
                                ExtractorLinkType.M3U8
                            )
                            {
                                this.quality = Qualities.P1080.value
                                this.headers = videoheaders
                            }
                        )
                    }
                }

                val (sig, timeStamp, route) = getSignature(html, it.name, query, key) ?: return@amap
                val sourceurl = "$host$route?id=$query&e=$timeStamp&s=$sig"
                val encjson = app.get(sourceurl, headers = headers).parsedSafe<Encrypted>()?.data
                    ?: "Not Found"

                val (encryptedData, ivhex) = encjson.substringAfter(":\"")
                    .substringBefore('"')
                    .replace("\\", "")
                    .split(":")
                val iv = ivhex.decodeHex()
                val decrypted =
                    tryParseJson<m3u8>(CryptoAES.decrypt(encryptedData, key, iv).toJson())

                val m3u8 = httpsify(decrypted?.hls!!)
                val videoheaders = mapOf(
                    "Accept" to "*/*",
                    "Accept-Language" to "en-US,en;q=0.5",
                    "Origin" to host,
                    "Sec-Fetch-Dest" to "empty",
                    "Sec-Fetch-Mode" to "cors",
                    "Sec-Fetch-Site" to "cross-site"
                )

                callback.invoke(
                    newExtractorLink(
                        "VidStreaming",
                        "VidStreaming",
                        m3u8,
                        ExtractorLinkType.M3U8
                        )
                        {
                            this.quality = Qualities.P1080.value
                            this.headers = videoheaders
                        }
                )

                decrypted.subtitles.amap {
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            it.name,  // Use label for the name
                            it.src     // Use extracted URL
                        )
                    )
                }
            }
            else
            if (it.name.contains("BirdStream"))
            {
                val baseurl=getBaseUrl(it.src)

                val headers = mapOf(
                    "Origin" to baseurl,
                    "User-Agent" to "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36"
                )

                val res= app.get(it.src, headers = headers).text

                val regex = Regex("""props="(.*?)"""")
                val match = regex.find(res)
                val encodedJson = match?.groupValues?.get(1)

                if (encodedJson != null) {
                    val unescapedJson = org.jsoup.parser.Parser.unescapeEntities(encodedJson, false)
                    val json = JSONObject(unescapedJson)

                    val videoUrl = "https:" + json.getJSONArray("manifest").getString(1)
                    callback.invoke(
                        newExtractorLink(
                            "CatStream",
                            "CatStream DASH",
                            videoUrl,
                            ExtractorLinkType.M3U8
                        )
                        {
                            this.referer = baseurl
                            this.quality = Qualities.P1080.value
                            this.headers = headers
                        }
                    )

                    val subtitleArray = json.getJSONArray("subtitles").getJSONArray(1)

                    for (i in 0 until subtitleArray.length()) {
                        val sub = subtitleArray.getJSONArray(i).getJSONObject(1)

                        val src = sub.getJSONArray("src").getString(1)
                        val name = sub.getJSONArray("name").getString(1)
                        subtitleCallback.invoke(
                            newSubtitleFile(
                                name,  // Use label for the name
                                src    // Use extracted URL
                            )
                        )
                    }

                } else {
                    println("Could not find embedded JSON in props attribute")
                }
            }
            else
                if (it.name.contains("CatStream")) {

                    val baseurl=getBaseUrl(it.src)
                    val headers = mapOf(
                        "Origin" to baseurl,
                        "User-Agent" to "Mozilla/5.0 (Linux; Android 10; K) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Mobile Safari/537.36"
                    )
                    val res = app.get(it.src, headers = headers).text

                    val regex = Regex("""props="(.*?)"""")
                    val match = regex.find(res)
                    val encodedJson = match?.groupValues?.get(1)

                    if (encodedJson != null) {
                        val unescapedJson = org.jsoup.parser.Parser.unescapeEntities(encodedJson, false)
                        val json = JSONObject(unescapedJson)

                        val videoUrl = "https:" + json.getJSONArray("manifest").getString(1)
                        callback.invoke(
                            newExtractorLink(
                                "CatStream",
                                "CatStream HLS",
                                videoUrl,
                                ExtractorLinkType.M3U8
                            )
                            {
                                this.referer = baseurl
                                this.quality = Qualities.P1080.value
                                this.headers = headers
                            }
                        )

                        val subtitleArray = json.getJSONArray("subtitles").getJSONArray(1)

                        for (i in 0 until subtitleArray.length()) {
                            val sub = subtitleArray.getJSONArray(i).getJSONObject(1)

                            val src = sub.getJSONArray("src").getString(1)
                            val name = sub.getJSONArray("name").getString(1)
                            subtitleCallback.invoke(
                                newSubtitleFile(
                                    name,  // Use label for the name
                                    src    // Use extracted URL
                                )
                            )
                        }

                    } else {
                        println("Could not find embedded JSON in props attribute")
                    }
                }
        }

        return true
    }

    private fun getSignature(
        html: String,
        server: String,
        query: String,
        key: ByteArray
    ): Triple<String, String, String>? {
        // Define the order based on the server type
        val headers= mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
        val order = when (server) {
            "VidStreaming", "DuckStream" -> listOf("IP", "USERAGENT", "ROUTE", "MID", "TIMESTAMP", "KEY")
            "BirdStream" -> listOf("IP", "USERAGENT", "ROUTE", "MID", "KEY")
            else -> return null
        }

        // Parse the HTML using Jsoup
        val document = Jsoup.parse(html)
        val cidRaw = document.select("script:containsData(cid:)").firstOrNull()
            ?.html()?.substringAfter("cid: '")?.substringBefore("'")?.decodeHex()
            ?: return null
        val cid = String(cidRaw).split("|")

        // Generate timestamp
        val timeStamp = (System.currentTimeMillis() / 1000 + 60).toString()

        // Update route
        val route = cid[1].replace("player.php", "source.php")

        val signature = buildString {
            order.forEach {
                when (it) {
                    "IP" -> append(cid[0])
                    "USERAGENT" -> append(headers["User-Agent"] ?: "")
                    "ROUTE" -> append(route)
                    "MID" -> append(query)
                    "TIMESTAMP" -> append(timeStamp)
                    "KEY" -> append(String(key))
                    "SIG" -> append(html.substringAfter("signature: '").substringBefore("'"))
                    else -> {}
                }
            }
        }
        // Compute SHA-1 hash of the signature
        return Triple(sha1sum(signature), timeStamp, route)
    }

    // Helper function to decode a hexadecimal string

    private fun sha1sum(value: String): String {
        return try {
            val md = MessageDigest.getInstance("SHA-1")
            val bytes = md.digest(value.toByteArray())
            bytes.joinToString("") { "%02x".format(it) }
        } catch (_: Exception) {
            throw Exception("Attempt to create the signature failed miserably.")
        }
    }

    //search

    data class Search(
        val result: List<SearchResult>,
        val maxPage: Long,
    )

    data class SearchResult(
        @JsonProperty("episode_count")
        val episodeCount: Long,
        val genres: List<String>,
        val locales: List<String>,
        val slug: String,
        val status: String,
        val synopsis: String,
        val title: String,
        @JsonProperty("title_en")
        val titleEn: String?,
        val type: String,
        val year: Long,
        val poster: SearchPoster,
        @JsonProperty("episode_duration")
        val episodeDuration: Long,
        @JsonProperty("watch_uri")
        val watchUri: String?,
        @JsonProperty("episode_number")
        val episodeNumber: Long?,
        @JsonProperty("episode_string")
        val episodeString: String?,
    )

    data class SearchPoster(
        val formats: List<String>,
        val sm: String,
        val aspectRatio: Double,
        val hq: String,
    )



    //Trending
data class ResponseHome(
    @JsonProperty("page_count")
    val pageCount: Long,
    val result: List<Result>,
)

data class Result(
    val title: String,
    @JsonProperty("title_en")
    val titleEn: String?,
    val synopsis: String,
    val status: String,
    val type: String,
    val slug: String,
    val rating: String?,
    val year: Long?,
    val poster: Poster,
    val genres: List<String>,
)

data class Poster(
    val formats: List<String>,
    val sm: String,
    val aspectRatio: Double,
    val hq: String,
)

//
//Episode

data class Episoderesponse(
    val slug: String,
    val title: String,
    val duration_ms: Long,
    val episode_number: Number,
    val episode_string: String,
    val thumbnail: Thumbnail
)

data class Thumbnail(
    val formats: List<String>,
    val sm: String,
    val aspectRatio: Double,
    val hq: String
)

//loadapi

data class loadres(
        val episodeDuration: Long?,
        val genres: List<String>?,
        val locales: List<String>?,
        val season: String?,
        val slug: String?,
        val startDate: String?,
        val status: String?,
        val synopsis: String?,
        val title: String?,
        val titleEn: String?,
        val titleOriginal: String?,
        val type: String?,
        val year: Long?,
        val poster: LoadPoster?,
        val banner: Banner?,
        val endDate: String?,
        val rating: String?,
        val watchUri: String?,
)


data class LoadPoster(
    val formats: List<String>,
    val sm: String,
    val aspectRatio: Double,
    val hq: String,
)

data class Banner(
    val formats: List<String>,
    val sm: String,
    val aspectRatio: Double,
    val hq: String,
)

//servers

data class ServersRes(
    val servers: List<Server>,

)
data class Server(
    val name: String,
    val shortName: String,
    val src: String,
)
//m3u8

data class m3u8(
        val hls: String,
        val subtitles: List<Subtitle>,
        val key: String,
)

data class Subtitle(
        val language: String,
        val name: String,
        val src: String,
)

private fun generateFilterWithCurrentYear(): String {
    val currentYear = Calendar.getInstance().get(Calendar.YEAR)
    val jsonObject = """{"year":$currentYear,"status":"airing"}"""
    val base64Encoded = base64Encode(jsonObject.toByteArray()).trim()
    return URLEncoder.encode(base64Encoded, "UTF-8")
}

// Encrypted
data class Encrypted(
    val data: String,
)
    private val gson = Gson()
    private fun parseJsonToEpisodes(json: String): List<Episoderesponse> {
        data class Response(val result: List<Episoderesponse>)
        return try {
            gson.fromJson(json, Response::class.java).result
        } catch (_: Exception) {
            emptyList()
        }
    }
}



================================================
FILE: Kickassanime/src/main/kotlin/com/Kickassanime/KickassanimePlugin.kt
================================================
package com.kickassanime

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class KickassanimePlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Kickassanime())
    }
}


================================================
FILE: Kickassanime/src/main/kotlin/com/Kickassanime/KickassanimeUtils.kt
================================================
package com.kickassanime

//mark
import com.kickassanime.Kickassanime.Companion.mainUrl
import com.lagradost.cloudstream3.utils.SubtitleHelper
import java.net.URI
import java.net.URLDecoder

fun decode(input: String): String =
    URLDecoder.decode(input, "utf-8").replace(" ", "%20")

fun String.createSlug(): String {
    return this.replace(Regex("[^\\w ]+"), "").replace(" ", "-").lowercase()
}

fun String.getTrackerTitle(): String {
    val blacklist = arrayOf(
        "Dub",
        "Uncensored",
        "TV",
        "JPN DUB",
        "Uncensored"
    ).joinToString("|") { "\\($it\\)" }
    return this.replace(Regex(blacklist), "").trim()
}

fun getImageUrl(link: String?): String? {
    if (link == null) return null
    return if (link.startsWith(mainUrl)) link else "$mainUrl/image/poster/$link.webp"
}

fun getThumbnailUrl(link: String?): String? {
    if (link == null) return null
    return if (link.startsWith(mainUrl)) link else "$mainUrl/image/thumbnail/$link.webp"
}

fun getBannerUrl(link: String?): String? {
    if (link == null) return null
    return if (link.startsWith(mainUrl)) link else "$mainUrl/image/banner/$link.webp"
}

fun getBaseUrl(url: String): String {
    return URI(url).let {
        "${it.scheme}://${it.host}"
    }
}


fun getLanguage(language: String?): String? {
    return SubtitleHelper.fromTagToEnglishLanguageName(language ?: return null)
        ?: SubtitleHelper.fromTagToEnglishLanguageName(language.substringBefore("-"))
}

fun fixUrl(url: String, domain: String): String {
    if (url.startsWith("http")) {
        return url
    }
    if (url.isEmpty()) {
        return ""
    }

    val startsWithNoHttp = url.startsWith("//")
    if (startsWithNoHttp) {
        return "https:$url"
    } else {
        if (url.startsWith('/')) {
            return domain + url
        }
        return "$domain/$url"
    }
}

/*

data class MyJsonData(val data: String)

fun tryParseJson(jsonString: String): MyJsonData? {
    return try {
        // Attempt to parse the JSON string into the data class
        val json = Json { isLenient = true; ignoreUnknownKeys = true }
        json.decodeFromString<MyJsonData>(jsonString)
    } catch (e: Exception) {
        // Catch any exceptions and return null if parsing fails
        println("Error parsing JSON: ${e.message}")
        null
    }
}
 */


================================================
FILE: KisskhProvider/build.gradle.kts
================================================

import org.jetbrains.kotlin.konan.properties.Properties
// use an integer for version numbers
version = 16

android {
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "KissKh", "\"${properties.getProperty("KissKh")}\"")
        buildConfigField("String", "KisskhSub", "\"${properties.getProperty("KisskhSub")}\"")

    }
}


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
     authors = listOf("Phisher98,Hexated,Peerless")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=kisskh.co&sz=%size%"

    isCrossPlatform = true
}


================================================
FILE: KisskhProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: KisskhProvider/src/main/kotlin/com/Phisher98/KisskhProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.Interceptor
import okhttp3.Response
import okhttp3.ResponseBody.Companion.toResponseBody
import java.util.ArrayList

class KisskhProvider : MainAPI() {
    override var mainUrl = "https://kisskh.ovh"
    override var name = "Kisskh"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.AsianDrama,
        TvType.Anime
    )

    override val mainPage = mainPageOf(
        "&type=0&sub=0&country=0&status=0&order=2" to "Latest",
        "&type=0&sub=0&country=2&status=0&order=1" to "Top K-Drama",
        "&type=0&sub=0&country=1&status=0&order=1" to "Top C-Drama",
        "&type=2&sub=0&country=2&status=0&order=1" to "Movie Popular",
        "&type=2&sub=0&country=2&status=0&order=2" to "Movie Last Update",
        "&type=1&sub=0&country=2&status=0&order=1" to "TVSeries Popular",
        "&type=1&sub=0&country=2&status=0&order=2" to "TVSeries Last Update",
        "&type=3&sub=0&country=0&status=0&order=1" to "Anime Popular",
        "&type=3&sub=0&country=0&status=0&order=2" to "Anime Latest Update",
        "&type=4&sub=0&country=0&status=0&order=1" to "Hollywood Popular",
        "&type=4&sub=0&country=0&status=0&order=2" to "Hollywood Last Update",
        "&type=0&sub=0&country=0&status=3&order=2" to "Upcoming"
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val home = app.get("$mainUrl/api/DramaList/List?page=$page${request.data}")
            .parsedSafe<Responses>()?.data
            ?.mapNotNull { media ->
                media.toSearchResponse()
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Media.toSearchResponse(): SearchResponse? {
        if (!settingsForProvider.enableAdult && this.label!!.contains("RAW")) {
            // Skip RAW entries when adult is disabled
            return null
        }

        return newAnimeSearchResponse(
            title ?: return null,
            "$title/$id",
            TvType.TvSeries,
        ) {
            this.posterUrl = thumbnail
            addSub(episodesCount)
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse =
            app.get("$mainUrl/api/DramaList/Search?q=$query&type=0", referer = "$mainUrl/").text
        return tryParseJson<ArrayList<Media>>(searchResponse)?.mapNotNull { media ->
            media.toSearchResponse()
        } ?: throw ErrorLoadingException("Invalid Json reponse")
    }

    private fun getTitle(str: String): String {
        return str.replace(Regex("[^a-zA-Z0-9]"), "-")
    }

    override suspend fun load(url: String): LoadResponse? {
        val id = url.split("/")
        val res = app.get(
            "$mainUrl/api/DramaList/Drama/${id.last()}?isq=false",
            referer = "$mainUrl/Drama/${
                getTitle(id.first())
            }?id=${id.last()}"
        ).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json reponse")

        val episodes = res.episodes?.map { eps ->

            val displayNumber = eps.number?.let { num ->
                if (num % 1.0 == 0.0) num.toInt().toString() else num.toString()
            } ?: ""

            newEpisode(Data(res.title, eps.number?.toInt(), res.id, eps.id).toJson()) {
                this.name = "Episode $displayNumber"
            }

        } ?: throw ErrorLoadingException("No Episode")


        return newTvSeriesLoadResponse(
            res.title ?: return null,
            url,
            if (res.type == "Movie" || episodes.size == 1) TvType.Movie else TvType.TvSeries,
            episodes.reversed()
        ) {
            this.posterUrl = res.thumbnail
            this.year = res.releaseDate?.split("-")?.first()?.toIntOrNull()
            this.plot = res.description
            this.tags = listOf("${res.country}", "${res.status}", "${res.type}")
            this.showStatus = when (res.status) {
                "Completed" -> ShowStatus.Completed
                "Ongoing" -> ShowStatus.Ongoing
                else -> null
            }
        }

    }

    private fun getLanguage(str: String): String {
        return when (str) {
            "Indonesia" -> "Indonesian"
            else -> str
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val KisskhAPI = BuildConfig.KissKh
        val KisskhSub = BuildConfig.KisskhSub
        val loadData = parseJson<Data>(data)
        val kkey = app.get("$KisskhAPI${loadData.epsId}&version=2.8.10", timeout = 10000).parsedSafe<Key>()?.key ?:""
        app.get(
            "$mainUrl/api/DramaList/Episode/${loadData.epsId}.png?err=false&ts=&time=&kkey=$kkey",
            referer = "$mainUrl/Drama/${getTitle("${loadData.title}")}/Episode-${loadData.eps}?id=${loadData.id}&ep=${loadData.epsId}&page=0&pageSize=100"
        ).parsedSafe<Sources>()?.let { source ->
            listOf(source.video, source.thirdParty).amap { link ->
                safeApiCall {
                    if (link?.contains(".m3u8") == true) {
                        M3u8Helper.generateM3u8(
                            this.name,
                            fixUrl(link),
                            referer = "$mainUrl/",
                            headers = mapOf("Origin" to mainUrl)
                        ).forEach(callback)
                    } else if (link?.contains("mp4") == true) {
                        callback.invoke(
                            newExtractorLink(
                                this.name,
                                this.name,
                                url = fixUrl(link),
                                INFER_TYPE
                            ) {
                                this.referer = mainUrl
                                this.quality = Qualities.P720.value
                            }
                        )

                    } else {
                        loadExtractor(
                            link?.substringBefore("=http") ?: return@safeApiCall,
                            "$mainUrl/",
                            subtitleCallback,
                            callback
                        )
                    }
                }
            }
        }

        val kkey1=app.get("$KisskhSub${loadData.epsId}&version=2.8.10", timeout = 10000).parsedSafe<Key>()?.key ?:""
        app.get("$mainUrl/api/Sub/${loadData.epsId}?kkey=$kkey1").text.let { res ->
            tryParseJson<List<Subtitle>>(res)?.map { sub ->
                if (sub.src!!.contains(".txt")) {
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            getLanguage(sub.label ?: return@map),
                            sub.src
                        )
                    )
                }
                else
                subtitleCallback.invoke(
                    newSubtitleFile(
                        getLanguage(sub.label ?: return@map),
                        sub.src
                    )
                )
            }
        }

        return true

    }
    // SubDecryptor Code from Thanks to https://github.com/Kohi-den/extensions-source/blob/515590ecfec6af2b915d23508266536f7f5a3ab8/src/en/kisskh/src/eu/kanade/tachiyomi/animeextension/en/kisskh/SubDecryptor.kt


    //OLD Method
    /*
    val decrypted = chunks.mapIndexed { index, chunk ->
    val parts = chunk.split("\n")
    val text = parts.slice(1 until parts.size)
    val d = text.map { decrypt(it) }.joinToString("\n")
    arrayOf(index + 1, parts.first(), d).joinToString("\n")
    }.joinToString("\n\n")
     */


    private val CHUNK_REGEX1 by lazy { Regex("^\\d+$", RegexOption.MULTILINE) }
    override fun getVideoInterceptor(extractorLink: ExtractorLink): Interceptor {
        return object : Interceptor {
            override fun intercept(chain: Interceptor.Chain): Response {
                val request = chain.request()
                    .newBuilder()
                    .build()
                val response = chain.proceed(request)
                if (response.request.url.toString().contains(".txt")) {
                    val responseBody = response.body.string()
                    val chunks = responseBody.split(CHUNK_REGEX1)
                        .filter(String::isNotBlank)
                        .map(String::trim)
                    val decrypted = chunks.mapIndexed { index, chunk ->
                        if (chunk.isBlank()) return@mapIndexed ""
                        val parts = chunk.split("\n")
                        if (parts.isEmpty()) return@mapIndexed ""

                        val header = parts.first()
                        val text = parts.drop(1)
                        val d = text.joinToString("\n") { line ->
                            try {
                                decrypt(line)
                            } catch (e: Exception) {
                                "DECRYPT_ERROR:${e.message}"
                            }
                        }
                        listOf(index + 1, header, d).joinToString("\n")
                    }.filter { it.isNotEmpty() }
                        .joinToString("\n\n")
                    val newBody = decrypted.toResponseBody(response.body.contentType())
                    return response.newBuilder()
                        .body(newBody)
                        .build()
                }
                return response
            }
        }
    }


    data class Data(
        val title: String?,
        val eps: Int?,
        val id: Int?,
        val epsId: Int?,
    )

    data class Sources(
        @JsonProperty("Video") val video: String?,
        @JsonProperty("ThirdParty") val thirdParty: String?,
    )

    data class Subtitle(
        @JsonProperty("src") val src: String?,
        @JsonProperty("label") val label: String?,
    )

    data class Responses(
        @JsonProperty("data") val data: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @JsonProperty("episodesCount") val episodesCount: Int?,
        @JsonProperty("thumbnail") val thumbnail: String?,
        @JsonProperty("label") val label: String?,
        @JsonProperty("id") val id: Int?,
        @JsonProperty("title") val title: String?,
    )

    data class Episodes(
        @JsonProperty("id") val id: Int?,
        @JsonProperty("number") val number: Double?,
        @JsonProperty("sub") val sub: Int?,
    )

    data class MediaDetail(
        @JsonProperty("description") val description: String?,
        @JsonProperty("releaseDate") val releaseDate: String?,
        @JsonProperty("status") val status: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("country") val country: String?,
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
        @JsonProperty("thumbnail") val thumbnail: String?,
        @JsonProperty("id") val id: Int?,
        @JsonProperty("title") val title: String?,
    )

    data class Key(
        val id: String,
        val version: String,
        val key: String,
    )
}



================================================
FILE: KisskhProvider/src/main/kotlin/com/Phisher98/KisskhProviderPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class KisskhProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(KisskhProvider())
    }
}


================================================
FILE: KisskhProvider/src/main/kotlin/com/Phisher98/SubDecryptor.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.base64DecodeArray
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

private const val KEY = "AmSmZVcH93UQUezi"
private const val KEY2 = "8056483646328763"
private const val KEY3 = "sWODXX04QRTkHdlZ"


private val IV = intArrayOf(1382367819, 1465333859, 1902406224, 1164854838)
private val IV2 = intArrayOf(909653298, 909193779, 925905208, 892483379)
private val IV3 = intArrayOf(946894696, 1634749029, 1127508082, 1396271183)



fun decrypt(encryptedB64: String): String {
    val keyIvPairs = listOf(
        Pair(KEY.toByteArray(Charsets.UTF_8), IV.toByteArray()),
        Pair(KEY2.toByteArray(Charsets.UTF_8), IV2.toByteArray()),
        Pair(KEY3.toByteArray(Charsets.UTF_8), IV3.toByteArray())
    )

    val encryptedBytes = base64DecodeArray(encryptedB64) // Decode Base64 input

    for ((keyBytes, ivBytes) in keyIvPairs) {
        try {
            return decryptWithKeyIv(keyBytes, ivBytes, encryptedBytes)
        } catch (ex: Exception) {
            println("Decryption attempt failed with key/IV pair. Error: ${ex.message}")
        }
    }
    return "Decryption failed: All keys/IVs failed"
}

private fun decryptWithKeyIv(keyBytes: ByteArray, ivBytes: ByteArray, encryptedBytes: ByteArray): String {
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.DECRYPT_MODE, SecretKeySpec(keyBytes, "AES"), IvParameterSpec(ivBytes))
    return String(cipher.doFinal(encryptedBytes), Charsets.UTF_8)
}

private fun IntArray.toByteArray(): ByteArray {
    return ByteArray(size * 4).also { bytes ->
        forEachIndexed { index, value ->
            bytes[index * 4] = (value shr 24).toByte()
            bytes[index * 4 + 1] = (value shr 16).toByte()
            bytes[index * 4 + 2] = (value shr 8).toByte()
            bytes[index * 4 + 3] = value.toByte()
        }
    }
}


================================================
FILE: Latanime/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "(Mexican) Anime Extension"
    language    = "mx"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","Anime","AnimeMovie")
    iconUrl = "https://latanime.org/public/img/logito.png"

    isCrossPlatform = false
}



================================================
FILE: Latanime/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Latanime/src/main/kotlin/com/latanime/Extractor.kt
================================================
package com.latanime

import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

open class Zilla : ExtractorApi() {
    override var name = "HLS"
    override var mainUrl = "https://player.zilla-networks.com"
    override val requiresReferer = false

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
            val mp4 = "$mainUrl/m3u8/${url.substringAfterLast("/")}"
            return listOf(
                newExtractorLink(
                    this.name,
                    this.name,
                    url = mp4,
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = referer ?: ""
                    this.quality = Qualities.P1080.value
                }
            )
    }
}

class Animeav1upn : VidStack() {
    override var mainUrl = "https://animeav1.uns.bio"
}


================================================
FILE: Latanime/src/main/kotlin/com/latanime/Latanime.kt
================================================
package com.latanime

import com.lagradost.cloudstream3.addDubStatus
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class Latanime : MainAPI() {
    override var mainUrl              = "https://latanime.org"
    override var name                 = "Latanime"
    override val hasMainPage          = true
    override var lang                 = "es-mx"
    override val hasDownloadSupport   = true
    override val hasQuickSearch       = true
    override val supportedTypes       = setOf(TvType.Anime, TvType.AnimeMovie)

    override val mainPage = mainPageOf(
        "animes?fecha=false&genero=false&letra=false&categoria=anime" to "Anime",
        "animes?fecha=false&genero=false&letra=false&categoria=Película" to "Película",
        "animes?fecha=false&genero=false&letra=false&categoria=especial" to "Especial",
        "animes?fecha=false&genero=false&letra=false&categoria=donghua" to "Donghua",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}&p=$page").documentLarge
        val home     = document.select("div.row a").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("h3").text()
        val href      = this.attr("href")
        val posterUrl = fixUrlNull(this.selectFirst("img")?.getImageAttr())
        val isDub     = title.contains("Latino") || title.contains("Castellano")
        return newAnimeSearchResponse(title, href, TvType.Anime) {
            this.posterUrl = posterUrl
            addDubStatus(isDub)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("${mainUrl}/buscar?q=$query").documentLarge
        return document.select("div.row a").mapNotNull { it.toSearchResult() }
    }

    override suspend fun load(url: String): LoadResponse {
        val document    = app.get(url).documentLarge
        val title       = document.selectFirst("h2")?.text() ?: "Desconocido"
        val poster      = document.selectFirst("meta[property=og:image]")?.attr("content")?.trim()
        val description = document.selectFirst("h2 ~ p.my-2")?.text()
        val tags        = document.select("a div.btn").map { it.text() }
        val year        = document.select(".span-tiempo").text().substringAfterLast(" de ").toIntOrNull()
        val epsAnchor   = document.select("div.row a[href*='/ver/']")

        return if (epsAnchor.size > 1) {
            val episodes: List<Episode>? = epsAnchor.map {
                val epPoster = it.select("img").attr("data-src")
                val epHref   = it.attr("href")

                newEpisode(epHref) {
                    this.posterUrl = epPoster
                }
            }

            newAnimeLoadResponse(title, url, TvType.Anime) {
                addEpisodes(DubStatus.Subbed, episodes)
                this.posterUrl = poster
                this.plot = description
                this.tags = tags
                this.year = year
            }
        } else newMovieLoadResponse(title, url, TvType.AnimeMovie, epsAnchor.attr("href")) {
            this.posterUrl = poster
            this.plot = description
            this.tags = tags
            this.year = year
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document.select("#play-video a").map {
            val href = base64Decode(it.attr("data-player")).substringAfter("=")
            loadExtractor(
                href,
                "",
                subtitleCallback,
                callback
            )
        }
        return true
    }

    private fun Element.getImageAttr(): String? {
        return this.attr("data-src")
            .takeIf { it.isNotBlank() && it.startsWith("http") }
            ?: this.attr("src").takeIf { it.isNotBlank() && it.startsWith("http") }
    }
}


================================================
FILE: Latanime/src/main/kotlin/com/latanime/LatanimeProvider.kt
================================================
package com.latanime

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class LatanimeProvider: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Latanime())
    }
}


================================================
FILE: LayarKacaProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 5


cloudstream {
    language = "id"
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    authors = listOf("Hexated,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Movie",
    )


    iconUrl = "https://www.google.com/s2/favicons?domain=tv7.lk21.am.in&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: LayarKacaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: LayarKacaProvider/src/main/kotlin/com/LayarKacaProvider/Extractors.kt
================================================
package com.layarKacaProvider

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONObject


class Co4nxtrl : Filesim() {
    override val mainUrl = "https://co4nxtrl.com"
    override val name = "Co4nxtrl"
    override val requiresReferer = true
}

open class Hownetwork : ExtractorApi() {
    override val name = "Hownetwork"
    override val mainUrl = "https://stream.hownetwork.xyz"
    override val requiresReferer = true

    override suspend fun getUrl(
            url: String,
            referer: String?,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val id = url.substringAfter("id=")
        val response = app.post(
                "$mainUrl/api.php?id=$id",
                data = mapOf(
                        "r" to "",
                        "d" to mainUrl,
                ),
                referer = url,
                headers = mapOf(
                        "X-Requested-With" to "XMLHttpRequest"
                )
        ).text
        val json = JSONObject(response)
        val file = json.optString("file")
        Log.d("Phisher", file)
            M3u8Helper.generateM3u8(
                this.name,
                file,
                file
            ).forEach(callback)
    }
}

class Furher : Filesim() {
    override val name = "Furher"
    override var mainUrl = "https://furher.in"
}

class Cloudhownetwork : Hownetwork() {
    override var mainUrl = "https://cloud.hownetwork.xyz"
}

class Furher2 : Filesim() {
    override val name = "Furher 2"
    override var mainUrl = "723qrh1p.fun"
}

class Turbovidhls : Filesim() {
    override val name = "Turbovidhls"
    override var mainUrl = "https://turbovidhls.com"
}



================================================
FILE: LayarKacaProvider/src/main/kotlin/com/LayarKacaProvider/LayarKacaProvider.kt
================================================
package com.layarKacaProvider

import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.*
import org.json.JSONObject
import org.jsoup.nodes.Element
import java.net.URI

class LayarKacaProvider : MainAPI() {

    override var mainUrl = "https://lk21.de"
    private var seriesUrl = "https://series.lk21.de"
    private var searchurl= "https://search.lk21.party"

    override var name = "LayarKaca"
    override val hasMainPage = true
    override var lang = "id"
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama
    )


    override val mainPage = mainPageOf(
        "$mainUrl/populer/page/" to "Film Terplopuler",
        "$mainUrl/rating/page/" to "Film Berdasarkan IMDb Rating",
        "$mainUrl/most-commented/page/" to "Film Dengan Komentar Terbanyak",
        "$seriesUrl/latest-series/page/" to "Series Terbaru",
        "$seriesUrl/series/asian/page/" to "Film Asian Terbaru",
        "$mainUrl/latest/page/" to "Film Upload Terbaru",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).documentLarge
        val home = document.select("article figure").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private suspend fun getProperLink(url: String): String {
        if (url.startsWith(seriesUrl)) return url
        val res = app.get(url).documentLarge
        return if (res.select("title").text().contains("Nontondrama", true)) {
            res.selectFirst("a#openNow")?.attr("href")
                ?: res.selectFirst("div.links a")?.attr("href")
                ?: url
        } else {
            url
        }
    }


    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3")?.ownText()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")!!.attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst("img")?.getImageAttr())
        val type = if (this.selectFirst("span.episode") == null) TvType.Movie else TvType.TvSeries
        val posterheaders= mapOf("Referer" to getBaseUrl(posterUrl))
        return if (type == TvType.TvSeries) {
            val episode = this.selectFirst("span.episode strong")?.text()?.filter { it.isDigit() }
                ?.toIntOrNull()
            newAnimeSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                this.posterHeaders = posterheaders
                addSub(episode)
            }
        } else {
            val quality = this.select("div.quality").text().trim()
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.posterHeaders = posterheaders
                addQuality(quality)
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val res = app.get("$searchurl/search.php?s=$query").text
        val results = mutableListOf<SearchResponse>()

        val root = JSONObject(res)
        val arr = root.getJSONArray("data")

        for (i in 0 until arr.length()) {
            val item = arr.getJSONObject(i)
            val title = item.getString("title")
            val slug = item.getString("slug")
            val type = item.getString("type")
            val posterUrl = "https://poster.lk21.party/wp-content/uploads/"+item.optString("poster")
            when (type) {
                "series" -> results.add(
                    newTvSeriesSearchResponse(title, "$seriesUrl/$slug", TvType.TvSeries) {
                        this.posterUrl = posterUrl
                    }
                )
                "movie" -> results.add(
                    newMovieSearchResponse(title, "$mainUrl/$slug", TvType.Movie) {
                        this.posterUrl = posterUrl
                    }
                )
            }
        }

        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val fixUrl = getProperLink(url)
        val document = app.get(fixUrl).documentLarge
        val baseurl=fetchURL(fixUrl)
        val title = document.selectFirst("div.movie-info h1")?.text()?.trim().toString()
        val poster = document.select("meta[property=og:image]").attr("content")
        val tags = document.select("div.tag-list span").map { it.text() }
        val posterheaders= mapOf("Referer" to getBaseUrl(poster))

        val year = Regex("\\d, (\\d+)").find(
            document.select("div.movie-info h1").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (document.selectFirst("#season-data") != null) TvType.TvSeries else TvType.Movie
        val description = document.selectFirst("div.meta-info")?.text()?.trim()
        val trailer = document.selectFirst("ul.action-left > li:nth-child(3) > a")?.attr("href")
        val rating = document.selectFirst("div.info-tag strong")?.text()

        val recommendations = document.select("li.slider article").map {
            val recName = it.selectFirst("h3")?.text()?.trim().toString()
            val recHref = baseurl+it.selectFirst("a")!!.attr("href")
            val recPosterUrl = fixUrl(it.selectFirst("img")?.attr("src").toString())
            newTvSeriesSearchResponse(recName, recHref, TvType.TvSeries) {
                this.posterUrl = recPosterUrl
                this.posterHeaders = posterheaders
            }
        }

        return if (tvType == TvType.TvSeries) {
            val json = document.selectFirst("script#season-data")?.data()
            val episodes = mutableListOf<Episode>()
            if (json != null) {
                val root = JSONObject(json)
                root.keys().forEach { seasonKey ->
                    val seasonArr = root.getJSONArray(seasonKey)
                    for (i in 0 until seasonArr.length()) {
                        val ep = seasonArr.getJSONObject(i)
                        val href = fixUrl("$baseurl/"+ep.getString("slug"))
                        val episodeNo = ep.optInt("episode_no")
                        val seasonNo = ep.optInt("s")
                        episodes.add(
                            newEpisode(href) {
                                this.name = "Episode $episodeNo"
                                this.season = seasonNo
                                this.episode = episodeNo
                            }
                        )
                    }
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.posterHeaders = posterheaders
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.posterHeaders = posterheaders
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document.select("ul#player-list > li").map {
                fixUrl(it.select("a").attr("href"))
            }.amap {
            val test=it.getIframe()
            val referer=getBaseUrl(it)
            Log.d("Phisher",test)
            loadExtractor(it.getIframe(), referer, subtitleCallback, callback)
        }
        return true
    }

    private suspend fun String.getIframe(): String {
        return app.get(this, referer = "$seriesUrl/").documentLarge.select("div.embed-container iframe")
            .attr("src")
    }

    private suspend fun fetchURL(url: String): String {
        val res = app.get(url, allowRedirects = false)
        val href = res.headers["location"]

        return if (href != null) {
            val it = URI(href)
            "${it.scheme}://${it.host}"
        } else {
            url
        }
    }


    private fun Element.getImageAttr(): String {
        return when {
            this.hasAttr("src") -> this.attr("src")
            this.hasAttr("data-src") -> this.attr("data-src")
            else -> this.attr("src")
        }
    }


    fun getBaseUrl(url: String?): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }

}



================================================
FILE: LayarKacaProvider/src/main/kotlin/com/LayarKacaProvider/LayarKacaProviderPlugin.kt
================================================
package com.layarKacaProvider

import com.lagradost.cloudstream3.extractors.EmturbovidExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro6
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.BasePlugin

@CloudstreamPlugin
class LayarKacaProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(LayarKacaProvider())
        registerExtractorAPI(EmturbovidExtractor())
        registerExtractorAPI(Furher())
        registerExtractorAPI(Hownetwork())
        registerExtractorAPI(VidHidePro6())
        registerExtractorAPI(Furher2())
        registerExtractorAPI(Turbovidhls())
        registerExtractorAPI(Cloudhownetwork())
        registerExtractorAPI(Co4nxtrl())
    }
}


================================================
FILE: MassTamilanProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 6


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Indian Multi-language Music Provider"
    language = "ta"
    authors = listOf("Phisher98,LikDev-256")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Music","Movie"
    )
    iconUrl = "https://raw.githubusercontent.com/LikDev-256/likdev256-tamil-providers/master/MassTamilanProvider/icon.png"

    isCrossPlatform = true
}



================================================
FILE: MassTamilanProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: MassTamilanProvider/src/main/kotlin/com/likdev256/MassTamilanProvider.kt
================================================
package com.likdev256


import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element

class MassTamilanProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://masstamilan.dev"
    override var name = "MassTamilan"
    override val hasMainPage = true
    override var lang = "ta"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Music,TvType.Movie
    )

    override val mainPage = mainPageOf(
        "$mainUrl/latest-updates" to "Latest Updates",
        "$mainUrl/tamil-songs" to "Tamil Songs",
        "$mainUrl/telugu-songs" to "Telugu Songs",
        "$mainUrl/malayalam-songs" to "Malayalam Songs",
        "$mainUrl/hindi-songs" to "Hindi Songs"
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get("${request.data}?page=$page").documentLarge
        Log.d("Phisher","${request.data}?page=$page")
        val home = document.select("div.a-i").mapNotNull {
                it.toSearchResult()
            }
        return newHomePageResponse(arrayListOf(HomePageList(request.name, home)), hasNext = true)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("div h2")?.text()?.trim() ?: return null
        val href = fixUrl(mainUrl + this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst("a picture img")?.attr("src"))
        return newTvSeriesSearchResponse(title, href+",,"+title, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
    }

    // Search is disabled bcz the provider doesn't support native search the current search is powered by google
    // which is garbaja and im too lazy to work on that PR if you can

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/search?keyword=$query").documentLarge
        //Log.d("document", document.toString())

        return document.select("div.a-i").mapNotNull {
            it.toSearchResult()
        }
    }

    data class MassTamilanLinks (
        @JsonProperty("sourceName") val sourceName: String,
        @JsonProperty("sourceLink") val sourceLink: String
    )

    override suspend fun load(url: String): LoadResponse {
        val docLink = url.substringBefore(",,")
        val doc = app.get(docLink).documentLarge
        //Log.d("Doc", doc.toString())
        val title = url.substringAfter(",,")
        //Log.d("title", title)
        val poster = fixUrlNull(mainUrl + doc.selectFirst("figure.ib > picture > img")?.attr("src"))
        //Log.d("poster", poster.toString())
        val description = doc.select("#movie-handle").text()
        var tags = listOf<String>()
        var year: Int? = 0
        var actors = listOf<ActorData>()
        doc.select("#movie-handle b + a").map { me ->
            tags = me.select("a[href~=-songs]").map { it.text() }
            year = me.select("a[href~=year]").text().trim().toIntOrNull()
            if (!me.select("a[href~=artist]").isEmpty()) {
                actors = me.select("a[href~=artist]").map {
                    ActorData(
                        Actor(
                            it.text()
                        ),
                        roleString = "Artist",
                    )
                }
            }
            if (!me.select("a[href~=music]").isEmpty()) {
                actors = me.select("a[href~=music]").map {
                    ActorData(
                        Actor(
                            it.text()
                        ),
                        roleString = "Music",
                    )
                }
            }
        }

        val episodes = ArrayList<Episode>()
        doc.select("#tlist > tbody > tr[itemprop]").map { me ->
            val links = me.select("td > a").map {
                MassTamilanLinks(
                    it.text(),
                    mainUrl + it.attr("href")
                )
            }
            val epPlot = "Singers: ${me.select("td > span[itemprop~=item] > span[itemprop~=byArtist]").text()} && \n" +
                    "Duration: ${me.select("td > span[itemprop~=item] > span[itemprop~=duration]").text()} && \n" +
                    "Downloads: ${me.select("td > span[itemprop~=item] > span[class~=dl-count]").text()}\n"

            episodes.add(
                newEpisode(links.toJson())
                {
                    this.name=me.select("td > span > h2 > span[itemprop~=name] > a").text()
                    this.season=1
                    this.episode=me.select("td > span[itemprop~=position]").text().toInt()
                    this.posterUrl=poster
                    this.description=epPlot
                }
            )
        }
        val zipLinks = doc.select("h2.ziparea > a.dlink").map {
            MassTamilanLinks(
                it.text(),
                mainUrl + it.attr("href")
            )
        }

        episodes.add(
            newEpisode(zipLinks.toJson())
            {
                this.name="Full Zip"
                this.season=1
                this.episode=episodes.count()+1
                this.posterUrl="https://miro.medium.com/v2/resize:fit:720/format:webp/1*nCwjG9N0CkYXOkznDB7kSw.png"
                this.description= "Zip/Rar links"
            }
        )

        return newTvSeriesLoadResponse(title, docLink, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.tags = tags
                this.actors = actors
                this.plot = description
            }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        parseJson<ArrayList<MassTamilanLinks>>(data).map {
            //val mp3Stream = app.get(data, allowRedirects = true)
            safeApiCall {
                callback.invoke(
                    newExtractorLink(
                        it.sourceName,
                        it.sourceName,
                        url = "https://goodproxy.goodproxy.workers.dev/fetch?url=${it.sourceLink}",
                        INFER_TYPE
                    ) {
                        this.referer = "$mainUrl/"
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        }


        return true
    }
}



================================================
FILE: MassTamilanProvider/src/main/kotlin/com/likdev256/MassTamilanProviderPlugin.kt
================================================
package com.likdev256

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class MovieHUBProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MassTamilanProvider())
    }
}



================================================
FILE: Megakino/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Movies,Series and Anime German Extension "
    language    = "de"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie,Anime,Cartoon")
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Megakino.jpg"

    isCrossPlatform = true
}



================================================
FILE: Megakino/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Megakino/src/main/kotlin/com/Megakino/Extractor.kt
================================================
package com.Megakino

import android.annotation.SuppressLint
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper

open class Gxplayer : ExtractorApi() {
    override var name = "Gxplayer"
    override var mainUrl = "https://watch.gxplayer.xyz"
    override val requiresReferer = true

    @SuppressLint("SuspiciousIndentation")
    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val json = app.get(url,referer=mainUrl).text.substringAfter("var video = ").substringBefore(";").toJson()
        val objectMapper = jacksonObjectMapper()
        val video: Details = objectMapper.readValue(json)
                M3u8Helper.generateM3u8(
                    this.name,
                    "$mainUrl/m3u8/${video.uid}/${video.md5}/master.txt?s=1&id=${video.id}&cache=${video.status}",
                    referer = "$mainUrl/",
                ).forEach(callback)
    }
}


data class Details(
    val id: String,
    val uid: String,
    val slug: String,
    val title: String,
    val folderid: Any?,
    val quality: String,
    val sources: Any?,
    val type: String,
    val userlinkhost: String,
    val poster: String,
    val subtitles: Any?,
    val added: String,
    val updatedtime: String,
    val status: String,
    val errorcount: String,
    val progressbar: String,
    val progress: String,
    val views: String,
    val md5: String,
)



================================================
FILE: Megakino/src/main/kotlin/com/Megakino/Megakino.kt
================================================
package com.Megakino

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element

class Megakino : MainAPI() {
    override var mainUrl              = "https://megakino.team"
    override var name                 = "Megakino"
    override val hasMainPage          = true
    override var lang                 = "de"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.TvSeries,TvType.Documentary)

    override val mainPage = mainPageOf(
        "" to "Trending",
        "kinofilme" to "Movies",
        "serials" to "Serials",
        "multfilm" to "Multfilm",
        "documentary" to "Documentary",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page").documentLarge
        val home = document.select("#dle-content > a").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("h3").text()
        val href = fixUrl(this.attr("href"))
        val posterUrl = fixUrlNull(mainUrl+this.select("img").attr("data-src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality= SearchQuality.HD
        }
    }

    private fun Element.toSearchResult1(): SearchResponse {
        val title = this.select("h3").text()
        val href = fixUrl(this.attr("href"))
        val posterUrl = fixUrlNull(mainUrl+this.select("img").attr("data-src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality= SearchQuality.HD
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val data= mapOf("do" to "search","subaction" to "search","story" to query.replace(" ","+"))
        val document=app.post(mainUrl, data = data).documentLarge
        val response = document.select("a.poster.grid-item").map {
                it.toSearchResult1()
            }
        return response
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("div.page__subcols.d-flex h1")?.text() ?: "Unknown"
        val poster = fixUrl(mainUrl+document.select("div.pmovie__poster.img-fit-cover img").attr("data-src"))
        val year=document.select("div.pmovie__year > span:nth-child(2)").text().toIntOrNull()
        val hreflist=document.select("div.pmovie__player iframe").map { it.attr("src").ifEmpty { it.attr("data-src") } }.toJson()
        val description = document.selectFirst("div.page__cols.d-flex p")?.text()
        val trailer=document.select("link[itemprop=embedUrl]").attr("href")
        val genresText = document.selectFirst("div.pmovie__genres")?.text()
        val genresList = genresText?.split(" / ")?.map { it.trim() } ?: emptyList()
        val typetag= document.select("div.pmovie__genres").text()
        val type=if (typetag.contains("Filme")) TvType.Movie else TvType.TvSeries
        return if (type==TvType.TvSeries)
        {
            val episodes = mutableListOf<Episode>()
            document.select("select.flex-grow-1.mr-select option").map {
                val epnumber="Episode "+it.attr("data-season")
                val ephref=it.select("option").attr("value")
                episodes+=newEpisode(ephref)
                {
                    this.name=epnumber
                    this.season=1
                    this.episode=epnumber.toIntOrNull()
                    this.posterUrl=poster
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genresList
                this.year = year
                addTrailer(trailer)
            }
        }
        else newMovieLoadResponse(title, url, TvType.Movie, hreflist) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genresList
                this.year = year
                addTrailer(trailer)
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        if (data.startsWith("["))
            {
            data.removeSurrounding("[\"", "\"]") // Remove the brackets
                .split("\",\"").amap {
                    loadExtractor(it,subtitleCallback, callback)
                }
            }
        else
            loadExtractor(data,subtitleCallback, callback)
        return true
    }
}



================================================
FILE: Megakino/src/main/kotlin/com/Megakino/MegakinoProvider.kt
================================================
package com.Megakino

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Voe

@CloudstreamPlugin
class MegakinoProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Megakino())
        registerExtractorAPI(Voe())
        registerExtractorAPI(Gxplayer())
    }
}


================================================
FILE: MovieBlast/build.gradle.kts
================================================
// use an integer for version numbers
version = 1

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "MovieBlast App"
    language    = "te"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries"
    )
    iconUrl="https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/movieblast.png"

    isCrossPlatform = false
}



================================================
FILE: MovieBlast/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: MovieBlast/src/main/kotlin/com/MovieBlast/MovieBlast.kt
================================================
package com.MovieBlast

import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.json.JSONArray
import org.json.JSONObject

class MovieBlast : MainAPI() {
    override var mainUrl = base64Decode("aHR0cHM6Ly9hcHAuY2xvdWQtbWIueHl6")
    override var name = "MovieBlast"
    override val hasMainPage = true
    override var lang = "te"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    companion object {
        val headers = mapOf(
           "user-agent" to "okhttp/5.0.0-alpha.6"
        )
        val token = base64Decode("amR2aGhqdjI1NXZnaGhnZGh2ZmNoMjU2NTY1NmpoZGNnaGZkZg==")

    }

    private fun HomeDaum.isSeries(): Boolean {
        return when (type?.lowercase()) {
            "series", "serie", "tv", "show" -> true
            else -> contentType?.lowercase() == "series"
        }
    }

    private fun MediaDetailResponse.isSeries(): Boolean {
        return seasons.isNotEmpty()
    }


    override val mainPage = mainPageOf(
        "api/genres/pinned/all" to "Latest",
        "api/genres/trending/all" to "Trending",
        "api/genres/new/all" to "Recently Added",
        "api/genres/popularmovies/all" to "Popular • Movies",
        "api/genres/popularseries/all" to "Popular • Series",
        "api/media/seriesEpisodesAll" to "Latest • Series",
        "api/genres/recommended/all" to "Recommended",
        "api/genres/media/names/New%20HD%20Released" to "New HD Releases"
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {

        val res = app.get(
            "$mainUrl/${request.data}/$token?page=$page",
            headers
        ).parsedSafe<Home>()

        val items = res?.data?.asSequence()?.mapNotNull { it.toSearchResultSafe() }
            ?.distinctBy { it.url.ifBlank { "${it.name}-${it.posterUrl}" } }?.toList()
            ?: emptyList()

        return newHomePageResponse(request.name, items)
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val safeQuery = query.trim().replace(" ", "%20")

        val res = app
            .get("$mainUrl/api/search/$safeQuery/$token")
            .parsedSafe<SearchRoot>()
            ?: return emptyList()

        return res.search.map { item ->
            val isSeries = item.type.contains("serie", ignoreCase = true)

            val path = if (isSeries) "series/show" else "media/detail"
            val href = "$mainUrl/api/$path/${item.id}/$token"

            newMovieSearchResponse(
                item.name,
                href,
                if (isSeries) TvType.TvSeries else TvType.Movie
            ) {
                posterUrl = item.posterPath
            }
        }
    }




    private fun HomeDaum.toSearchResultSafe(): SearchResponse? {
        val id = id ?: return null
        val title = name ?: return null

        val isSeries = isSeries()
        val path = if (isSeries) "series/show" else "media/detail"
        val tvType = if (isSeries) TvType.TvSeries else TvType.Movie

        return newMovieSearchResponse(
            title,
            "$mainUrl/api/$path/$id/$token",
            tvType
        ) {
            posterUrl = posterPath
        }
    }




    override suspend fun load(url: String): LoadResponse {
        val json = JSONObject(app.get(url).text)

        val title = json.optString("name", json.optString("title", "Unknown"))
        val poster = json.optString("poster_path").takeIf { it.isNotBlank() }

        val background = json.optString("backdrop_path_tv")
            .takeIf { it.isNotBlank() }
            ?: json.optString("backdrop_path")
                .takeIf { it.isNotBlank() }
            ?: poster
        Log.d("Phisher","$poster")
        val backdroppath = json.optString("backdrop_path")

        val overview = json.optString("overview")
        val releaseDate = json.optString("first_air_date",
            json.optString("release_date")
        )

        val voteAverage = json.optDouble("vote_average", -1.0)
            .takeIf { it >= 0 }

        val genres = json.optJSONArray("genres")?.let { arr ->
            (0 until arr.length()).mapNotNull {
                arr.optJSONObject(it)?.optString("name")
            }
        } ?: emptyList()

        val actors = json.optJSONArray("casterslist")?.let { arr ->
            (0 until arr.length()).mapNotNull {
                arr.optJSONObject(it)?.let { obj ->
                    val name = obj.optString("original_name") ?: return@let null
                    ActorData(
                        Actor(name, obj.optString("profile_path")),
                        roleString = obj.optString("character")
                    )
                }
            }
        } ?: emptyList()

        val isSeries = (json.optJSONArray("seasons")?.length() ?: 0) > 0

        return if (isSeries) {

            val episodes = mutableListOf<Episode>()

            val seasons = json.optJSONArray("seasons") ?: JSONArray()
            for (i in 0 until seasons.length()) {
                val seasonObj = seasons.getJSONObject(i)
                val seasonNumber = seasonObj.optInt("season_number", 0)

                val eps = seasonObj.optJSONArray("episodes") ?: continue
                for (j in 0 until eps.length()) {
                    val ep = eps.getJSONObject(j)

                    val videoUrls = ep.optJSONArray("videos")?.let { vids ->
                        (0 until vids.length()).mapNotNull { v ->
                            vids.optJSONObject(v)?.let {
                                LoadURL(
                                    it.optString("link"),
                                    it.optString("server"),
                                    it.optString("lang")
                                )
                            }
                        }
                    } ?: emptyList()

                    episodes += newEpisode(videoUrls.toJson()) {
                        name = ep.optString("name")
                        season = seasonNumber
                        episode = ep.optInt("episode_number", 0)
                        description = ep.optString("overview")
                        addDate(ep.optString("created_at"))
                        posterUrl = ep.optString("still_path_tv", ep.optString("still_path"))
                    }
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                posterUrl = poster
                backgroundPosterUrl = background ?: backdroppath ?: poster
                plot = overview
                tags = genres
                year = releaseDate.substringBefore("-").toIntOrNull()
                score = Score.from10(voteAverage)
                this.actors = actors
                addImdbId(json.optString("imdb_external_id"))
                addTMDbId(json.optLong("tmdb_id").toString())
            }

        } else {

            val videoUrls = json.optJSONArray("videos")?.let { vids ->
                (0 until vids.length()).mapNotNull { it ->
                    vids.optJSONObject(it)?.let {
                        LoadURL(
                            it.optString("link"),
                            it.optString("server"),
                            it.optString("lang")
                        )
                    }
                }
            } ?: emptyList()

            newMovieLoadResponse(title, url, TvType.Movie, videoUrls.toJson()) {
                posterUrl = poster
                backgroundPosterUrl = background ?: backdroppath
                plot = overview
                tags = genres
                year = releaseDate.substringBefore("-").toIntOrNull()
                score = Score.from10(voteAverage)
                this.actors = actors
                addImdbId(json.optString("imdb_external_id"))
                addTMDbId(json.optLong("tmdb_id").toString())
            }
        }
    }




    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links = tryParseJson<List<LoadURL>>(data) ?: emptyList()
        links.forEach { loadUrl ->
            if (loadUrl.link!=null)
            {
                Log.d("Phisher", loadUrl.link)
                callback.invoke(
                    newExtractorLink(
                        "${loadUrl.server}",
                        "$name ${loadUrl.lang}",
                        url = loadUrl.link,
                        INFER_TYPE
                    ) {
                        this.quality = matchQualityFromString(loadUrl.server)
                    }
                )
            }
        }
        return true
    }

    fun matchQualityFromString(s: String?): Int {
        if (s.isNullOrBlank()) return Qualities.Unknown.value

        val v = s.lowercase()

        return when {
            "2160" in v || "4k" in v        -> Qualities.P2160.value
            "1440" in v                    -> Qualities.P1440.value
            "1080" in v || "fullhd" in v   -> Qualities.P1080.value
            "720" in v || "hd" in v        -> Qualities.P720.value
            "480" in v                     -> Qualities.P480.value
            "360" in v                     -> Qualities.P360.value
            else                           -> Qualities.Unknown.value
        }
    }

}





================================================
FILE: MovieBlast/src/main/kotlin/com/MovieBlast/MovieBlastParser.kt
================================================
package com.MovieBlast

import com.fasterxml.jackson.annotation.JsonAlias
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty

data class LoadURL(
    val link: String?=null ,
    val server: String?=null,
    val lang: String?=null,
)


data class Home(
    @JsonProperty("current_page")
    val currentPage: Long? = null,
    val data: List<HomeDaum> = emptyList(),
    @JsonProperty("first_page_url")
    val firstPageUrl: String? = null,
    val from: Long? = null,
    @JsonProperty("last_page")
    val lastPage: Long? = null,
    @JsonProperty("last_page_url")
    val lastPageUrl: String? = null,
    val links: List<HomeLink> = emptyList(),
    @JsonProperty("next_page_url")
    val nextPageUrl: String? = null,
    val path: String? = null,
    @JsonProperty("per_page")
    val perPage: Long? = null,
    @JsonProperty("prev_page_url")
    val prevPageUrl: String? = null,
    val to: Long? = null,
    val total: Long? = null
)

data class HomeDaum(
    val id: Long? = null,
    val name: String? = null,
    @JsonProperty("poster_path")
    val posterPath: String? = null,
    @JsonProperty("backdrop_path")
    val backdropPath: String? = null,
    @JsonProperty("backdrop_path_tv")
    val backdropPathTv: String? = null,
    @JsonProperty("vote_average")
    val voteAverage: Double? = null,
    val subtitle: String? = null,
    val overview: String? = null,
    @JsonProperty("release_date")
    val releaseDate: String? = null,
    val pinned: Long? = null,
    @JsonProperty("created_at")
    val createdAt: String? = null,
    val views: Long? = null,
    val type: String? = null,
    @JsonProperty("genre_name")
    val genreName: String? = null,
    @JsonProperty("recent_views")
    val recentViews: Long? = null,
    @JsonProperty("content_type")
    val contentType: String? = null
)

data class HomeLink(
    val url: String? = null,
    val label: String? = null,
    val active: Boolean? = null
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MediaDetailResponse(
    val id: Long? = null,
    @JsonProperty("tmdb_id")
    val tmdbId: String? = null,
    @JsonAlias("title", "name")
    val title: String? = null,
    @JsonProperty("original_name")
    val originalName: String? = null,
    @JsonProperty("imdb_external_id")
    val imdbExternalId: String? = null,
    val subtitle: String? = null,
    val overview: String? = null,
    @JsonProperty("poster_path")
    val posterPath: String? = null,
    @JsonProperty("backdrop_path")
    val backdropPath: String? = null,
    @JsonProperty("backdrop_path_tv")
    val backdropPathTv: String? = null,
    @JsonProperty("preview_path")
    val previewPath: String? = null,
    @JsonProperty("vote_average")
    val voteAverage: Double? = null,
    @JsonProperty("vote_count")
    val voteCount: Long? = null,
    val popularity: Double? = null,
    val runtime: String? = null,
    val views: Long? = null,
    val featured: Boolean? = null,
    val premuim: Boolean? = null,
    val active: Boolean? = null,
    val pinned: Boolean? = null,
    @JsonAlias("release_date", "first_air_date")
    val releaseDate: String? = null,

    @JsonProperty("skiprecap_start_in")
    val skipRecapStartIn: Long? = null,

    val hasrecap: Boolean? = null,

    @JsonProperty("enable_stream")
    val enableStream: Boolean? = null,

    @JsonProperty("enable_media_download")
    val enableMediaDownload: Boolean? = null,

    @JsonProperty("enable_ads_unlock")
    val enableAdsUnlock: Boolean? = null,

    val casterslist: List<Caster> = emptyList(),
    val networkslist: List<Network> = emptyList(),
    val genres: List<Genre> = emptyList(),
    val videos: List<Video> = emptyList(),
    val seasons: List<Season> = emptyList()
)

data class Caster(
    val id: Long? = null,
    val name: String? = null,
    @JsonProperty("original_name")
    val originalName: String? = null,
    @JsonProperty("profile_path")
    val profilePath: String? = null,
    val character: String? = null
)

data class Network(
    val id: Long? = null,
    val name: String? = null,
    @JsonProperty("logo_path")
    val logoPath: String? = null,
    @JsonProperty("origin_country")
    val originCountry: String? = null,
    @JsonProperty("created_at")
    val createdAt: String? = null,
    @JsonProperty("updated_at")
    val updatedAt: String? = null
)

data class Genre(
    val id: Long? = null,
    @JsonProperty("movie_id")
    val movieId: Long? = null,
    @JsonProperty("genre_id")
    val genreId: Long? = null,
    val name: String? = null
)

data class Season(
    val id: Long,
    @JsonProperty("tmdb_id")
    val tmdbId: Long,
    @JsonProperty("serie_id")
    val serieId: Long,
    @JsonProperty("season_number")
    val seasonNumber: Int,
    val name: String,
    val overview: Any?,
    @JsonProperty("poster_path")
    val posterPath: String,
    @JsonProperty("air_date")
    val airDate: String,
    @JsonProperty("created_at")
    val createdAt: String,
    @JsonProperty("updated_at")
    val updatedAt: String,
    val episodes: List<Episode>,
)

data class Episode(
    val id: Long,
    @JsonProperty("tmdb_id")
    val tmdbId: Long,
    @JsonProperty("season_id")
    val seasonId: Long,
    @JsonProperty("episode_number")
    val episodeNumber: Int,
    val name: String,
    val overview: String,
    @JsonProperty("still_path")
    val stillPath: String,
    @JsonProperty("vote_average")
    val voteAverage: Long,
    @JsonProperty("vote_count")
    val voteCount: Long,
    val views: Long,
    @JsonProperty("air_date")
    val airDate: String,
    @JsonProperty("skiprecap_start_in")
    val skiprecapStartIn: Long,
    val hasrecap: Long,
    @JsonProperty("created_at")
    val createdAt: String,
    @JsonProperty("updated_at")
    val updatedAt: String,
    @JsonProperty("still_path_tv")
    val stillPathTv: String,
    @JsonProperty("enable_stream")
    val enableStream: Long,
    @JsonProperty("enable_media_download")
    val enableMediaDownload: Long,
    @JsonProperty("enable_ads_unlock")
    val enableAdsUnlock: Long,
    val videos: List<Video>,
    val substitles: List<Any?>,
    val downloads: List<Any?>,
)

data class Video(
    val id: Long? = null,
    @JsonProperty("movie_id")
    val movieId: Long? = null,
    val server: String? = null,
    val link: String? = null,
    val lang: String? = null,
    val hd: Boolean? = null,
    val embed: Boolean? = null,
    val youtubelink: Boolean? = null,
    val hls: Boolean? = null,
    val drm: Boolean? = null,
    val status: Long? = null,
    @JsonProperty("created_at")
    val createdAt: String? = null,
    @JsonProperty("updated_at")
    val updatedAt: String? = null
)

//search

data class SearchRoot(
    val search: List<Search>,
)

data class Search(
    val id: Long,
    val name: String,

    @JsonProperty("original_name")
    val originalName: String?,

    @JsonProperty("poster_path")
    val posterPath: String?,

    @JsonProperty("backdrop_path")
    val backdropPath: String?,

    @JsonProperty("backdrop_path_tv")
    val backdropPathTv: String?,

    @JsonProperty("vote_average")
    val voteAverage: Double?,

    val subtitle: Any?,

    val overview: String?,

    @JsonProperty("release_date")
    val releaseDate: String?,

    val pinned: Int?,

    @JsonProperty("created_at")
    val createdAt: String?,

    @JsonProperty("updated_at")
    val updatedAt: String?,

    val views: Long?,

    val type: String,

    @JsonProperty("genre_name")
    val genreName: String?,

    @JsonProperty("match_score")
    val matchScore: Double?
)





================================================
FILE: MovieBlast/src/main/kotlin/com/MovieBlast/MovieBlastProvider.kt
================================================
package com.MovieBlast

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class MovieBlastProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(MovieBlast())
    }
}


================================================
FILE: MovieBoxProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 5

android {
    buildFeatures {
        buildConfig = true
    }
}

cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

    description = "Multi Language Movies and Series Provider"
    authors = listOf("NivinCNC,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Movie",
        "TvSeries"
    )

    iconUrl = "https://github.com/NivinCNC/CNCVerse-Cloud-Stream-Extension/raw/refs/heads/master/MovieBoxProvider/icon.png"

    requiresResources = true
    isCrossPlatform = false
}



================================================
FILE: MovieBoxProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: MovieBoxProvider/src/main/kotlin/com/MovieBox/MovieBoxProvider.kt
================================================
package com.MovieBox

import android.annotation.SuppressLint
import android.net.Uri
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.net.URLEncoder
import java.security.MessageDigest
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import kotlin.math.max

class MovieBoxProvider : MainAPI() {
    override var mainUrl = "https://api.inmoviebox.com"
    override var name = "MovieBox"
    override val hasMainPage = true
    override var lang = "hi"
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries)

    private val secretKeyDefault = base64Decode("NzZpUmwwN3MweFNOOWpxbUVXQXQ3OUVCSlp1bElRSXNWNjRGWnIyTw==")
    private val secretKeyAlt = base64Decode("WHFuMm5uTzQxL0w5Mm8xaXVYaFNMSFRiWHZZNFo1Wlo2Mm04bVNMQQ==")

        private fun md5(input: ByteArray): String {
        return MessageDigest.getInstance("MD5").digest(input)
            .joinToString("") { "%02x".format(it) }
    }

    private fun reverseString(input: String): String = input.reversed()

    private fun generateXClientToken(hardcodedTimestamp: Long? = null): String {
        val timestamp = (hardcodedTimestamp ?: System.currentTimeMillis()).toString()
        val reversed = reverseString(timestamp)
        val hash = md5(reversed.toByteArray())
        return "$timestamp,$hash"
    }

    @SuppressLint("UseKtx")
    private fun buildCanonicalString(
        method: String,
        accept: String?,
        contentType: String?,
        url: String,
        body: String?,
        timestamp: Long
    ): String {
        val parsed = Uri.parse(url)
        val path = parsed.path ?: ""
        
        // Build query string with sorted parameters (if any)
        val query = if (parsed.queryParameterNames.isNotEmpty()) {
            parsed.queryParameterNames.sorted().joinToString("&") { key ->
                parsed.getQueryParameters(key).joinToString("&") { value ->
                    "$key=$value"  // Don't URL encode here - Python doesn't do it
                }
            }
        } else ""
        
        val canonicalUrl = if (query.isNotEmpty()) "$path?$query" else path

        val bodyBytes = body?.toByteArray(Charsets.UTF_8)
        val bodyHash = if (bodyBytes != null) {
            val trimmed = if (bodyBytes.size > 102400) bodyBytes.copyOfRange(0, 102400) else bodyBytes
            md5(trimmed)
        } else ""

        val bodyLength = bodyBytes?.size?.toString() ?: ""
        return "${method.uppercase()}\n" +
                "${accept ?: ""}\n" +
                "${contentType ?: ""}\n" +
                "$bodyLength\n" +
                "$timestamp\n" +
                "$bodyHash\n" +
                canonicalUrl
    }

    private fun generateXTrSignature(
        method: String,
        accept: String?,
        contentType: String?,
        url: String,
        body: String? = null,
        useAltKey: Boolean = false,
        hardcodedTimestamp: Long? = null
    ): String {
        val timestamp = hardcodedTimestamp ?: System.currentTimeMillis()
        val canonical = buildCanonicalString(method, accept, contentType, url, body, timestamp)
        val secret = if (useAltKey) secretKeyAlt else secretKeyDefault
        val secretBytes = base64DecodeArray(secret)

        val mac = Mac.getInstance("HmacMD5")
        mac.init(SecretKeySpec(secretBytes, "HmacMD5"))
        val signature = mac.doFinal(canonical.toByteArray(Charsets.UTF_8))
        val signatureB64 = base64Encode(signature)

        return "$timestamp|2|$signatureB64"
    }

    override val mainPage = mainPageOf(
        "4516404531735022304" to "Trending",
        "5692654647815587592" to "Trending in Cinema",
        "414907768299210008"  to "Bollywood",
        "3859721901924910512" to "South Indian",
        "8019599703232971616" to "Hollywood",
        "4741626294545400336" to "Top Series This Week",
        "8434602210994128512" to "Anime",
        "1255898847918934600" to "Reality TV",
        "4903182713986896328" to "Indian Drama",
        "7878715743607948784" to "Korean Drama",
        "8788126208987989488" to "Chinese Drama",
        "3910636007619709856" to "Western TV",
        "5177200225164885656" to "Turkish Drama",
        "1|1" to "Movies",
        "1|2" to "Series",
        "1|1006" to "Anime",
        "1|1;country=India" to "Indian (Movies)",
        "1|2;country=India" to "Indian (Series)",
        "1|1;classify=Hindi dub;country=United States" to "USA (Movies)",
        "1|2;classify=Hindi dub;country=United States" to "USA (Series)",
        "1|1;country=Japan" to "Japan (Movies)",
        "1|2;country=Japan" to "Japan (Series)",
        "1|1;country=China" to "China (Movies)",
        "1|2;country=China" to "China (Series)",
        "1|1;country=Philippines" to "Philippines (Movies)",
        "1|2;country=Philippines" to "Philippines (Series)",
        "1|1;country=Thailand" to "Thailand(Movies)",
        "1|2;country=Thailand" to "Thailand(Series)",
        "1|1;country=Nigeria" to "Nollywood (Movies)",
        "1|2;country=Nigeria" to "Nollywood (Series)",
        "1|1;country=Korea" to "South Korean (Movies)",
        "1|2;country=Korea" to "South Korean (Series)",
        "1|1;classify=Hindi dub;genre=Action" to "Action (Movies)",
        "1|1;classify=Hindi dub;genre=Crime" to "Crime (Movies)",
        "1|1;classify=Hindi dub;genre=Comedy" to "Comedy (Movies)",
        "1|1;classify=Hindi dub;genre=Romance" to "Romance (Movies)",
        "1|2;classify=Hindi dub;genre=Crime" to "Crime (Series)",
        "1|2;classify=Hindi dub;genre=Comedy" to "Comedy (Series)",
        "1|2;classify=Hindi dub;genre=Romance" to "Romance (Series)",
        )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val perPage = 15
        val url = if (request.data.contains("|")) "$mainUrl/wefeed-mobile-bff/subject-api/list" else "$mainUrl/wefeed-mobile-bff/tab/ranking-list?tabId=0&categoryType=${request.data}&page=$page&perPage=$perPage"

        val data1 = request.data

        val mainParts = data1.substringBefore(";").split("|")
        val pg = mainParts.getOrNull(0)?.toIntOrNull() ?: 1
        val channelId = mainParts.getOrNull(1)

        val options = mutableMapOf<String, String>()
        data1.substringAfter(";", "")
            .split(";")
            .forEach {
                val (k, v) = it.split("=").let { p ->
                    p.getOrNull(0) to p.getOrNull(1)
                }
                if (!k.isNullOrBlank() && !v.isNullOrBlank()) {
                    options[k] = v
                }
            }

        val classify = options["classify"] ?: "All"
        val country  = options["country"] ?: "All"
        val year     = options["year"] ?: "All"
        val genre    = options["genre"] ?: "All"
        val sort     = options["sort"] ?: "ForYou"

        val jsonBody = """{"page":$pg,"perPage":$perPage,"channelId":"$channelId","classify":"$classify","country":"$country","year":"$year","genre":"$genre","sort":"$sort"}"""

        // Use current timestamps instead of hardcoded ones
        val xClientToken = generateXClientToken()
        val xTrSignature = generateXTrSignature("POST", "application/json", "application/json; charset=utf-8", url , jsonBody)

        val getxTrSignature = generateXTrSignature("GET", "application/json", "application/json", url)

        val headers = mapOf(
            "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
            "accept" to "application/json",
            "content-type" to "application/json",
            "connection" to "keep-alive",
            "x-client-token" to xClientToken,
            "x-tr-signature" to xTrSignature,
            "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
            "x-client-status" to "0",
            "x-play-mode" to "2" // Optional, if needed for specific API behavior
        )

        val getheaders = mapOf(
            "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
            "accept" to "application/json",
            "content-type" to "application/json",
            "connection" to "keep-alive",
            "x-client-token" to xClientToken,
            "x-tr-signature" to getxTrSignature,
            "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
            "x-client-status" to "0",
        )

            val requestBody = jsonBody.toRequestBody("application/json".toMediaType())
            val response = if (request.data.contains("|")) app.post(url, headers = headers, requestBody = requestBody) else app.get(url, headers = getheaders)

            val responseBody = response.body.string()
            // Use Jackson to parse the new API response structure
            val data = try {
                val mapper = jacksonObjectMapper()
                val root = mapper.readTree(responseBody)
                val items = root["data"]?.get("items") ?: root["data"]?.get("subjects") ?: return newHomePageResponse(emptyList())
                items.mapNotNull { item ->
                    val title = item["title"]?.asText()?.substringBefore("[") ?: return@mapNotNull null
                    val id = item["subjectId"]?.asText() ?: return@mapNotNull null
                    val coverImg = item["cover"]?.get("url")?.asText()
                    val subjectType = item["subjectType"]?.asInt() ?: 1
                    val type = when (subjectType) {
                        1 -> TvType.Movie
                        2 -> TvType.TvSeries
                        else -> TvType.Movie
                    }
                    newMovieSearchResponse(
                        name = title,
                        url = id,
                        type = type
                    ) {
                        this.posterUrl = coverImg
                        this.score = Score.from10(item["imdbRatingValue"]?.asText())
                    }
                }
            } catch (_: Exception) {
                null
            } ?: emptyList()

            return newHomePageResponse(
                listOf(
                    HomePageList(request.name, data)
                )
            )

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/wefeed-mobile-bff/subject-api/search/v2"
        val jsonBody = """{"page": 1, "perPage": 10, "keyword": "$query"}"""
        val xClientToken = generateXClientToken()
        val xTrSignature = generateXTrSignature("POST", "application/json", "application/json; charset=utf-8", url, jsonBody)
        val headers = mapOf(
            "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
            "accept" to "application/json",
            "content-type" to "application/json",
            "connection" to "keep-alive",
            "x-client-token" to xClientToken,
            "x-tr-signature" to xTrSignature,
            "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
            "x-client-status" to "0"
        )
        val requestBody = jsonBody.toRequestBody("application/json".toMediaType())
        val response = app.post(
            url,
            headers = headers,
            requestBody = requestBody
        )

        val responseBody = response.body.string()
        val mapper = jacksonObjectMapper()
        val root = mapper.readTree(responseBody)
        val results = root["data"]?.get("results") ?: return emptyList()
        val searchList = mutableListOf<SearchResponse>()
        for (result in results) {
            val subjects = result["subjects"] ?: continue
            for (subject in subjects) {
            val title = subject["title"]?.asText() ?: continue
            val id = subject["subjectId"]?.asText() ?: continue
            val coverImg = subject["cover"]?.get("url")?.asText()
            val subjectType = subject["subjectType"]?.asInt() ?: 1
            val type = when (subjectType) {
                        1 -> TvType.Movie
                        2 -> TvType.TvSeries
                        else -> TvType.Movie
                }
            searchList.add(
                newMovieSearchResponse(
                name = title,
                url = id,
                type = type
                ) {
                    this.posterUrl = coverImg
                    this.score = Score.from10(subject["imdbRatingValue"]?.asText())
                }
            )
            }
        }
        return searchList
    }

    override suspend fun load(url: String): LoadResponse {

        val id = Regex("""subjectId=([^&]+)""")
            .find(url)
            ?.groupValues?.get(1)
            ?: url.substringAfterLast('/')


        val finalUrl = "$mainUrl/wefeed-mobile-bff/subject-api/get?subjectId=$id"
        val xClientToken = generateXClientToken()
        val xTrSignature = generateXTrSignature("GET", "application/json", "application/json", finalUrl)

        val headers = mapOf(
            "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
            "accept" to "application/json",
            "content-type" to "application/json",
            "connection" to "keep-alive",
            "x-client-token" to xClientToken,
            "x-tr-signature" to xTrSignature,
            "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
            "x-client-status" to "0",
            "x-play-mode" to "2"
        )

        val response = app.get(finalUrl, headers = headers)
        if (response.code != 200) {
            throw ErrorLoadingException("Failed to load data: ${response.body.string()}")
        }

        val body = response.body.string()
        val mapper = jacksonObjectMapper()
        val root = mapper.readTree(body)
        val data = root["data"] ?: throw ErrorLoadingException("No data")

        val title = data["title"]?.asText()?.substringBefore("[") ?: throw ErrorLoadingException("No title found")
        val description = data["description"]?.asText()
        val releaseDate = data["releaseDate"]?.asText()
        val duration = data["duration"]?.asText()
        val genre = data["genre"]?.asText()
        val imdbRating = data["imdbRatingValue"]?.asText()?.toDoubleOrNull()?.times(10)?.toInt()
        val year = releaseDate?.substring(0, 4)?.toIntOrNull()

        val coverUrl = data["cover"]?.get("url")?.asText()
        val backgroundUrl = data["cover"]?.get("url")?.asText()

        val subjectType = data["subjectType"]?.asInt() ?: 1

        val actors = data["staffList"]
            ?.mapNotNull { staff ->
                val staffType = staff["staffType"]?.asInt()
                if (staffType == 1) {
                    val name = staff["name"]?.asText() ?: return@mapNotNull null
                    val character = staff["character"]?.asText()
                    val avatarUrl = staff["avatarUrl"]?.asText()
                    ActorData(
                        Actor(name, avatarUrl),
                        roleString = character
                    )
                } else null
            }
            ?.distinctBy { it.actor.name }
            ?: emptyList()


        val tags = genre?.split(",")?.map { it.trim() } ?: emptyList()

        val durationMinutes = duration?.let { dur ->
            val regex = """(\d+)h\s*(\d+)m""".toRegex()
            val m = regex.find(dur)
            if (m != null) {
                val h = m.groupValues[1].toIntOrNull() ?: 0
                val min = m.groupValues[2].toIntOrNull() ?: 0
                h * 60 + min
            } else dur.replace("m", "").toIntOrNull()
        }

        val type = when (subjectType) {
            1 -> TvType.Movie
            2 -> TvType.TvSeries
            else -> TvType.Movie
        }

        val (tmdbId, imdbId) = identifyID(
            title = title.substringBefore("(").substringBefore("["),
            year = releaseDate?.take(4)?.toIntOrNull(),
            imdbRatingValue = imdbRating?.toDouble(),
        )

        val logoUrl = fetchTmdbLogoUrl(
            tmdbAPI = "https://api.themoviedb.org/3",
            apiKey = "98ae14df2b8d8f8f8136499daf79f0e0",
            type = type,
            tmdbId = tmdbId,
            appLangCode = "en"
        )

        val meta = if (!imdbId.isNullOrBlank()) fetchMetaData(imdbId, type) else null
        val metaVideos = meta?.get("videos")?.toList() ?: emptyList()

        val Poster = meta?.get("poster")?.asText() ?: coverUrl
        val Background = meta?.get("background")?.asText() ?: backgroundUrl
        val Description = meta?.get("description")?.asText() ?: description
        val IMDBRating = meta?.get("imdbRating")?.asText()

        if (type == TvType.TvSeries) {

            val seasonUrl = "$mainUrl/wefeed-mobile-bff/subject-api/season-info?subjectId=$id"
            val seasonSig = generateXTrSignature("GET", "application/json", "application/json", seasonUrl)
            val seasonHeaders = headers.toMutableMap().apply {
                put("x-tr-signature", seasonSig)
            }

            val seasonResponse = app.get(seasonUrl, headers = seasonHeaders)
            val episodes = mutableListOf<Episode>()

            if (seasonResponse.code == 200) {
                val seasonBody = seasonResponse.body.string()
                val seasonRoot = mapper.readTree(seasonBody)
                val seasons = seasonRoot["data"]?.get("seasons")

                seasons?.forEach { season ->
                    val seasonNumber = season["se"]?.asInt() ?: 1
                    val maxEp = season["maxEp"]?.asInt() ?: 1

                    for (episodeNumber in 1..maxEp) {

                        val epMeta = metaVideos.firstOrNull {
                            it["season"]?.asInt() == seasonNumber &&
                                    it["episode"]?.asInt() == episodeNumber
                        }

                        val epName =
                            epMeta?.get("name")?.asText()?.takeIf { it.isNotBlank() }
                                ?: "S${seasonNumber}E${episodeNumber}"

                        val epDesc =
                            epMeta?.get("overview")?.asText()
                                ?: epMeta?.get("description")?.asText()
                                ?: "Season $seasonNumber Episode $episodeNumber"

                        val epThumb =
                            epMeta?.get("thumbnail")?.asText()?.takeIf { it.isNotBlank() }
                                ?: coverUrl

                        val aired =
                        epMeta?.get("firstAired")?.asText()?.takeIf { it.isNotBlank() }
                            ?: ""

                        episodes.add(
                            newEpisode("$id|$seasonNumber|$episodeNumber") {
                                this.name = epName
                                this.season = seasonNumber
                                this.episode = episodeNumber
                                this.posterUrl = epThumb
                                this.description = epDesc
                                addDate(aired)
                            }
                        )
                    }
                }
            }

            if (episodes.isEmpty()) {
                episodes.add(
                    newEpisode("$id|1|1") {
                        this.name = "Episode 1"
                        this.season = 1
                        this.episode = 1
                        this.posterUrl = Poster
                    }
                )
            }

            return newTvSeriesLoadResponse(title, finalUrl, type, episodes) {
                this.posterUrl =  coverUrl ?: Poster
                this.backgroundPosterUrl = Background ?: backgroundUrl
                try { this.logoUrl = logoUrl } catch(_:Throwable){}
                this.plot = Description ?: description
                this.year = year
                this.tags = tags
                this.actors = actors
                this.score = Score.from10(IMDBRating) ?: imdbRating?.let { Score.from10(it) }
                this.duration = durationMinutes
                addImdbId(imdbId)
                addTMDbId(tmdbId.toString())
            }
        }

        return newMovieLoadResponse(title, finalUrl, type, id) {
            this.posterUrl = coverUrl ?: Poster
            this.backgroundPosterUrl = Background ?: backgroundUrl
            try { this.logoUrl = logoUrl } catch(_:Throwable){}
            this.plot = Description ?: description
            this.year = year
            this.tags = tags
            this.actors = actors
            this.score = Score.from10(IMDBRating) ?:imdbRating?.let { Score.from10(it) }
            this.duration = durationMinutes
            addImdbId(imdbId)
            addTMDbId(tmdbId.toString())
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        try {
            val parts = data.split("|")
            val originalSubjectId = when {
                parts[0].contains("get?subjectId") -> {
                    Regex("""subjectId=([^&]+)""")
                        .find(parts[0])
                        ?.groupValues?.get(1)
                        ?: parts[0].substringAfterLast('/')
                }
                parts[0].contains("/") -> {
                    parts[0].substringAfterLast('/')
                }
                else -> parts[0]
            }

            val season = if (parts.size > 1) parts[1].toIntOrNull() ?: 0 else 0
            val episode = if (parts.size > 2) parts[2].toIntOrNull() ?: 0 else 0
            val subjectUrl = "$mainUrl/wefeed-mobile-bff/subject-api/get?subjectId=$originalSubjectId"
            val subjectXClientToken = generateXClientToken()
            val subjectXTrSignature = generateXTrSignature("GET", "application/json", "application/json", subjectUrl)
            val subjectHeaders = mapOf(
                "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                "accept" to "application/json",
                "content-type" to "application/json",
                "connection" to "keep-alive",
                "x-client-token" to subjectXClientToken,
                "x-tr-signature" to subjectXTrSignature,
                "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                "x-client-status" to "0"
            )
            
            val subjectResponse = app.get(subjectUrl, headers = subjectHeaders)
            val mapper = jacksonObjectMapper()
            val subjectIds = mutableListOf<Pair<String, String>>() // Pair of (subjectId, language)
            var originalLanguageName = "Original"
            if (subjectResponse.code == 200) {
                val subjectResponseBody = subjectResponse.body.string()
                val subjectRoot = mapper.readTree(subjectResponseBody)
                val subjectData = subjectRoot["data"]
                val dubs = subjectData?.get("dubs")
                if (dubs != null && dubs.isArray) {
                    for (dub in dubs) {
                        val dubSubjectId = dub["subjectId"]?.asText()
                        val lanName = dub["lanName"]?.asText()
                        if (dubSubjectId != null && lanName != null) {
                            if (dubSubjectId == originalSubjectId) {
                                originalLanguageName = lanName
                            } else {
                                subjectIds.add(Pair(dubSubjectId, lanName))
                            }
                        }
                    }
                }
            }
            
            // Always add the original subject ID first as the default source with proper language name
            subjectIds.add(0, Pair(originalSubjectId, originalLanguageName))
            
            //var hasAnyLinks = false
            
            // Process each subjectId (including dubs)
            for ((subjectId, language) in subjectIds) {
                try {
                    val url = "$mainUrl/wefeed-mobile-bff/subject-api/play-info?subjectId=$subjectId&se=$season&ep=$episode"
                    
                    val xClientToken = generateXClientToken()
                    val xTrSignature = generateXTrSignature("GET", "application/json", "application/json", url)
                    val headers = mapOf(
                        "user-agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                        "accept" to "application/json",
                        "content-type" to "application/json",
                        "connection" to "keep-alive",
                        "x-client-token" to xClientToken,
                        "x-tr-signature" to xTrSignature,
                        "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                        "x-client-status" to "0"
                    )
                    
                    val response = app.get(url, headers = headers)
                    if (response.code == 200) {
                        val responseBody = response.body.string()
                        val root = mapper.readTree(responseBody)
                        val playData = root["data"]
                        // Handle the new API response format with streams
                        val streams = playData?.get("streams")
                        if (streams != null && streams.isArray) {
                            for (stream in streams) {
                                val streamUrl = stream["url"]?.asText() ?: continue
                                val format = stream["format"]?.asText() ?: ""
                                val resolutions = stream["resolutions"]?.asText() ?: ""
                                //val codecName = stream["codecName"]?.asText() ?: "h264"
                                val signCookieRaw = stream["signCookie"]?.asText()
                                val signCookie = if (signCookieRaw.isNullOrEmpty()) null else signCookieRaw
                                //val duration = stream["duration"]?.asInt()
                                val id = stream["id"]?.asText() ?: "$subjectId|$season|$episode"
                                val quality = getHighestQuality(resolutions)
                                callback.invoke(
                                    newExtractorLink(
                                        source = "$name $language",
                                        name = "$name ($language)",
                                        url = streamUrl,
                                        type = when {
                                            streamUrl.startsWith("magnet:", ignoreCase = true) -> ExtractorLinkType.MAGNET
                                            streamUrl.contains(".mpd", ignoreCase = true) -> ExtractorLinkType.DASH
                                            streamUrl.substringAfterLast('.', "").equals("torrent", ignoreCase = true) -> ExtractorLinkType.TORRENT
                                            format.equals("HLS", ignoreCase = true) || streamUrl.substringAfterLast('.', "").equals("m3u8", ignoreCase = true) -> ExtractorLinkType.M3U8
                                            streamUrl.contains(".mp4", ignoreCase = true) || streamUrl.contains(".mkv", ignoreCase = true) -> ExtractorLinkType.VIDEO
                                            else -> INFER_TYPE
                                        }
                                    ) {
                                        this.headers = mapOf("Referer" to mainUrl)
                                        if (quality != null) {
                                            this.quality = quality
                                        }
                                        if (signCookie != null) {
                                            this.headers += mapOf("Cookie" to signCookie)
                                        }
                                    }
                                )
                                val subLink = "$mainUrl/wefeed-mobile-bff/subject-api/get-stream-captions?subjectId=$subjectId&streamId=$id"
                                val xClientToken = generateXClientToken()
                                val xTrSignature = generateXTrSignature("GET", "", "", subLink)
                                val headers = mapOf(
                                    "User-Agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                                    "Accept" to "",
                                    "X-Client-Info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                                    "X-Client-Status" to "0",
                                    "Content-Type" to "",
                                    "X-Client-Token" to xClientToken,
                                    "x-tr-signature" to xTrSignature,
                                )
                                val subResponse = app.get(subLink, headers = headers)
                                val subRoot = mapper.readTree(subResponse.toString())
                                val extCaptions = subRoot["data"]?.get("extCaptions")
                                if (extCaptions != null && extCaptions.isArray) {
                                    for (caption in extCaptions) {
                                        val captionUrl = caption["url"]?.asText() ?: continue
                                        val lang = caption["language"]?.asText()
                                            ?: caption["lanName"]?.asText()
                                            ?: caption["lan"]?.asText()
                                            ?: "Unknown"
                                        subtitleCallback.invoke(
                                            newSubtitleFile(
                                                url = captionUrl,
                                                lang = "$lang ($language)"
                                            )
                                        )
                                    }
                                }

                                val subLink1 = "$mainUrl/wefeed-mobile-bff/subject-api/get-ext-captions?subjectId=$subjectId&resourceId=$id&episode=0"
                                val xClientToken1 = generateXClientToken()
                                val xTrSignature1 = generateXTrSignature("GET", "", "", subLink1)
                                val headers1 = mapOf(
                                    "User-Agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                                    "Accept" to "",
                                    "X-Client-Info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                                    "X-Client-Status" to "0",
                                    "Content-Type" to "",
                                    "X-Client-Token" to xClientToken1,
                                    "x-tr-signature" to xTrSignature1,
                                )
                                val subResponse1 = app.get(subLink1, headers = headers1)

                                val subRoot1 = mapper.readTree(subResponse1.toString())
                                val extCaptions1 = subRoot1["data"]?.get("extCaptions")
                                if (extCaptions1 != null && extCaptions1.isArray) {
                                    for (caption in extCaptions1) {
                                        val captionUrl = caption["url"]?.asText() ?: continue
                                        val lang = caption["lan"]?.asText()
                                            ?: caption["lanName"]?.asText()
                                            ?: caption["language"]?.asText()
                                            ?: "Unknown"
                                        subtitleCallback.invoke(
                                            newSubtitleFile(
                                                url = captionUrl,
                                                lang = "$lang ($language)"
                                            )
                                        )
                                    }
                                }


                                //hasAnyLinks = true
                            }
                        }
                    }
                } catch (_: Exception) {
                    continue
                }
            }
            
            return true
              
        } catch (_: Exception) {
            return false
        }
    }
}

fun getHighestQuality(input: String): Int? {
    val qualities = listOf(
        "2160" to Qualities.P2160.value,
        "1440" to Qualities.P1440.value,
        "1080" to Qualities.P1080.value,
        "720"  to Qualities.P720.value,
        "480"  to Qualities.P480.value,
        "360"  to Qualities.P360.value,
        "240"  to Qualities.P240.value
    )

    for ((label, mappedValue) in qualities) {
        if (input.contains(label, ignoreCase = true)) {
            return mappedValue
        }
    }
    return null
}

private suspend fun identifyID(
    title: String,
    year: Int?,
    imdbRatingValue: Double?
): Pair<Int?, String?> {
    val normTitle = normalize(title)

    // try multi -> tv -> movie (with year)
    val tryOrder = listOf("multi", "tv", "movie")
    for (type in tryOrder) {
        val res = searchAndPick(normTitle, year, imdbRatingValue)
        if (res.first != null) return res
    }

    // retry without year (often helpful for dubbed/localized titles)
    if (year != null) {
        for (type in tryOrder) {
            val res = searchAndPick(normTitle, null, imdbRatingValue)
            if (res.first != null) return res
        }
    }

    val stripped = normTitle
        .replace("\\b(hindi|tamil|telugu|dub|dubbed|dubbed audio|dual audio|dubbed version)\\b".toRegex(RegexOption.IGNORE_CASE), " ")
        .replace("\\s+".toRegex(), " ")
        .trim()
    if (stripped.isNotBlank() && stripped != normTitle) {
        for (type in tryOrder) {
            val res = searchAndPick(stripped, year, imdbRatingValue)
            if (res.first != null) return res
        }
        if (year != null) {
            for (type in tryOrder) {
                val res = searchAndPick(stripped, null, imdbRatingValue)
                if (res.first != null) return res
            }
        }
    }

    return Pair(null, null)
}

private suspend fun searchAndPick(
    normTitle: String,
    year: Int?,
    imdbRatingValue: Double?,
): Pair<Int?, String?> {

    suspend fun doSearch(endpoint: String, extraParams: String = ""): org.json.JSONArray? {
        val url = buildString {
            append("https://api.themoviedb.org/3/").append(endpoint)
            append("?api_key=").append("1865f43a0549ca50d341dd9ab8b29f49")
            append(extraParams)
            append("&include_adult=false&page=1")
        }
        val text = app.get(url).text
        return JSONObject(text).optJSONArray("results")
    }

    val multiResults = doSearch("search/multi", "&query=${URLEncoder.encode(normTitle, "UTF-8")}" + (if (year != null) "&year=$year" else ""))
    val searchQueues: List<Pair<String, org.json.JSONArray?>> = listOf(
        "multi" to multiResults,
        "tv" to doSearch("search/tv", "&query=${URLEncoder.encode(normTitle, "UTF-8")}" + (if (year != null) "&first_air_date_year=$year" else "")),
        "movie" to doSearch("search/movie", "&query=${URLEncoder.encode(normTitle, "UTF-8")}" + (if (year != null) "&year=$year" else ""))
    )

    var bestId: Int? = null
    var bestScore = -1.0
    var bestIsTv = false

    for ((sourceType, results) in searchQueues) {
        if (results == null) continue
        for (i in 0 until results.length()) {
            val o = results.getJSONObject(i)

            val mediaType = when (sourceType) {
                "multi" -> o.optString("media_type", "")
                "tv" -> "tv"
                else -> "movie"
            }

            val candidateId = o.optInt("id", -1)
            if (candidateId == -1) continue

            val candTitle = when (mediaType) {
                "tv" -> listOf(o.optString("name", ""), o.optString("original_name", "")).firstOrNull { it.isNotBlank() }?.lowercase() ?: ""
                "movie" -> listOf(o.optString("title", ""), o.optString("original_title", "")).firstOrNull { it.isNotBlank() }?.lowercase() ?: ""
                else -> listOf(o.optString("title", ""), o.optString("name", ""), o.optString("original_title", ""), o.optString("original_name", "")).firstOrNull { it.isNotBlank() }?.lowercase() ?: ""
            }

            val candDate = when (mediaType) {
                "tv" -> o.optString("first_air_date", "")
                else -> o.optString("release_date", "")
            }
            val candYear = candDate.take(4).toIntOrNull()
            val candRating = o.optDouble("vote_average", Double.NaN)

            // scoring
            var score = 0.0
            if (tokenEquals(candTitle, normTitle)) score += 50.0
            else if (candTitle.contains(normTitle) || normTitle.contains(candTitle)) score += 15.0

            if (candYear != null && year != null && candYear == year) score += 35.0

            if (imdbRatingValue != null && !candRating.isNaN()) {
                val diff = kotlin.math.abs(candRating - imdbRatingValue)
                if (diff <= 0.5) score += 10.0 else if (diff <= 1.0) score += 5.0
            }

            if (o.has("popularity")) score += (o.optDouble("popularity", 0.0) / 100.0).coerceAtMost(5.0)

            if (score > bestScore) {
                bestScore = score
                bestId = candidateId
                bestIsTv = (mediaType == "tv")
            }
        }

        if (bestScore >= 45) break
    }

    if (bestId == null || bestScore < 40.0) return Pair(null, null)

    // fetch details for external_ids
    val detailKind = if (bestIsTv) "tv" else "movie"
    val detailUrl = "https://api.themoviedb.org/3/$detailKind/$bestId?api_key=1865f43a0549ca50d341dd9ab8b29f49&append_to_response=external_ids"
    val detailText = app.get(detailUrl).text
    val detailJson = JSONObject(detailText)
    val imdbId = detailJson.optJSONObject("external_ids")?.optString("imdb_id")

    return Pair(bestId, imdbId)
}

private fun tokenEquals(a: String, b: String): Boolean {
    val sa = a.split("\\s+".toRegex()).filter { it.isNotBlank() }.toSet()
    val sb = b.split("\\s+".toRegex()).filter { it.isNotBlank() }.toSet()
    if (sa.isEmpty() || sb.isEmpty()) return false
    val inter = sa.intersect(sb).size
    return inter >= max(1, minOf(sa.size, sb.size) * 3 / 4)
}

private fun normalize(s: String): String {
    val t = s.replace("\\[.*?]".toRegex(), " ")
        .replace("\\(.*?\\)".toRegex(), " ")
        .replace("(?i)\\b(dub|dubbed|hd|4k|hindi|tamil|telugu|dual audio)\\b".toRegex(), " ")
        .trim()
        .lowercase()
        .replace(":", " ")
        .replace("\\p{Punct}".toRegex(), " ")
        .replace("\\s+".toRegex(), " ")
    return t
}

private suspend fun fetchMetaData(imdbId: String?, type: TvType): JsonNode? {
    if (imdbId.isNullOrBlank()) return null

    val metaType = if (type == TvType.TvSeries) "series" else "movie"
    val url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta/$metaType/$imdbId.json"

    return try {
        val resp = app.get(url).text
        mapper.readTree(resp)["meta"]
    } catch (_: Exception) {
        null
    }
}

suspend fun fetchTmdbLogoUrl(
    tmdbAPI: String,
    apiKey: String,
    type: TvType,
    tmdbId: Int?,
    appLangCode: String?
): String? {
    if (tmdbId == null) return null

    val appLang = appLangCode?.substringBefore("-")?.lowercase()
    val url = if (type == TvType.Movie) {
        "$tmdbAPI/movie/$tmdbId/images?api_key=$apiKey"
    } else {
        "$tmdbAPI/tv/$tmdbId/images?api_key=$apiKey"
    }

    val json = runCatching { JSONObject(app.get(url).text) }.getOrNull() ?: return null
    val logos = json.optJSONArray("logos") ?: return null
    if (logos.length() == 0) return null

    fun logoUrlAt(i: Int): String = "https://image.tmdb.org/t/p/w500${logos.getJSONObject(i).optString("file_path")}"
    fun isSvg(i: Int): Boolean = logos.getJSONObject(i).optString("file_path").endsWith(".svg", ignoreCase = true)

    if (!appLang.isNullOrBlank()) {
        var svgFallback: String? = null
        for (i in 0 until logos.length()) {
            val logo = logos.optJSONObject(i) ?: continue
            if (logo.optString("iso_639_1") == appLang) {
                if (isSvg(i)) {
                    if (svgFallback == null) svgFallback = logoUrlAt(i)
                } else {
                    return logoUrlAt(i)
                }
            }
        }
        if (svgFallback != null) return svgFallback
    }

    var enSvgFallback: String? = null
    for (i in 0 until logos.length()) {
        val logo = logos.optJSONObject(i) ?: continue
        if (logo.optString("iso_639_1") == "en") {
            if (isSvg(i)) {
                if (enSvgFallback == null) enSvgFallback = logoUrlAt(i)
            } else {
                return logoUrlAt(i)
            }
        }
    }
    if (enSvgFallback != null) return enSvgFallback

    for (i in 0 until logos.length()) {
        if (!isSvg(i)) return logoUrlAt(i)
    }

    return logoUrlAt(0)
}



================================================
FILE: MovieBoxProvider/src/main/kotlin/com/MovieBox/MovieBoxProviderPlugin.kt
================================================
package com.MovieBox

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class MovieBoxProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MovieBoxProvider())
    }
}



================================================
FILE: Movierulzhd/build.gradle.kts
================================================
// use an integer for version numbers
version = 153


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them

     description = "Includes: Hdmovie2,hdmovie6"
     authors = listOf("Phisher98,hexated")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie",
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/cloudstream-extensions-phisher/refs/heads/master/Movierulzhd/faviconV2.png"

    isCrossPlatform = true
}



================================================
FILE: Movierulzhd/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Movierulzhd/src/main/kotlin/com/phisher98/Extractors.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.FilemoonV2
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.utils.JsUnpacker
import okhttp3.FormBody
import org.json.JSONObject

class FMHD : Filesim() {
    override val name = "FMHD"
    override var mainUrl = "https://fmhd.bar/"
    override val requiresReferer = true
}

class Playonion : Filesim() {
    override val mainUrl = "https://playonion.sbs"
}


class Luluvdo : StreamWishExtractor() {
    override val mainUrl = "https://luluvdo.com"
}

class Lulust : StreamWishExtractor() {
    override val mainUrl = "https://lulu.st"
}

class Movierulz : FilemoonV2() {
    override var name = "Movierulz"
    override var mainUrl = "https://movierulz2025.bar"
}

class Movierulzups : VidStack() {
    override var name = "Movierulz"
    override var mainUrl = "https://onion.uns.wtf"
}

class cherryMovierulzups : VidStack() {
    override var name = "Movierulz"
    override var mainUrl = "https://cherry.upns.online"
}


open class FMX : ExtractorApi() {
    override var name = "FMX"
    override var mainUrl = "https://fmx.lol"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
            val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
            JsUnpacker(extractedpack).unpack()?.let { unPacked ->
                Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                    return listOf(
                        newExtractorLink(
                            this.name,
                            this.name,
                            url = link,
                            INFER_TYPE
                        ) {
                            this.referer = referer ?: ""
                            this.quality = Qualities.Unknown.value
                        }
                    )
                }
            }
            return null
    }
}

open class Akamaicdn : ExtractorApi() {
    override val name = "Akamaicdn"
    override val mainUrl = "https://molop.art"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers= mapOf("user-agent" to "okhttp/4.12.0")
        val res = app.get(url, referer = referer, headers = headers).documentLarge
        val sniffScript = res.selectFirst("script:containsData(sniff\\()")
            ?.data()
            ?.substringAfter("sniff(")
            ?.substringBefore(");") ?: return
        
        val cleaned = sniffScript.replace(Regex("\\[.*?]"), "")
        val regex = Regex("\"(.*?)\"")
        val args = regex.findAll(cleaned).map { it.groupValues[1].trim() }.toList()
        val token = args.lastOrNull().orEmpty()
        val m3u8 = "$mainUrl/m3u8/${args[1]}/${args[2]}/master.txt?s=1&cache=1&plt=$token"
        M3u8Helper.generateM3u8(name, m3u8, mainUrl, headers = headers).forEach(callback)
    }
}

@Suppress("PARAMETER_NAME_CHANGED_ON_OVERRIDE")
class GDFlix : ExtractorApi() {
    override val name = "GDFlix"
    override val mainUrl = "https://new10.gdflix.dad"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        source: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val newUrl = try {
            app.get(url)
                .documentLarge
                .selectFirst("meta[http-equiv=refresh]")
                ?.attr("content")
                ?.substringAfter("url=")
        } catch (e: Exception) {
            Log.e("Error", "Failed to fetch redirect: ${e.localizedMessage}")
            return
        } ?: url

        val document = app.get(newUrl).documentLarge
        val fileName = document.select("ul > li.list-group-item:contains(Name)").text()
            .substringAfter("Name : ")
        val fileSize = document.select("ul > li.list-group-item:contains(Size)").text()
            .substringAfter("Size : ")

        document.select("div.text-center a").amap { anchor ->
            val text = anchor.select("a").text()

            when {
                text.contains("DIRECT DL",ignoreCase = true) -> {
                    val link = anchor.attr("href")
                    callback.invoke(
                        newExtractorLink("$source GDFlix[Direct]", "$source GDFlix[Direct] [$fileSize]", link) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }

                text.contains("Index Links",ignoreCase = true) -> {
                    try {
                        val link = anchor.attr("href")
                        app.get("https://new6.gdflix.dad$link").documentLarge
                            .select("a.btn.btn-outline-info").amap { btn ->
                                val serverUrl = "https://new6.gdflix.dad" + btn.attr("href")
                                app.get(serverUrl).documentLarge
                                    .select("div.mb-4 > a").amap { sourceAnchor ->
                                        val sourceurl = sourceAnchor.attr("href")
                                        callback.invoke(
                                            newExtractorLink("$source GDFlix[Index]", "$source GDFlix[Index] [$fileSize]", sourceurl) {
                                                this.quality = getIndexQuality(fileName)
                                            }
                                        )
                                    }
                            }
                    } catch (e: Exception) {
                        Log.d("Index Links", e.toString())
                    }
                }

                text.contains("DRIVEBOT",ignoreCase = true) -> {
                    try {
                        val driveLink = anchor.attr("href")
                        val id = driveLink.substringAfter("id=").substringBefore("&")
                        val doId = driveLink.substringAfter("do=").substringBefore("==")
                        val baseUrls = listOf("https://drivebot.sbs", "https://drivebot.cfd")

                        baseUrls.amap { baseUrl ->
                            val indexbotLink = "$baseUrl/download?id=$id&do=$doId"
                            val indexbotResponse = app.get(indexbotLink, timeout = 100L)

                            if (indexbotResponse.isSuccessful) {
                                val cookiesSSID = indexbotResponse.cookies["PHPSESSID"]
                                val indexbotDoc = indexbotResponse.documentLarge

                                val token = Regex("""formData\.append\('token', '([a-f0-9]+)'\)""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val postId = Regex("""fetch\('/download\?id=([a-zA-Z0-9/+]+)'""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val requestBody = FormBody.Builder()
                                    .add("token", token)
                                    .build()

                                val headers = mapOf("Referer" to indexbotLink)
                                val cookies = mapOf("PHPSESSID" to "$cookiesSSID")

                                val downloadLink = app.post(
                                    "$baseUrl/download?id=$postId",
                                    requestBody = requestBody,
                                    headers = headers,
                                    cookies = cookies,
                                    timeout = 100L
                                ).text.let {
                                    Regex("url\":\"(.*?)\"").find(it)?.groupValues?.get(1)?.replace("\\", "").orEmpty()
                                }

                                callback.invoke(
                                    newExtractorLink("$source GDFlix[DriveBot]", "$source GDFlix[DriveBot] [$fileSize]", downloadLink) {
                                        this.referer = baseUrl
                                        this.quality = getIndexQuality(fileName)
                                    }
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.d("DriveBot", e.toString())
                    }
                }

                text.contains("Instant DL",ignoreCase = true) -> {
                    try {
                        val instantLink = anchor.attr("href")
                        val link = app.get(instantLink, allowRedirects = false)
                            .headers["location"]?.substringAfter("url=").orEmpty()

                        callback.invoke(
                            newExtractorLink("$source GDFlix[Instant Download]", "$source GDFlix[Instant Download] [$fileSize]", link) {
                                this.quality = getIndexQuality(fileName)
                            }
                        )
                    } catch (e: Exception) {
                        Log.d("Instant DL", e.toString())
                    }
                }


                text.contains("GoFile",ignoreCase = true) -> {
                    try {
                        app.get(anchor.attr("href")).documentLarge
                            .select(".row .row a").amap { gofileAnchor ->
                                val link = gofileAnchor.attr("href")
                                if (link.contains("gofile")) {
                                    Gofile().getUrl(link, "", subtitleCallback, callback)
                                }
                            }
                    } catch (e: Exception) {
                        Log.d("Gofile", e.toString())
                    }
                }

                text.contains("PixelDrain",ignoreCase = true) || text.contains("Pixel",ignoreCase = true)-> {
                    callback.invoke(
                        newExtractorLink(
                            "$source GDFlix[Pixeldrain]",
                            "$source GDFlix[Pixeldrain] [$fileSize]",
                            anchor.attr("href"),
                        ) { this.quality = quality }
                    )
                }

                else -> {
                    Log.d("Error", "No Server matched")
                }
            }
        }

        // Cloudflare backup links
        try {
            val types = listOf("type=1", "type=2")
            types.map { type ->
                val sourceurl = app.get("${newUrl.replace("file", "wfile")}?$type")
                    .documentLarge.select("a.btn-success").attr("href")

                if (source?.isNotEmpty() == true) {
                    callback.invoke(
                        newExtractorLink("$source GDFlix[CF]", "$source GDFlix[CF] [$fileSize]", sourceurl) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }
            }
        } catch (e: Exception) {
            Log.d("CF", e.toString())
        }
    }
}


class Gofile : ExtractorApi() {
    override val name = "Gofile"
    override val mainUrl = "https://gofile.io"
    override val requiresReferer = false
    private val mainApi = "https://api.gofile.io"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        try {
            val id = Regex("/(?:\\?c=|d/)([\\da-zA-Z-]+)").find(url)?.groupValues?.get(1) ?: return
            val responseText = app.post("$mainApi/accounts").text
            val json = JSONObject(responseText)
            val token = json.getJSONObject("data").getString("token")

            val globalJs = app.get("$mainUrl/dist/js/global.js").text
            val wt = Regex("""appdata\.wt\s*=\s*["']([^"']+)["']""")
                .find(globalJs)?.groupValues?.getOrNull(1) ?: return

            val responseTextfile = app.get(
                "$mainApi/contents/$id?wt=$wt",
                headers = mapOf("Authorization" to "Bearer $token")
            ).text

            val fileDataJson = JSONObject(responseTextfile)

            val data = fileDataJson.getJSONObject("data")
            val children = data.getJSONObject("children")
            val firstFileId = children.keys().asSequence().first()
            val fileObj = children.getJSONObject(firstFileId)

            val link = fileObj.getString("link")
            val fileName = fileObj.getString("name")
            val fileSize = fileObj.getLong("size")

            val sizeFormatted = if (fileSize < 1024L * 1024 * 1024) {
                "%.2f MB".format(fileSize / 1024.0 / 1024)
            } else {
                "%.2f GB".format(fileSize / 1024.0 / 1024 / 1024)
            }

            callback.invoke(
                newExtractorLink(
                    "Gofile",
                    "Gofile [$sizeFormatted]",
                    link
                ) {
                    this.quality = getQuality(fileName)
                    this.headers = mapOf("Cookie" to "accountToken=$token")
                }
            )
        } catch (e: Exception) {
            Log.e("Gofile", "Error occurred: ${e.message}")
        }
    }

    private fun getQuality(fileName: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(fileName ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}


class HDm2 : ExtractorApi() {
    override val name = "Ultra Stream V3"
    override val mainUrl = "https://hdm2.ink"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf("user-agent" to "okhttp/4.12.0")

        val res = app.get(url, referer = referer, headers = headers).textLarge
        val regex = Regex("""data-stream-url=["'](.*?)["']""")
        val args = regex.find(res)?.groupValues?.get(1)?.trim()

        if (!args.isNullOrEmpty()) {
            val m3u8 = if (args.startsWith("http")) {
                args
            } else {
                "${mainUrl.trimEnd('/')}/${args.removePrefix("/")}"
            }
            val safe = safeUrl(m3u8)
            M3u8Helper.generateM3u8(name, safe, mainUrl, headers = headers).forEach(callback)
        } else {
            Log.w("HDm2", "stream url not found")
        }
    }

    private fun safeUrl(raw: String): String {
        val cleaned = raw.replace("&amp;", "&")
        val base = cleaned.substringBefore("?")
        val tok = Regex("""[?&]tok=([^&]+)""").find(cleaned)?.groupValues?.get(1)
        return if (!tok.isNullOrEmpty()) "$base?tok=$tok" else base
    }
}



================================================
FILE: Movierulzhd/src/main/kotlin/com/phisher98/Hdmovie2.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import kotlinx.coroutines.runBlocking
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.util.Calendar

open class Hdmovie2 : Movierulzhd() {

    override var mainUrl: String = runBlocking {
        MovierulzhdPlugin.getDomains()?.hdmovie2 ?: "https://hdmovie2.qpon"
    }
    override var name = "Hdmovie2"
    override val mainPage = mainPageOf(
        "release/${Calendar.getInstance().get(Calendar.YEAR)}" to "Latest",
        "genre/bollywood" to "BollyWood",
        "movies" to "Movies",
        "genre/hindi-webseries" to "Hindi Web Series",
        "genre/netflix" to "Netflix",
        "genre/zee5" to "Zee5",
        "genre/hindi-dubbed" to "Hindi Dubbed",
        "genre/comedy" to "Comedy",
        "genre/science-fiction" to "Science Fiction"
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val ajaxUrl = "$directUrl/wp-admin/admin-ajax.php"
        val commonHeaders = mapOf(
            "Accept" to "*/*",
            "X-Requested-With" to "XMLHttpRequest"
        )

        suspend fun fetchSource(post: String, nume: String, type: String): String {
            val response = app.post(
                url = ajaxUrl,
                data = mapOf(
                    "action" to "doo_player_ajax",
                    "post" to post,
                    "nume" to nume,
                    "type" to type
                ),
                referer = data,
                headers = commonHeaders
            ).parsed<ResponseHash>()
            return response.embed_url.getIframe()
        }

        if (data.startsWith("{")) {
            val loadData = tryParseJson<LinkData>(data) ?: return false
            val source = fetchSource(
                loadData.post.orEmpty(),
                loadData.nume.orEmpty(),
                loadData.type.orEmpty()
            )

            when {
                !source.contains("youtube") -> {
                    loadExtractor(source, "$directUrl/", subtitleCallback, callback)
                }
            }
        } else {
            val document = app.get(data).documentLarge
            val id = document.selectFirst("ul#playeroptionsul > li")?.attr("data-post") ?: return false
            val type = if (data.contains("/movies/")) "movie" else "tv"

            document.select("ul#playeroptionsul > li")
                .map { it.attr("data-nume") }
                .amap { nume ->
                    val source = fetchSource(id, nume, type)
                    when {
                        source.contains("ok.ru") -> {
                            loadExtractor("https:$source", "$directUrl/", subtitleCallback, callback)
                        }
                        !source.contains("youtube") -> {
                            loadExtractor(source, "$directUrl/", subtitleCallback, callback)
                        }

                        else -> {
                            Log.d("Error:","Not Found")

                        }
                    }
                }
        }

        if (data.contains("hdmovie2")) {
            val directLinks = app.get(data).documentLarge.selectFirst("p > a")?.attr("href")
            directLinks?.let {
                val doc = app.get(it).documentLarge
                doc.select("p > a").forEach { element ->
                    val label = element.selectFirst("button")?.text()?.trim() ?: return@forEach
                    val href = element.attr("href")
                    if (label.contains("GDFlix", ignoreCase = true)) {
                        val redirectedurl= app.get(href, allowRedirects = false).headers["location"] ?:""
                        loadExtractor(redirectedurl,name,subtitleCallback, callback)
                    }
                }
            }
            return true
        }

        return true
    }


    private fun String.getIframe(): String {
        return Jsoup.parse(this).select("iframe").attr("src")
    }

    data class LinkData(
        val type: String? = null,
        val post: String? = null,
        val nume: String? = null,
    )

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("type") val type: String?,
    )

}



================================================
FILE: Movierulzhd/src/main/kotlin/com/phisher98/Movierulzhd.kt
================================================
package com.phisher98


import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchQuality
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.fixTitle
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.newTvSeriesSearchResponse
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import okhttp3.Interceptor
import org.jsoup.nodes.Element
import java.net.URI
import java.text.Normalizer

open class Movierulzhd : MainAPI() {

    override var mainUrl: String = runBlocking {
        MovierulzhdPlugin.getDomains()?.movierulzhd ?: "https://1movierulzhd.pro"
    }
    var directUrl = ""
    override var name = "Movierulzhd"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        "trending" to "Trending",
        "movies" to "Movies",
        "tvshows" to "TV Shows",
        "genre/netflix" to "Netflix",
        "genre/amazon-prime" to "Amazon Prime",
        "genre/Zee5" to "Zee5",
        "genre/sony-liv" to "Sony Liv",
        "genre/hotstar" to "Hotstar",
        "genre/jio-cinema" to "Jio Cinema",
        "seasons" to "Season",
        "episodes" to "Episode",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = if(page == 1) "$mainUrl/${request.data}/" else "$mainUrl/${request.data}/page/$page/"
        val document = app.get(url).document
        val home =
            document.select("div.items.normal article, div#archive-content article, div.items.full article").mapNotNull {
                it.toSearchResult()
            }
        return newHomePageResponse(request.name, home)
    }

    fun getProperLink(uri: String): String {
        return when {
            uri.contains("/episodes/") -> {
                var title = uri.substringAfter("$mainUrl/episodes/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvshows/$title"
            }

            uri.contains("/seasons/") -> {
                var title = uri.substringAfter("$mainUrl/seasons/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvshows/$title"
            }

            else -> {
                uri
            }
        }
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3 > a")?.text() ?: return null
        val href = getProperLink(fixUrl(this.selectFirst("h3 > a")!!.attr("href")))
        var posterUrl = this.select("div.poster img").last()?.getImageAttr()
       
        if (posterUrl != null) {
            if (posterUrl.contains(".gif")) {
                posterUrl = fixUrlNull(this.select("div.poster img").attr("data-wpfc-original-src"))
            }
        }
        val quality = getSearchQuality(this.select("span.quality").text())
        val score = this.select("div.rating").text()
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
            this.score = Score.from10(score)
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/search/$query").documentLarge
        return document.select("div.result-item").map {
            val title =
                it.selectFirst("div.title > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
            val href = getProperLink(it.selectFirst("div.title > a")!!.attr("href"))
            val posterUrl = it.selectFirst("img")!!.attr("src")
            newMovieSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val request = app.get(url)
        val document = request.documentLarge
        directUrl = getBaseUrl(request.url)
        val title =
            document.selectFirst("div.data > h1")?.text()?.trim().toString()
        val background = fixUrlNull(document.selectFirst(".playbox img.cover")?.getImageAttr())
        val posterUrl = fixUrlNull(document.selectFirst("div.poster img")?.getImageAttr())
        /*if (backgroud.isNullOrEmpty()) {
            if (background.contains("movierulzhd")) {
                background = fixUrlNull(document.select("div.poster img").attr("src"))
            }
        }*/
        val tags = document.select("div.sgeneros > a").map { it.text() }
        val year = Regex(",\\s?(\\d+)").find(
            document.select("span.date").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (document.select("ul#section > li:nth-child(1)").text()
                .contains("Episodes") || document.select("ul#playeroptionsul li span.title")
                .text().contains(
                    Regex("Episode\\s+\\d+|EP\\d+|PE\\d+|S\\d{2}|E\\d{2}")
                )
        ) TvType.TvSeries else TvType.Movie
        val description = document.select("div.wp-content > p").text().trim()
        val trailer = document.selectFirst("div.embed iframe")?.attr("src")
        val rating = document.selectFirst("span.dt_rating_vgs")?.text()
        val actors = document.select("div.persons > div[itemprop=actor]").map {
            Actor(
                it.select("meta[itemprop=name]").attr("content"),
                it.select("img:last-child").attr("src")
            )
        }

        val recommendations = document.select("div.owl-item").map {
            val recName = it.selectFirst("a")!!.attr("href").removeSuffix("/").split("/").last()
            val recHref = it.selectFirst("a")!!.attr("href")
            val recPosterUrl = it.selectFirst("img")?.getImageAttr()
            newTvSeriesSearchResponse(recName, recHref, TvType.TvSeries) {
                this.posterUrl = recPosterUrl
            }
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = if (document.select("ul.episodios > li").isNotEmpty()) {
                document.select("ul.episodios > li").map {
                    val href = it.select("a").attr("href")
                    val name = fixTitle(it.select("div.episodiotitle > a").text().trim())
                    val image = it.selectFirst("div.imagen > img")?.getImageAttr()
                    val episode =
                        it.select("div.numerando").text().replace(" ", "").split("-").last()
                            .toIntOrNull()
                    val season =
                        it.select("div.numerando").text().replace(" ", "").split("-").first()
                            .toIntOrNull()
                    newEpisode(href)
                    {
                        this.name=name
                        this.episode=episode
                        this.season=season
                        this.posterUrl=image
                    }
                }
            } else {
            val check = document.select("ul#playeroptionsul > li").toString().contains("Super")
				if (check) {
				    document.select("ul#playeroptionsul > li").drop(1).map {
				        val name = it.selectFirst("span.title")?.text()
				        val type = it.attr("data-type")
				        val post = it.attr("data-post")
				        val nume = it.attr("data-nume")
                        newEpisode(LinkData(name, type, post, nume).toJson())
                        {
                            this.name=name
                        }
				    }
				} else {
				    document.select("ul#playeroptionsul > li").map {
				        val name = it.selectFirst("span.title")?.text()
				        val type = it.attr("data-type")
				        val post = it.attr("data-post")
				        val nume = it.attr("data-nume")
                        newEpisode(LinkData(name, type, post, nume).toJson())
                        {
                            this.name=name
                        }
				    }
				}
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = posterUrl
                this.backgroundPosterUrl= background
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = posterUrl
                this.year = year
                this.backgroundPosterUrl= background
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        try {
            if (data.startsWith("{")) {
                val loadData = AppUtils.tryParseJson<LinkData>(data)
                if (loadData != null) {
                    try {
                        val source = app.post(
                            url = "$directUrl/wp-admin/admin-ajax.php",
                            data = mapOf(
                                "action" to "doo_player_ajax",
                                "post" to "${loadData.post}",
                                "nume" to "${loadData.nume}",
                                "type" to "${loadData.type}"
                            ),
                            referer = data,
                            headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                        ).parsed<ResponseHash>().embed_url

                        if (!source.contains("youtube")) {
                            loadCustomExtractor(name,source, "$directUrl/", subtitleCallback, callback)
                        }
                    } catch (e: Exception) {
                        println("Error loading direct source: ${e.message}")
                    }
                }
            } else {
                try {
                    val document = app.get(data).documentLarge
                    val items = document.select("ul#playeroptionsul > li").map {
                        Triple(
                            it.attr("data-post"),
                            it.attr("data-nume"),
                            it.attr("data-type")
                        )
                    }

                    items.amap { (post, nume, type) ->
                        try {
                            val source = app.post(
                                url = "$directUrl/wp-admin/admin-ajax.php",
                                data = mapOf(
                                    "action" to "doo_player_ajax",
                                    "post" to post,
                                    "nume" to nume,
                                    "type" to type
                                ),
                                referer = data,
                                headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                            ).parsed<ResponseHash>().embed_url
                            if (!source.contains("youtube")) {
                                if (source.contains("/#"))
                                {
                                    VidStack().getUrl(source,"",subtitleCallback,callback)
                                }
                                else
                                loadExtractor(source, subtitleCallback, callback)
                            }
                        } catch (e: Exception) {
                            println("Error loading item: ${e.message}")
                        }
                    }
                } catch (e: Exception) {
                    println("Error processing HTML document: ${e.message}")
                }
            }
            return true
        } catch (e: Exception) {
            println("General error in loadLinks: ${e.message}")
            return false
        }
    }


    private fun Element.getImageAttr(): String {
        return when {
            this.hasAttr("data-src") -> this.attr("abs:data-src")
            this.hasAttr("data-lazy-src") -> this.attr("abs:data-lazy-src")
            this.hasAttr("srcset") -> this.attr("abs:srcset").substringBefore(" ")
            else -> this.attr("abs:src")
        }
    }

    private suspend fun loadCustomExtractor(
        name: String? = null,
        url: String,
        referer: String? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        quality: Int? = null,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        name ?: link.source,
                        name ?: link.name,
                        link.url,
                    ) {
                        this.quality = when {
                            link.name == "VidSrc" -> Qualities.P1080.value
                            link.type == ExtractorLinkType.M3U8 -> link.quality
                            else -> quality ?: link.quality
                        }
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }


    override fun getVideoInterceptor(extractorLink: ExtractorLink): Interceptor {
        return Interceptor { chain ->
            val request = chain.request()
            val originalUrl = request.url.toString()
            val modifiedRequest = if (originalUrl.startsWith("https://exxample.com/")) {
                val encodedPart = originalUrl.removePrefix("https://exxample.com/")
                val decodedUrl = try {
                    base64Decode(encodedPart)
                } catch (e: IllegalArgumentException) {
                    println("Failed to decode Base64: ${e.message}")
                    null
                }
                if (decodedUrl != null) {
                    request.newBuilder()
                        .url(decodedUrl)
                        .build()
                } else {
                    request
                }
            } else {
                request
            }

            val finalRequest = if (modifiedRequest.url.host.contains("sukumsanghas.com")) {
                modifiedRequest.newBuilder()
                    .header("Accept", "*/*")
                    .header("Accept-Encoding", "gzip, deflate, br")
                    .header("Accept-Language", "en-US,en;q=0.5")
                    .header("Cache-Control", "no-cache")
                    .header("Connection", "keep-alive")
                    .header("DNT", "1")
                    .header("Origin", "https://molop.art")
                    .header("Pragma", "no-cache")
                    .header("Referer", "https://molop.art/")
                    .header("Sec-Fetch-Dest", "empty")
                    .header("Sec-Fetch-Mode", "cors")
                    .header("Sec-Fetch-Site", "cross-site")
                    .header("Sec-GPC", "1")
                    .header(
                        "User-Agent",
                        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:137.0) Gecko/20100101 Firefox/137.0"
                    )
                    .build()
            } else {
                modifiedRequest
            }
            chain.proceed(finalRequest)
        }
    }




    data class LinkData(
        val tag: String? = null,
        val type: String? = null,
        val post: String? = null,
        val nume: String? = null,
    )

    /**
     * Determines the search quality based on the presence of specific keywords in the input string.
     *
     * @param check The string to check for keywords.
     * @return The corresponding `SearchQuality` enum value, or `null` if no match is found.
     */
    fun getSearchQuality(check: String?): SearchQuality? {
        val s = check ?: return null
        val u = Normalizer.normalize(s, Normalizer.Form.NFKC).lowercase()
        val patterns = listOf(
            Regex("\\b(4k|ds4k|uhd|2160p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.FourK,

            // CAM / THEATRE SOURCES FIRST
            Regex("\\b(hdts|hdcam|hdtc)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HdCam,
            Regex("\\b(camrip|cam[- ]?rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip,
            Regex("\\b(cam)\\b", RegexOption.IGNORE_CASE) to SearchQuality.Cam,

            // WEB / RIP
            Regex("\\b(web[- ]?dl|webrip|webdl)\\b", RegexOption.IGNORE_CASE) to SearchQuality.WebRip,

            // BLURAY
            Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,

            // RESOLUTIONS
            Regex("\\b(1440p|qhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,
            Regex("\\b(1080p|fullhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,
            Regex("\\b(720p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.SD,

            // GENERIC HD LAST
            Regex("\\b(hdrip|hdtv|HD)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,

            Regex("\\b(dvd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.DVD,
            Regex("\\b(hq)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HQ,
            Regex("\\b(rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip
        )


        for ((regex, quality) in patterns) if (regex.containsMatchIn(u)) return quality
        return null
    }

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("type") val type: String?,
    )
}



================================================
FILE: Movierulzhd/src/main/kotlin/com/phisher98/MovierulzhdPlugin.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class MovierulzhdPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Movierulzhd())
        registerMainAPI(Hdmovie2())
        registerExtractorAPI(FMHD())
        registerExtractorAPI(Akamaicdn())
        registerExtractorAPI(Luluvdo())
        registerExtractorAPI(FMX())
        registerExtractorAPI(Lulust())
        registerExtractorAPI(Playonion())
        registerExtractorAPI(GDFlix())
        registerExtractorAPI(Movierulzups())
        registerExtractorAPI(Movierulz())
        registerExtractorAPI(VidStack())
        registerExtractorAPI(HDm2())
        registerExtractorAPI(cherryMovierulzups())
    }
    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("movierulzhd")
            val movierulzhd: String,
            @JsonProperty("hdmovie2")
            val hdmovie2: String,
        )
    }
}



================================================
FILE: MPlayerProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 6


cloudstream {
    language = "hi"
    // All of these properties are optional, you can safely remove them
    description = "Indian Movies/Series/Kdrama(Hindi Dubbed)"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Movie",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=www.mxplayer.in&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: MPlayerProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: MPlayerProvider/src/main/kotlin/com/MPlayer/MPlayer.kt
================================================
package com.MPlayer
import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.Headers
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

class MPlayer : MainAPI() {
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama,
    )
    override var lang = "hi"
    override var mainUrl = "https://www.mxplayer.in"
    override var name = "M Player"
    override val hasMainPage = true
    private var imageUrl="https://qqcdnpictest.mxplay.com/"
    private var userID: String? = null
    private val webApi = "https://api.mxplayer.in/v1/web"
    private val endpointurl="https://d3sgzbosmwirao.cloudfront.net/"
    private val endParam
        get() = "&device-density=2&userid=$userID&platform=com.mxplay.desktop&content-languages=hi,en&kids-mode-enabled=false"

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val res = app.get(mainUrl)
        userID = res.okhttpResponse.headers.getCookies()["UserID"]
            ?: throw ErrorLoadingException("load fail, geo blocked")

        val dramaResponse = app.get(
            "$webApi/detail/browseItem?&pageNum=$page&pageSize=20&isCustomized=true&genreFilterIds=48efa872f6f17facebf6149dfc536ee1&type=2$endParam",
            referer = "$mainUrl/"
        ).toString()
        val dramaRoot: MXPlayer = Gson().fromJson(dramaResponse, object : TypeToken<MXPlayer>() {}.type)
        val dramashows = dramaRoot.items.map { item ->
            item.toSearchResult()
        }

        val crimeResponse = app.get(
            "$webApi/detail/browseItem?&pageNum=1&pageSize=20&isCustomized=true&genreFilterIds=b413dff55bdad743c577a8bea3b65044&type=2$endParam",
            referer = "$mainUrl/"
        ).toString()
        val crimeRoot: MXPlayer = Gson().fromJson(crimeResponse, object : TypeToken<MXPlayer>() {}.type)
        val crime_shows = crimeRoot.items.map { item ->
            item.toSearchResult()
        }

        val thrillerResponse = app.get(
            "$webApi/detail/browseItem?&pageNum=1&pageSize=20&isCustomized=true&genreFilterIds=2dd5daf25be5619543524f360c73c3d8&type=2$endParam",
            referer = "$mainUrl/"
        ).toString()
        val thrillerRoot: MXPlayer = Gson().fromJson(thrillerResponse, object : TypeToken<MXPlayer>() {}.type)
        val thriller_shows = thrillerRoot.items.map { item ->
            item.toSearchResult()
        }

        val hindimovieresponse = app.get(
            "$webApi/detail/browseItem?&pageNum=$page&pageSize=20&isCustomized=true&browseLangFilterIds=hi&type=1$endParam",
            referer = "$mainUrl/").toString()
        val movieRoot: MovieRoot = Gson().fromJson(hindimovieresponse, object : TypeToken<MovieRoot>() {}.type)
        val hindi_Movies = movieRoot.items.map { item ->
            item.toSearchResult()
        }

        val telgumovieresponse = app.get(
            "$webApi/detail/browseItem?&pageNum=$page&pageSize=20&isCustomized=true&browseLangFilterIds=te&type=1$endParam",
            referer = "$mainUrl/").toString()
        val movieRootte: MovieRoot = Gson().fromJson(telgumovieresponse, object : TypeToken<MovieRoot>() {}.type)
        val telgu_Movies = movieRootte.items.map { item ->
            item.toSearchResult()
        }
        val Dramashows = HomePageList("Drama Shows", dramashows)
        val HindiMovies = HomePageList("Hindi Movies", hindi_Movies)
        val telguMovies = HomePageList("Telgu Movies", telgu_Movies)
        val crimeshows = HomePageList("Crime Shows", crime_shows)
        val thrillershows = HomePageList("Thriller Shows", thriller_shows)

        return newHomePageResponse(listOf(crimeshows,Dramashows,thrillershows,HindiMovies,telguMovies))
    }

    //Movie classes
    private fun MovieItem.toSearchResult(): SearchResponse {
        val portraitLargeImageUrl = getPortraitLargeImageUrl(this)
        val bigpic=getMBigPic(this)
        return newMovieSearchResponse(title, LoadUrl(this.title, this.titleContentImageInfo,bigpic,this.type,this.stream,this.description,this.shareUrl,null,languages = this.languages).toJson()) {
            posterUrl = portraitLargeImageUrl
        }
    }

    private fun Item.toSearchResult(): SearchResponse {
        val portraitLargeImageUrl = getPortraitLargeImageUrl(this)
        return newMovieSearchResponse(title, LoadUrl(this.title, this.titleContentImageInfo,null,this.type,null,this.description,this.shareUrl,null,languages = this.languages).toJson()) {
            posterUrl = portraitLargeImageUrl
        }
    }

    fun getPortraitLargeImageUrl(item: MovieItem): String? {
        return item.imageInfo
            .firstOrNull { it.type == "portrait_large" }
            ?.url?.let { imageUrl + it }
    }


    fun getPortraitLargeImageUrl(item: Item): String? {
        return item.imageInfo
            .firstOrNull { it.type == "portrait_large" }
            ?.url?.let { imageUrl + it }
    }

    fun getMovieBigPic(jsonString: String): String? {
        val gson = Gson()
        val item = gson.fromJson(jsonString, MovieItem::class.java)
        val bigPicUrl = item.titleContentImageInfo?.firstOrNull { it.type == "banner_and_static_bg_desktop" }?.url
        return bigPicUrl?.let { "$imageUrl$it" }
    }

    fun getMBigPic(item: MovieItem): String? {
        return item.imageInfo
            .firstOrNull { it.type == "bigpic" }
            ?.url?.let { imageUrl + it }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val response = app.post(
            "$webApi/search/resultv2?query=$query$endParam",
            referer = "$mainUrl/",
            requestBody = "{}".toRequestBody("application/json".toMediaType())
        ).body.string()

        val result = mutableListOf<SearchResponse>()
        val root = JSONObject(response)

        val sections = root.optJSONArray("sections") ?: return result

        for (i in 0 until sections.length()) {
            val section = sections.getJSONObject(i)
            val items = section.optJSONArray("items") ?: continue

            for (j in 0 until items.length()) {
                val item = items.getJSONObject(j)

                val title = item.optString("title")
                val description = item.optString("description")
                val type = item.optString("type")
                val shareUrl = item.optString("shareUrl")
                val languages: List<String> = item.optJSONArray("languages")?.let { arr -> List(arr.length()) { idx -> arr.optString(idx) } } ?: emptyList()

                // --- Image handling ---
                val imageInfo = item.optJSONArray("imageInfo")
                var portraitLargeImageUrl: String? = null
                if (imageInfo != null) {
                    for (k in 0 until imageInfo.length()) {
                        val img = imageInfo.getJSONObject(k)
                        if (img.optString("type") == "portrait_large") {
                            portraitLargeImageUrl = endpointurl + img.optString("url")
                            break
                        }
                    }
                }

                // --- Stream URL handling ---
                //val streamUrl: String? = null
                val stream = item.optJSONObject("stream")

                var alternativeStream: String? = null

                if (stream != null) {
                    val thirdParty = stream.optJSONObject("thirdParty")
                    val mxplay = stream.optJSONObject("mxplay")

                    val hlsObj = stream.optJSONObject("hls") ?: mxplay?.optJSONObject("hls")
                    val dashObj = stream.optJSONObject("dash") ?: mxplay?.optJSONObject("dash")

                    val hlsRaw = hlsObj.bestVariant() ?: thirdParty?.optString("hlsUrl")?.takeIf { it.isNotBlank() }

                    val dashRaw = dashObj.bestVariant() ?: thirdParty?.optString("dashUrl")?.takeIf { it.isNotBlank() }

                    val hlsUrl = normalizeUrl(hlsRaw)
                    val dashUrl = normalizeUrl(dashRaw)

                    val urls = listOfNotNull(hlsUrl, dashUrl).distinct()

                    alternativeStream = when (urls.size) {
                        0 -> null
                        1 -> urls[0]
                        else -> Gson().toJson(urls)
                    }
                }


                // --- Build response ---
                if (type.contains("movie", ignoreCase = true)) {
                    val titleContentImageInfo = item.optJSONArray("titleContentImageInfo")?.let { arr ->
                        (0 until arr.length()).map { arr.get(it) }
                    }
                    result.add(
                        newMovieSearchResponse(
                            title,
                            LoadUrl(
                                title,
                                titleContentImageInfo,
                                null,
                                type,
                                null,
                                description,
                                shareUrl,
                                alternativeStream,
                                portraitLargeImageUrl,
                                languages = languages
                            ).toJson()
                        ) {
                            posterUrl = portraitLargeImageUrl
                        }
                    )
                } else {
                    val titleContentImageInfo = item.optJSONArray("titleContentImageInfo")?.let { arr ->
                        (0 until arr.length()).map { arr.get(it) }
                    }
                    result.add(
                        newMovieSearchResponse(
                            title,
                            LoadUrl(
                                title,
                                titleContentImageInfo,
                                null,
                                type,
                                null,
                                description,
                                shareUrl,
                                alternativeStream,
                                portraitLargeImageUrl,
                                languages = languages
                            ).toJson()
                        ) {
                            posterUrl = portraitLargeImageUrl
                        }
                    )
                }
            }
        }

        return result
    }

    /*
    fun getBigPic(item: Item): String? {
        return item.imageInfo
            .firstOrNull { it.type == "bigpic" }
            ?.url?.let { imageUrl + it }
    }

     */



    @Suppress("LABEL_NAME_CLASH")
    override suspend fun load(url: String): LoadResponse? {
        val gson = Gson()
        val video: LoadUrl? = try {
            gson.fromJson(url, LoadUrl::class.java)
        } catch (e: Exception) {
            Log.e("Error", "Failed to parse JSON into Entity: ${e.message}")
            null
        }
        if (video == null) {
            Log.e("Error", "Failed to parse video from JSON")
            return null
        }

        val title = video.title
        val poster = getMovieBigPic(url) ?: video.titleContentImageInfo ?: video.alternativeposter
        val type = if (video.tvType.contains("tvshow", true)) TvType.TvSeries else TvType.Movie

        val languages: List<String> = video.languages.orEmpty()

        val alternativeUrls: List<String> = video.alternativestream
            ?.trim()
            ?.let { alt ->
                when {
                    alt.startsWith("[") -> {
                        try {
                            gson.fromJson(alt, Array<String>::class.java)?.toList().orEmpty()
                        } catch (e: Exception) {
                            Log.e("Error M Player:", "Failed to parse alternativestream: ${e.message}")
                            listOf(alt)
                        }
                    }
                    alt.contains("|") -> {
                        alt.split("|")
                            .map { it.trim() }
                            .filter { it.isNotEmpty() }
                    }
                    else -> listOf(alt)
                }
            } ?: emptyList()

        val hrefList = buildList {
            addAll(
                listOfNotNull(
                    video.stream?.hls?.high,
                    video.stream?.hls?.base,
                    video.stream?.hls?.main,
                    video.stream?.dash?.high,
                    video.stream?.dash?.base,
                    video.stream?.dash?.main,

                    video.stream?.mxplay?.hls?.high,
                    video.stream?.mxplay?.hls?.base,
                    video.stream?.mxplay?.hls?.main,
                    video.stream?.mxplay?.dash?.high,
                    video.stream?.mxplay?.dash?.base,
                    video.stream?.mxplay?.dash?.main,

                    video.stream?.thirdParty?.hlsUrl,
                    video.stream?.thirdParty?.dashUrl,
                )
            )

            addAll(alternativeUrls)
        }.distinct()

        return if (type == TvType.TvSeries) {
            val epposter = getMovieBigPic(url)
            val seasonData = getSeasonData("$mainUrl${video.shareUrl}")
            val episodes = mutableListOf<Episode>()

            seasonData.forEach { (season, seasonId) ->
                var episodeNumber = 1
                var page = 1
                var nextQuery: String? = null

                do {
                    val apiUrl = if (nextQuery == null) {
                        "$webApi/detail/tab/tvshowepisodes?type=season&id=$seasonId&sortOrder=0$endParam"
                    } else {
                        "$webApi/detail/tab/tvshowepisodes?type=season&$nextQuery&id=$seasonId&sortOrder=0&$endParam"
                    }
                    val jsonResponse = app.get(apiUrl).text

                    val episodesParser = try {
                        gson.fromJson(jsonResponse, EpisodesParser::class.java)
                    } catch (e: Exception) {
                        Log.e("Error M Player:", "Failed to parse JSON on page $page: ${e.message}")
                        break
                    }
                    episodesParser?.items?.forEach {
                        val streamUrls = listOfNotNull(
                            it.stream.hls.high,
                            it.stream.hls.base,
                            it.stream.hls.main,
                            it.stream.dash.high,
                            it.stream.dash.base,
                            it.stream.dash.main,
                            it.stream.mxplay.hls.high,
                            it.stream.mxplay.hls.base,
                            it.stream.mxplay.hls.main,
                            it.stream.mxplay.dash.high,
                            it.stream.mxplay.dash.base,
                            it.stream.mxplay.dash.main
                        ).distinct()
                        if (streamUrls.isEmpty()) return@forEach
                        val name = it.title ?: "Unknown Title"
                        val image = imageUrl + it.imageInfo.firstOrNull()?.url
                        val description = it.description

                        val duration= it.duration.toInt() / 60
                        val epno=it.sequence.toInt()
                        episodes += newEpisode(streamUrls) {
                            this.name = name
                            this.season = season
                            this.episode = epno
                            this.posterUrl = image
                            this.description = description
                            this.runTime = duration
                        }
                        episodeNumber++
                    }

                    nextQuery = episodesParser?.next
                    page++
                } while (nextQuery != null)
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                posterUrl = epposter ?: video.alternativeposter
                backgroundPosterUrl = epposter
                plot = video.description
                tags = languages
            }
        }
        else {
            newMovieLoadResponse(title, url, TvType.Movie, hrefList) {
                posterUrl = poster.toString()
                backgroundPosterUrl = poster.toString()
                plot = video.description
                tags = languages
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val urls = if (data.trim().startsWith("[")) {
            val gson=Gson()
            try {
                gson.fromJson(data, Array<String>::class.java)?.toList().orEmpty()
            } catch (e: Exception) {
                Log.e("Error M Player:", "Failed to parse stream URL list: ${e.message}")
                listOf(data) // fallback to single link
            }
        } else listOf(data)
        urls.forEach { url ->
            val label = if (url.contains(".m3u8")) "HLS"
            else if (url.contains(".mpd")) "DASH"
            else ""
            val fullUrl = if (url.startsWith("video")) endpointurl + url else url

            callback.invoke(
                newExtractorLink(
                    label,
                    "${this.name} $label",
                    url = fullUrl,
                    type = INFER_TYPE
                ) {
                    this.referer = "$mainUrl/"
                    this.quality = Qualities.P1080.value
                }
            )
        }

        return true
    }

private suspend fun getSeasonData(url: String): List<Pair<Int, String>> {
    val document = app.get(url).documentLarge
    return document.select("div.hs__items-container > div").mapNotNull { element ->
        val tab = element.attr("data-tab").toIntOrNull()
        val id = element.attr("data-id")
        if (tab != null && id.isNotBlank()) {
            tab to id
        } else {
            null
        }
    }
}


private fun Headers.getCookies(cookieKey: String = "set-cookie"): Map<String, String> {
    // Get a list of cookie strings
    // set-cookie: name=value; -----> name=value
    val cookieList =
        this.filter { it.first.equals(cookieKey, ignoreCase = true) }.mapNotNull {
            it.second.split(";").firstOrNull()
        }

    return cookieList.associate {
        val split = it.split("=", limit = 2)
        (split.getOrNull(0)?.trim() ?: "") to (split.getOrNull(1)?.trim() ?: "")
    }.filter { it.key.isNotBlank() && it.value.isNotBlank() }
}

    data class LoadUrl(
        val title: String,
        val titleContentImageInfo: List<Any>? = emptyList(),
        val bigpic:String? = null,
        val tvType: String,
        val stream: MovieStream? = null,
        val description: String,
        val shareUrl: String? = null,
        val alternativestream: String? = null,
        val alternativeposter: String? = null,
        val languages: List<String>? = emptyList(),
    )

    private fun JSONObject?.bestVariant(): String? {
        if (this == null) return null
        val keys = arrayOf("high", "base", "main")
        for (k in keys) {
            val v = optString(k)
            if (!v.isNullOrBlank()) return v
        }
        return null
    }

    private fun normalizeUrl(url: String?): String? {
        if (url.isNullOrBlank()) return null
        return if (url.startsWith("http", ignoreCase = true)) {
            url
        } else {
            endpointurl + url
        }
    }

}


================================================
FILE: MPlayerProvider/src/main/kotlin/com/MPlayer/MPlayerPlugin.kt
================================================
package com.MPlayer

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class MPlayerPlugin : BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MPlayer())
    }
}



================================================
FILE: MPlayerProvider/src/main/kotlin/com/MPlayer/Parser.kt
================================================
package com.MPlayer


import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty

@JsonIgnoreProperties(ignoreUnknown = true)
data class MXPlayer(
    val style: String,
    val totalCount: Long,
    val next: String,
    val previous: String,
    val items: List<Item>,
)


data class Item(
    val description: String,
    val title: String,
    val releaseDate: String,
    val stream: Stream?,
    val type: String,
    val tvodPackImageInfo: Any?,
    val tvodDetail: Any?,
    val watchAt: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val subtitleLanguageCode: Any?,
    val audioTrackLanguageCode: Any?,
    val statusCode: Long,
    val lastTvShowEpisode: Boolean,
    val rating: Long,
    val descriptor: Any?,
    val id: String,
    val languages: List<String>,
    val languagesDetails: List<LanguagesDetail>,
    val duration: Long,
    val genres: List<String>,
    val genresDetails: List<GenresDetail>,
    val secondaryGenres: List<String>,
    val publishTime: Any?,
    val shareUrl: String,
    val image: Image,
    val imageInfo: List<ImageInfo>,
    val titleContentImageInfo: List<TitleContentImageInfo>,
    val trailerPreview: Any?,
    val trailer: List<Trailer>?,
    val container: Any?,
    val contributors: List<Any?>,
    val sequence: Long,
    val subType: String,
    val gifVideoUrl: Any?,
    val gifVideoUrlInfo: Any?,
    @JsonProperty("canPreviewGIFVideo")
    val canPreviewGifvideo: Boolean,
    val webUrl: String,
    val isOptimizedDescription: Boolean,
    val childCount: Long,
    val videoCount: Long,
    val detailKey: Any?,
    val inlineData: Any?,
    val statistics: Any?,
    val viewCount: Long,
    val overlayImages: Any?,
    val tags: Any?,
    val tabs: Any?,
    val goldBadgeImageInfo: Any?,
    @JsonProperty("existInCW")
    val existInCw: Boolean,
)

data class LanguagesDetail(
    val id: String,
    val name: String,
    val webUrl: String?,
    @JsonProperty("three_char_language_id")
    val threeCharLanguageId: String,
)

data class GenresDetail(
    val id: String,
    val name: String,
    val webUrl: String?,
)

data class Image(
    @JsonProperty("16x9")
    val n16x9: String,
    @JsonProperty("2x3")
    val n2x3: String,
    @JsonProperty("1x1")
    val n1x1: String?,
    @JsonProperty("18x14")
    val n18x14: Any?,
    @JsonProperty("40x13")
    val n40x13: Any?,
    @JsonProperty("9x16")
    val n9x16: Any?,
    @JsonProperty("13x15")
    val n13x15: Any?,
    @JsonProperty("2x1")
    val n2x1: String?,
    @JsonProperty("9x19")
    val n9x19: String?,
)

data class ImageInfo(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
    @JsonProperty("genre_ids")
    val genreIds: List<String>?,
)

data class TitleContentImageInfo(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
)

data class Trailer(
    val description: String,
    val title: String,
    val releaseDate: String,
    val stream: Stream,
    val type: String,
    val tvodPackImageInfo: Any?,
    val tvodDetail: Any?,
    val watchAt: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val subtitleLanguageCode: Any?,
    val audioTrackLanguageCode: Any?,
    val statusCode: Long,
    val lastTvShowEpisode: Boolean,
    val rating: Long,
    val descriptor: Any?,
    val id: String,
    val languages: List<String>,
    val languagesDetails: List<LanguagesDetail2>,
    val duration: Long,
    val genres: List<String>,
    val genresDetails: List<GenresDetail2>,
    val secondaryGenres: Any?,
    val publishTime: Any?,
    val shareUrl: String,
    val image: Image2,
    val imageInfo: List<ImageInfo2>,
    val titleContentImageInfo: Any?,
    val trailer: Any?,
    val firstVideo: Any?,
    val container: Any?,
    val contributors: List<Any?>,
    val sequence: Long,
    val subType: String,
    @JsonProperty("canPreviewGIFVideo")
    val canPreviewGifvideo: Boolean,
    val webUrl: String,
    val isOptimizedDescription: Boolean,
    val childCount: Long,
    val videoCount: Long,
    val detailKey: Any?,
    val inlineData: Any?,
    val statistics: Any?,
    val viewCount: Long,
    val overlayImages: Any?,
    val tabs: Any?,
    val goldBadgeImageInfo: Any?,
    @JsonProperty("existInCW")
    val existInCw: Boolean,
)

data class Stream(
    val provider: String,
    val dash: Dash,
    val hls: Hls,
    val drmProtect: Boolean,
    val mxplay: Mxplay,
    val youtube: Any?,
    val sony: Any?,
    val altBalaji: Any?,
    val thirdParty: ThirdParty?,
    val videoHash: String,
    val adTagProvider: String,
    val download: Download,
    val watermark: Any?,
    val aspectRatio: String,
)

data class ThirdParty(
    val dashUrl: String?,
    val hlsUrl: String?,
    val contentId: String?,
    val hlsId: String?,
    val dashId: String?,
    val webHlsUrl: String?,
    val validUntil: String?,
    val name: String
)

data class Dash(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class Hls(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class Mxplay(
    val dash: Dash2,
    val hls: Hls2,
    val contentId: String,
    val validUntil: Any?,
    val offsetTime: Long,
    val dvr: Boolean,
)

data class Dash2(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class Hls2(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class Download(
    val expiryDate: String,
    val requireLoginToDownload: Boolean,
    val requiredPack: String,
    val requireSubscriptionToDownload: Boolean,
    val downloadCriteria: String,
    val isEligibleForDownload: Boolean,
)

data class LanguagesDetail2(
    val id: String,
    val name: String,
    val webUrl: String,
    @JsonProperty("three_char_language_id")
    val threeCharLanguageId: String,
)

data class GenresDetail2(
    val id: String,
    val name: String,
)

data class Image2(
    @JsonProperty("16x9")
    val n16x9: String,
    @JsonProperty("2x3")
    val n2x3: Any?,
    @JsonProperty("1x1")
    val n1x1: Any?,
    @JsonProperty("18x14")
    val n18x14: Any?,
    @JsonProperty("40x13")
    val n40x13: Any?,
    @JsonProperty("9x16")
    val n9x16: String?,
    @JsonProperty("13x15")
    val n13x15: Any?,
    @JsonProperty("2x1")
    val n2x1: Any?,
    @JsonProperty("9x19")
    val n9x19: Any?,
)

data class ImageInfo2(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
)

//Loadtest




//Entity


//EpisodesParser
@JsonIgnoreProperties(ignoreUnknown = true)
data class EpisodesParser(
    val id: String,
    val style: String,
    val items: List<EpisodesItem>,
    val next: String?,
    val previous: String,
    val name: String,
    val webUrl: Any?,
    val channelDetails: Any?,
    val features: Any?,
    val tournament: Any?,
    val ascend: Boolean,
)


data class EpisodesItem(
    val description: String,
    val title: String?,
    val releaseDate: String,
    val stream: EpisodesStream,
    val type: String,
    val tvodPackImageInfo: Any?,
    val tvodDetail: Any?,
    val watchAt: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val subtitleLanguageCode: Any?,
    val audioTrackLanguageCode: Any?,
    val statusCode: Long,
    val lastTvShowEpisode: Boolean,
    val rating: Long,
    val descriptor: Any?,
    val id: String,
    val languages: List<String>,
    val languagesDetails: List<EpisodesLanguagesDetail>,
    val duration: Long,
    val genres: List<String>,
    val genresDetails: List<GenresDetail>,
    val secondaryGenres: List<String>,
    val publishTime: String,
    val shareUrl: String,
    val image: EpisodesImage,
    val imageInfo: List<EpisodesImageInfo>,
    val titleContentImageInfo: Any?,
    val trailerPreview: Any?,
    val trailer: Any?,
    val firstVideo: Any?,
    val container: Container,
    val sequence: Long,
    val subType: String,
    @JsonProperty("canPreviewGIFVideo")
    val canPreviewGifvideo: Boolean,
    val webUrl: String?,
    val isOptimizedDescription: Boolean,
    val childCount: Long,
    val videoCount: Long,
    val detailKey: Any?,
    val inlineData: Any?,
    val statistics: Any?,
    val viewCount: Long,
    val overlayImages: Any?,
    val tabs: Any?,
    val goldBadgeImageInfo: Any?,
    @JsonProperty("existInCW")
    val existInCw: Boolean,
)

data class EpisodesStream(
    val provider: String,
    val dash: EpisodesDash,
    val hls: EpisodesHls,
    val drmProtect: Boolean,
    val mxplay: EpisodesMxplay,
    val youtube: Any?,
    val sony: Any?,
    val altBalaji: Any?,
    val thirdParty: Any?,
    val videoHash: String,
    val adTagProvider: String,
    val download: EpisodesDownload,
    val watermark: Any?,
    val aspectRatio: String,
)

data class EpisodesDash(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class EpisodesHls(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class EpisodesMxplay(
    val dash: EpisodesDash2,
    val hls: EpisodesHls2,
    val contentId: String,
    val validUntil: Any?,
    val offsetTime: Long,
    val dvr: Boolean,
)

data class EpisodesDash2(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class EpisodesHls2(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class EpisodesDownload(
    val expiryDate: String,
    val requireLoginToDownload: Boolean,
    val requiredPack: String,
    val requireSubscriptionToDownload: Boolean,
    val downloadCriteria: String,
    val isEligibleForDownload: Boolean,
)

data class EpisodesLanguagesDetail(
    val id: String,
    val name: String,
    val webUrl: String,
    @JsonProperty("three_char_language_id")
    val threeCharLanguageId: String,
)

data class EpisodesImage(
    @JsonProperty("16x9")
    val n16x9: String,
    @JsonProperty("2x3")
    val n2x3: Any?,
    @JsonProperty("1x1")
    val n1x1: Any?,
    @JsonProperty("18x14")
    val n18x14: String,
    @JsonProperty("40x13")
    val n40x13: Any?,
    @JsonProperty("9x16")
    val n9x16: Any?,
    @JsonProperty("13x15")
    val n13x15: Any?,
    @JsonProperty("2x1")
    val n2x1: String,
    @JsonProperty("9x19")
    val n9x19: Any?,
)

data class EpisodesImageInfo(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
)

data class Container(
    val title: String,
    val type: String,
    val sequence: Long,
    val imageInfo: List<ImageInfo2>,
    val aroundApi: Any?,
    val episodesCount: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val id: String,
)


//MovieHomapege

data class MovieRoot(
    val style: String,
    val totalCount: Long,
    val next: String,
    val previous: String,
    val items: List<MovieItem>,
)

data class MovieItem(
    val description: String,
    val title: String,
    val releaseDate: String,
    val stream: MovieStream,
    val type: String,
    val tvodPackImageInfo: Any?,
    val tvodDetail: Any?,
    val watchAt: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val subtitleLanguageCode: Any?,
    val audioTrackLanguageCode: Any?,
    val statusCode: Long,
    val lastTvShowEpisode: Boolean,
    val rating: Long,
    val descriptor: Any?,
    val id: String,
    val languages: List<String>,
    val languagesDetails: List<MovieLanguagesDetail>,
    val duration: Long,
    val genres: List<String>,
    val genresDetails: List<MovieGenresDetail>,
    val secondaryGenres: List<String>?,
    val publishTime: String,
    val shareUrl: String,
    val image: MovieImage,
    val imageInfo: List<MovieImageInfo>,
    val titleContentImageInfo: List<MovieTitleContentImageInfo>?,
    val trailerPreview: Any?,
    val trailer: List<MovieTrailer>?,
    val firstVideo: Any?,
    val container: Any?,
    val sequence: Long,
    val subType: String,
    @JsonProperty("canPreviewGIFVideo")
    val canPreviewGifvideo: Boolean,
    val webUrl: String,
    val isOptimizedDescription: Boolean,
    val publisher: MoviePublisher2,
    val childCount: Long,
    val videoCount: Long,
    val detailKey: Any?,
    val inlineData: Any?,
    val statistics: Any?,
    val viewCount: Long,
    val overlayImages: Any?,
    val tabs: Any?,
    val goldBadgeImageInfo: Any?,
    @JsonProperty("existInCW")
    val existInCw: Boolean,
)

data class MovieStream(
    val provider: String,
    val dash: MovieDash?,
    val hls: MovieHls?,
    val drmProtect: Boolean,
    val mxplay: MovieMxplay?,
    val youtube: Any?,
    val sony: Any?,
    val altBalaji: Any?,
    val thirdParty: MovieThirdParty?,
    val videoHash: String,
    val adTagProvider: String,
    val download: MovieDownload,
    val watermark: Any?,
    val aspectRatio: String,
)

data class MovieDash(
    val high: String?,
    val base: String?,
    val main: Any?,
)

data class MovieHls(
    val high: String?,
    val base: String?,
    val main: Any?,
)

data class MovieMxplay(
    val dash: MovieDash2,
    val hls: MovieHls2,
    val contentId: String,
    val validUntil: Any?,
    val offsetTime: Long,
    val dvr: Boolean,
)

data class MovieDash2(
    val high: String?,
    val base: String?,
    val main: Any?,
)

data class MovieHls2(
    val high: String?,
    val base: String?,
    val main: Any?,
)

data class MovieThirdParty(
    val dashUrl: String,
    val hlsUrl: String,
    val contentId: Any?,
    val hlsId: Any?,
    val dashId: Any?,
    val webHlsUrl: Any?,
    val validUntil: Any?,
    val name: String,
)

data class MovieDownload(
    val expiryDate: String?,
    val requireLoginToDownload: Boolean,
    val requiredPack: String,
    val requireSubscriptionToDownload: Boolean,
    val downloadCriteria: String,
    val isEligibleForDownload: Boolean,
)

data class MovieLanguagesDetail(
    val id: String,
    val name: String,
    val webUrl: String,
    @JsonProperty("three_char_language_id")
    val threeCharLanguageId: String,
)

data class MovieGenresDetail(
    val id: String,
    val name: String,
    val webUrl: String,
)

data class MovieImage(
    @JsonProperty("16x9")
    val n16x9: String,
    @JsonProperty("2x3")
    val n2x3: String,
    @JsonProperty("1x1")
    val n1x1: Any?,
    @JsonProperty("18x14")
    val n18x14: Any?,
    @JsonProperty("40x13")
    val n40x13: Any?,
    @JsonProperty("9x16")
    val n9x16: Any?,
    @JsonProperty("13x15")
    val n13x15: Any?,
    @JsonProperty("2x1")
    val n2x1: Any?,
    @JsonProperty("9x19")
    val n9x19: Any?,
)

data class MovieImageInfo(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
)

data class MovieTitleContentImageInfo(
    val density: String,
    val width: Long,
    val type: String,
    val url: String,
    val height: Long,
)

data class MovieTrailer(
    val description: String,
    val title: String,
    val releaseDate: String,
    val stream: MovieStream2,
    val type: String,
    val tvodPackImageInfo: Any?,
    val tvodDetail: Any?,
    val watchAt: Long,
    val lastWatched: Boolean,
    val lastWatchedEpisodeId: Any?,
    val subtitleLanguageCode: Any?,
    val audioTrackLanguageCode: Any?,
    val statusCode: Long,
    val lastTvShowEpisode: Boolean,
    val rating: Long,
    val descriptor: Any?,
    val id: String,
    val languages: List<String>,
    val languagesDetails: List<MovieLanguagesDetail2>,
    val duration: Long,
    val genres: List<String>,
    val genresDetails: List<MovieGenresDetail2>,
    val secondaryGenres: Any?,
    val publishTime: Any?,
    val shareUrl: String,
    val image: MovieImage2,
    val titleContentImageInfo: Any?,
    val trailerPreview: MovieTrailerPreview,
    val trailer: Any?,
    val firstVideo: Any?,
    val container: Any?,
    val contributors: List<Any?>,
    val sequence: Long,
    val subType: String,
    val gifVideoUrl: MovieGifVideoUrl,
    val gifVideoUrlInfo: List<MovieGifVideoUrlInfo>,
    @JsonProperty("canPreviewGIFVideo")
    val canPreviewGifvideo: Boolean,
    val webUrl: String,
    val isOptimizedDescription: Boolean,
    val publisher: MoviePublisher,
    val childCount: Long,
    val videoCount: Long,
    val detailKey: Any?,
    val inlineData: Any?,
    val statistics: Any?,
    val viewCount: Long,
    val overlayImages: Any?,
    val tags: List<MovieTag>,
    val tabs: Any?,
    val goldBadgeImageInfo: Any?,
    @JsonProperty("existInCW")
    val existInCw: Boolean,
)

data class MovieStream2(
    val provider: String,
    val dash: MovieDash3,
    val hls: MovieHls3,
    val drmProtect: Boolean,
    val mxplay: MovieMxplay2,
    val youtube: Any?,
    val sony: Any?,
    val altBalaji: Any?,
    val thirdParty: Any?,
    val videoHash: String,
    val adTagProvider: String,
    val download: MovieDownload2,
    val watermark: Any?,
    val aspectRatio: String,
)

data class MovieDash3(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class MovieHls3(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class MovieMxplay2(
    val dash: MovieDash4,
    val hls: MovieHls4,
    val contentId: String,
    val validUntil: Any?,
    val offsetTime: Long,
    val dvr: Boolean,
)

data class MovieDash4(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class MovieHls4(
    val high: String,
    val base: Any?,
    val main: Any?,
)

data class MovieDownload2(
    val expiryDate: String?,
    val requireLoginToDownload: Boolean,
    val requiredPack: String,
    val requireSubscriptionToDownload: Boolean,
    val downloadCriteria: String,
    val isEligibleForDownload: Boolean,
)

data class MovieLanguagesDetail2(
    val id: String,
    val name: String,
    val webUrl: String,
    @JsonProperty("three_char_language_id")
    val threeCharLanguageId: String,
)

data class MovieGenresDetail2(
    val id: String,
    val name: String,
)

data class MovieImage2(
    @JsonProperty("16x9")
    val n16x9: String,
    @JsonProperty("2x3")
    val n2x3: String,
    @JsonProperty("1x1")
    val n1x1: Any?,
)

data class MovieTrailerPreview(
    val url: String,
    val previewImage: String,
)

data class MovieGifVideoUrl(
    val high: String,
    val base: String,
)

data class MovieGifVideoUrlInfo(
    val height: String,
    val width: String,
    val type: String,
    val url: String,
)

data class MoviePublisher(
    val id: String,
    val name: String,
)

data class MovieTag(
    val id: String,
    val name: String,
)

data class MoviePublisher2(
    val id: String,
    val name: String,
)



================================================
FILE: MPlayerProvider/src/main/kotlin/com/MPlayer/Utils.kt
================================================
package com.MPlayer

import com.fasterxml.jackson.core.json.JsonReadFeature
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.nicehttp.Requests
import com.lagradost.nicehttp.ResponseParser
import kotlin.reflect.KClass

val JSONParser = object : ResponseParser {
    val mapper: ObjectMapper = jacksonObjectMapper().configure(
        DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false
    ).configure(
        JsonReadFeature.ALLOW_UNESCAPED_CONTROL_CHARS.mappedFeature(), true
    )

    override fun <T : Any> parse(text: String, kClass: KClass<T>): T {
        return mapper.readValue(text, kClass.java)
    }

    override fun <T : Any> parseSafe(text: String, kClass: KClass<T>): T? {
        return try {
            mapper.readValue(text, kClass.java)
        } catch (e: Exception) {
            null
        }
    }

    override fun writeValueAsString(obj: Any): String {
        return mapper.writeValueAsString(obj)
    }
}

val app = Requests(responseParser = JSONParser).apply {
    defaultHeaders = mapOf("User-Agent" to USER_AGENT)
}




================================================
FILE: MultiMoviesProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 45

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Indian Multi-language HD Provider"
    language = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
        "Anime",
    )
    iconUrl = "https://raw.githubusercontent.com/LikDev-256/likdev256-tamil-providers/master/MultiMoviesProvider/icon.png"

    isCrossPlatform = true
}



================================================
FILE: MultiMoviesProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: MultiMoviesProvider/src/main/kotlin/com/phisher98/Extractor.kt
================================================
package com.phisher98

import com.google.gson.JsonParser
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.net.URI

class MultimoviesAIO: StreamWishExtractor() {
    override var name = "Multimovies Cloud AIO"
    override var mainUrl = "https://allinonedownloader.fun"
    override var requiresReferer = true
}

class Techinmind: GDMirrorbot() {
    override var name = "Techinmind Cloud AIO"
    override var mainUrl = "https://stream.techinmind.space"
    override var requiresReferer = true
}

class Dhcplay: VidHidePro() {
    override var name = "DHC Play"
    override var mainUrl = "https://dhcplay.com"
    override var requiresReferer = true
}

class Multimovies: StreamWishExtractor() {
    override var name = "Multimovies Cloud"
    override var mainUrl = "https://multimovies.cloud"
    override var requiresReferer = true
}

class Animezia : VidhideExtractor() {
    override var name = "Animezia"
    override var mainUrl = "https://animezia.cloud"
    override var requiresReferer = true
}

class server1 : VidStack() {
    override var name = "MultimoviesVidstack"
    override var mainUrl = "https://server1.uns.bio"
    override var requiresReferer = true
}

class server2 : VidhideExtractor() {
    override var name = "Multimovies Vidhide"
    override var mainUrl = "https://server2.shop"
    override var requiresReferer = true
}

class Asnwish : StreamWishExtractor() {
    override val name = "Streanwish Asn"
    override val mainUrl = "https://asnwish.com"
    override val requiresReferer = true
}

class CdnwishCom : StreamWishExtractor() {
    override val name = "Cdnwish"
    override val mainUrl = "https://cdnwish.com"
    override val requiresReferer = true
}
open class GDMirrorbot : ExtractorApi() {
    override var name = "GDMirrorbot"
    override var mainUrl = "https://gdmirrorbot.nl"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val (sid, host) = if (!url.contains("key=")) {
            Pair(url.substringAfterLast("embed/"), getBaseUrl(app.get(url).url))
        } else {
            var pageText = app.get(url).text
            val finalId = Regex("""FinalID\s*=\s*"([^"]+)"""").find(pageText)?.groupValues?.get(1)
            val myKey = Regex("""myKey\s*=\s*"([^"]+)"""").find(pageText)?.groupValues?.get(1)
            val idType = Regex("""idType\s*=\s*"([^"]+)"""").find(pageText)?.groupValues?.get(1) ?: "imdbid"
            val baseUrl = Regex("""let\s+baseUrl\s*=\s*"([^"]+)"""").find(pageText)?.groupValues?.get(1)
            val hostUrl = baseUrl?.let { getBaseUrl(it) }

            if (finalId != null && myKey != null) {
                val apiUrl = "$mainUrl/mymovieapi?$idType=$finalId&key=$myKey"
                pageText = app.get(apiUrl).text
            }

            val jsonElement = JsonParser.parseString(pageText)
            if (!jsonElement.isJsonObject) return
            val jsonObject = jsonElement.asJsonObject

            val embedId = url.substringAfterLast("/")
            val sidValue = jsonObject["data"]?.asJsonArray
                ?.takeIf { it.size() > 0 }
                ?.get(0)?.asJsonObject
                ?.get("fileslug")?.asString
                ?.takeIf { it.isNotBlank() } ?: embedId

            Pair(sidValue, hostUrl)
        }

        val postData = mapOf("sid" to sid)
        val responseText = app.post("$host/embedhelper.php", data = postData).text

        val rootElement = JsonParser.parseString(responseText)
        if (!rootElement.isJsonObject) return
        val root = rootElement.asJsonObject

        val siteUrls = root["siteUrls"]?.asJsonObject ?: return
        val siteFriendlyNames = root["siteFriendlyNames"]?.asJsonObject

        val decodedMresult = when {
            root["mresult"]?.isJsonObject == true -> root["mresult"]!!.asJsonObject
            root["mresult"]?.isJsonPrimitive == true -> try {
                base64Decode(root["mresult"]!!.asString)
                    .let { JsonParser.parseString(it).asJsonObject }
            } catch (e: Exception) {
                Log.e("Phisher", "Failed to decode mresult: $e")
                return
            }
            else -> return
        }

        siteUrls.keySet().intersect(decodedMresult.keySet()).forEach { key ->
            val base = siteUrls[key]?.asString?.trimEnd('/') ?: return@forEach
            val path = decodedMresult[key]?.asString?.trimStart('/') ?: return@forEach
            val fullUrl = "$base/$path"
            val friendlyName = siteFriendlyNames?.get(key)?.asString ?: key

            try {
                Log.d("Phisher","$friendlyName $fullUrl")
                when (friendlyName) {
                    "StreamHG","EarnVids" -> VidHidePro().getUrl(fullUrl, referer, subtitleCallback, callback)
                    "RpmShare", "UpnShare", "StreamP2p" -> VidStack().getUrl(fullUrl, referer, subtitleCallback, callback)
                    else -> loadExtractor(fullUrl, referer ?: mainUrl, subtitleCallback, callback)
                }
            } catch (e: Exception) {
                Log.e("Phisher", "Failed to extract from $friendlyName at $fullUrl: $e")
            }
        }
    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let { "${it.scheme}://${it.host}" }
    }
}

class Streamcasthub : ExtractorApi() {
    override var name = "Streamcasthub"
    override var mainUrl = "https://multimovies.streamcasthub.store"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val id=url.substringAfterLast("/#")
        val m3u8= "https://ss1.rackcloudservice.cyou/ic/$id/master.txt"
        callback.invoke(
            newExtractorLink(
                this.name,
                this.name,
                m3u8,
                ExtractorLinkType.M3U8
            )
            {
                this.referer = url
            }
        )
    }
}



class Strwishcom : StreamWishExtractor() {
    override val name = "Strwish"
    override val mainUrl = "https://strwish.com"
    override val requiresReferer = true
}


================================================
FILE: MultiMoviesProvider/src/main/kotlin/com/phisher98/MultiMoviesProvider.kt
================================================
package com.phisher98


import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.newTvSeriesSearchResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.nicehttp.NiceResponse
import kotlinx.coroutines.runBlocking
import okhttp3.FormBody
import org.jsoup.nodes.Element

class MultiMoviesProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl: String = runBlocking {
        MultiMoviesProviderPlugin.getDomains()?.MultiMovies ?: "https://multimovies.cheap"
    }
    override var name = "MultiMovies"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AnimeMovie,
    )

    override val mainPage = mainPageOf(
        "trending/" to "Trending",
        "genre/bollywood-movies/" to "Bollywood Movies",
        "genre/hollywood/" to "Hollywood Movies",
        "genre/south-indian/" to "South Indian Movies",
        "genre/punjabi/" to "Punjabi Movies",
        "genre/amazon-prime/" to "Amazon Prime",
        "genre/disney-hotstar/" to "Disney Hotstar",
        "genre/jio-ott/" to "Jio OTT",
        "genre/netflix/" to "Netfilx",
        "genre/sony-liv/" to "Sony Live",
        "genre/k-drama/" to "KDrama",
        "genre/zee-5/" to "Zee5",
        "genre/anime-hindi/" to "Anime Series",
        "genre/anime-movies/" to "Anime Movies",
        "genre/cartoon-network/" to "Cartoon Network",
        "genre/disney-channel/" to "Disney Channel",
        "genre/hungama/" to "Hungama",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = if (page == 1) {
            app.get("$mainUrl/${request.data}").documentLarge
        } else {
            app.get("$mainUrl/${request.data}" + "page/$page/").documentLarge
        }
        val home = if (request.data.contains("/movies")) {
            document.select("#archive-content > article").mapNotNull {
                it.toSearchResult()
            }
        } else {
            document.select("div.items > article").mapNotNull {
                it.toSearchResult()
            }
        }
        return newHomePageResponse(HomePageList(request.name, home))
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("div.data > h3 > a")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("div.data > h3 > a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("div.poster > img")?.getImageAttr())
        val quality = getQualityFromString(this.select("div.poster > div.mepo > span").text())
        return if (href.contains("Movie")) {
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        } else {
            newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        return document.select("div.result-item").mapNotNull {
            val title =
                it.selectFirst("article > div.details > div.title > a")?.text().toString().trim()
            val href = fixUrl(
                it.selectFirst("article > div.details > div.title > a")?.attr("href").toString()
            )
            val posterUrl = fixUrlNull(
                it.selectFirst("article > div.image > div.thumbnail > a > img")?.attr("src")
            )
            val quality = getQualityFromString(it.select("div.poster > div.mepo > span").text())
            val type = it.select("article > div.image > div.thumbnail > a > span").text()
            if (type.contains("Movie")) {
                newMovieSearchResponse(title, href, TvType.Movie) {
                    this.posterUrl = posterUrl
                    this.quality = quality
                }
            } else {
                newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                    this.posterUrl = posterUrl
                    this.quality = quality
                }
            }
        }
    }

    private suspend fun getEmbed(postid: String?, nume: String, referUrl: String?): NiceResponse {

        val body = FormBody.Builder()
            .addEncoded("action", "doo_player_ajax")
            .addEncoded("post", postid.toString())
            .addEncoded("nume", nume)
            .addEncoded("type", "movie")
            .build()

        return app.post(
            "$mainUrl/wp-admin/admin-ajax.php",
            requestBody = body,
            referer = referUrl
        )
    }

    data class TrailerUrl(
        @JsonProperty("embed_url") var embedUrl: String?,
        @JsonProperty("type") var type: String?
    )

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get(url).documentLarge
        val titleL = doc.selectFirst("div.sheader > div.data > h1")?.text()?.trim() ?: return null
        val titleRegex = Regex("(^.*\\)\\d*)")
        val titleClean = titleRegex.find(titleL)?.groups?.get(1)?.value.toString()
        val title = if (titleClean == "null") titleL else titleClean
        val poster = fixUrlNull(
            doc.select("div.g-item a").attr("href")
        )
        val tags = doc.select("div.sgeneros > a").map { it.text() }
        val year = doc.selectFirst("span.date")?.text()?.substringAfter(",")?.trim()?.toInt()
        val description = doc.selectFirst("#info div.wp-content p")?.text()?.trim()
        val type = if (url.contains("tvshows")) TvType.TvSeries else TvType.Movie
        val trailerRegex = Regex("\"http.*\"")

        var trailer: String? = if (type == TvType.Movie) {
            try {
                val postId = doc.select("#player-option-trailer").attr("data-post")
                val embedResponse = getEmbed(postId, "trailer", url)
                val parsed = embedResponse.parsed<TrailerUrl>()
                parsed.embedUrl?.let { fixUrlNull(it) }
            } catch (_: Exception) {
                null
            }
        } else {
            val iframeSrc = doc.select("iframe.rptss").attr("src")
            fixUrlNull(iframeSrc)
        }
        trailer = trailer?.let { trailerRegex.find(it)?.value?.trim('"') }
        val rating = doc.select("span.dt_rating_vgs").text()
        val duration =
            doc.selectFirst("span.runtime")?.text()?.removeSuffix(" Min.")?.trim()
                ?.toInt()
        val actors =
            doc.select("div.person").map {
                ActorData(
                    Actor(
                        it.select("div.data > div.name > a").text(),
                        it.select("div.img > a > img").attr("src")
                    ),
                    roleString = it.select("div.data > div.caracter").text(),
                )
            }
        val recommendations = doc.select("#dtw_content_related-2 article").mapNotNull {
            it.toSearchResult()
        }

        val episodes = ArrayList<Episode>()
        doc.select("#seasons ul.episodios").mapIndexed { seasonNum, me ->
            me.select("li").mapIndexed { epNum, it ->
                episodes.add(
                    newEpisode(it.select("div.episodiotitle > a").attr("href"))
                    {
                        this.name = it.select("div.episodiotitle > a").text()
                        this.season = seasonNum + 1
                        this.episode = epNum + 1
                        this.posterUrl = it.selectFirst("div.imagen > img")?.getImageAttr()
                    }
                )
            }
        }

        return if (type == TvType.Movie) {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = poster?.trim()
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.duration = duration
                this.actors = actors
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster?.trim()
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.duration = duration
                this.actors = actors
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val req = app.get(data).documentLarge
        req.select("ul#playeroptionsul li").map {
                Triple(
                    it.attr("data-post"),
                    it.attr("data-nume"),
                    it.attr("data-type")
                )
            }.amap { (id, nume, type) ->
            if (!nume.contains("trailer")) {
                val source = app.post(
                    url = "$mainUrl/wp-admin/admin-ajax.php",
                    data = mapOf(
                        "action" to "doo_player_ajax",
                        "post" to id,
                        "nume" to nume,
                        "type" to type
                    ),
                    referer = mainUrl,
                    headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                ).parsed<ResponseHash>().embed_url
                val link = source.substringAfter("\"").substringBefore("\"").trim()
                when {
                    !link.contains("youtube") -> {
                        if (link.contains("deaddrive.xyz")) {
                            app.get(link).documentLarge.select("ul.list-server-items > li").map {
                                val server = it.attr("data-video")
                                loadExtractor(server, referer = mainUrl, subtitleCallback, callback)
                            }
                        } else
                            loadExtractor(link, referer = mainUrl, subtitleCallback, callback)
                    }

                    else -> return@amap
                }
            }
        }
        return true
    }

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("key") val key: String? = null,
        @JsonProperty("type") val type: String? = null,
    )


    private fun Element.getImageAttr(): String? {
        return this.attr("data-src")
            .takeIf { it.isNotBlank() && it.startsWith("http") }
            ?: this.attr("src").takeIf { it.isNotBlank() && it.startsWith("http") }
    }
}



================================================
FILE: MultiMoviesProvider/src/main/kotlin/com/phisher98/MultiMoviesProviderPlugin.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.DoodLaExtractor
import com.lagradost.cloudstream3.extractors.MixDrop
import com.lagradost.cloudstream3.extractors.XStreamCdn
import com.lagradost.cloudstream3.extractors.VidHidePro5
import com.lagradost.cloudstream3.extractors.VidHidePro6
import com.lagradost.cloudstream3.app


@CloudstreamPlugin
class MultiMoviesProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MultiMoviesProvider())
        registerExtractorAPI(VidHidePro5())
        registerExtractorAPI(MixDrop())
        registerExtractorAPI(Multimovies())
        registerExtractorAPI(XStreamCdn())
        registerExtractorAPI(DoodLaExtractor())
        registerExtractorAPI(Animezia())
        registerExtractorAPI(server2())
        registerExtractorAPI(MultimoviesAIO())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(Asnwish())
        registerExtractorAPI(CdnwishCom())
        registerExtractorAPI(Strwishcom())
        registerExtractorAPI(VidHidePro6())
        registerExtractorAPI(Streamcasthub())
        registerExtractorAPI(Dhcplay())
        registerExtractorAPI(server1())
        registerExtractorAPI(Techinmind())
        }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("MultiMovies")
            val MultiMovies: String,
        )
    }
}



================================================
FILE: Netcinez/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Movies,Series and Anime Portuguese Extension "
    language    = "pt-br"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://cdn.bcdn.zip/wp-content/uploads/2017/04/nc-header-responsive.png"

    isCrossPlatform = true
}



================================================
FILE: Netcinez/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Netcinez/src/main/kotlin/com/Netcinez/Netcinez.kt
================================================
package com.Netcinez

import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.newTvSeriesSearchResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.nodes.Element

class Netcinez : MainAPI() {
    override var mainUrl = "https://netcinez.si"
    override var name = "Netcinez"
    override val hasMainPage = true
    override var lang = "pt-br"
    override val hasDownloadSupport = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.TvSeries)

    override val mainPage = mainPageOf(
        "category/ultimos-filmes" to "Últimas Atualizações Filmes",
        "category/acao" to "Ação Filmes",
        "category/animacao" to "Animação Filmes",
        "category/aventura" to "Aventura Filmes",
        "category/comedia" to "Comédia Filmes",
        "category/crime" to "Crime Filmes",
        "tvshows" to "Últimas Atualizações Séries",
        "tvshows/category/acao" to "Ação Séries",
        "tvshows/category/animacao" to "Animação Séries",
        "tvshows/category/aventura" to "Aventura Séries",
        "tvshows/category/comedia" to "Comédia Séries",
        "tvshows/category/crime" to "Crime Séries",
    )


    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = "$mainUrl/${request.data}"
        val document = app.get(url).documentLarge

        val home = document.select("#box_movies > div.movie").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("h2").text().trim()
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl =
            this.select("img").attr("data-src").ifEmpty { this.select("img").attr("src") }
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()
        for (i in 1..3) {
            val document = app.get("${mainUrl}/?s=$query").documentLarge
            val results = document.select("#box_movies > div.movie").mapNotNull { it.toSearchResult() }
            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }
            if (results.isEmpty()) break
        }
        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("div.dataplus h1")?.text() ?: document.select("div.dataplus span.original").text()
        val poster = fixUrl(document.select("div.headingder > div.cover").attr("data-bg"))
        val description = document.selectFirst("meta[property=og:description]")?.attr("content")
        val type = if (url.contains("tvshows")) TvType.TvSeries else TvType.Movie
        val imdbid = document.selectFirst("div.imdbdatos a")?.attr("href")?.substringAfterLast("/")
        val actors=document.select("#dato-1 > div:nth-child(4)").map { it.select("a").text() }
        val recommendations=document.select("div.links a").amap {
            val recName = it.select("div.data-r > h4").text()
            val recHref = it.attr("href")
            val recPosterUrl = it.select("img").attr("src")
            newTvSeriesSearchResponse(recName,recHref, TvType.Movie) {
                this.posterUrl = recPosterUrl
            }
        }
        val year = document.select("#dato-1 > div:nth-child(5)").text().toIntOrNull()
            if (type == TvType.TvSeries) {
                val episodes = mutableListOf<Episode>()
                document.select("div.post #cssmenu > ul li > ul > li").map {
                    val seasonno = it.select("a > span.datex").text().substringBefore("-").trim()
                        .toIntOrNull()
                    val episodeno= it.select("a > span.datex").text().substringAfterLast("-").trim()
                        .toIntOrNull()
                    val epname=it.select("a > span.datix").text()
                    val ephref = it.selectFirst("a")?.attr("href")
                    episodes += newEpisode(ephref)
                    {
                        this.name = epname
                        this.season = seasonno
                        this.episode = episodeno
                    }
                }
                return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                    this.posterUrl = poster
                    this.plot = description
                    this.year=year
                    this.recommendations=recommendations
                    addActors(actors)
                    addImdbId(imdbid)
                }
            }
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl = poster
            this.plot = description
            this.year=year
            this.recommendations=recommendations
            addActors(actors)
            addImdbId(imdbid)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).documentLarge
        val iframeUrl = doc.selectFirst("#player-container iframe")?.absUrl("src")
        if (iframeUrl.isNullOrEmpty()) {
            Log.d("Error:", "Iframe not found")
            return false
        }

        val iframeDoc = app.get(iframeUrl).documentLarge
        val buttons = iframeDoc.select("div.btn-container a")
        if (buttons.isEmpty()) {
            Log.d("Error:", "No buttons found in iframe")
            return false
        }

        for (button in buttons) {
            val intermediateUrl = button.absUrl("href")

            val label = button.text().trim()
            try {
                val finalDoc = app.get(intermediateUrl).documentLarge
                val finalElement = finalDoc.selectFirst("div.container a, source")
                val finalUrl = when (finalElement?.tagName()) {
                    "a" -> finalElement.absUrl("href")
                    "source" -> finalElement.absUrl("src")
                    else -> null
                }

                if (finalUrl != null) {
                    if (finalUrl.isNotEmpty()) {
                        callback.invoke(
                            newExtractorLink(
                                "$name $label",
                                "$name $label",
                                finalUrl,
                                INFER_TYPE
                            )
                            {
                                this.referer=mainUrl
                            }
                        )
                    } else {
                        Log.d("Error:", "No final link found at $intermediateUrl")
                    }
                }
            } catch (e: Exception) {
                Log.e("Error:", "Error processing link: $intermediateUrl $e")
            }
        }
        return true
    }
}



================================================
FILE: Netcinez/src/main/kotlin/com/Netcinez/NetcinezProvider.kt
================================================
package com.Netcinez

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class NetcinezProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Netcinez())
    }
}


================================================
FILE: NOXXProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 3


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "HD TV Shows (Not all links are working because of a unsolvable issue)"
    language = "en"
    authors = listOf("LikDev-256,Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    iconUrl = "https://www.google.com/s2/favicons?domain=noxx.to&sz=%size%"
    tvTypes = listOf(
        "TvSeries"
    )

    isCrossPlatform = false
}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: NOXXProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: NOXXProvider/src/main/kotlin/com/Phisher98/NOXXProvider.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.extractors.DoodLaExtractor
import com.lagradost.cloudstream3.network.DdosGuardKiller
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8
import com.lagradost.nicehttp.NiceResponse
import okhttp3.FormBody
import org.jsoup.nodes.Element

class NOXXProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://noxx.to"
    override var name = "NOXX"
    override val hasMainPage = true
    override var lang = "en"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.TvSeries
    )
    private var ddosGuardKiller = DdosGuardKiller(true)

    private suspend fun queryTVApi(count: Int, query: String): NiceResponse {
        val body = FormBody.Builder()
            .addEncoded("no", "$count")
            .addEncoded("gpar", query)
            .addEncoded("qpar", "")
            .addEncoded("spar", "series_added_date desc")
            .build()

        return app.post(
            "$mainUrl/fetch.php",
            requestBody = body,
            interceptor = ddosGuardKiller,
            referer = "$mainUrl/"
        )
    }

    private suspend fun queryTVsearchApi(query: String): NiceResponse {
        return app.post(
            "$mainUrl/livesearch.php",
            data = mapOf(
                "searchVal" to query
            ),
            interceptor = ddosGuardKiller,
            referer = "$mainUrl/"
        )
    }

    private val scifiShows = "Sci-Fi"
    private val advenShows = "Adventure"
    private val actionShows = "Action"
    private val horrorShows = "Horror"
    private val DramaShows= "Drama"
    private val comedyShows = "Comedy"
    private val fantasyShows = "Fantasy"
    private val romanceShows = "Romance"

    override val mainPage = mainPageOf(
        //TV Shows
        scifiShows to scifiShows,
        advenShows to advenShows,
        actionShows to actionShows,
        comedyShows to comedyShows,
        fantasyShows to fantasyShows,
        DramaShows to DramaShows,
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val query = request.data.format(page)
        val TVlist = queryTVApi(
            page * 48,
            query
        ).documentLarge
        val home = TVlist.select("a.block").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(arrayListOf(HomePageList(request.name, home)), hasNext = true)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("div > div > span")?.text()?.toString()?.trim() ?: return null
        val href = fixUrl(this.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("data-src"))
        val quality = SearchQuality.HD
        val rating = this.select("div.flex.items-center > span").text()
        return newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
            this.posterUrl = posterUrl
            this.quality = quality
            this.score = Score.from10(rating)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val TVlist = queryTVsearchApi(
            query
        ).documentLarge
        return TVlist.select("a[href^=\"/tv\"]").mapNotNull {
            val title = it.selectFirst("div > h2")?.text().toString().trim()
            val href = fixUrl(mainUrl + it.attr("href").toString())
            val posterUrl = fixUrlNull(it.selectFirst("img")?.attr("src"))
            val quality = SearchQuality.HD

            newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get(url, interceptor = ddosGuardKiller).documentLarge
        val title = doc.selectFirst("h1.px-5")?.text()?.toString()?.trim() ?: return null
        val poster = fixUrlNull(doc.selectFirst("img.relative")?.attr("src"))
        val tags = doc.select("div.relative a[class*=\"py-0.5\"]").map { it.text().replace("\"","").replace("[","").replace("]","") }
        val description = doc.selectFirst("p.leading-tight")?.text()?.trim()
        val rating = doc.select("span.text-xl").text()
        val actors = doc.select("div.font-semibold span.text-blue-300").map { it.text() }
        val recommendations = doc.select("a.block").mapNotNull {
            it.toSearchResult()
        }

        val titRegex = Regex("\\d+")
        val episodes = ArrayList<Episode>()
        doc.select("section.container > div.border-b").forEach { me ->
            val seasonNum = me.select("button > span").text()
            me.select("div.season-list > a").forEach {
                episodes.add(
                    newEpisode(mainUrl + it.attr("href"))
                    {
                        this.name= it.ownText().removePrefix("Episode ").substring(2)
                        this.season=titRegex.find(seasonNum)?.value?.toInt()
                        this.episode=titRegex.find(it.select("span.flex").text().toString())?.value?.toInt()
                    }
                )
            }
        }
        return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
            this.posterUrl = poster
            this.plot = description
            this.tags = tags
            this.score = Score.from10(rating)
            addActors(actors)
            this.recommendations = recommendations
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links = app.get(data, interceptor = ddosGuardKiller).documentLarge.select("div.h-vw-65 iframe.w-full").attr("src").toString()
        val sourcelink= app.get(links, referer = mainUrl).documentLarge.selectFirst("iframe")?.attr("src")
        if (sourcelink != null) {
            val embedUrl = sourcelink.replace("/download/", "/e/")
            val response = app.get(embedUrl, headers = mapOf("Accept-Language" to "en-US,en;q=0.9"))
            val script = if (!getPacked(response.text).isNullOrEmpty()) {
                getAndUnpack(response.text)
            } else {
                response.documentLarge.selectFirst("script:containsData(sources:)")?.data()
            }
            val m3u8 =
                Regex("file:\\s*\"(.*?m3u8.*?)\"").find(script ?: "")?.groupValues?.getOrNull(1)
            generateM3u8(
                name,
                m3u8 ?: "",
                mainUrl
            ).forEach(callback)
        }
        return true
    }
}

class DoodPmExtractor : DoodLaExtractor() {
    override var mainUrl = "https://dood.pm"
}


================================================
FILE: NOXXProvider/src/main/kotlin/com/Phisher98/NOXXProviderPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class NOXXProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(NOXXProvider())
        registerExtractorAPI(DoodPmExtractor())
    }
}



================================================
FILE: OHLI24/build.gradle.kts
================================================
// use an integer for version numbers
version = 3

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Anime and movies with Korean subtitles only (no Korean audio)"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Movie",
    )

    requiresResources = true
    language = "ko"

    iconUrl = "https://ani.ohli24.com/img/logo@2x.png"

    isCrossPlatform = false
}


================================================
FILE: OHLI24/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: OHLI24/src/main/kotlin/com/ohli24/Extractor.kt
================================================
package com.ohli24

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.net.URI

class MichealCDN : Cdndania() {
    override val name = "MichealCDN"
    override val mainUrl = "https://michealcdn.com"
}

open class Cdndania : ExtractorApi() {
    override val name = "CDNdania"
    override val mainUrl = "https://cdndania.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val host= getBaseUrl(url)
        if (url.contains("/video/")) {
            val doc = app.get(url, referer = referer).document.selectFirst("script:containsData(playerjsSubtitle)")?.data().orEmpty()
            val srtRegex = Regex("""playerjsSubtitle\s*=\s*"[^"]*(https?://[^"]+\.srt)"""")
            val srtUrl = srtRegex.find(doc)?.groupValues?.get(1) ?: ""

            val extractedHash = url.substringAfterLast("/")
            val m3u8Url = "$host/player/index.php?data=$extractedHash&do=getVideo"
            val header= mapOf("x-requested-with" to "XMLHttpRequest")
            val formdata= mapOf("hash" to extractedHash,"r" to "$referer")
            val response = app.post(m3u8Url, headers=header, data = formdata).parsedSafe<Response>()
            response?.videoSource?.let { m3u8 ->
                callback(
                    newExtractorLink(
                        "CDN",
                        "CDN",
                        url = m3u8,
                        type = ExtractorLinkType.M3U8
                    ) {
                        this.referer = ""
                        this.quality = Qualities.P1080.value
                    }
                )

                subtitleCallback.invoke(
                    newSubtitleFile(
                        "Korean",
                        srtUrl
                    )
                )
            }
        }
    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let { "${it.scheme}://${it.host}" }
    }
}

data class Response(
    val hls: Boolean,
    val videoImage: String,
    val videoSource: String,
    val securedLink: String,
    val downloadLinks: List<Any?>,
    val attachmentLinks: List<Any?>,
    val ck: String,
)



================================================
FILE: OHLI24/src/main/kotlin/com/ohli24/OHLI24.kt
================================================
package com.ohli24

import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class OHLI24 : MainAPI() {
    override var mainUrl = "https://ani.ohli24.com"
    override var name = "OHLI24"
    override val hasMainPage = true
    override var lang = "ko"
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Anime,TvType.AnimeMovie)

    override val mainPage = mainPageOf(
        "bbs/board.php?bo_table=ing" to "방영중",
        "bbs/board.php?bo_table=fin" to "종영",
        "bbs/board.php?bo_table=theater" to "극장판"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.post("$mainUrl/${request.data}&page=$page", timeout = 100).document

        val home = document.select("div.list-row").mapNotNull {
                it.toSearchResult()
        }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }


    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("div.post-title")?.text() ?: return null
        val rawHref = this.select("div.list-desc a").attr("href")

        val href = fixUrl(
            if (rawHref.startsWith("./") || rawHref.startsWith("board.php")) {
                "$mainUrl/bbs/${rawHref.removePrefix("./")}"
            } else {
                rawHref
            }
        )

        val posterUrl = fixUrl(this.select("img").attr("src"))
        val score = this.select("div.rating").text()
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.score = Score.from10(score)
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        return app.get("$mainUrl/bbs/search.php?srows=24&gr_id=&sfl=wr_subject&stx=$query", timeout = 100).document
            .select("div.list-row").mapNotNull { it.toSearchResult() }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url, timeout = 100).document
        doc.setBaseUri(url)
        val title = doc.selectFirst("div.view-title h1")?.text() ?: "UnKnown"
        val poster = fixUrlNull(doc.selectFirst("div.image img")?.attr("src") ?: doc.selectFirst("meta[property=og:image]")?.attr("content"))
        val genres = doc.select("p:contains(장르)").first()?.select("span:nth-of-type(2)")?.text()?.split(",")?.map { it.trim() } ?: emptyList()
        val year = title.substringAfterLast("(").substringBefore(")").toIntOrNull()
        val descript = doc.select("div.view-stocon,div.view-cont").html().split("<br>").map { Jsoup.parse(it).text().trim() }.filter { it.isNotEmpty() }.joinToString("\n")

        val items = doc.select("li.list-item a")

        val hasEpisodeText = items.any {
            it.text().contains("episode", ignoreCase = true) ||
                    it.text().contains("회") ||
                    it.text().contains("화")
        }

        val type = when {
            items.size > 1 -> TvType.TvSeries
            hasEpisodeText -> TvType.TvSeries
            else -> TvType.Movie
        }

        val href= fixUrl(doc.selectFirst("li.list-item a")?.absUrl("href").orEmpty())


        if (type == TvType.TvSeries)
        {
            val episodes= doc.select("li.list-item").map {
                val epno = it.select("div.wr-num").text().toIntOrNull()
                val href = it.selectFirst("a")?.absUrl("href").orEmpty()

                newEpisode(href)
                {
                    this.name = "Episode $epno"
                    this.episode = epno
                }

            }
            return newAnimeLoadResponse(title, url, TvType.Anime)
            {
                addEpisodes(DubStatus.Subbed, episodes.reversed())
                this.year = year
                this.tags = genres
                this.posterUrl = poster
                this.plot = descript
            }
        }
        else
        {
            return newMovieLoadResponse(title, url, TvType.AnimeMovie, href)
            {
                this.year = year
                this.tags = genres
                this.posterUrl = poster
                this.plot = descript
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data, timeout = 20).document
        val iframeSrc = doc.selectFirst("iframe")?.attr("src")
        val vurl = doc.selectFirst("form.tt input[name=vurl]")?.attr("value")
        val iframe = iframeSrc ?: vurl.orEmpty()
        if (iframe.contains("/video/"))
        {
            Cdndania().getUrl(iframe,mainUrl,subtitleCallback,callback)
        }
        else loadExtractor(iframe,mainUrl,subtitleCallback,callback)
        return true
    }

}


================================================
FILE: OHLI24/src/main/kotlin/com/ohli24/OHLI24Plugin.kt
================================================
package com.ohli24

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class OHLI24Plugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(OHLI24())
        registerExtractorAPI(Cdndania())
        registerExtractorAPI(MichealCDN())
    }
}


================================================
FILE: OnePace/build.gradle.kts
================================================
version = 16


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    description = "One Pace"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Anime"
    )
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/onepace.png"

    isCrossPlatform = true
}



================================================
FILE: OnePace/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: OnePace/src/main/kotlin/com/Phisher98/AnimedekhoOnePace.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import org.jsoup.nodes.Element

class OnepaceProvider : MainAPI() {
    override var mainUrl = "https://onepace.co"
    override var name = "OnePace AD"
    override val hasMainPage = true
    override var lang = "en"

    override val supportedTypes =
        setOf(
            TvType.Anime,
        )

    override val mainPage =
        mainPageOf(
            "/series/one-pace-english-sub/" to "One Pace English Sub",
            "/series/one-pace-english-dub/" to "One Pace English Dub",
        )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest,
    ): HomePageResponse {
        val link = "$mainUrl${request.data}"
        val document = app.get(link).documentLarge
        val home =
            document.select("div.seasons.aa-crd > div.seasons-bx").map {
                it.toSearchResult()
            }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): AnimeSearchResponse {
        val hreftitle= this.selectFirst("img")?.attr("alt")
        var href=""
        if (hreftitle!!.isNotEmpty()) {
            href = if (hreftitle.contains("Dub")) {
                "$mainUrl/series/one-pace-english-dub"
            } else {
                "$mainUrl/series/one-pace-english-sub"
            }
        }
        val title = this.selectFirst("p")?.text() ?:""
        val posterUrl = this.selectFirst("img")?.getsrcAttribute()
        val dubtype:Boolean
        val subtype:Boolean
        if (hreftitle.contains("Dub"))
        {
            dubtype = true
            subtype =false
        }
        else
        {
            dubtype = false
            subtype = true

        }
        return newAnimeSearchResponse(title, Media(href, posterUrl,title).toJson(), TvType.Anime, false) {
            this.posterUrl = posterUrl
            addDubStatus(dubExist = dubtype, subExist = subtype)
        }
    }

    override suspend fun search(query: String): List<AnimeSearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        val links = document.select("main > section > ul li article > a")
            .mapNotNull { it.attr("href") }

        return links.flatMap { link ->
            val pageDocument = app.get(link).documentLarge
            val seasonElements = pageDocument.select("div.seasons.aa-crd > div.seasons-bx")
            seasonElements.mapNotNull { it.toSearchResult() }
        }
    }




    override suspend fun load(url: String): LoadResponse {
        val media = parseJson<Media>(url)
        val document = app.get(media.url).documentLarge
        val arcINT = media.mediaType?.substringAfter("Arc ")?.replace("'", "\\'") ?: ""
        val element = document.selectFirst("div.seasons.aa-crd > div.seasons-bx:contains($arcINT)")

        val title = media.mediaType ?:"No Title"
        val poster = "https://images3.alphacoders.com/134/1342304.jpeg"
        val plot = document.selectFirst("div.entry-content p")?.text()?.trim()
            ?: document.selectFirst("meta[name=twitter:description]")?.attr("content")
        val year = (document.selectFirst("span.year")?.text()?.trim()
            ?: document.selectFirst("meta[property=og:updated_time]")?.attr("content")
                ?.substringBefore("-"))?.toIntOrNull()
        val lst = element?.select("ul.seasons-lst.anm-a li")
        return if (lst?.isEmpty() != false) {
            newMovieLoadResponse(title, url, TvType.Movie, Media(
                media.url,
                mediaType = "1"
            ).toJson()) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
            }
        } else {
                val episodes = element.select("ul.seasons-lst.anm-a li").mapNotNull {
                val name = it.selectFirst("h3.title")?.ownText() ?: "null"
                val href = it.selectFirst("a")?.attr("href") ?: return@mapNotNull null
                val poster= "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/OnePack.png"
                val seasonnumber = it.selectFirst("h3.title > span")?.text().toString().substringAfter("S").substringBefore("-")
                val season=seasonnumber.toIntOrNull()
                newEpisode(Media(href, mediaType = 2.toString()).toJson())
                {
                    this.name=name
                    this.posterUrl=poster
                    this.season=season
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = plot
                this.year = year
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val media = parseJson<Media>(data)
        val body = app.get(media.url).documentLarge.selectFirst("body")?.attr("class") ?: return false
        val term = Regex("""(?:term|postid)-(\d+)""").find(body)?.groupValues?.get(1) ?: throw ErrorLoadingException("no id found")
        for (i in 0..7) {
            val link = app.get("$mainUrl/?trdekho=$i&trid=$term&trtype=${media.mediaType}")
                .documentLarge.selectFirst("iframe")?.attr("src")
                ?: throw ErrorLoadingException("no iframe found")
            loadExtractor(link,subtitleCallback, callback)
        }
        return true
    }

    data class Media(val url: String, val poster: String? = null, val mediaType: String? = null)

    private fun Element.getsrcAttribute(): String {
        val src = this.attr("src")
        val dataSrc = this.attr("data-src")
        val lazysrc=this.attr("data-lazy-src")
        return when {
            src.startsWith("http") -> src
            dataSrc.startsWith("http") -> dataSrc
            lazysrc.startsWith("http") -> lazysrc
            else -> ""
        }
    }

}



================================================
FILE: OnePace/src/main/kotlin/com/Phisher98/Extractor.kt
================================================
package com.phisher98

import com.google.gson.JsonObject
import com.google.gson.JsonParser
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.extractors.Vidmoly
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.nodes.Document
import java.net.URI

open class Streamruby : ExtractorApi() {
    override var name = "Streamruby"
    override var mainUrl = "streamruby.com"
    override val requiresReferer = false
    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        if (url.contains("/e/"))
        {
            val newurl=url.replace("/e","")
            val txt = app.get(newurl).text
            val m3u8 = Regex("file:\\s*\"(.*?m3u8.*?)\"").find(txt)?.groupValues?.getOrNull(1).toString()
            return listOf(
                newExtractorLink(
                    this.name,
                    this.name,
                    url = m3u8,
                    INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
        }
        else
        {
            val txt = app.get(url).text
            val m3u8 = Regex("file:\\s*\"(.*?m3u8.*?)\"").find(txt)?.groupValues?.getOrNull(1).toString()
            return listOf(
                newExtractorLink(
                    this.name,
                    this.name,
                    url = m3u8,
                    INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }
}


class Vidmolynet : Vidmoly() {
    override val mainUrl = "https://vidmoly.net"
}

class Animedekhoco : ExtractorApi() {
    override val name = "Animedekhoco"
    override val mainUrl = "https://animedekho.co"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc: Document? = if (url.contains("url=")) app.get(url).documentLarge else null
        val text: String? = if (!url.contains("url=")) app.get(url).text else null

        val links = mutableListOf<Pair<String, String>>()

        doc?.select("select#serverSelector option")?.forEach { option ->
            val link = option.attr("value")
            val name = option.text().ifBlank { "Unknown" }
            if (link.isNotBlank()) links.add(name to link)
        }

        text?.let {
            val regex = Regex("""file\s*:\s*"([^"]+)"""")
            regex.find(it)?.groupValues?.get(1)?.let { link ->
                links.add("Player File" to link)
            }
        }

        links.forEach { (serverName, serverUrl) ->
            callback.invoke(
                newExtractorLink(
                    serverName,
                    serverName,
                    url = serverUrl,
                    INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }
}


class Cdnwish : StreamWishExtractor() {
    override var name = "Streamwish"
    override var mainUrl = "https://cdnwish.com"
}

class vidcloudupns : VidStack() {
    override var mainUrl = "https://vidcloud.upns.ink"
}

class Dhcplay: VidHidePro() {
    override var name = "DHC Play"
    override var mainUrl = "https://dhcplay.com"
    override var requiresReferer = true
}

class GDMirrorbot : ExtractorApi() {
    override var name = "GDMirrorbot"
    override var mainUrl = "https://gdmirrorbot.nl"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val host = getBaseUrl(app.get(url).url)
        val embedId = url.substringAfterLast("/")
        val postData = mapOf("sid" to embedId)

        val responseJson = app.post("$host/embedhelper.php", data = postData).text
        val jsonElement = JsonParser.parseString(responseJson)
        if (!jsonElement.isJsonObject) return

        val root = jsonElement.asJsonObject
        val siteUrls = root["siteUrls"]?.asJsonObject ?: return
        val siteFriendlyNames = root["siteFriendlyNames"]?.asJsonObject

        val decodedMresult: JsonObject = when {
            root["mresult"]?.isJsonObject == true -> {
                root["mresult"]?.asJsonObject!!
            }
            root["mresult"]?.isJsonPrimitive == true -> {
                val mresultBase64 = root["mresult"]?.asString ?: return
                try {
                    val jsonStr = base64Decode(mresultBase64)
                    JsonParser.parseString(jsonStr).asJsonObject
                } catch (e: Exception) {
                    Log.e("Error:", "Failed to decode mresult base64: $e")
                    return
                }
            }
            else -> return
        }

        val commonKeys = siteUrls.keySet().intersect(decodedMresult.keySet())

        for (key in commonKeys) {
            val base = siteUrls[key]?.asString?.trimEnd('/') ?: continue
            val path = decodedMresult[key]?.asString?.trimStart('/') ?: continue
            val fullUrl = "$base/$path"

            val friendlyName = siteFriendlyNames?.get(key)?.asString ?: key

            try {
                when (friendlyName) {
                    "EarnVids" -> {
                        VidhideExtractor().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    "StreamHG" -> {
                        VidHidePro().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    "RpmShare", "UpnShare", "StreamP2p" -> {
                        VidStack().getUrl(fullUrl, referer, subtitleCallback, callback)
                    }
                    else -> {
                        loadExtractor(fullUrl, referer ?: mainUrl, subtitleCallback, callback)
                    }
                }
            } catch (e: Exception) {
                Log.e("Error:", "Failed to extract from $friendlyName at $fullUrl")
                continue
            }
        }

    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let { "${it.scheme}://${it.host}" }
    }
}


================================================
FILE: OnePace/src/main/kotlin/com/Phisher98/OnePacePlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class OnePacePlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(OnepaceProvider())
        registerExtractorAPI(Streamruby())
        registerExtractorAPI(Vidmolynet())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(Cdnwish())
        registerExtractorAPI(Dhcplay())
        registerExtractorAPI(vidcloudupns())
        registerExtractorAPI(Animedekhoco())
    }
}



================================================
FILE: OneTouchTV/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

     description = "Asian Dramas"
     authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=onetouchtv.xyz/&sz=%size%"

    isCrossPlatform = true
}


================================================
FILE: OneTouchTV/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: OneTouchTV/src/main/kotlin/com/OneTouchTV/Decryption.kt
================================================
package com.OneTouchTV

import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64DecodeArray
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import org.json.JSONObject

private val keyHex = base64Decode("Njk2ZDM3MzI2MzY4NjE3MjUwNjE3MzczNzc2ZjcyNjQ2ZjY2NjQ0OTZlNjk3NDU2NjU2Mzc0NmY3MjUzNzQ2ZA==")
private val ivHex  = base64Decode("Njk2ZDM3MzI2MzY4NjE3MjUwNjE3MzczNzc2ZjcyNjQ=")
private val key = keyHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
private val iv  = ivHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()

fun normalizeCustomAlphabet(s: String): String {
    return s.replace("-_.", "/")
        .replace("@", "+")
        .replace("\\s+".toRegex(), "")
}

fun base64ToBytes(b64: String): ByteArray {
    var base64Str = b64
    val pad = base64Str.length % 4
    if (pad != 0) base64Str += "=".repeat(4 - pad)
    return base64DecodeArray(base64Str)
}

fun decryptAes256Cbc(cipherBytes: ByteArray, key: ByteArray, iv: ByteArray): ByteArray {
    if (cipherBytes.size % 16 != 0) {
        throw IllegalArgumentException("Ciphertext length (${cipherBytes.size}) not multiple of 16.")
    }
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    val secretKey = SecretKeySpec(key, "AES")
    val ivSpec = IvParameterSpec(iv)
    cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
    return cipher.doFinal(cipherBytes)
}

fun decryptString(input: String): String {
    val normalized = normalizeCustomAlphabet(input)
    val cipherBytes = base64ToBytes(normalized)
    val plaintextBytes = decryptAes256Cbc(cipherBytes, key, iv)
    val text = String(plaintextBytes, Charsets.UTF_8)
    return JSONObject(text).getString("result")
}


================================================
FILE: OneTouchTV/src/main/kotlin/com/OneTouchTV/OneTouchTV.kt
================================================
package com.OneTouchTV

import com.google.gson.Gson
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.newTvSeriesSearchResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import org.json.JSONObject

class OneTouchTV : MainAPI() {
    override var mainUrl = base64Decode("aHR0cHM6Ly9hcGkzLmRldmNvcnAubWU=")
    override var name = "OneTouchTV"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.AsianDrama,
        TvType.Anime
    )

    override val mainPage = mainPageOf(
        "vod/home" to "Home",
    )

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val url = "$mainUrl/vod/search?page=$page&keyword=$query"
        val responseText = try {
            app.get(url, referer = "$mainUrl/").text
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch search data: ${e.message}")
        }

        val decryptedJson = try {
            decryptString(responseText)
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to decrypt response: ${e.message}")
        }

        val gson = Gson()
        val results: List<SearchResult> = try {
            if (decryptedJson.trim().startsWith("[")) {
                gson.fromJson(decryptedJson, Array<SearchResult>::class.java).toList()
            } else {
                val parsed = gson.fromJson(decryptedJson, Search::class.java)
                parsed.result
            }
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to parse decrypted JSON: ${e.message}")
        }

        if (results.isEmpty()) {
            throw ErrorLoadingException("No search results found")
        }

        return results.map { result ->
            newTvSeriesSearchResponse(
                result.title,
                "$mainUrl/vod/${result.id}/detail",
                if (result.type.equals("movie", true)) TvType.Movie else TvType.TvSeries
            ) {
                posterUrl = result.image
            }
        }.toNewSearchResponseList()
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val rawResponse = try {
            app.get("$mainUrl/${request.data}").text
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch raw response: ${e.message}")
        }

        val decryptedJson = try {
            decryptString(rawResponse)
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to decrypt response: ${e.message}")
        }

        val parser = try {
            Gson().fromJson(decryptedJson, MediaResult::class.java)
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to parse decrypted JSON: ${e.message}")
        }

        val allRawMedia = buildList {
            addAll(parser.randomSlideShow?.map { it.toCleanMedia() } ?: emptyList())
            addAll(parser.recents?.map { it.toCleanMedia() } ?: emptyList())
        }

        val uniqueMedia = allRawMedia.distinctBy { it.id ?: it.title }

        val filteredMedia = uniqueMedia.filter { media ->
            settingsForProvider.enableAdult || !(media.type?.contains("RAW", ignoreCase = true) ?: false)
        }

        val groupedByCountry = filteredMedia.groupBy { it.country?.trim()?.lowercase() ?: "unknown" }

        val homeLists = groupedByCountry.mapNotNull { (country, items) ->
            if (items.size > 4) {
                HomePageList(
                    name = country.replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() },
                    list = items.map { it.toSearchResponse(mainUrl) },
                    isHorizontalImages = false
                )
            } else null
        }

        return newHomePageResponse(list = homeLists, hasNext = false)
    }

    private fun OneTouchTVParser.Day.toMedia() = OneTouchMedia(
        title = title ?: "Unknown Title",
        id = id ?: "0",
        image = image,
        type = type,
        country = country,
        year = year,
        status = status,
        isSub = isSub
    )

    private fun OneTouchTVParser.Week.toMedia() = OneTouchMedia(
        title = title ?: "Unknown Title",
        id = id ?: "0",
        image = image,
        type = type,
        country = country,
        year = year,
        status = status,
        isSub = isSub
    )

    private fun OneTouchTVParser.Month.toMedia() = OneTouchMedia(
        title = title ?: "Unknown Title",
        id = id ?: "0",
        image = image,
        type = type,
        country = country,
        year = year,
        status = status,
        isSub = isSub
    )

    private fun OneTouchMedia.toSearchResponse(): SearchResponse {
        return newTvSeriesSearchResponse(title, "$mainUrl/vod/${id}/detail", TvType.Movie) {
            this.posterUrl = image
        }
    }

    data class OneTouchMedia(
        val title: String = "Unknown Title",
        val id: String? = "0",
        val image: String? = null,
        val type: String? = null,
        val country: String? = null,
        val year: String? = null,
        val status: String? = null,
        val isSub: Boolean = false
    )

    private fun RandomSlideShow.toCleanMedia() = CleanMedia(
        id = id2 ?: id,
        title = title,
        image = image,
        country = country,
        type = type,
        year = year,
        status = status,
        isSub = isSub ?: false
    )

    private fun Recent.toCleanMedia() = CleanMedia(
        id = id2 ?: id,
        title = title,
        image = image,
        country = country,
        type = type,
        year = year,
        status = status,
        isSub = isSub ?: false
    )

    private fun CleanMedia.toSearchResponse(mainUrl: String): SearchResponse {
        return newTvSeriesSearchResponse(
            title ?: "Unknown Title",
            "$mainUrl/vod/${id ?: ""}/detail",
            TvType.Movie
        ) {
            this.posterUrl = image
        }
    }


    override suspend fun load(url: String): LoadResponse {
        val rawResponse = try {
            app.get(url).text
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch raw response: ${e.message}")
        }

        val decryptedJson = try {
            val raw = decryptString(rawResponse)
            raw
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to decrypt response: ${e.message}")
        }

        val obj = JSONObject(decryptedJson)
        val title = obj.optString("title", "Unknown Title")
        val poster = obj.optString("image", "null")
        val backgroundposter = obj.optString("poster", "")
            .replace("image-7wk.pages.dev","image-v1.pages.dev")
            .takeIf { it.isNotBlank() && it != "null" }
            ?: obj.optString("image", "")
        val description = obj.optString("description", "")
        val year = obj.optString("year", "").toIntOrNull()
        val status = getStatus(obj.optString("status", ""))

        val actorsJsonArray = obj.optJSONArray("actors")
        val actors = mutableListOf<ActorData>()

        if (actorsJsonArray != null) {
            for (i in 0 until actorsJsonArray.length()) {
                val actorObj = actorsJsonArray.getJSONObject(i)
                val actorName = actorObj.optString("name", "")
                val actorImage = actorObj.optString("image", "")

                actors.add(
                    ActorData(
                        Actor(
                            actorName,
                            actorImage,
                        )
                    )
                )
            }
        }

        val tags = mutableListOf<String>()
        val tagsJson = obj.optJSONArray("genres")
        if (tagsJson != null) {
            for (i in 0 until tagsJson.length()) {
                tags.add(tagsJson.optString(i).capitalize())
            }
        }

        val episodes = mutableListOf<Episode>()
        val episodesJson = obj.optJSONArray("episodes")

        if (episodesJson != null) {
            for (i in 0 until episodesJson.length()) {
                val ep = episodesJson.getJSONObject(i)
                val epStr = ep.optString("episode", "?")
                val identifier = ep.optString("identifier", "")
                val playId = ep.optString("playId", "")
                episodes.add(
                    newEpisode("$mainUrl/vod/$identifier/episode/$playId") {
                        name = "Episode $epStr"
                    }
                )
            }
        }

        val recommendation: List<SearchResponse> = try {
            val rawResponse = app.get("$mainUrl/vod/top").text

            val decryptedJson = try {
                decryptString(rawResponse)
            } catch (e: Exception) {
                throw ErrorLoadingException("Failed to decrypt response: ${e.message}")
            }

            val gson = Gson()
            val parser = try {
                gson.fromJson(decryptedJson, OneTouchTVParser::class.java)
            } catch (e: Exception) {
                throw ErrorLoadingException("Failed to parse decrypted JSON: ${e.message}")
            }

            val allMedia = buildList {
                parser.day?.forEach { add(it.toMedia()) }
                parser.week?.forEach { add(it.toMedia()) }
                parser.month?.forEach { add(it.toMedia()) }
            }

            allMedia.map { it.toSearchResponse() }

        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to load recommendations: ${e.message}")
        }



        return newTvSeriesLoadResponse(title,url, type = TvType.TvSeries, episodes = episodes.reversed()) {
            this.backgroundPosterUrl = backgroundposter
            this.posterUrl = poster
            this.plot = description
            this.tags = tags
            this.showStatus = status
            this.year = year
            this.actors = actors
            this.recommendations =recommendation
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean = coroutineScope {
        val rawResponse = try {
            app.get(data).text
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to fetch raw response: ${e.message}")
        }
        val decryptedJson = try {
            decryptString(rawResponse)
        } catch (e: Exception) {
            throw ErrorLoadingException("Failed to decrypt response: ${e.message}")
        }

        val (sources, tracks) = parseSourcesAndTracks(decryptedJson)

        launch {
            for (track in tracks) {
                subtitleCallback(
                    newSubtitleFile(
                        track.name ?: "Unknown",
                        track.file ?: continue)
                )
            }
        }

        launch {
            for (src in sources) {
                callback(
                    newExtractorLink(
                        src.name?.capitalize() ?: "Source",
                        src.name?.capitalize() ?: "Source",
                        src.url ?: continue,
                        INFER_TYPE
                    )
                    {
                        this.quality = getQualityFromName(src.quality ?: "")
                        this.headers = src.headers
                    }
                )
            }
        }
        true
    }

    private fun getStatus(t: String): ShowStatus {
        return when (t) {
            "Finished Airing" -> ShowStatus.Completed
            "ongoing" -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }
}



================================================
FILE: OneTouchTV/src/main/kotlin/com/OneTouchTV/OneTouchTVParser.kt
================================================
package com.OneTouchTV

import com.fasterxml.jackson.annotation.JsonProperty
import org.json.JSONArray
import org.json.JSONObject

data class OneTouchTVParser(
    val day: List<Day>? = emptyList(),
    val week: List<Week>? = emptyList(),
    val month: List<Month>? = emptyList()
) {
    data class Day(
        val _id: String? = null,
        val id: String? = null,
        val title: String? = null,
        val image: String? = null,
        val country: String? = null,
        val type: String? = null,
        val year: String? = null,
        val popularity: Int = 0,
        val status: String? = null,
        val releaseDate: String? = null,
        val isSub: Boolean = false
    )

    data class Week(
        val _id: String? = null,
        val id: String? = null,
        val title: String? = null,
        val image: String? = null,
        val country: String? = null,
        val type: String? = null,
        val year: String? = null,
        val popularity: Int = 0,
        val status: String? = null,
        val releaseDate: String? = null,
        val isSub: Boolean = false
    )

    data class Month(
        val _id: String? = null,
        val id: String? = null,
        val title: String? = null,
        val image: String? = null,
        val country: String? = null,
        val type: String? = null,
        val year: String? = null,
        val popularity: Int = 0,
        val status: String? = null,
        val releaseDate: String? = null,
        val isSub: Boolean = false
    )
}

data class SourceItem(
    val type: String?,
    val contentId: String?,
    val id: String?,
    val name: String?,
    val quality: String?,
    val url: String?,
    val headers: Map<String, String>
)

data class TrackItem(
    val file: String?,
    val name: String?,
    val isDefault: Boolean,
    val kind: String?,
    val format: String?
)

fun parseSourcesAndTracks(
    decryptedJson: String,
    subtitleCallback: (TrackItem) -> Unit = {},
    extractorCallback: (SourceItem) -> Unit = {}
): Pair<List<SourceItem>, List<TrackItem>> {
    val sourcesList = mutableListOf<SourceItem>()
    val tracksList = mutableListOf<TrackItem>()
    val root = JSONObject(decryptedJson)
    val result = if (root.has("result")) root.optJSONObject("result") else root
    val sourcesArray: JSONArray? = result?.optJSONArray("sources")
    if (sourcesArray != null) {
        for (i in 0 until sourcesArray.length()) {
            val s = sourcesArray.optJSONObject(i) ?: continue
            val headersMap = mutableMapOf<String, String>()
            val headersObj = s.optJSONObject("headers")
            if (headersObj != null) {
                val keys = headersObj.keys()
                while (keys.hasNext()) {
                    val k = keys.next()
                    val v = headersObj.optString(k, "")
                    headersMap[k] = v
                }
            }
            val sourceItem = SourceItem(
                type = s.optString("type", ""),
                contentId = s.optString("contentId", ""),
                id = s.optString("id", ""),
                name = s.optString("name", ""),
                quality = s.optString("quality", ""),
                url = s.optString("url", ""),
                headers = headersMap
            )
            sourcesList.add(sourceItem)
            extractorCallback(sourceItem)
        }
    }
    val tracksArray: JSONArray? = result?.optJSONArray("track") ?: result?.optJSONArray("tracks")
    if (tracksArray != null) {
        for (i in 0 until tracksArray.length()) {
            val t = tracksArray.optJSONObject(i) ?: continue
            val trackItem = TrackItem(
                file = t.optString("file", ""),
                name = t.optString("name", ""),
                isDefault = t.optBoolean("default", false),
                kind = t.optString("kind", ""),
                format = t.optString("format", "")
            )
            tracksList.add(trackItem)
            subtitleCallback(trackItem)
        }
    }
    return Pair(sourcesList, tracksList)
}


data class Search(
    val status: Long,
    val result: List<SearchResult>,
)

data class SearchResult(
    val id: String,
    val loklokContentId: String,
    val isSub: Boolean,
    val title: String,
    val image: String,
    val type: String,
    val year: String,
    val source: String,
    val status: String,
    val loklokCategory: Long,
    val episodes: List<Any?>,
    val description: String,
    val genres: List<String>,
    val otherTitles: List<String>,
)

data class MediaResult(
    val randomSlideShow: List<RandomSlideShow>?,
    val recents: List<Recent>?,
    val result: ResultWrapper?
)

data class ResultWrapper(
    val randomSlideShow: List<RandomSlideShow>?,
    val recents: List<Recent>?
)

data class RandomSlideShow(
    @JsonProperty("_id") val id: String?,
    @JsonProperty("id") val id2: String?,
    val title: String?,
    val image: String?,
    val country: String?,
    val type: String?,
    val year: String?,
    val popularity: Long?,
    val description: String?,
    val status: String?,
    val releaseDate: String?,
    val isSub: Boolean?
)

data class Recent(
    @JsonProperty("_id") val id: String?,
    @JsonProperty("id") val id2: String?,
    val title: String?,
    val image: String?,
    val country: String?,
    val type: String?,
    val year: String?,
    val popularity: Long?,
    val description: String?,
    val status: String?,
    val releaseDate: String?,
    val isSub: Boolean?
)

data class CleanMedia(
    val id: String?,
    val title: String?,
    val image: String?,
    val country: String?,
    val type: String?,
    val year: String?,
    val status: String?,
    val isSub: Boolean?
)


================================================
FILE: OneTouchTV/src/main/kotlin/com/OneTouchTV/OneTouchTVPlugin.kt
================================================
package com.OneTouchTV

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class OneTouchTVPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(OneTouchTV())
    }
}


================================================
FILE: Pelisplushd/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "(Mexican) Movies/Series/Anime Extension"
    language    = "mx"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://www.google.com/s2/favicons?domain=pelisplushd.bz&sz=%size%"

    isCrossPlatform = false
}



================================================
FILE: Pelisplushd/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Pelisplushd/src/main/kotlin/com/pelisplushd/Extractor.kt
================================================
package com.pelisplushd

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.extractors.FilemoonV2
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


class FileMoonlink : FilemoonV2() {
    override var mainUrl = "https://filemoon.link"
    override var name = "FileMoon"
}

class Mivalyo : VidHidePro() {
    override var name = "VidHide"
    override var mainUrl = "https://mivalyo.com"
}


class StreamwishHG : StreamWishExtractor() {
    override val mainUrl = "https://hglink.to"
}


fun getLanguage(language: String?): String? {
    language ?: return null
    val normalizedLang = language.substringBefore("-")
    return languageMap.entries.find { it.value.first == normalizedLang || it.value.second == normalizedLang }?.key
}

private val languageMap = mapOf(
    "Afrikaans" to Pair("af", "afr"),
    "Albanian" to Pair("sq", "sqi"),
    "Amharic" to Pair("am", "amh"),
    "Arabic" to Pair("ar", "ara"),
    "Armenian" to Pair("hy", "hye"),
    "Azerbaijani" to Pair("az", "aze"),
    "Basque" to Pair("eu", "eus"),
    "Belarusian" to Pair("be", "bel"),
    "Bengali" to Pair("bn", "ben"),
    "Bosnian" to Pair("bs", "bos"),
    "Bulgarian" to Pair("bg", "bul"),
    "Catalan" to Pair("ca", "cat"),
    "Chinese" to Pair("zh", "zho"),
    "Croatian" to Pair("hr", "hrv"),
    "Czech" to Pair("cs", "ces"),
    "Danish" to Pair("da", "dan"),
    "Dutch" to Pair("nl", "nld"),
    "English" to Pair("en", "eng"),
    "Estonian" to Pair("et", "est"),
    "Filipino" to Pair("tl", "tgl"),
    "Finnish" to Pair("fi", "fin"),
    "French" to Pair("fr", "fra"),
    "Galician" to Pair("gl", "glg"),
    "Georgian" to Pair("ka", "kat"),
    "German" to Pair("de", "deu"),
    "Greek" to Pair("el", "ell"),
    "Gujarati" to Pair("gu", "guj"),
    "Hebrew" to Pair("he", "heb"),
    "Hindi" to Pair("hi", "hin"),
    "Hungarian" to Pair("hu", "hun"),
    "Icelandic" to Pair("is", "isl"),
    "Indonesian" to Pair("id", "ind"),
    "Italian" to Pair("it", "ita"),
    "Japanese" to Pair("ja", "jpn"),
    "Kannada" to Pair("kn", "kan"),
    "Kazakh" to Pair("kk", "kaz"),
    "Korean" to Pair("ko", "kor"),
    "Latvian" to Pair("lv", "lav"),
    "Lithuanian" to Pair("lt", "lit"),
    "Macedonian" to Pair("mk", "mkd"),
    "Malay" to Pair("ms", "msa"),
    "Malayalam" to Pair("ml", "mal"),
    "Maltese" to Pair("mt", "mlt"),
    "Marathi" to Pair("mr", "mar"),
    "Mongolian" to Pair("mn", "mon"),
    "Nepali" to Pair("ne", "nep"),
    "Norwegian" to Pair("no", "nor"),
    "Persian" to Pair("fa", "fas"),
    "Polish" to Pair("pl", "pol"),
    "Portuguese" to Pair("pt", "por"),
    "Punjabi" to Pair("pa", "pan"),
    "Romanian" to Pair("ro", "ron"),
    "Russian" to Pair("ru", "rus"),
    "Serbian" to Pair("sr", "srp"),
    "Sinhala" to Pair("si", "sin"),
    "Slovak" to Pair("sk", "slk"),
    "Slovenian" to Pair("sl", "slv"),
    "Spanish" to Pair("es", "spa"),
    "Swahili" to Pair("sw", "swa"),
    "Swedish" to Pair("sv", "swe"),
    "Tamil" to Pair("ta", "tam"),
    "Telugu" to Pair("te", "tel"),
    "Thai" to Pair("th", "tha"),
    "Turkish" to Pair("tr", "tur"),
    "Ukrainian" to Pair("uk", "ukr"),
    "Urdu" to Pair("ur", "urd"),
    "Uzbek" to Pair("uz", "uzb"),
    "Vietnamese" to Pair("vi", "vie"),
    "Welsh" to Pair("cy", "cym"),
    "Yiddish" to Pair("yi", "yid")
)

fun decryptLink(encryptedB64: String): String {
    val secretKey="Ak7qrvvH4WKYxV2OgaeHAEg2a5eh16vE"
    val encryptedData = base64DecodeArray(encryptedB64)
    val iv = encryptedData.copyOfRange(0, 16)
    val ciphertext = encryptedData.copyOfRange(16, encryptedData.size)
    val keyBytes = secretKey.toByteArray(Charsets.UTF_8)
    val secretKeySpec = SecretKeySpec(keyBytes, "AES")
    val ivSpec = IvParameterSpec(iv)
    val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
    cipher.init(Cipher.DECRYPT_MODE, secretKeySpec, ivSpec)
    val decrypted = cipher.doFinal(ciphertext)
    return String(decrypted, Charsets.UTF_8)
}

suspend fun loadCustomExtractor(
    name: String? = null,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
    quality: Int? = null,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    name ?: link.source,
                    name ?: link.name,
                    link.url,
                ) {
                    this.quality = when {
                        link.name == "VidSrc" -> Qualities.P1080.value
                        link.type == ExtractorLinkType.M3U8 -> link.quality
                        else -> quality ?: link.quality
                    }
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


suspend fun loadSourceNameExtractor(
    source: String,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    "$source [${link.source}]",
                    "$source [${link.source}]",
                    link.url,
                ) {
                    this.quality = link.quality
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


================================================
FILE: Pelisplushd/src/main/kotlin/com/pelisplushd/Pelisplushd.kt
================================================
package com.pelisplushd

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray

class Pelisplushd() : TmdbProvider() {
    override var name = "Pelisplushd"
    override var mainUrl = "https://embed69.org" //https://pelisplushd.bz/
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama)
    override var lang = "mx"
    override val hasMainPage = true
    override val hasQuickSearch = false

    companion object {
        private const val tmdbAPI = "https://api.themoviedb.org/3"
        private const val apiKey = "1865f43a0549ca50d341dd9ab8b29f49"

        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage = mainPageOf(
        "$tmdbAPI/trending/all/day?api_key=$apiKey&region=US" to "Trending",
        "$tmdbAPI/trending/movie/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular Movies",
        "$tmdbAPI/trending/tv/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows",
        "$tmdbAPI/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=49" to "HBO",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=3353" to "Peacock",
        "$tmdbAPI/discover/movie?api_key=$apiKey&language=en-US&page=1&sort_by=popularity.desc&with_origin_country=IN&release_date.gte=${getDate().lastWeekStart}&release_date.lte=${getDate().today}" to "Trending Indian Movies",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().today}&air_date.gte=${getDate().today}" to "Airing Today Anime",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().nextWeek}&air_date.gte=${getDate().today}" to "On The Air Anime",
        "$tmdbAPI/discover/movie?api_key=$apiKey&with_keywords=210024|222243" to "Anime Movies",
        "$tmdbAPI/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies",
        "$tmdbAPI/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_original_language=ko" to "Korean Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_genres=99" to "Documentary",
    )

    private fun getImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val adultQuery =
            if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669|190370"
        val type = if (request.data.contains("/movie")) "movie" else "tv"
        val home = app.get("${request.data}$adultQuery&language=es-ES&page=$page")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse(type)
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath)
            this.score= Score.from10(voteAverage)
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        return app.get(
            "$tmdbAPI/search/multi?api_key=$apiKey&language=es-ES&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}"
        ).parsedSafe<Results>()?.results?.mapNotNull { media ->
            media.toSearchResponse()
        }?.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse? {
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&language=es-ES&append_to_response=keywords,credits,external_ids,videos,recommendations"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&language=es-ES&append_to_response=keywords,credits,external_ids,videos,recommendations"
        }
        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")

        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath)
        val bgPoster = getOriImageUrl(res.backdropPath)
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val genres = res.genres?.mapNotNull { it.name }
        val isAnime =
            genres?.contains("Animation") == true && (res.original_language == "zh" || res.original_language == "ja")
        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            ActorData(
                Actor(
                    cast.name ?: cast.originalName ?: return@mapNotNull null,
                    getImageUrl(cast.profilePath)
                ), roleString = cast.character
            )
        } ?: return null
        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer =
            res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" }?.randomOrNull()

        return if (type == TvType.TvSeries) {
            val episodes = res.seasons?.mapNotNull { season ->
                app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey&language=es-ES")
                    .parsedSafe<MediaDetailEpisodes>()?.episodes?.map { eps ->
                        newEpisode(LoadData(
                            res.title,
                            year,
                            isAnime,
                            res.external_ids?.imdb_id,
                            eps.seasonNumber,
                            eps.episodeNumber
                        ).toJson())
                        {
                            this.name = eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                            this.season = eps.seasonNumber
                            this.episode = eps.episodeNumber
                            this.posterUrl = getImageUrl(eps.stillPath)
                            this.score = Score.from10(eps.voteAverage)
                            this.description = eps.overview
                            this.addDate(eps.airDate)
                        }
                    }
            }?.flatten() ?: listOf()
            newTvSeriesLoadResponse(
                title, url, if (isAnime) TvType.Anime else TvType.TvSeries, episodes
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.tags =  keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.showStatus = getStatus(res.status)
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addTMDbId(data.id.toString())
                addImdbId(res.external_ids?.imdb_id)
            }
        } else {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LoadData(res.title,year,isAnime,res.external_ids?.imdb_id).toJson()
            ) {
                this.posterUrl = poster
                this.comingSoon = isUpcoming(releaseDate)
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addTMDbId(data.id.toString())
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }




    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val dataObj = parseJson<LoadData>(data)
        val season = dataObj.season
        val episode = dataObj.episode
        val id = dataObj.imdbId
        val iframe=if(season==null) { "$mainUrl/f/$id" } else { "$mainUrl/f/$id-${season}x0$episode" }
        val res= app.get(iframe).documentLarge
        val jsonString = res.selectFirst("script:containsData(dataLink)")?.data()?.substringAfter("dataLink = ")?.substringBefore(";")

        val allLinksByLanguage = mutableMapOf<String, MutableList<String>>()
        if (jsonString != null) {
            val jsonArray = JSONArray(jsonString)

            for (i in 0 until jsonArray.length()) {
                val fileObject = jsonArray.getJSONObject(i)
                val language = fileObject.getString("video_language")
                val embeds = fileObject.getJSONArray("sortedEmbeds")

                val serverLinks = mutableListOf<String>()
                for (j in 0 until embeds.length()) {
                    val embedObj = embeds.getJSONObject(j)
                    embedObj.optString("link").let { link ->
                        if (link.isNotBlank()) serverLinks.add("\"$link\"")
                    }
                }

                val json = """ {"links":$serverLinks} """.trimIndent()
                    .toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())

                val decrypted = app.post("$mainUrl/api/decrypt", requestBody = json).parsedSafe<Loadlinks>()

                if (decrypted?.success == true) {
                    val links = decrypted.links.map { it.link }
                    val listForLang = allLinksByLanguage.getOrPut(language) { mutableListOf() }
                    listForLang.addAll(links)
                }
            }
        } else {
            println("dataLink not found in response")
        }

        for ((language, links) in allLinksByLanguage) {
            links.forEach { link ->
                loadSourceNameExtractor(language.capitalize(),link,"",subtitleCallback,callback)
            }
        }

        Log.d("Phisher",allLinksByLanguage.toJson())
        // Subtitles
        val subApiUrl = "https://opensubtitles-v3.strem.io"
        val url = if (season == null) "$subApiUrl/subtitles/movie/$id.json"
        else "$subApiUrl/subtitles/series/$id:$season:$episode.json"

        val headers = mapOf(
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )

        app.get(url, headers = headers, timeout = 100L)
            .parsedSafe<Subtitles>()?.subtitles?.amap {
                val lan = getLanguage(it.lang) ?: it.lang
                subtitleCallback(
                    newSubtitleFile(
                        lan,
                        it.url
                    )
                )
            }

        return true
    }
}

data class Subtitles(
    val subtitles: List<Subtitle>,
    val cacheMaxAge: Long,
)

data class Subtitle(
    val id: String,
    val url: String,
    @JsonProperty("SubEncoding")
    val subEncoding: String,
    val lang: String,
    val m: String,
    val g: String,
)


data class Loadlinks(
    val success: Boolean,
    val links: List<Link>,
)

data class Link(
    val index: Long,
    val link: String,
)




================================================
FILE: Pelisplushd/src/main/kotlin/com/pelisplushd/PelisplushdParser.kt
================================================
package com.pelisplushd

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.mvvm.logError
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

data class Results(
    @param:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
)

data class Media(
    @param:JsonProperty("id") val id: Int? = null,
    @param:JsonProperty("name") val name: String? = null,
    @param:JsonProperty("title") val title: String? = null,
    @param:JsonProperty("original_title") val originalTitle: String? = null,
    @param:JsonProperty("media_type") val mediaType: String? = null,
    @param:JsonProperty("poster_path") val posterPath: String? = null,
    @param:JsonProperty("vote_average") val voteAverage: Double? = null,
)

data class Genres(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
)

data class Keywords(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
)

data class KeywordResults(
    @get:JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
    @get:JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
)

data class Seasons(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("season_number") val seasonNumber: Int? = null,
    @get:JsonProperty("air_date") val airDate: String? = null,
)

data class Cast(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("original_name") val originalName: String? = null,
    @get:JsonProperty("character") val character: String? = null,
    @get:JsonProperty("known_for_department") val knownForDepartment: String? = null,
    @get:JsonProperty("profile_path") val profilePath: String? = null,
)

data class Episodes(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("overview") val overview: String? = null,
    @get:JsonProperty("air_date") val airDate: String? = null,
    @get:JsonProperty("still_path") val stillPath: String? = null,
    @get:JsonProperty("vote_average") val voteAverage: Double? = null,
    @get:JsonProperty("episode_number") val episodeNumber: Int? = null,
    @get:JsonProperty("season_number") val seasonNumber: Int? = null,
    @get:JsonProperty("runtime") val runTime: Int? = null
)

data class MediaDetailEpisodes(
    @get:JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
)

data class Trailers(
    @get:JsonProperty("key") val key: String? = null,
    @get:JsonProperty("type") val type: String? = null,
)

data class ResultsTrailer(
    @get:JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
)

data class AltTitles(
    @get:JsonProperty("iso_3166_1") val iso_3166_1: String? = null,
    @get:JsonProperty("title") val title: String? = null,
    @get:JsonProperty("type") val type: String? = null,
)

data class ResultsAltTitles(
    @get:JsonProperty("results") val results: ArrayList<AltTitles>? = arrayListOf(),
)

data class ExternalIds(
    @get:JsonProperty("imdb_id") val imdb_id: String? = null,
    @get:JsonProperty("tvdb_id") val tvdb_id: Int? = null,
)

data class Credits(
    @get:JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
)

data class ResultsRecommendations(
    @get:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
)

data class LastEpisodeToAir(
    @get:JsonProperty("episode_number") val episode_number: Int? = null,
    @get:JsonProperty("season_number") val season_number: Int? = null,
)

data class ProductionCountries(
    @get:JsonProperty("name") val name: String? = null,
)

data class MediaDetail(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("imdb_id") val imdbId: String? = null,
    @get:JsonProperty("title") val title: String? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("original_title") val originalTitle: String? = null,
    @get:JsonProperty("original_name") val originalName: String? = null,
    @get:JsonProperty("poster_path") val posterPath: String? = null,
    @get:JsonProperty("backdrop_path") val backdropPath: String? = null,
    @get:JsonProperty("release_date") val releaseDate: String? = null,
    @get:JsonProperty("first_air_date") val firstAirDate: String? = null,
    @get:JsonProperty("overview") val overview: String? = null,
    @get:JsonProperty("runtime") val runtime: Int? = null,
    @get:JsonProperty("vote_average") val vote_average: Any? = null,
    @get:JsonProperty("original_language") val original_language: String? = null,
    @get:JsonProperty("status") val status: String? = null,
    @get:JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
    @get:JsonProperty("keywords") val keywords: KeywordResults? = null,
    @get:JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
    @get:JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
    @get:JsonProperty("videos") val videos: ResultsTrailer? = null,
    @get:JsonProperty("external_ids") val external_ids: ExternalIds? = null,
    @get:JsonProperty("credits") val credits: Credits? = null,
    @get:JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
    @get:JsonProperty("alternative_titles") val alternative_titles: ResultsAltTitles? = null,
    @get:JsonProperty("production_countries") val production_countries: ArrayList<ProductionCountries>? = arrayListOf(),
)

data class LoadData(
    val title: String? = null,
    val year: Int? =null,
    val isAnime: Boolean = false,
    val imdbId: String? = null,
    val season: Int? = null,
    val episode: Int? = null,
)

data class Data(
    val id: Int? = null,
    val type: String? = null,
    val aniId: String? = null,
    val malId: Int? = null,
)

data class TmdbDate(
    val today: String,
    val nextWeek: String,
    val lastWeekStart: String,
    val monthStart: String
)

fun getDate(): TmdbDate {
    val formatter = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    val calendar = Calendar.getInstance()

    // Today
    val today = formatter.format(calendar.time)

    // Next week
    calendar.add(Calendar.WEEK_OF_YEAR, 1)
    val nextWeek = formatter.format(calendar.time)

    // Last week's Monday
    calendar.time = Date()
    calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
    calendar.add(Calendar.WEEK_OF_YEAR, -1)
    val lastWeekStart = formatter.format(calendar.time)

    // Start of current month
    calendar.time = Date()
    calendar.set(Calendar.DAY_OF_MONTH, 1)
    val monthStart = formatter.format(calendar.time)

    return TmdbDate(today, nextWeek, lastWeekStart, monthStart)
}

fun isUpcoming(dateString: String?): Boolean {
    return try {
        val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val dateTime = dateString?.let { format.parse(it)?.time } ?: return false
        unixTimeMS < dateTime
    } catch (t: Throwable) {
        logError(t)
        false
    }
}


================================================
FILE: Pelisplushd/src/main/kotlin/com/pelisplushd/PelisplushdProvider.kt
================================================
package com.pelisplushd

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class Animeav1Provider: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Pelisplushd())
        registerExtractorAPI(FileMoonlink())
        registerExtractorAPI(Mivalyo())
        registerExtractorAPI(StreamwishHG())
    }
}


================================================
FILE: Pencurimovie/build.gradle.kts
================================================
// use an integer for version numbers
version = 4


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Pencurimovie "
    language    = "id"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://ww03.pencurimovie.bond&size=%size%"

    isCrossPlatform = true
}



================================================
FILE: Pencurimovie/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Pencurimovie/src/main/kotlin/com/Pencurimovie/Pencurimovie.kt
================================================
package com.Pencurimovie

import com.lagradost.api.Log
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.*

class Pencurimovie : MainAPI() {
    override var mainUrl = "https://ww73.pencurimovie.bond"
    override var name = "Pencurimovie"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    override val mainPage = mainPageOf(
        "movies" to "Latest Movies",
        "series" to "TV Series",
        "most-rating" to "Most Rating Movies",
        "top-imdb" to "Top IMDB Movies",
        "country/malaysia" to "Malaysia Movies",
        "country/indonesia" to "Indonesia Movies",
        "country/india" to "India Movies",
        "country/japan" to "Japan Movies",
        "country/thailand" to "Thailand Movies",
        "country/china" to "China Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page", timeout = 50L).documentLarge
        val home = document.select("div.ml-item").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("a").attr("oldtitle").substringBefore("(")
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("a img").attr("data-original"))
        val quality = getQualityFromString(this.select("span.mli-quality").text())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
            val document = app.get("${mainUrl}?s=$query", timeout = 50L).documentLarge
            val results =document.select("div.ml-item").mapNotNull { it.toSearchResult() }
        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url, timeout = 50L).documentLarge
        val title =
            document.selectFirst("div.mvic-desc h3")?.text()?.trim().toString().substringBefore("(")
        val poster = document.select("meta[property=og:image]").attr("content")
        val description = document.selectFirst("div.desc p.f-desc")?.text()?.trim()
        val tvtag = if (url.contains("series")) TvType.TvSeries else TvType.Movie
        val trailer = document.select("meta[itemprop=embedUrl]").attr("content")
        val genre = document.select("div.mvic-info p:contains(Genre)").select("a").map { it.text() }
        val actors =
            document.select("div.mvic-info p:contains(Actors)").select("a").map { it.text() }
        val year =
            document.select("div.mvic-info p:contains(Release)").select("a").text().toIntOrNull()
        val recommendation=document.select("div.ml-item").mapNotNull {
            it.toSearchResult()
        }
        return if (tvtag == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            document.select("div.tvseason").amap { info ->
                val season = info.select("strong").text().substringAfter("Season").trim().toIntOrNull()
                info.select("div.les-content a").forEach {
                    Log.d("Phis","$it")
                    val name = it.select("a").text().substringAfter("-").trim()
                    val href = it.select("a").attr("href")
                    val Rawepisode = it.select("a").text().substringAfter("Episode")
                            .substringBefore("-")
                            .trim().toIntOrNull()
                    episodes.add(
                        newEpisode(href)
                        {
                            this.episode=Rawepisode
                            this.name=name
                            this.season=season
                        }
                    )
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genre
                this.year = year
                addTrailer(trailer)
                addActors(actors)
                this.recommendations=recommendation
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
                this.tags = genre
                this.year = year
                addTrailer(trailer)
                addActors(actors)
                this.recommendations=recommendation
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).documentLarge
        document.select("div.movieplay iframe").forEach {
            val href = it.attr("data-src")
            loadExtractor(href,subtitleCallback, callback)
        }
        return true
    }
}




================================================
FILE: Pencurimovie/src/main/kotlin/com/Pencurimovie/PencurimovieProvider.kt
================================================
package com.Pencurimovie

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class PencurimovieProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Pencurimovie())
    }
}


================================================
FILE: Pinoymoviepedia/build.gradle.kts
================================================
version = 2

cloudstream {
    authors     = listOf("Phisher98")
    language    = "fil"
    description = "Contains Bluray7"

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
    **/
    status  = 1 // will be 3 if unspecified
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://t3.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://pinoymoviepedia.ru&size=16"

    isCrossPlatform = true
}



================================================
FILE: Pinoymoviepedia/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Pinoymoviepedia/src/main/kotlin/com/Pinoymoviepedia/Bluray7.kt
================================================
package com.Pinoymoviepedia

import com.lagradost.cloudstream3.mainPageOf
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class Bluray : Pinoymoviepedia() {

    override var mainUrl = "https://bluray7.com"
    override var name = "Bluray7"
    override val mainPage = mainPageOf(
        "trending" to "Trending",
        "movies" to "Movies",
        "genre/action" to "Action",
        "genre/comedy" to "Comedy",
        "genre/drama" to "Drama",
        "genre/romance" to "Romance",
        "genre/thriller" to "Thriller",
        "genre/adventure" to "Adventure",
        "genre/horror" to "Horror",
        "genre/war" to "War",
        "genre/science-fiction" to "Science Fiction"
    )
    override suspend fun load(url: String): LoadResponse {
        val request = app.get(url)
        val document = request.documentLarge
        //val directUrl = getBaseUrl(request.url)
        val title =
            document.selectFirst("div.data > h1")?.text()?.trim().toString()
        var posterUrl = fixUrlNull(document.selectFirst("meta[property=og:image]")?.attr("content"))
        if (posterUrl.isNullOrEmpty()) {
            posterUrl = fixUrlNull(document.select("div.poster img").attr("src"))
        }
        val description = document.select("div.wp-content > p").text().trim()
        val episodes =
            document.select("ul#playeroptionsul > li").map {
                val name = it.selectFirst("span.title")?.text()
                val type = it.attr("data-type")
                val post = it.attr("data-post")
                val nume = it.attr("data-nume")
                newEpisode(LinkData(type, post,nume).toJson())
                {
                    this.name=name
                }
            }

        return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
            this.posterUrl = posterUrl
            this.plot = description
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = tryParseJson<LinkData>(data)
        Log.d("Phisher", loadData.toString())
        val source = app.post(
            url = "$mainUrl/wp-admin/admin-ajax.php", data = mapOf(
                "action" to "doo_player_ajax", "post" to "${loadData?.post}", "nume" to "${loadData?.nume}", "type" to "movie"
            ), headers = mapOf("Accept" to "*/*", "X-Requested-With" to "XMLHttpRequest"
            )).parsed<ResponseHash>().embed_url
        if (!source.contains("youtube")) loadExtractor(
            source,
            "",
            subtitleCallback,
            callback
        )
        return true
    }

    data class LinkData(
        val type: String? = null,
        val post: String? = null,
        val nume: String? = null,
    )

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("type") val type: String?,
    )
}


================================================
FILE: Pinoymoviepedia/src/main/kotlin/com/Pinoymoviepedia/Extractor.kt
================================================
package com.Pinoymoviepedia

import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.MixDrop
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink

class Vidsp : VidhideExtractor() {
    override var mainUrl = "https://vidsp.lol"
}

class Luluvdostore : StreamWishExtractor() {
    override val mainUrl = "https://luluvdo.store"
}

class VidHideplus : VidhideExtractor() {
    override var mainUrl = "https://vidhideplus.com"
}

class MixDropAg : MixDrop(){
    override var mainUrl = "https://mixdrop.ag"
}

open class Ds2play : ExtractorApi() {
    override var name = "DoodStream"
    override var mainUrl = "https://ds2play.com"
    override val requiresReferer = false

    override fun getExtractorUrl(id: String): String {
        return "https://dood.wf/d/$id"
    }

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response0 = app.get(url).text // html of DoodStream page to look for /pass_md5/...
        val md5 =mainUrl+(Regex("/pass_md5/[^']*").find(response0)?.value ?: return null)  // get https://dood.ws/pass_md5/...
        val trueUrl = app.get(md5, referer = url).text + "zUEJeL3mUN?token=" + md5.substringAfterLast("/")   //direct link to extract  (zUEJeL3mUN is random)
        val quality = Regex("\\d{3,4}p").find(response0.substringAfter("<title>").substringBefore("</title>"))?.groupValues?.get(0)
        return listOf(
            newExtractorLink(
                this.name,
                this.name,
                url = trueUrl,
                ExtractorLinkType.M3U8
            ) {
                this.referer = mainUrl
                this.quality = getQualityFromName(quality)
            }
        ) // links are valid in 8h

    }
}



================================================
FILE: Pinoymoviepedia/src/main/kotlin/com/Pinoymoviepedia/Pinoymoviepedia.kt
================================================
package com.Pinoymoviepedia


import com.lagradost.api.Log
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.*
import org.jsoup.nodes.Element

open class Pinoymoviepedia : MainAPI() {

    override var mainUrl = "https://pinoymoviepedia.ru"
    override var name = "Pinoymoviepedia"
    override val hasMainPage= true
    override var supportedTypes = setOf(TvType.Movie)
    override var lang = "fil"
    override val mainPage = mainPageOf(
        "trending" to "Trending",
        "movies" to "Movies",
        "genre/comedy" to "Comedy",
        "genre/romance" to "Romance",
        "genre/action" to "Action",
        "genre/digitally-restored" to "Digitally Restored"
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = if(page == 1) "$mainUrl/${request.data}/" else "$mainUrl/${request.data}/page/$page/"
        val document = app.get(url).documentLarge
        val home =
            document.select("div.items.normal article, div#archive-content article, div.items.full article").mapNotNull {
                it.toSearchResult()
            }
        return newHomePageResponse(request.name, home)
    }

    private fun getProperLink(uri: String): String {
        return when {
            uri.contains("/episodes/") -> {
                var title = uri.substringAfter("$mainUrl/episodes/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvshows/$title"
            }

            uri.contains("/seasons/") -> {
                var title = uri.substringAfter("$mainUrl/seasons/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvshows/$title"
            }

            else -> {
                uri
            }
        }
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3 > a")?.text() ?: return null
        val href = getProperLink(fixUrl(this.selectFirst("h3 > a")!!.attr("href")))
        var posterUrl = this.select("div.poster img").last()?.getImageAttr()
        if (posterUrl != null) {
            if (posterUrl.contains(".gif")) {
                posterUrl = fixUrlNull(this.select("div.poster img").attr("data-wpfc-original-src"))
            }
        }
        val quality = getQualityFromString(this.select("span.quality").text())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/search/$query").documentLarge
        return document.select("div.result-item").map {
            val title =
                it.selectFirst("div.title > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
            val href = getProperLink(it.selectFirst("div.title > a")!!.attr("href"))
            val posterUrl = it.selectFirst("img")!!.attr("src").toString()
            newMovieSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val request = app.get(url)
        val document = request.documentLarge
        val title =
            document.selectFirst("div.data > h1")?.text()?.trim().toString()
        var posterUrl = fixUrlNull(document.selectFirst("meta[property=og:image]")?.attr("content"))
        if (posterUrl.isNullOrEmpty()) {
                posterUrl = fixUrlNull(document.select("div.poster img").attr("src"))
        }
        val description = document.select("div.wp-content > p").text().trim()

        /*
            val episodes =
                document.select("ul#playeroptionsul > li").map {
                    val name = it.selectFirst("span.title")?.text()
                    val type = it.attr("data-type")
                    val post = it.attr("data-post")
                    val nume = it.attr("data-nume")
                    Episode(
                        LinkData(type, post,nume).toJson(),
                        name,
                    )
                }

            return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = posterUrl
                this.plot = description
            }
         */
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl=posterUrl
            this.plot = description
            }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
            Log.d("Phisher",data)
            app.get(data).documentLarge.select("div.pframe iframe").forEach {
                val href=it.attr("src")
                Log.d("Phisher",href)
                loadExtractor(
                    href,
                    "",
                    subtitleCallback,
                    callback
                )
            }
        return true
        }

    private fun Element.getImageAttr(): String? {
        return when {
            this.hasAttr("data-src") -> this.attr("abs:data-src")
            this.hasAttr("data-lazy-src") -> this.attr("abs:data-lazy-src")
            this.hasAttr("srcset") -> this.attr("abs:srcset").substringBefore(" ")
            else -> this.attr("abs:src")
        }
    }
}



================================================
FILE: Pinoymoviepedia/src/main/kotlin/com/Pinoymoviepedia/PinoymoviepediaProvider.kt
================================================
package com.Pinoymoviepedia

import com.lagradost.cloudstream3.extractors.Upstream
import com.lagradost.cloudstream3.extractors.VidHidePro3
import com.lagradost.cloudstream3.extractors.Voe
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class PinoymoviepediaProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Pinoymoviepedia())
        registerMainAPI(Bluray())
        registerExtractorAPI(Ds2play())
        registerExtractorAPI(Upstream())
        registerExtractorAPI(Vidsp())
        registerExtractorAPI(VidHidePro3())
        registerExtractorAPI(VidHideplus())
        registerExtractorAPI(Voe())
        registerExtractorAPI(MixDropAg())
        registerExtractorAPI(Luluvdostore())
    }
}



================================================
FILE: PublicSportsIPTV/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties

version = 2

android {
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "FanCode_API", "\"${properties.getProperty("FanCode_API")}\"")

    }
}

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Sports Live Streams (FanCode)"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Live")

    iconUrl="https://www.thestatesman.com/wp-content/uploads/2021/05/fancode.jpg"

    isCrossPlatform = true
}



================================================
FILE: PublicSportsIPTV/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: PublicSportsIPTV/src/main/kotlin/com/PublicSportsIPTV/PublicSportsIPTV.kt
================================================
package com.PublicSportsIPTV

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson

class PublicSportsIPTV : MainAPI() {
    override var mainUrl: String = com.phisher98.BuildConfig.FanCode_API
    override var name = "PublicSportsIPTV"
    override val hasMainPage = true
    override var lang = "en"
    override val supportedTypes = setOf(TvType.Live)


    companion object
    {
        private const val User_Agent  = "ReactNativeVideo/8.0.0 (Linux;Android/13) AndroidXMedia3/1.1.1"
        val Referer  = base64Decode("aHR0cHM6Ly9mYW5jb2RlLmNvbS8=")
    }


    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val data = app.get(mainUrl).parsed<Root>()
        val matches = data.matches

        val live = matches.filter  {
            it.status.trim().contains("LIVE", ignoreCase = true)
        }

        val upcoming = matches.filter {
            it.status.trim().contains("NOT_STARTED", ignoreCase = true)
        }

        val liveList = live.map { it.toSearchResult() }
        val upcomingList = upcoming.map { it.toSearchResult() }

        return newHomePageResponse(
            listOf(
                HomePageList("Live Now", liveList, isHorizontalImages = true),
                HomePageList("Upcoming", upcomingList, isHorizontalImages = true)
            ),
            hasNext = false
        )
    }

    private fun Match.toSearchResult(): SearchResponse {
        val title = this.title
        val href = LoadURL(this.streamingCdn.primaryPlaybackUrl,this.streamingCdn.fancodeCdn,this.streamingCdn.daiGoogleCdn,this.streamingCdn.cloudfrontCdn,this.title,this.tournament,this.image)
        val posterUrl = this.imageCdn.cloudfare ?: this.image
        return newLiveSearchResponse(title, href.toJson(), TvType.Live) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val parsed = tryParseJson<LoadURL>(url)
        val title = parsed?.title ?: "PublicSportsIPTV"
        val poster = parsed?.poster ?: "https://www.fancode.com/skillup-uploads/fc-web/home-page-new-arc/hero-image/v1/hero-image-dweb-v4.png"
        val description = parsed?.tournament ?:"FanCode was founded in 2019 by Yannick Colaco and Prasana Krishnan. It is an over-the-top streaming service and sports e-commerce company in India. It is part of the Dream Sports group"

        return newMovieLoadResponse(title, url, TvType.Live, url) {
            this.posterUrl = poster
            this.plot = description
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val parsed = tryParseJson<LoadURL>(data) ?: return false
        val urls = listOfNotNull(
            parsed.primaryPlaybackUrl,
            parsed.fancodeCdn,
            parsed.daiGoogleCdn,
            parsed.cloudfrontCdn
        ).distinct().toMutableList()

        if (urls.isEmpty()) return false

        urls.forEachIndexed { index, url ->
            if (url.startsWith("http"))
            callback.invoke(
                newExtractorLink(
                    name,
                    "$name ${index+1}",
                    url = url,
                    INFER_TYPE
                ) {
                    this.referer = Referer
                    this.quality = Qualities.P1080.value
                }
            )
        }

        return true
    }
}



================================================
FILE: PublicSportsIPTV/src/main/kotlin/com/PublicSportsIPTV/PublicSportsIPTVParser.kt
================================================
package com.PublicSportsIPTV

import com.fasterxml.jackson.annotation.JsonProperty

data class Root(
    @JsonProperty("Author")
    val author: String,
    val name: String,
    @JsonProperty("last_updated")
    val lastUpdated: String,
    val headers: Headers,
    @JsonProperty("total_matches")
    val totalMatches: Long,
    @JsonProperty("live_matches")
    val liveMatches: Long,
    @JsonProperty("upcoming_matches")
    val upcomingMatches: Long,
    val matches: List<Match>,
)

data class Headers(
    @JsonProperty("User-Agent")
    val userAgent: String,
    @JsonProperty("Referer")
    val referer: String,
)

data class Match(
    val category: String,
    val title: String,
    val tournament: String,
    @JsonProperty("match_id")
    val matchId: Long,
    val status: String,
    val streamingStatus: String,
    val startTime: String,
    val startDate: String,
    val image: String,
    @JsonProperty("image_cdn")
    val imageCdn: ImageCdn,
    val teams: List<Team>,
    val language: String,
    @JsonProperty("adfree_stream")
    val adfreeStream: String?,
    @JsonProperty("dai_stream")
    val daiStream: String?,
    @JsonProperty("STREAMING_CDN")
    val streamingCdn: StreamingCdn,
)

data class ImageCdn(
    @JsonProperty("TATAPLAY")
    val tataplay: String,
    @JsonProperty("APP")
    val app: String,
    @JsonProperty("PLAYBACK")
    val playback: String?,
    @JsonProperty("LOGO")
    val logo: String,
    @JsonProperty("SPORTS")
    val sports: String,
    @JsonProperty("BG_IMAGE")
    val bgImage: String,
    @JsonProperty("SPORT_BY_IMAGE")
    val sportByImage: String,
    @JsonProperty("CLOUDFARE")
    val cloudfare: String?,
)

data class Team(
    val name: String,
    val shortName: String,
    val flag: Flag,
    val isWinner: Boolean?,
    val color: String,
    val cricketScore: List<CricketScore>?,
    val kabaddiScore: Any?,
    val footballScore: Any?,
    val basketBallScore: Any?,
    val hockeyScore: Any?,
    val status: Status?,
)

data class Flag(
    val src: String,
)

data class CricketScore(
    val runs: Long,
    val overs: String,
    val balls: String,
    val status: String,
    val wickets: Long,
)

data class Status(
    val cricket: Cricket,
)

data class Cricket(
    val isBatting: Boolean,
)

data class StreamingCdn(
    val language: String,
    @JsonProperty("Primary_Playback_URL")
    val primaryPlaybackUrl: String?,
    @JsonProperty("fancode_cdn")
    val fancodeCdn: String?,
    @JsonProperty("dai_google_cdn")
    val daiGoogleCdn: String?,
    @JsonProperty("cloudfront_cdn")
    val cloudfrontCdn: String?,
    @JsonProperty("sony_cdn")
    val sonyCdn: String?,
)


data class LoadURL(
    @JsonProperty("Primary_Playback_URL")
    val primaryPlaybackUrl: String?,
    @JsonProperty("fancode_cdn")
    val fancodeCdn: String?,
    @JsonProperty("dai_google_cdn")
    val daiGoogleCdn: String?,
    @JsonProperty("cloudfront_cdn")
    val cloudfrontCdn: String?,
    @JsonProperty("title")
    val title: String?,
    @JsonProperty("tournament")
    val tournament: String?,
    @JsonProperty("poster")
    val poster: String?,
)


================================================
FILE: PublicSportsIPTV/src/main/kotlin/com/PublicSportsIPTV/PublicSportsIPTVProvider.kt
================================================
package com.PublicSportsIPTV

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class PublicSportsIPTVProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(PublicSportsIPTV())
    }
}



================================================
FILE: QuickIPTV/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties
// use an integer for version numbers
version = 5

android {
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "Su_sports", "\"${properties.getProperty("Su_sports")}\"")
        buildConfigField("String", "PirateIPTV", "\"${properties.getProperty("PirateIPTV")}\"")
        buildConfigField("String", "SonyIPTV", "\"${properties.getProperty("SonyIPTV")}\"")
        buildConfigField("String", "JapanIPTV", "\"${properties.getProperty("JapanIPTV")}\"")
    }
}

cloudstream {
    // All of these properties are optional, you can safely remove them
    language = "en"
    description = "Includes PirateIPTV,Sports IPTV,Japanese IPTV,Sony IPTV"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Live",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=github.com&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: QuickIPTV/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: QuickIPTV/src/main/kotlin/com/Phisher98/JapanIPTV.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newDrmExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.util.UUID

class JapanIPTV : SportsIPTV() {
    override var lang = "en"
    override var mainUrl: String = BuildConfig.JapanIPTV
    override var name = "Japan IPTV"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Live,
    )


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        if (loadData.url.contains("mpd"))
        {
            callback.invoke(
                newDrmExtractorLink(
                    this.name,
                    this.name,
                    loadData.url,
                    INFER_TYPE,
                    UUID.randomUUID()
                )
                {
                    this.key=loadData.key.trim()
                    this.kid=loadData.keyid.trim()
                }
            )
        }
            else
        if(loadData.url.contains("&e=.m3u"))
            {
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = loadData.url,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = "https://embedme.top/"
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        else
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    loadData.title,
                    url = loadData.url,
                    INFER_TYPE
                ) {
                    this.referer = "https://embedme.top/"
                    this.quality = Qualities.Unknown.value
                }
            )
        }
        return true
    }
}


================================================
FILE: QuickIPTV/src/main/kotlin/com/Phisher98/PirateIPTV.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newDrmExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.util.UUID

class PirateIPTV : SportsIPTV() {
    override var lang = "en"
    override var mainUrl: String = BuildConfig.PirateIPTV
    override var name = "Pirate IPTV"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Live,
    )


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        if (loadData.url.contains("mpd"))
        {
            callback.invoke(
                newDrmExtractorLink(
                    this.name,
                    this.name,
                    loadData.url,
                    INFER_TYPE,
                    UUID.randomUUID()
                )
                {
                    this.key=loadData.key.trim()
                    this.kid=loadData.keyid.trim()
                }
            )
        }
            else
        if(loadData.url.contains("&e=.m3u"))
            {
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = loadData.url,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = "https://embedme.top/"
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        else
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    loadData.title,
                    url = loadData.url,
                    INFER_TYPE
                ) {
                    this.referer = "https://embedme.top/"
                    this.quality = Qualities.Unknown.value
                }
            )
        }
        return true
    }
}


================================================
FILE: QuickIPTV/src/main/kotlin/com/Phisher98/QuickIPTV.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newDrmExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.io.InputStream
import java.util.UUID

open class SportsIPTV : MainAPI() {
    override var lang = "en"
    override var mainUrl: String = BuildConfig.Su_sports
    override var name = "Sports IPTV"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Live,
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val data = IptvPlaylistParser().parseM3U(app.get(mainUrl).text)
        return newHomePageResponse(data.items.groupBy{it.attributes["group-title"]}.map { group ->
            val title = group.key ?: ""
            val show = group.value.map { channel ->
                val streamurl = channel.url.toString()
                val channelname = channel.title.toString()
                val posterurl = channel.attributes["tvg-logo"].toString()
                val nation = channel.attributes["group-title"].toString()
                val key=channel.attributes["key"].toString()
                val keyid=channel.attributes["keyid"].toString()
                newLiveSearchResponse(channelname,LoadData(streamurl, channelname, posterurl, nation, key, keyid).toJson(),TvType.Live)
                {
                    this.posterUrl=posterurl
                    this.lang=channel.attributes["group-title"]
                }
            }
            HomePageList(
                title,
                show,
                isHorizontalImages = true
            )
        })
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val data = IptvPlaylistParser().parseM3U(app.get(mainUrl).text)
        return data.items.filter { it.title?.contains(query,ignoreCase = true) ?: false }.map { channel ->
                val streamurl = channel.url.toString()
                val channelname = channel.title.toString()
                val posterurl = channel.attributes["tvg-logo"].toString()
                val nation = channel.attributes["group-title"].toString()
                val key=channel.attributes["key"].toString()
                val keyid=channel.attributes["keyid"].toString()
            newLiveSearchResponse(channelname,LoadData(streamurl, channelname, posterurl, nation, key, keyid).toJson(),TvType.Live)
            {
                this.posterUrl=posterurl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val data = parseJson<LoadData>(url)
        return newLiveStreamLoadResponse(data.title,data.url,url)
        {
            this.posterUrl=data.poster
            this.plot=data.nation
        }
    }
    data class LoadData(
        val url: String,
        val title: String,
        val poster: String,
        val nation: String,
        val key: String,
        val keyid: String,
    )
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        if (loadData.url.contains("mpd"))
        {
            callback.invoke(
                newDrmExtractorLink(
                    this.name,
                    this.name,
                    loadData.url,
                    INFER_TYPE,
                    UUID.randomUUID()
                )
                {
                    this.key=loadData.key.trim()
                    this.kid=loadData.keyid.trim()
                }
            )
        }
            else
        if(loadData.url.contains("&e=.m3u"))
            {
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = loadData.url,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = "https://embedme.top/"
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        else
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    loadData.title,
                    url = loadData.url,
                    INFER_TYPE
                ) {
                    this.referer = "https://embedme.top/"
                    this.quality = Qualities.Unknown.value
                }
            )
        }
        return true
    }
}


data class Playlist(
    val items: List<PlaylistItem> = emptyList(),
)

data class PlaylistItem(
    val title: String? = null,
    val attributes: Map<String, String> = emptyMap(),
    val headers: Map<String, String> = emptyMap(),
    val url: String? = null,
    val userAgent: String? = null,
    val key: String? = null,
    val keyid: String? = null,
)


class IptvPlaylistParser {


    /**
     * Parse M3U8 string into [Playlist]
     *
     * @param content M3U8 content string.
     * @throws PlaylistParserException if an error occurs.
     */
    fun parseM3U(content: String): Playlist {
        return parseM3U(content.byteInputStream())
    }

    /**
     * Parse M3U8 content [InputStream] into [Playlist]
     *
     * @param input Stream of input data.
     * @throws PlaylistParserException if an error occurs.
     */
    @Throws(PlaylistParserException::class)
    fun parseM3U(input: InputStream): Playlist {
        val reader = input.bufferedReader()

        if (!reader.readLine().isExtendedM3u()) {
            throw PlaylistParserException.InvalidHeader()
        }

        val playlistItems: MutableList<PlaylistItem> = mutableListOf()
        var currentIndex = 0

        var line: String? = reader.readLine()

        while (line != null) {
            if (line.isNotEmpty()) {
                if (line.startsWith(EXT_INF)) {
                    val title = line.getTitle()
                    val attributes = line.getAttributes()
                    playlistItems.add(PlaylistItem(title, attributes))
                } else if (line.startsWith(EXT_VLC_OPT)) {
                    val item = playlistItems[currentIndex]
                    val userAgent = line.getTagValue("http-user-agent")
                    val referrer = line.getTagValue("http-referrer")
                    val headers = if (referrer != null) {
                        item.headers + mapOf("referrer" to referrer)
                    } else item.headers
                    playlistItems[currentIndex] =
                        item.copy(userAgent = userAgent, headers = headers)
                } else {
                    if (!line.startsWith("#")) {
                        val item = playlistItems[currentIndex]
                        val url = line.getUrl()
                        val userAgent = line.getUrlParameter("user-agent")
                        val referrer = line.getUrlParameter("referer")
                        val key = line.getUrlParameter("key")
                        val keyid = line.getUrlParameter("keyid")
                        val urlHeaders = if (referrer != null) {
                            item.headers + mapOf("referrer" to referrer)
                        } else item.headers
                        playlistItems[currentIndex] =
                            item.copy(
                                url = url,
                                headers = item.headers + urlHeaders,
                                userAgent = userAgent,
                                key=key,
                                keyid=keyid
                            )
                        currentIndex++
                    }
                }
            }

            line = reader.readLine()
        }
        return Playlist(playlistItems)
    }

    /**
     * Replace "" (quotes) from given string.
     */
    private fun String.replaceQuotesAndTrim(): String {
        return replace("\"", "").trim()
    }

    /**
     * Check if given content is valid M3U8 playlist.
     */
    private fun String.isExtendedM3u(): Boolean = startsWith(EXT_M3U)

    /**
     * Get title of media.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTINF:-1 tvg-id="1234" group-title="Kids" tvg-logo="url/to/logo", Title
     * ```
     * Result: Title
     */
    private fun String.getTitle(): String? {
        return split(",").lastOrNull()?.replaceQuotesAndTrim()
    }

    /**
     * Get media url.
     *
     * Example:-
     *
     * Input:
     * ```
     * https://example.com/sample.m3u8|user-agent="Custom"
     * ```
     * Result: https://example.com/sample.m3u8
     */
    private fun String.getUrl(): String? {
        return split("|").firstOrNull()?.replaceQuotesAndTrim()
    }

    /**
     * Get url parameters.
     *
     * Example:-
     *
     * Input:
     * ```
     * http://192.54.104.122:8080/d/abcdef/video.mp4|User-Agent=Mozilla&Referer=CustomReferrer
     * ```
     * Result will be equivalent to kotlin map:
     * ```Kotlin
     * mapOf(
     *   "User-Agent" to "Mozilla",
     *   "Referer" to "CustomReferrer"
     * )
     * ```
     */
  /*  private fun String.getUrlParameters(): Map<String, String> {
        val urlRegex = Regex("^(.*)\\|", RegexOption.IGNORE_CASE)
        val headersString = replace(urlRegex, "").replaceQuotesAndTrim()
        return headersString.split("&").mapNotNull {
            val pair = it.split("=")
            if (pair.size == 2) pair.first() to pair.last() else null
        }.toMap()
    }

   */

    /**
     * Get url parameter with key.
     *
     * Example:-
     *
     * Input:
     * ```
     * http://192.54.104.122:8080/d/abcdef/video.mp4|User-Agent=Mozilla&Referer=CustomReferrer
     * ```
     * If given key is `user-agent`, then
     *
     * Result: Mozilla
     */
    private fun String.getUrlParameter(key: String): String? {
        val urlRegex = Regex("^(.*)\\|", RegexOption.IGNORE_CASE)
        val keyRegex = Regex("$key=(\\w[^&]*)", RegexOption.IGNORE_CASE)
        val paramsString = replace(urlRegex, "").replaceQuotesAndTrim()
        return keyRegex.find(paramsString)?.groups?.get(1)?.value
    }

    /**
     * Get attributes from `#EXTINF` tag as Map<String, String>.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTINF:-1 tvg-id="1234" group-title="Kids" tvg-logo="url/to/logo", Title
     * ```
     * Result will be equivalent to kotlin map:
     * ```Kotlin
     * mapOf(
     *   "tvg-id" to "1234",
     *   "group-title" to "Kids",
     *   "tvg-logo" to "url/to/logo"
     *)
     * ```
     */
    private fun String.getAttributes(): Map<String, String> {
        val extInfRegex = Regex("(#EXTINF:.?[0-9]+)", RegexOption.IGNORE_CASE)
        val attributesString = replace(extInfRegex, "").replaceQuotesAndTrim().split(",").first()
        return attributesString.split(Regex("\\s")).mapNotNull {
            val pair = it.split("=")
            if (pair.size == 2) pair.first() to pair.last()
                .replaceQuotesAndTrim() else null
        }.toMap()
    }

    /**
     * Get value from a tag.
     *
     * Example:-
     *
     * Input:
     * ```
     * #EXTVLCOPT:http-referrer=http://example.com/
     * ```
     * Result: http://example.com/
     */
    private fun String.getTagValue(key: String): String? {
        val keyRegex = Regex("$key=(.*)", RegexOption.IGNORE_CASE)
        return keyRegex.find(this)?.groups?.get(1)?.value?.replaceQuotesAndTrim()
    }

    companion object {
        const val EXT_M3U = "#EXTM3U"
        const val EXT_INF = "#EXTINF"
        const val EXT_VLC_OPT = "#EXTVLCOPT"
    }

}

/**
 * Exception thrown when an error occurs while parsing playlist.
 */
sealed class PlaylistParserException(message: String) : Exception(message) {

    /**
     * Exception thrown if given file content is not valid.
     */
    class InvalidHeader :
        PlaylistParserException("Invalid file header. Header doesn't start with #EXTM3U")

}



================================================
FILE: QuickIPTV/src/main/kotlin/com/Phisher98/QuickIPTVPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class QuickIPTVPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SportsIPTV())
        registerMainAPI(PirateIPTV())
        registerMainAPI(SonyIPTV())
        registerMainAPI(JapanIPTV())
    }
}


================================================
FILE: QuickIPTV/src/main/kotlin/com/Phisher98/SonyIPTV.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newDrmExtractorLink
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.util.UUID

class SonyIPTV : SportsIPTV() {
    override var lang = "en"
    override var mainUrl: String = BuildConfig.SonyIPTV
    override var name = "Sony IPTV"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Live,
    )


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        if (loadData.url.contains("mpd"))
        {
            callback.invoke(
                newDrmExtractorLink(
                    this.name,
                    this.name,
                    loadData.url,
                    INFER_TYPE,
                    UUID.randomUUID()
                )
                {
                    this.key=loadData.key.trim()
                    this.kid=loadData.keyid.trim()
                }
            )
        }
            else
        if(loadData.url.contains("&e=.m3u"))
            {
                callback.invoke(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = loadData.url,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = "https://embedme.top/"
                        this.quality = Qualities.Unknown.value
                    }
                )
            }
        else
        {
            callback.invoke(
                newExtractorLink(
                    this.name,
                    loadData.title,
                    url = loadData.url,
                    INFER_TYPE
                ) {
                    this.referer = "https://embedme.top/"
                    this.quality = Qualities.Unknown.value
                }
            )
        }
        return true
    }
}


================================================
FILE: RingZ/build.gradle.kts
================================================
// use an integer for version numbers
version = 6


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Ringz App"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://ringzapk.com/logo.png"

    isCrossPlatform = false
}



================================================
FILE: RingZ/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: RingZ/src/main/kotlin/com/RingZ/RingZ.kt
================================================
package com.RingZ

import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.MovieSearchResponse
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.runBlocking
import org.json.JSONArray
import org.json.JSONObject

class RingZ : MainAPI() {
    override var mainUrl = base64Decode("aHR0cHM6Ly9kYXRhYXBpLnlvbW92aWVzYXBrLmNvbS8=")
    override var name = "RingZ"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Movie, TvType.Anime, TvType.Cartoon)

    companion object {
        val headers = mapOf(
            "cf-access-client-id" to base64Decode("ZTNhMTVhZDk5OWRhYjdmMzU5MmYzZDg1NWUwZWM2ZWQuYWNjZXNz"),
            "cf-access-client-secret" to base64Decode("OGEyMjUzNmUyZGFjODYzNjlhMmNhYTkxMWQ1NWE4OWExMDk5MzljYzY5ZTY2NDZlNTFiZjVkODUyN2ExZGNhNQ0K"),
            "user-agent" to "Dart/3.8 (dart:io)"
        )

    }

    data class MainCategory(
        val url: String,
        val title: String,
        val adult: Boolean? = false
    )

    private fun defaultMainPage() = mainPageOf(
        *listOfNotNull(
            "$mainUrl/Nwm.json" to "Movies",
            "$mainUrl/Nws.json" to "Web Series",
            "$mainUrl/lstanime.json" to "Anime",
            if (settingsForProvider.enableAdult) "$mainUrl/desihub.json" to "Adult (18+)" else null
        ).toTypedArray()
    )

    private suspend fun fetchMainPageFromGithub(): List<Pair<String, String>> {
        val jsonUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/main/RingzCategories.json"
        val resp = app.get(jsonUrl)
        val body = resp.text

        val categories = try {
            AppUtils.parseJson<List<MainCategory>>(body)
        } catch (_: Throwable) {
            Log.e(name, "Failed to parse RingzCategories")
            null
        }

        return (categories ?: emptyList())
            .filter { settingsForProvider.enableAdult || it.adult != true }
            .map { cat ->
                "$mainUrl/${cat.url}" to cat.title
            }
    }

    override val mainPage = runBlocking {
        try {
            val pages = fetchMainPageFromGithub()
            if (pages.isNotEmpty()) {
                mainPageOf(*pages.toTypedArray())
            } else {
                defaultMainPage()
            }
        } catch (_: Throwable) {
            defaultMainPage()
        }
    }



    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = request.data
        val responseString = app.get(url, headers).text
        val json = JSONObject(responseString)

        // Helper to get JSONArray safely
        fun getJsonArray(vararg keys: String): JSONArray {
            for (key in keys) {
                json.optJSONArray(key)?.let { return it }
            }
            return JSONArray()
        }

        // Helper to create LoadURL
        fun JSONObject.toLoadURL(type: String): LoadURL {
            return LoadURL(
                url = this.optString("l", url),
                title = this.optString("mn"),
                id = this.optString("id"),
                posterUrl = this.optString("IH"),
                trailer = this.optString("trailer").takeIf { it != "FALSE" },
                quality = this.optString("qlty").takeIf { it.isNotEmpty() },
                language = this.optString("lng"),
                type = type,
                category = this.optString("cg"),
                genre = this.optString("gn"),
                extra = this.toString()
            )
        }

        // Helper to create MovieSearchResponse list
        fun JSONArray.toSearchResponses(
            type: String,
            tvType: TvType,
            filterGenre: String? = null
        ): List<MovieSearchResponse> {
            val list = mutableListOf<MovieSearchResponse>()
            for (i in 0 until this.length()) {
                val item = this.getJSONObject(i)
                if (filterGenre != null && !item.optString("gn")
                        .contains(filterGenre, ignoreCase = true)
                ) continue

                val loadUrl = item.toLoadURL(type)
                list += newMovieSearchResponse(item.optString("mn"), loadUrl.toJson(), tvType) {
                    this.posterUrl = item.optString("IH")
                    if (type == "Movies") this.quality =
                        getQualityFromString(item.optString("qlty").takeIf { it.isNotEmpty() })
                }
            }
            return list
        }

        return when {
            request.name.contains("Movies", ignoreCase = true) -> {
                val allMovies = getJsonArray("AllMovieDataList", "allMovieDataList")
                val searchResponses = allMovies.toSearchResponses("Movies", TvType.Movie)
                newHomePageResponse(
                    list = listOf(
                        HomePageList(
                            request.name.capitalize(),
                            searchResponses,
                            isHorizontalImages = true
                        )
                    ),
                    hasNext = false
                )
            }

            request.name.contains("Anime", ignoreCase = true) -> {
                val animeList = getJsonArray("webSeriesDataList")
                val searchResponses =
                    animeList.toSearchResponses("Anime", TvType.Anime, filterGenre = "Anime")
                newHomePageResponse(
                    list = listOf(
                        HomePageList(
                            request.name.capitalize(),
                            searchResponses,
                            isHorizontalImages = true
                        )
                    ),
                    hasNext = false
                )
            }

            request.name.contains("Adult", ignoreCase = true) || request.name.contains(
                "Web Series",
                ignoreCase = true
            ) -> {
                val webSeriesList = getJsonArray("webSeriesDataList")
                val searchResponses = webSeriesList.toSearchResponses("Series", TvType.TvSeries)
                newHomePageResponse(
                    list = listOf(
                        HomePageList(
                            request.name.capitalize(),
                            searchResponses,
                            isHorizontalImages = true
                        )
                    ),
                    hasNext = false
                )
            }

            else -> {
                val allMovies = getJsonArray("AllMovieDataList", "allMovieDataList")
                val searchResponses = allMovies.toSearchResponses("Movies", TvType.Movie)
                newHomePageResponse(
                    list = listOf(
                        HomePageList(
                            request.name.capitalize(),
                            searchResponses,
                            isHorizontalImages = true
                        )
                    ),
                    hasNext = false
                )
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val urls = try {
            fetchMainPageFromGithub()
        } catch (_: Throwable) {
            listOfNotNull(
                "$mainUrl/Nwm.json" to "Movies",
                "$mainUrl/Nws.json" to "Web Series",
                "$mainUrl/lstanime.json" to "Anime",
                if (settingsForProvider.enableAdult)
                    "$mainUrl/desihub.json" to "Adult (18+)"
                else null
            )
        }


        val results = mutableListOf<SearchResponse>()

        suspend fun fetchJson(url: String) = JSONObject(app.get(url, headers).text)

        // Helper to convert JSONObject to LoadURL
        fun JSONObject.toLoadURL(type: String, fallbackUrl: String): LoadURL {
            return LoadURL(
                url = this.optString("l", fallbackUrl),
                title = this.optString("mn"),
                id = this.optString("id"),
                posterUrl = this.optString("IH"),
                trailer = this.optString("trailer").takeIf { it != "FALSE" },
                quality = this.optString("qlty").takeIf { it.isNotEmpty() },
                language = this.optString("lng"),
                type = type,
                category = this.optString("cg"),
                genre = this.optString("gn"),
                extra = this.toString()
            )
        }

        fun JSONArray.toSearchResponses(
            type: String,
            tvType: TvType,
            filterGenre: String? = null,
            fallback: String? = null
        ): List<SearchResponse> {
            val list = mutableListOf<SearchResponse>()
            for (i in 0 until this.length()) {
                val item = this.getJSONObject(i)

                val name = item.optString("mn")
                if (!name.contains(query, ignoreCase = true)) continue
                if (filterGenre != null && !item.optString("gn")
                        .contains(filterGenre, ignoreCase = true)
                ) continue

                val loadUrl = item.toLoadURL(type, fallbackUrl = "$fallback")

                list += newMovieSearchResponse(name, loadUrl.toJson(), tvType) {
                    this.posterUrl = item.optString("IH")
                    if (tvType == TvType.Movie) this.quality =
                        getQualityFromString(item.optString("qlty").takeIf { it.isNotEmpty() })
                }
            }
            return list
        }

        // Loop through all sources
        for ((url, type) in urls) {
            val json = fetchJson(url)
            val arrayKeys = listOf("AllMovieDataList", "allMovieDataList", "webSeriesDataList")
            val jsonArray = arrayKeys.firstNotNullOfOrNull { json.optJSONArray(it) } ?: JSONArray()

            val tvType = when {
                type.contains("Movies", ignoreCase = true) -> TvType.Movie
                type.contains("Anime", ignoreCase = true) -> TvType.Anime
                else -> TvType.TvSeries
            }

            results += jsonArray.toSearchResponses(
                type,
                tvType,
                filterGenre = if (type == "Anime") "Anime" else null,
                url
            )
        }

        return results
    }


    override suspend fun load(url: String): LoadResponse {
        val res = tryParseJson<LoadURL>(url) ?: throw ErrorLoadingException("Invalid URL JSON")
        val title = res.title ?: "Unknown Title"
        val href = res.url ?: throw ErrorLoadingException("URL missing")
        val poster = res.posterUrl
        val genre = res.genre?.split(",")?.map { it.trim() }

        val tvTag = when {
            res.type?.contains("Series", ignoreCase = true) == true -> TvType.TvSeries
            res.type?.contains("Anime", ignoreCase = true) == true -> TvType.Anime
            else -> TvType.Movie
        }

        // Helper to fetch JSON
        suspend fun fetchJson(fullUrl: String) = JSONObject(app.get(fullUrl, headers).text)

        fun parseEpisodes(seriesObj: JSONObject): List<Episode> {
            val episodeMap = mutableMapOf<String, MutableList<JSONObject>>()

            val keys = seriesObj.keys()
            while (keys.hasNext()) {
                val key = keys.next()

                if (key.startsWith("eServer") || key == "eTape") {
                    val serverBlock = seriesObj.getJSONObject(key)
                    val epKeys = serverBlock.keys()

                    while (epKeys.hasNext()) {
                        val epNum = epKeys.next()
                        val epUrl = serverBlock.getString(epNum)

                        val list = episodeMap.getOrPut(epNum) { mutableListOf() }

                        val entry = JSONObject().apply {
                            put("source", key)
                            put("url", epUrl)
                            put("episode", epNum)
                        }

                        list.add(entry)
                    }
                }
            }

            return episodeMap.entries
                .sortedBy { it.key.toInt() }
                .map { (epNum, jsonList) ->
                    newEpisode(jsonList.toString()) {
                        name = "Episode $epNum"
                        episode = epNum.toInt()
                    }
                }
        }


        return when (tvTag) {
            TvType.TvSeries, TvType.Anime -> {
                val seriesResText =
                    fetchJson(if (href.contains(mainUrl)) href else "$mainUrl/$href")
                val webSeriesList = seriesResText.getJSONArray("webSeriesDataList")
                val seriesObj = (0 until webSeriesList.length())
                    .map { webSeriesList.getJSONObject(it) }
                    .firstOrNull { it.getString("id") == res.id }

                val allEpisodes = seriesObj?.let { parseEpisodes(it) } ?: emptyList()

                if (tvTag == TvType.TvSeries) {
                    newTvSeriesLoadResponse(title, url, TvType.TvSeries, allEpisodes) {
                        this.posterUrl = poster
                        this.tags = genre
                    }
                } else {
                    newAnimeLoadResponse(title, url, TvType.Anime) {
                        this.posterUrl = poster
                        this.tags = genre
                        addEpisodes(DubStatus.Subbed, allEpisodes)
                    }
                }
            }

            else -> {
                val movieResText = fetchJson("$mainUrl/$href")
                val allMovieDataList = movieResText.getJSONArray("AllMovieDataList")
                val movie = (0 until allMovieDataList.length())
                    .map { allMovieDataList.getJSONObject(it) }
                    .firstOrNull { it.optString("id") == res.id }

                if (movie != null) {
                    val linksArray = JSONArray()
                    val keysIter = movie.keys()
                    while (keysIter.hasNext()) {
                        val key = keysIter.next()
                        val value = movie.optString(key)
                        if (key == "hf") continue
                        val entry = JSONObject()
                        entry.put("key", key)
                        entry.put("value", value)
                        if (value.startsWith("http", ignoreCase = true)) {
                            entry.put("url", value)
                        }
                        linksArray.put(entry)
                    }

                    newMovieLoadResponse(
                        movie.optString("mn"),
                        url,
                        TvType.Movie,
                        linksArray.toString()
                    ) {
                        this.posterUrl = poster
                        this.tags = genre
                    }
                } else {
                    newMovieLoadResponse(title, url, TvType.Movie, url) {
                        this.posterUrl = poster
                        this.tags = genre
                    }
                }
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        Log.d("Phisher", data)

        val urlsArray = try {
            JSONArray(data)
        } catch (_: Exception) {
            JSONArray().apply { put(data) }
        }

        for (i in 0 until urlsArray.length()) {
            val item = urlsArray.get(i)

            var urlStr: String? = null
            var keyName: String? = null
            var valueStr: String? = null

            when (item) {
                is JSONObject -> {
                    if (item.has("url")) urlStr = item.optString("url").ifEmpty { null }
                    if (item.has("value")) valueStr = item.optString("value").ifEmpty { null }
                    if (item.has("key")) keyName = item.optString("key").ifEmpty { null }
                }

                is String -> {
                    val trimmed = item.trim()
                    if ((trimmed.startsWith("{") && trimmed.endsWith("}")) ||
                        (trimmed.startsWith("[") && trimmed.endsWith("]"))
                    ) {
                        try {
                            val maybeObj = JSONObject(trimmed)
                            if (maybeObj.has("url")) {
                                urlStr = maybeObj.optString("url").ifEmpty { null }
                                keyName = maybeObj.optString("key").ifEmpty { null }
                                valueStr = maybeObj.optString("value").ifEmpty { null }
                            } else {
                                urlStr = item
                            }
                        } catch (_: Exception) {
                            urlStr = item
                        }
                    } else {
                        urlStr = item
                    }
                }

                else -> {
                    // fallback: convert to string
                    urlStr = item.toString()
                }
            }

            if (urlStr.isNullOrEmpty() && !valueStr.isNullOrEmpty() && valueStr.startsWith(
                    "http",
                    ignoreCase = true
                )
            ) {
                urlStr = valueStr
            }

            val serverName =  "Server ${i + 1}"

            val quality = inferQuality(urlStr, keyName, valueStr)

            val finalUrl = urlStr ?: continue

            callback.invoke(
                newExtractorLink(
                    serverName,
                    serverName,
                    url = finalUrl,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = quality
                }
            )
        }

        return true
    }

    /**
     * Infer quality by checking url first, then key, then value.
     * Returns Qualities.*.value or Qualities.Unknown.value when not determinable.
     */
    fun inferQuality(url: String?, key: String?, value: String?): Int {
        fun matchQualityFromString(s: String?): Int {
            if (s == null) return Qualities.Unknown.value
            val lower = s.lowercase()
            return when {
                lower.contains("2160") || lower.contains("4k") -> Qualities.P2160.value
                lower.contains("1080") -> Qualities.P1080.value
                lower.contains("720") -> Qualities.P720.value
                lower.contains("480") -> Qualities.P480.value
                lower.contains("360") -> Qualities.P360.value
                lower.contains("hd") && lower.contains("1080") -> Qualities.P1080.value
                lower.contains("hd") && lower.contains("720") -> Qualities.P720.value
                else -> Qualities.Unknown.value
            }
        }

        // 1) Try from URL
        val qFromUrl = matchQualityFromString(url)
        if (qFromUrl != Qualities.Unknown.value) return qFromUrl

        // 2) Try from key (e.g., "4s1", "480p", "1080p", "4k")
        val qFromKey = matchQualityFromString(key)
        if (qFromKey != Qualities.Unknown.value) return qFromKey

        // 3) Try from value (sometimes key="480p" and value="TRUE", or value might contain the link)
        val qFromValue = matchQualityFromString(value)
        if (qFromValue != Qualities.Unknown.value) return qFromValue

        // 4) Default unknown
        return Qualities.Unknown.value
    }
}





================================================
FILE: RingZ/src/main/kotlin/com/RingZ/RingZParser.kt
================================================
package com.RingZ

data class LoadURL(
    val url: String?=null ,
    val title: String?=null,
    val id: String?=null,
    val posterUrl: String?=null,
    val trailer: String?=null,
    val quality: String?=null,
    val language: String?=null,
    val type: String?=null,
    val category: String?=null,
    val genre: String?=null,
    val extra: String? = null
)



================================================
FILE: RingZ/src/main/kotlin/com/RingZ/RingZProvider.kt
================================================
package com.RingZ

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class RingZProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(RingZ())
    }
}


================================================
FILE: RingZ/src/main/kotlin/com/RingZ/Utils.kt
================================================
package com.RingZ

import android.util.Log
import com.RingZ.RingZ.Companion.headers
import com.lagradost.cloudstream3.app
import org.json.JSONArray
import org.json.JSONObject

object RingzConfigLoader {

    suspend fun fetchPages(
        baseUrlFetch: String,
        baseUrlResult: String,
        configPath: String,
        includeAdult: Boolean,
    ): List<Pair<String, String>> {
        val allowedKeys = listOf(
            "allData",
            "latest",
            "JustAdded",
            "Bollywood",
            "Hollywood",
            "South",
            "Punjabi",
            "Gujarati",
            "Bengali",
            "Marathi",
            "Adult",
            "webseries",
            "desihub",
            "anime",
        )

        return try {
            val configUrl = if (configPath.startsWith("/")) baseUrlFetch.trimEnd('/') + configPath else baseUrlFetch.trimEnd('/') + "/" + configPath

            val jsonText = app.get(configUrl, headers = headers).text

            val array = JSONArray(jsonText)

            var selected: JSONObject? = null
            var highestId = Long.MIN_VALUE

            for (i in 0 until array.length()) {
                val obj = array.getJSONObject(i)
                val idNum = obj.optString("id", "").toLongOrNull()
                if (idNum != null && idNum > highestId) {
                    highestId = idNum
                    selected = obj
                }
                Log.d("Phisher",highestId.toString())

            }
            Log.d("Phisher",selected.toString())

            if (selected == null && array.length() > 0)
                selected = array.getJSONObject(array.length() - 1)

            if (selected == null) return emptyList()

            fun getString(key: String): String? =
                if (selected.has(key) && !selected.isNull(key)) selected.optString(key) else null

            fun resolve(path: String?): String? {
                if (path.isNullOrBlank()) return null
                val p = path.trim()
                return when {
                    p.startsWith("http://", true) || p.startsWith("https://", true) -> p
                    p.startsWith("/") -> baseUrlResult.trimEnd('/') + p
                    else -> baseUrlResult.trimEnd('/') + "/" + p
                }
            }

            val output = mutableListOf<Pair<String, String>>()

            for (key in allowedKeys) {
                val raw = getString(key) ?: continue
                if (!raw.contains(".json", ignoreCase = true)) continue
                if (!includeAdult && raw.contains("desihub", ignoreCase = true)) continue
                if (!includeAdult && raw.contains("adult", ignoreCase = true)) continue
                val resolved = resolve(raw) ?: continue
                output += resolved to key
            }

            val seen = linkedSetOf<String>()
            output.filter { seen.add(it.first) }

        } catch (_: Exception) {
            emptyList()
        }
    }
}


================================================
FILE: ShowFlixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 11


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "HD Provider for all Indian Languages"
    language = "hi"
    authors = listOf("LikDev-256,Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "TvSeries",
        "Movie",
    )
    iconUrl = "https://raw.githubusercontent.com/LikDev-256/likdev256-tamil-providers/master/ShowFlixProvider/icon.png"

    isCrossPlatform = true
}



================================================
FILE: ShowFlixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: ShowFlixProvider/src/main/kotlin/com/phisher98/Extractor.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.FormBody
import org.json.JSONObject
import java.net.URI

open class StreamRuby : VidhideExtractor() {
    override var name = "StreamRuby"
    override var mainUrl = "https://streamruby.com"
    override val requiresReferer = false
}


class Showflixupnshare : VidStack() {
    override var name: String = "VidStack"
    override var mainUrl: String = "https://showflix.upns.one"
}


class Rubyvidhub : VidhideExtractor() {
    override var mainUrl = "https://rubyvidhub.com"
}

class Smoothpre : VidhideExtractor() {
    override var mainUrl = "https://smoothpre.com"
    override var requiresReferer = true
}


class Showflixarchives : ExtractorApi() {
    override val name = "Showflix Archives"
    override val mainUrl = "https://showflix.sbs"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        Log.d("Phisher1 ","I'm here")

        val doc = app.get(url).documentLarge
        val links = doc.select("a[href]")
        Log.d("Phisher1 ","$links")

        for (link in links) {
            val href = link.attr("href")
            Log.d("Phisher1 ",href)

            if ("gdflix" in href || "appdrive" in href || "gdlink" in href) {
                if (href.contains("gdflix", ignoreCase = true) || href.contains("gdlink", ignoreCase = true) ) {
                    GDFlix().getUrl(href, referer, subtitleCallback, callback)
                } else {
                    Driveseed().getUrl(href, referer, subtitleCallback, callback)
                }
            }
        }
    }
}




@Suppress("PARAMETER_NAME_CHANGED_ON_OVERRIDE")
class GDFlix : ExtractorApi() {
    override val name = "GDFlix"
    override val mainUrl = "https://new6.gdflix.dad"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        source: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val newUrl = try {
            app.get(url)
                .documentLarge
                .selectFirst("meta[http-equiv=refresh]")
                ?.attr("content")
                ?.substringAfter("url=")
        } catch (e: Exception) {
            Log.e("Error", "Failed to fetch redirect: ${e.localizedMessage}")
            return
        } ?: url

        val document = app.get(newUrl).documentLarge
        val fileName = document.select("ul > li.list-group-item:contains(Name)").text()
            .substringAfter("Name : ")
        val fileSize = document.select("ul > li.list-group-item:contains(Size)").text()
            .substringAfter("Size : ")

        document.select("div.text-center a").amap { anchor ->
            val text = anchor.select("a").text()

            when {
                text.contains("DIRECT DL",ignoreCase = true) -> {
                    val link = anchor.attr("href")
                    callback.invoke(
                        newExtractorLink("$source GDFlix[Direct]", "$source GDFlix[Direct] [$fileSize]", link) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }

                text.contains("Index Links",ignoreCase = true) -> {
                    try {
                        val link = anchor.attr("href")
                        app.get("https://new6.gdflix.dad$link").documentLarge
                            .select("a.btn.btn-outline-info").amap { btn ->
                                val serverUrl = "https://new6.gdflix.dad" + btn.attr("href")
                                app.get(serverUrl).documentLarge
                                    .select("div.mb-4 > a").amap { sourceAnchor ->
                                        val sourceurl = sourceAnchor.attr("href")
                                        callback.invoke(
                                            newExtractorLink("$source GDFlix[Index]", "$source GDFlix[Index] [$fileSize]", sourceurl) {
                                                this.quality = getIndexQuality(fileName)
                                            }
                                        )
                                    }
                            }
                    } catch (e: Exception) {
                        Log.d("Index Links", e.toString())
                    }
                }

                text.contains("DRIVEBOT",ignoreCase = true) -> {
                    try {
                        val driveLink = anchor.attr("href")
                        val id = driveLink.substringAfter("id=").substringBefore("&")
                        val doId = driveLink.substringAfter("do=").substringBefore("==")
                        val baseUrls = listOf("https://drivebot.sbs", "https://drivebot.cfd")

                        baseUrls.amap { baseUrl ->
                            val indexbotLink = "$baseUrl/download?id=$id&do=$doId"
                            val indexbotResponse = app.get(indexbotLink, timeout = 100L)

                            if (indexbotResponse.isSuccessful) {
                                val cookiesSSID = indexbotResponse.cookies["PHPSESSID"]
                                val indexbotDoc = indexbotResponse.documentLarge

                                val token = Regex("""formData\.append\('token', '([a-f0-9]+)'\)""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val postId = Regex("""fetch\('/download\?id=([a-zA-Z0-9/+]+)'""")
                                    .find(indexbotDoc.toString())?.groupValues?.get(1).orEmpty()

                                val requestBody = FormBody.Builder()
                                    .add("token", token)
                                    .build()

                                val headers = mapOf("Referer" to indexbotLink)
                                val cookies = mapOf("PHPSESSID" to "$cookiesSSID")

                                val downloadLink = app.post(
                                    "$baseUrl/download?id=$postId",
                                    requestBody = requestBody,
                                    headers = headers,
                                    cookies = cookies,
                                    timeout = 100L
                                ).text.let {
                                    Regex("url\":\"(.*?)\"").find(it)?.groupValues?.get(1)?.replace("\\", "").orEmpty()
                                }

                                callback.invoke(
                                    newExtractorLink("$source GDFlix[DriveBot]", "$source GDFlix[DriveBot] [$fileSize]", downloadLink) {
                                        this.referer = baseUrl
                                        this.quality = getIndexQuality(fileName)
                                    }
                                )
                            }
                        }
                    } catch (e: Exception) {
                        Log.d("DriveBot", e.toString())
                    }
                }

                text.contains("Instant DL",ignoreCase = true) -> {
                    try {
                        val instantLink = anchor.attr("href")
                        val link = app.get(instantLink, allowRedirects = false)
                            .headers["location"]?.substringAfter("url=").orEmpty()

                        callback.invoke(
                            newExtractorLink("$source GDFlix[Instant Download]", "$source GDFlix[Instant Download] [$fileSize]", link) {
                                this.quality = getIndexQuality(fileName)
                            }
                        )
                    } catch (e: Exception) {
                        Log.d("Instant DL", e.toString())
                    }
                }

                text.contains("CLOUD DOWNLOAD",ignoreCase = true) -> {
                    callback.invoke(
                        newExtractorLink("$source GDFlix[CLOUD]", "$source GDFlix[CLOUD] [$fileSize]", anchor.attr("href")) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }

                text.contains("GoFile",ignoreCase = true) -> {
                    try {
                        app.get(anchor.attr("href")).documentLarge
                            .select(".row .row a").amap { gofileAnchor ->
                                val link = gofileAnchor.attr("href")
                                if (link.contains("gofile")) {
                                    Gofile().getUrl(link, "", subtitleCallback, callback)
                                }
                            }
                    } catch (e: Exception) {
                        Log.d("Gofile", e.toString())
                    }
                }

                text.contains("PixelDrain",ignoreCase = true) || text.contains("Pixel",ignoreCase = true)-> {
                    callback.invoke(
                        newExtractorLink(
                            "$source GDFlix[Pixeldrain]",
                            "$source GDFlix[Pixeldrain] [$fileSize]",
                            anchor.attr("href"),
                        ) { this.quality = quality }
                    )
                }

                else -> {
                    Log.d("Error", "No Server matched")
                }
            }
        }

        // Cloudflare backup links
        try {
            val types = listOf("type=1", "type=2")
            types.map { type ->
                val sourceurl = app.get("${newUrl.replace("file", "wfile")}?$type")
                    .documentLarge.select("a.btn-success").attr("href")

                if (source?.isNotEmpty() == true) {
                    callback.invoke(
                        newExtractorLink("$source GDFlix[CF]", "$source GDFlix[CF] [$fileSize]", sourceurl) {
                            this.quality = getIndexQuality(fileName)
                        }
                    )
                }
            }
        } catch (e: Exception) {
            Log.d("CF", e.toString())
        }
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}

class Gofile : ExtractorApi() {
    override val name = "Gofile"
    override val mainUrl = "https://gofile.io"
    override val requiresReferer = false
    private val mainApi = "https://api.gofile.io"

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        try {
            val id = Regex("/(?:\\?c=|d/)([\\da-zA-Z-]+)").find(url)?.groupValues?.get(1) ?: return
            val responseText = app.post("$mainApi/accounts").text
            val json = JSONObject(responseText)
            val token = json.getJSONObject("data").getString("token")

            val globalJs = app.get("$mainUrl/dist/js/global.js").text
            val wt = Regex("""appdata\.wt\s*=\s*["']([^"']+)["']""")
                .find(globalJs)?.groupValues?.getOrNull(1) ?: return

            val responseTextfile = app.get(
                "$mainApi/contents/$id?wt=$wt",
                headers = mapOf("Authorization" to "Bearer $token")
            ).text

            val fileDataJson = JSONObject(responseTextfile)

            val data = fileDataJson.getJSONObject("data")
            val children = data.getJSONObject("children")
            val firstFileId = children.keys().asSequence().first()
            val fileObj = children.getJSONObject(firstFileId)

            val link = fileObj.getString("link")
            val fileName = fileObj.getString("name")
            val fileSize = fileObj.getLong("size")

            val sizeFormatted = if (fileSize < 1024L * 1024 * 1024) {
                "%.2f MB".format(fileSize / 1024.0 / 1024)
            } else {
                "%.2f GB".format(fileSize / 1024.0 / 1024 / 1024)
            }

            callback.invoke(
                newExtractorLink(
                    "Gofile",
                    "Gofile [$sizeFormatted]",
                    link
                ) {
                    this.quality = getQuality(fileName)
                    this.headers = mapOf("Cookie" to "accountToken=$token")
                }
            )
        } catch (e: Exception) {
            Log.e("Gofile", "Error occurred: ${e.message}")
        }
    }

    private fun getQuality(fileName: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(fileName ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }
}

open class Driveseed : ExtractorApi() {
    override val name: String = "Driveseed"
    override val mainUrl: String = "https://driveseed.org"
    override val requiresReferer = false

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }

    private suspend fun CFType1(url: String): List<String> {
        return runCatching {
            app.get("$url?type=1").documentLarge
                .select("a.btn-success")
                .mapNotNull { it.attr("href").takeIf { href -> href.startsWith("http") } }
        }.getOrElse {
            Log.e("Driveseed", "CFType1 error: ${it.message}")
            emptyList()
        }
    }

    private suspend fun resumeCloudLink(baseUrl: String, path: String): String? {
        return runCatching {
            app.get(baseUrl + path).documentLarge
                .selectFirst("a.btn-success")?.attr("href")
                ?.takeIf { it.startsWith("http") }
        }.getOrElse {
            Log.e("Driveseed", "ResumeCloud error: ${it.message}")
            null
        }
    }

    private suspend fun resumeBot(url: String): String? {
        return runCatching {
            val response = app.get(url)
            val docString = response.documentLarge.toString()
            val ssid = response.cookies["PHPSESSID"].orEmpty()
            val token = Regex("formData\\.append\\('token', '([a-f0-9]+)'\\)").find(docString)?.groupValues?.getOrNull(1).orEmpty()
            val path = Regex("fetch\\('/download\\?id=([a-zA-Z0-9/+]+)'").find(docString)?.groupValues?.getOrNull(1).orEmpty()
            val baseUrl = url.substringBefore("/download")

            if (token.isEmpty() || path.isEmpty()) return@runCatching null

            val json = app.post(
                "$baseUrl/download?id=$path",
                requestBody = FormBody.Builder().addEncoded("token", token).build(),
                headers = mapOf("Accept" to "*/*", "Origin" to baseUrl, "Sec-Fetch-Site" to "same-origin"),
                cookies = mapOf("PHPSESSID" to ssid),
                referer = url
            ).text

            JSONObject(json).getString("url").takeIf { it.startsWith("http") }
        }.getOrElse {
            Log.e("Driveseed", "ResumeBot error: ${it.message}")
            null
        }
    }

    private suspend fun instantLink(finallink: String): String? {
        return runCatching {
            val uri = URI(finallink)
            val host = uri.host ?: if (finallink.contains("video-leech")) "video-leech.pro" else "video-seed.pro"
            val token = finallink.substringAfter("url=")
            val response = app.post(
                "https://$host/api",
                data = mapOf("keys" to token),
                referer = finallink,
                headers = mapOf("x-token" to host)
            ).text

            response.substringAfter("url\":\"")
                .substringBefore("\",\"name")
                .replace("\\/", "/")
                .takeIf { it.startsWith("http") }
        }.getOrElse {
            Log.e("Driveseed", "InstantLink error: ${it.message}")
            null
        }
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val Basedomain = getBaseUrl(url)

        val document = try {
            if (url.contains("r?key=")) {
                val temp = app.get(url).documentLarge.selectFirst("script")
                    ?.data()
                    ?.substringAfter("replace(\"")
                    ?.substringBefore("\")")
                    .orEmpty()
                app.get(mainUrl + temp).documentLarge
            } else {
                app.get(url).documentLarge
            }
        } catch (e: Exception) {
            Log.e("Driveseed", "getUrl page load error: ${e.message}")
            return
        }

        val qualityText = document.selectFirst("li.list-group-item")?.text().orEmpty()
        val rawFileName = qualityText.replace("Name : ", "").trim()
        val fileName = cleanTitle(rawFileName)
        val size = document.selectFirst("li:nth-child(3)")?.text().orEmpty().replace("Size : ", "").trim()

        val labelExtras = buildString {
            if (fileName.isNotEmpty()) append("[$fileName]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("div.text-center > a").forEach { element ->
            val text = element.text()
            val href = element.attr("href")
            Log.d("Driveseed", "Link: $href")

            if (href.isNotBlank()) {
                when {
                    text.contains("Instant Download", ignoreCase = true) -> {
                        instantLink(href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name Instant(Download) $labelExtras",
                                    "$name Instant(Download) $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Resume Worker Bot", ignoreCase = true) -> {
                        resumeBot(href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name ResumeBot(VLC) $labelExtras",
                                    "$name ResumeBot(VLC) $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Direct Links", ignoreCase = true) -> {
                        CFType1(Basedomain + href).forEach { link ->
                            callback(
                                newExtractorLink(
                                    "$name CF Type1 $labelExtras",
                                    "$name CF Type1 $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Resume Cloud", ignoreCase = true) -> {
                        resumeCloudLink(Basedomain, href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name ResumeCloud $labelExtras",
                                    "$name ResumeCloud $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }
                }
            }
        }
    }
    private fun getBaseUrl(url: String): String {
        return URI(url).let { "${it.scheme}://${it.host}" }
    }
}

fun cleanTitle(title: String): String {
    val parts = title.split(".", "-", "_")

    val qualityTags = listOf(
        "WEBRip", "WEB-DL", "WEB", "BluRay", "HDRip", "DVDRip", "HDTV",
        "CAM", "TS", "R5", "DVDScr", "BRRip", "BDRip", "DVD", "PDTV",
        "HD"
    )

    val audioTags = listOf(
        "AAC", "AC3", "DTS", "MP3", "FLAC", "DD5", "EAC3", "Atmos"
    )

    val subTags = listOf(
        "ESub", "ESubs", "Subs", "MultiSub", "NoSub", "EnglishSub", "HindiSub"
    )

    val codecTags = listOf(
        "x264", "x265", "H264", "HEVC", "AVC"
    )

    val startIndex = parts.indexOfFirst { part ->
        qualityTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    val endIndex = parts.indexOfLast { part ->
        subTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                audioTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                codecTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    return if (startIndex != -1 && endIndex != -1 && endIndex >= startIndex) {
        parts.subList(startIndex, endIndex + 1).joinToString(".")
    } else if (startIndex != -1) {
        parts.subList(startIndex, parts.size).joinToString(".")
    } else {
        parts.takeLast(3).joinToString(".")
    }
}



================================================
FILE: ShowFlixProvider/src/main/kotlin/com/phisher98/ShowFlixParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty

data class Season(val objectId: String, val name: String)

data class SeasonResult(val results: List<Season>)

data class EpisodeResult(
    val results: List<EpisodeDetails>
)

data class EpisodeDetails(
    val objectId: String,
    val name: String?,
    val seasonId: String?,
    val seasonNumber: String?,
    val episodeNumber: Int,
    val embedLinks: EmbedLinks?,
    val createdAt: String?,
    val updatedAt: String?
)

data class EmbedLinks(
    val streamruby: String?,
    val upnshare: String?,
    val streamwish: String?,
    val vihide: String?
)


data class Loadlinks(
    val streamruby: String,
    val upnshare: String,
    val streamwish: String,
    val vihide: String,
    val hdlink: String?,
    @JsonProperty("originalURL")
    val originalUrl: String?,
    val drive: String?,
    val goFile: String?,
    val hubCloudLink: String?
)


================================================
FILE: ShowFlixProvider/src/main/kotlin/com/phisher98/ShowFlixProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.*
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.lagradost.nicehttp.NiceResponse
import com.lagradost.nicehttp.RequestBodyTypes
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import me.xdrop.fuzzywuzzy.FuzzySearch
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody

class ShowFlixProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://showflix.store"
    override var name = "ShowFlix"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    private val installationID = "60f6b1a7-8860-4edf-b255-6bc465b6c704"


    data class TVAll(
        @JsonProperty("results") var results: List<TVResult> = listOf()
    )

    data class TVResult(
        @JsonProperty("objectId") var objectId: String,
        @JsonProperty("name") var name: String,
        @JsonProperty("posterURL") var posterURL: String?,
        @JsonProperty("releaseYear") var releaseYear: Int?,
        @JsonProperty("backdropURL") var backdropURL: String?,
        @JsonProperty("genres") var genres: List<String> = listOf(),
        @JsonProperty("storyline") var storyline: String?,
        @JsonProperty("rating") var rating: String?,
        @JsonProperty("tmdbId") var tmdbId: Int?,
        @JsonProperty("hdLink") var hdLink: String?,
        @JsonProperty("hubCloudLink") var hubCloudLink: String?,
        @JsonProperty("languages") var languages: List<String> = listOf(),
        @JsonProperty("createdAt") var createdAt: String?,
        @JsonProperty("updatedAt") var updatedAt: String?,
        @JsonProperty("seriesCategory") var seriesCategory: String?,

        )


    data class MovieAll(
        @JsonProperty("results") var results: List<MovieResults> = emptyList()
    )

    data class MovieResults(
        @JsonProperty("objectId") val objectId: String? = null,
        @JsonProperty("name") val name: String,
        @JsonProperty("posterURL") val posterURL: String? = null,
        @JsonProperty("releaseYear") val releaseYear: Int? = null,
        @JsonProperty("backdropURL") val backdropURL: String? = null,
        @JsonProperty("genres") val genres: List<String>? = null,
        @JsonProperty("storyline") val storyline: String? = null,
        @JsonProperty("rating") val rating: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("embedLinks") val embedLinks: EmbedLinks? = null,
        @JsonProperty("hdLink") val hdLink: String? = null,
        @JsonProperty("hubCloudLink") val hubCloudLink: String? = null,
        @JsonProperty("languages") val languages: List<String>? = null,
        @JsonProperty("originalURL") val originalURL: String? = null,
        @JsonProperty("goFile") val goFile: String? = null,
        //Remove Category not Needed for Fix Recommendation
        @JsonProperty("category") val category: String? = null,
        @JsonProperty("drive") val drive: String? = null,
        @JsonProperty("createdAt") val createdAt: String? = null,
        @JsonProperty("updatedAt") val updatedAt: String? = null
    )

    data class EmbedLinks(
        @JsonProperty("upnshare") val upnshare: String? = null,
        @JsonProperty("streamruby") val streamruby: String? = null,
        @JsonProperty("streamwish") val streamwish: String? = null,
        @JsonProperty("vihide") val vihide: String? = null
    )


    data class MovieLinks(
        @JsonProperty("streamruby") var streamRuby: String? = null,
        @JsonProperty("upnshare") var upnshare: String? = null,
        @JsonProperty("streamwish") var streamWish: String? = null,
        @JsonProperty("vihide") var vihide: String? = null,
        @JsonProperty("hdlink") var hdLink: String? = null,
        @JsonProperty("originalURL") var originalURL: String? = null,
        @JsonProperty("drive") var drive: String? = null,
        @JsonProperty("goFile") var goFile: String? = null,
        @JsonProperty("hubCloudLink") var hubCloudLink: String? = null
    )


    private val MovieapiUrl = "https://parse.showflix.sbs/parse/classes/moviesv2"
    private val TVapiUrl    = "https://parse.showflix.sbs/parse/classes/seriesv2"
    private val Api = "https://parse.showflix.sbs/parse/classes"

    private suspend fun queryMovieApi(query: String): NiceResponse {

        val req = (if (query.isBlank()) """{"where":{},"limit":20,"order":"-createdAt","count":1,"_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""" else """{"where":{"languages":{"${"$"}in":["$query"]}},"limit":20,"order":"-createdAt","_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""").toRequestBody("text/plain".toMediaTypeOrNull())
        return app.post(
            MovieapiUrl,
            requestBody = req,
            referer = "$mainUrl/"
        )
    }

    private suspend fun queryTVApi(query: String): NiceResponse {
        val req = (if (query.isBlank()) """{"where":{},"limit":20,"order":"-createdAt","count":1,"_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""" else """{"where":{"languages":{"${"$"}in":["$query"]}},"limit":20,"order":"-createdAt","_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""").toRequestBody("text/plain".toMediaTypeOrNull())
        return app.post(
            TVapiUrl,
            requestBody = req,
            referer = "$mainUrl/"
        )
    }

    private val trendingMovies = "Trending Movies"
    private val tamilMovies = "Tamil Movies"
    private val dubbedMovies = "Dubbed Movies"
    private val englishMovies = "English Movies"
    private val teluguMovies = "Telugu Movies"
    private val hindiMovies = "Hindi Movies"
    private val malayalamMovies = "Malayalam Movies"

    private val trendingShows = "Trending Shows"
    private val tamilShows = "Tamil Shows"
    private val dubbedShows = "Dubbed Shows"
    private val englishShows = "English Shows"
    private val teluguShows = "Telugu Shows"
    private val hindiShows = "Hindi Shows"
    private val malayalamShows = "Malayalam Shows"

    override val mainPage = mainPageOf(
        "" to trendingMovies,
        """Tamil""" to tamilMovies,
        """Tamil Dubbed""" to dubbedMovies,
        """English""" to englishMovies,
        """Telugu""" to teluguMovies,
        """Hindi""" to hindiMovies,
        """Malayalam""" to malayalamMovies,
        //TV Shows
        "" to trendingShows,
        """Tamil""" to tamilShows,
        """Tamil Dubbed""" to dubbedShows,
        """English""" to englishShows,
        """Telugu""" to teluguShows,
        """Hindi""" to hindiShows,
        """Malayalam""" to malayalamShows
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val elements = ArrayList<HomePageList>()
        val query = request.data.format(page)
        val Movielist = queryMovieApi(
            query
        ).parsed<MovieAll>().results

        val TVlist = queryTVApi(
            query
        ).parsed<TVAll>().results
        if (request.name.contains("Movies")) {
            val home =
                Movielist.map {
                    newMovieSearchResponse(
                        it.name,
                        "$mainUrl/movie/${it.objectId}",
                        TvType.Movie
                    ) {
                        this.posterUrl = it.posterURL
                        this.quality = SearchQuality.HD
                    }
                }
            elements.add(HomePageList(request.name, home))
        } else {
            val home =
                TVlist.map {
                    newTvSeriesSearchResponse(
                        it.name,
                        "$mainUrl/series/${it.objectId}",
                        TvType.TvSeries
                    ) {
                        this.posterUrl = it.posterURL
                        this.quality = SearchQuality.HD
                    }
                }
            elements.add(HomePageList(request.name, home))
        }
        return newHomePageResponse(elements, hasNext = true)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val MovieSearchreq = """{"where":{"name":{"${"$"}regex":"$query","${"$"}options":"i"}},"order":"-createdAt","_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""".toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())
        val TVSearchreq = """{"where":{"name":{"${"$"}regex":"$query","${"$"}options":"i"}},"order":"-createdAt","_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""".toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val MovieResults =
            app.post(MovieapiUrl, requestBody = MovieSearchreq, referer = "$mainUrl/")
                .parsed<MovieAll>().results

        val TVResults = app.post(TVapiUrl, requestBody = TVSearchreq, referer = "$mainUrl/")
            .parsed<TVAll>().results

        val Movies = MovieResults.map {
            newMovieSearchResponse(
                it.name,
                "$mainUrl/movie/${it.objectId}",
                TvType.Movie
            ) {
                this.posterUrl = it.posterURL
                this.quality = SearchQuality.HD
            }
        }
        val TVSeries = TVResults.map {
            newTvSeriesSearchResponse(
                it.name,
                "$mainUrl/series/${it.objectId}",
                TvType.TvSeries
            ) {
                this.posterUrl = it.posterURL
                this.quality = SearchQuality.HD
            }
        }
        val merge = Movies + TVSeries
        return merge.sortedBy { -FuzzySearch.partialRatio(it.name.replace("(\\()+(.*)+(\\))".toRegex(), "").lowercase(), query.lowercase()) }
    }

    override suspend fun load(url: String): LoadResponse {
        if (url.contains("movie")) {
            val MovieobjID = url.removePrefix("$mainUrl/movie/")
            val MovieLoadreq = """{"where":{"objectId":"$MovieobjID"},"limit":1,"_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"60f6b1a7-8860-4edf-b255-6bc465b6c704"}""".toRequestBody("text/plain".toMediaTypeOrNull())
            val data = app.post(MovieapiUrl, requestBody = MovieLoadreq, referer = "$mainUrl/").toString()

            val Movieresp = tryParseJson<MovieAll>(data)?.results
            val Movieit = Movieresp?.firstOrNull() ?: error("No movie found")

            val title = Movieit.name
            val yearRegex = Regex("""\((\d{4})\)""")
            val year = yearRegex.find(title)?.groupValues?.get(1)?.toIntOrNull()

            val poster = Movieit.posterURL
            val backdrop = Movieit.backdropURL
            val plot = Movieit.storyline
            val rating = Movieit.rating

            val recQuery = when {
                Movieit.category?.contains("Dubbed", ignoreCase = true) == true    -> "Tamil Dubbed"
                Movieit.category?.contains("Tamil", ignoreCase = true) == true     -> "Tamil"
                Movieit.category?.contains("English", ignoreCase = true) == true   -> "English"
                Movieit.category?.contains("Hindi", ignoreCase = true) == true     -> "Hindi"
                Movieit.category?.contains("Malayalam", ignoreCase = true) == true -> "Malayalam"
                else -> ""
            }
            val recommendations = queryMovieApi(
                recQuery
            ).parsed<MovieAll>().results.map{
                newMovieSearchResponse(
                    it.name,
                    "$mainUrl/movie/${it.objectId}",
                    TvType.Movie
                ) {
                    this.posterUrl = it.posterURL
                    this.quality = SearchQuality.HD
                }
            }

            return newMovieLoadResponse(
                title,
                "$mainUrl/movie/${Movieit.objectId}",
                TvType.Movie,
                MovieLinks(
                    Movieit.embedLinks?.streamruby,
                    Movieit.embedLinks?.upnshare,
                    Movieit.embedLinks?.streamwish,
                    Movieit.embedLinks?.vihide,
                    Movieit.hdLink,
                    Movieit.originalURL,
                    Movieit.drive,
                    Movieit.goFile,
                    Movieit.hubCloudLink,
                ).toJson()
            ) {
                this.posterUrl = poster
                this.year = year
                this.plot = plot
                this.score = Score.from10(rating)
                this.backgroundPosterUrl = backdrop
                this.recommendations = recommendations
            }
        } else {
            val TVobjID =
                url.removePrefix("$mainUrl/series/")
            val TVLoadreq =
                """{"where":{"objectId":"$TVobjID"},"limit":1,"_method":"GET","_ApplicationId":"SHOWFLIXAPPID","_JavaScriptKey":"SHOWFLIXMASTERKEY","_ClientVersion":"js3.4.1","_InstallationId":"$installationID"}""".toRequestBody(
                    RequestBodyTypes.JSON.toMediaTypeOrNull()
                )
            val TVresp = app.post(TVapiUrl, requestBody = TVLoadreq, referer = "$mainUrl/")
                .toString().removePrefix("""{"results":[""").removeSuffix("]}")
            val TVit = parseJson<TVResult>(TVresp)
            val title = TVit.name
            val yearRegex = Regex("(?<=\\()[\\d(\\]]+(?!=\\))")
            val year = yearRegex.find(title)?.value
                ?.toIntOrNull()
            val poster = TVit.posterURL
            val backdrop = TVit.backdropURL
            val plot = TVit.storyline
            val rating = TVit.rating
            val recQuery = when(TVit.seriesCategory != null) {
                TVit.seriesCategory.toString().contains("Dubbed")    -> """Tamil Dubbed"""
                TVit.seriesCategory.toString().contains("Tamil")     -> """Tamil"""
                TVit.seriesCategory.toString().contains("English")   -> """English"""
                TVit.seriesCategory.toString().contains("Hindi")     -> """Hindi"""
                TVit.seriesCategory.toString().contains("Malayalam") -> """Malayalam"""
                else -> ""
            }
            val recommendations = queryTVApi(
                recQuery
            ).parsed<TVAll>().results.map {
                newTvSeriesSearchResponse(
                    it.name,
                    "$mainUrl/series/${it.objectId}",
                    TvType.TvSeries
                ) {
                    this.posterUrl = it.posterURL
                    this.quality = SearchQuality.HD
                }
            }
            val seriesId = TVit.objectId
            val result = getSeasonsWithEpisodes(seriesId)
            val episodes = result.map { (seasonName, episodes) ->
                val seasonNum = Regex("\\d+").find(seasonName)?.value?.toInt()
                episodes.mapIndexed { _, data ->
                    val linksJson = MovieLinks(
                        data.embedLinks?.streamruby,
                        data.embedLinks?.upnshare,
                        data.embedLinks?.streamwish,
                        data.embedLinks?.vihide,
                    ).toJson()

                    newEpisode(linksJson) {
                        this.season = seasonNum
                        this.episode = data.episodeNumber
                        this.posterUrl = backdrop
                    }
                }.filter { it.episode != 0 }
            }.flatten()

            return newTvSeriesLoadResponse(
                title,
                "$mainUrl/series/${TVit.objectId}",
                TvType.TvSeries,
                episodes
            ) {
                this.posterUrl = poster
                this.year = year
                this.plot = plot
                this.score = Score.from10(rating)
                this.backgroundPosterUrl = backdrop
                this.recommendations = recommendations
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val root: Loadlinks? = tryParseJson<Loadlinks>(data)
        val urls = root?.toEmbedUrls()
        urls?.amap { iframe ->
            if (iframe.contains(".mkv"))
            {
                callback.invoke(
                    newExtractorLink(
                        name,
                        name,
                        iframe,
                        INFER_TYPE
                    )
                    {
                        this.referer=url
                        this.quality= Qualities.P1080.value
                        this.headers=headers

                    }
                )
            }
            loadSourceNameExtractor(
                "Showflix ",
                iframe,
                "",
                subtitleCallback,
                callback
            )
        }
        return true
    }

    private suspend fun getSeasonsWithEpisodes(seriesId: String): List<Pair<String, List<EpisodeDetails>>> {
        val seasonRequest = """
        {
            "where": {"seriesId": "$seriesId"},
            "_method": "GET",
            "_ApplicationId": "SHOWFLIXAPPID",
            "_JavaScriptKey": "SHOWFLIXMASTERKEY",
            "_ClientVersion": "js3.4.1",
            "_InstallationId": "60f6b1a7-8860-4edf-b255-6bc465b6c704"
        }
    """.trimIndent().toRequestBody("text/plain".toMediaTypeOrNull())

        val seasonResponseText = app.post("$Api/seasonv2", requestBody = seasonRequest, referer = "https://showflix.store/").toString()
        val seasonResult = parseJson<SeasonResult>(seasonResponseText)

        val allSeasons = mutableListOf<Pair<String, List<EpisodeDetails>>>()

        for (season in seasonResult.results) {
            val episodeRequest = """
            {
                "where": {"seasonId": "${season.objectId}"},
                "_method": "GET",
                "_ApplicationId": "SHOWFLIXAPPID",
                "_JavaScriptKey": "SHOWFLIXMASTERKEY",
                "_ClientVersion": "js3.4.1",
                "_InstallationId": "60f6b1a7-8860-4edf-b255-6bc465b6c704"
            }
        """.trimIndent().toRequestBody("text/plain".toMediaTypeOrNull())

            val episodeResponseText = app.post("$Api/episodev2", requestBody = episodeRequest, referer = "https://showflix.store/").toString()
            val episodeResult = parseJson<EpisodeResult>(episodeResponseText)

            val episodes = episodeResult.results.map {
                EpisodeDetails(
                    objectId = it.objectId,
                    name = it.name,
                    seasonId = it.seasonId,
                    seasonNumber = it.seasonNumber,
                    episodeNumber = it.episodeNumber,
                    embedLinks = it.embedLinks,
                    createdAt = it.createdAt,
                    updatedAt = it.updatedAt
                )
            }
            allSeasons.add(season.name to episodes)
        }
        return allSeasons
    }

    private fun Loadlinks.toEmbedUrls(): List<String> {
        return listOfNotNull(
            streamwish.takeIf { it.isNotBlank() }?.let { "https://embedwish.com/e/$it" },
            streamruby.takeIf { it.isNotBlank() }?.let { "https://rubyvidhub.com/embed-$it.html" },
            upnshare.takeIf { it.isNotBlank() }?.let { "https://showflix.upns.one/#$it" },
            vihide.takeIf { it.isNotBlank() }?.let { "https://smoothpre.com/v/$it.html" },
            originalUrl,
            hdlink
        )
    }
}


suspend fun loadSourceNameExtractor(
    source: String,
    url: String,
    referer: String? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit,
) {
    loadExtractor(url, referer, subtitleCallback) { link ->
        CoroutineScope(Dispatchers.IO).launch {
            callback.invoke(
                newExtractorLink(
                    "$source[${link.source}]",
                    "$source[${link.source}]",
                    link.url,
                ) {
                    this.quality = link.quality
                    this.type = link.type
                    this.referer = link.referer
                    this.headers = link.headers
                    this.extractorData = link.extractorData
                }
            )
        }
    }
}


================================================
FILE: ShowFlixProvider/src/main/kotlin/com/phisher98/ShowFlixProviderPlugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidHidePro3
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class ShowFlixProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(ShowFlixProvider())
        registerExtractorAPI(StreamWishExtractor())
        registerExtractorAPI(VidHidePro3())
        registerExtractorAPI(StreamRuby())
        registerExtractorAPI(Showflixupnshare())
        registerExtractorAPI(Rubyvidhub())
        registerExtractorAPI(Smoothpre())
        registerExtractorAPI(Showflixarchives())
    }
}



================================================
FILE: Streamblasters/build.gradle.kts
================================================
// use an integer for version numbers
version = 8


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Streamblasters Multi Language"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie,TvSeries")

    iconUrl="https://raw.githubusercontent.com/phisher98/cloudstream-extensions-phisher/refs/heads/master/Telugumv/faviconV2.png"

    isCrossPlatform = true
}



================================================
FILE: Streamblasters/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Streamblasters/src/main/kotlin/com/Streamblasters/Extractors.kt
================================================
package com.Streamblasters

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.extractors.DoodLaExtractor
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8
import com.lagradost.cloudstream3.utils.fixUrl
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.getPacked


class D000d : DoodLaExtractor() {
    override var mainUrl = "https://dood.li"
}

class swhoi : StreamWishExtractor() {
    override var mainUrl = "https://swhoi.com"
}

class wishonly : StreamWishExtractor() {
    override var mainUrl = "https://wishonly.site"
}

class cybervynx : Filesim() {
    override var mainUrl = "https://cybervynx.com"
}


class mivalyo : VidhideExtractor() {
    override var name = "Mivalyo"
    override var mainUrl = "https://mivalyo.com"
}

class vidhidevip : VidhideExtractor() {
    override var mainUrl = "https://vidhidevip.com"
}

class luluvdoo : VidhideExtractor() {
    override var mainUrl = "https://luluvdoo.com"
}


class smoothpre : VidhideExtractor() {
    override var mainUrl = "https://smoothpre.com"
}

class vidhidepre : VidhideExtractor() {
    override var mainUrl = "https://vidhidepre.com"
}

class ups2up : ExtractorApi() {
    override val name = "VidHidePro"
    override val mainUrl = "https://ups2up.fun"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Origin" to mainUrl,
            "referer" to mainUrl,
        )

        val response = app.get(getEmbedUrl(url), referer = referer)
        val script = if (!getPacked(response.text).isNullOrEmpty()) {
            var result = getAndUnpack(response.text)
            if(result.contains("var links")){
                result = result.substringAfter("var links")
            }
            result
        } else {
            response.documentLarge.selectFirst("script:containsData(sources:)")?.data()
        } ?: return

        // m3u8 urls could be prefixed by 'file:', 'hls2:' or 'hls4:', so we just match ':'
        Regex(":\\s*\"(.*?m3u8.*?)\"").findAll(script).forEach { m3u8Match ->
            generateM3u8(
                name,
                fixUrl(m3u8Match.groupValues[1]),
                referer = "$mainUrl/",
                headers = headers
            ).forEach(callback)
        }
    }

    private fun getEmbedUrl(url: String): String {
        return when {
            url.contains("/d/") -> url.replace("/d/", "/v/")
            url.contains("/download/") -> url.replace("/download/", "/v/")
            url.contains("/file/") -> url.replace("/file/", "/v/")
            else -> url.replace("/f/", "/v/")
        }
    }

}

class jodwish : StreamWishExtractor() {
    override var mainUrl = "https://jodwish.com"
}

class asnwish : StreamWishExtractor() {
    override var mainUrl = "https://asnwish.com"
}

class hglink : ExtractorApi() {
    override var name = "hglink"
    override var mainUrl = "https://Hglink.to"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val response = app.get(url, allowRedirects = false)
        val script = if (!getPacked(response.text).isNullOrEmpty()) {
            var result = getAndUnpack(response.text)
            if(result.contains("var links")){
                result = result.substringAfter("var links")
            }
            result
        } else {
            response.documentLarge.selectFirst("script:containsData(sources:)")?.data()
        } ?: return

        // m3u8 urls could be prefixed by 'file:', 'hls2:' or 'hls4:', so we just match ':'
        Regex(":\\s*\"(.*?m3u8.*?)\"").findAll(script).forEach { m3u8Match ->
            generateM3u8(
                name,
                fixUrl(m3u8Match.groupValues[1]),
                referer = "$mainUrl/",
            ).forEach(callback)
        }
    }
}


================================================
FILE: Streamblasters/src/main/kotlin/com/Streamblasters/Streamblasters.kt
================================================
package com.Streamblasters


import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.*
import org.json.JSONArray

class Streamblasters : MainAPI() {
    override var mainUrl              = "https://www.streamblasters.city"
    override var name                 = "Streamblasters"
    override val hasMainPage          = true
    override var lang                 = "hi"
    override val hasQuickSearch       = true
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie)

    override val mainPage = mainPageOf(
        "" to "Latest",
        "category/hindi" to "Hindi",
        "category/english" to "English",
        "category/tamil" to "Tamil",
        "category/telugu" to "Telugu",
        "category/malayalam" to "Malayalam",
        "category/kannada" to "Kannada",
        "category/web-series" to "Web Series"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page/").documentLarge
        val home     = document.select("div.blog-items > article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.blog-items > article > div > div > div > a").attr("title").trim().replace("Watch Online","")
        val href      = fixUrl(this.select("div.blog-items > article > div > div > div > a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.blog-items > article > div > div > div > a img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/page/$i/?s=$query").documentLarge

            val results = document.select("div.blog-items > article").mapNotNull { it.toSearchResult() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("header.entry-header > h1")?.text()?.trim().toString().replace("Watch Online","")
        var poster = document.select("header.entry-header > header").attr("style").substringAfter("background-image:url(").substringBefore(");").trim()
        if (poster.isEmpty())
        {
            poster="https://img.freepik.com/free-photo/assortment-cinema-elements-red-background-with-copy-space_23-2148457848.jpg?size=626&ext=jpg&ga=GA1.1.2082370165.1716422400&semt=ais_user"
        }
        val href=document.select("div.series-listing > a").map { it.attr("href") }.toList()
        val description = document.selectFirst("div.actor-element > p")?.text()?.trim()
        val trailer = document.selectFirst("div.tmdb-trailer > iframe")?.attr("src")
        val actors = document.select("div.ac-di-content").map {
            Actor(
                it.select("div.ac-di-content > div.post-content > h6").text(),
                it.select("div.ac-di-content > div.post-img > span > img").attr("src")
            )
        }
        val tvType = if (document.select("div.series-listing:contains(Player)").isNotEmpty()) TvType.Movie else TvType.TvSeries
        return if (tvType == TvType.TvSeries) {
            val episodes =
                document.select("div.series-listing > a").mapNotNull {
                    val hreff = it.attr("href")
                    val episode = it.select("span").text()
                    newEpisode(hreff)
                    {
                        this.name=episode
                    }
                }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot = description
            }
        }
        else {
            return newMovieLoadResponse(title, url, TvType.Movie, href) {
                this.posterUrl = poster.ifEmpty {
                    ({
                        posterUrl =
                            "https://www.streamblasters.city/wp-content/uploads/2022/05/cropped-png12.png"
                    }).toString()
                }
                this.plot = description
                addTrailer(trailer)
                addActors(actors)
            }
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        if (data.startsWith("["))
        {
            val servers = JSONArray(data)
            for (i in 0 until servers.length()) {
                val server = servers.getString(i)
                val iframe = app.get(server).documentLarge.select("#player-api-control > iframe").attr("src")
                loadExtractor(iframe, subtitleCallback, callback)
            }
        }
        else
        {
            val iframe= app.get(data).documentLarge
            val server=iframe.selectFirst("#player-api-control > iframe")?.attr("src") ?:""
            loadExtractor(server,server,subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: Streamblasters/src/main/kotlin/com/Streamblasters/StreamblastersProvider.kt
================================================
package com.Streamblasters

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class StreamblastersProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Streamblasters())
        registerExtractorAPI(D000d())
        registerExtractorAPI(jodwish())
        registerExtractorAPI(asnwish())
        registerExtractorAPI(vidhidevip())
        registerExtractorAPI(vidhidepre())
        registerExtractorAPI(swhoi())
        registerExtractorAPI(wishonly())
        registerExtractorAPI(smoothpre())
        registerExtractorAPI(cybervynx())
        registerExtractorAPI(luluvdoo())
        registerExtractorAPI(hglink())
        registerExtractorAPI(mivalyo())
        registerExtractorAPI(ups2up())
    }
}



================================================
FILE: StreamPlay/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties

version = 529

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "TMDB_API", "\"${properties.getProperty("TMDB_API")}\"")
        buildConfigField("String", "CINEMATV_API", "\"${properties.getProperty("CINEMATV_API")}\"")
        buildConfigField("String", "SFMOVIES_API", "\"${properties.getProperty("SFMOVIES_API")}\"")
        buildConfigField("String", "ZSHOW_API", "\"${properties.getProperty("ZSHOW_API")}\"")
        buildConfigField("String", "DUMP_API", "\"${properties.getProperty("DUMP_API")}\"")
        buildConfigField("String", "DUMP_KEY", "\"${properties.getProperty("DUMP_KEY")}\"")
        buildConfigField("String", "CRUNCHYROLL_BASIC_TOKEN", "\"${properties.getProperty("CRUNCHYROLL_BASIC_TOKEN")}\"")
        buildConfigField("String", "CRUNCHYROLL_REFRESH_TOKEN", "\"${properties.getProperty("CRUNCHYROLL_REFRESH_TOKEN")}\"")
        buildConfigField("String", "MOVIE_API", "\"${properties.getProperty("MOVIE_API")}\"")
        buildConfigField("String", "ANICHI_API", "\"${properties.getProperty("ANICHI_API")}\"")
        buildConfigField("String", "Whvx_API", "\"${properties.getProperty("Whvx_API")}\"")
        buildConfigField("String", "CatflixAPI", "\"${properties.getProperty("CatflixAPI")}\"")
        buildConfigField("String", "ConsumetAPI", "\"${properties.getProperty("ConsumetAPI")}\"")
        buildConfigField("String", "FlixHQAPI", "\"${properties.getProperty("FlixHQAPI")}\"")
        buildConfigField("String", "WhvxAPI", "\"${properties.getProperty("WhvxAPI")}\"")
        buildConfigField("String", "WhvxT", "\"${properties.getProperty("WhvxT")}\"")
        buildConfigField("String", "SharmaflixApikey", "\"${properties.getProperty("SharmaflixApikey")}\"")
        buildConfigField("String", "SharmaflixApi", "\"${properties.getProperty("SharmaflixApi")}\"")
        buildConfigField("String", "Theyallsayflix", "\"${properties.getProperty("Theyallsayflix")}\"")
        buildConfigField("String", "GojoAPI", "\"${properties.getProperty("GojoAPI")}\"")
        buildConfigField("String", "HianimeAPI", "\"${properties.getProperty("HianimeAPI")}\"")
        buildConfigField("String", "Vidsrccc", "\"${properties.getProperty("Vidsrccc")}\"")
        buildConfigField("String", "WASMAPI", "\"${properties.getProperty("WASMAPI")}\"")
        buildConfigField("String", "KissKh", "\"${properties.getProperty("KissKh")}\"")
        buildConfigField("String", "KisskhSub", "\"${properties.getProperty("KisskhSub")}\"")
        buildConfigField("String", "SUPERSTREAM_THIRD_API", "\"${properties.getProperty("SUPERSTREAM_THIRD_API")}\"")
        buildConfigField("String", "SUPERSTREAM_FOURTH_API", "\"${properties.getProperty("SUPERSTREAM_FOURTH_API")}\"")
        buildConfigField("String", "SUPERSTREAM_FIRST_API", "\"${properties.getProperty("SUPERSTREAM_FIRST_API")}\"")
        buildConfigField("String", "StreamPlayAPI", "\"${properties.getProperty("StreamPlayAPI")}\"")
        buildConfigField("String", "PROXYAPI", "\"${properties.getProperty("PROXYAPI")}\"")
        buildConfigField("String", "KAISVA", "\"${properties.getProperty("KAISVA")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_ALT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_ALT")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_DEFAULT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_DEFAULT")}\"")
        buildConfigField("String", "KAIMEG", "\"${properties.getProperty("KAIMEG")}\"")
        buildConfigField("String", "KAIDEC", "\"${properties.getProperty("KAIDEC")}\"")
        buildConfigField("String", "KAIENC", "\"${properties.getProperty("KAIENC")}\"")
        buildConfigField("String", "Nuviostreams", "\"${properties.getProperty("Nuviostreams")}\"")
        buildConfigField("String", "VideasyDEC", "\"${properties.getProperty("VideasyDEC")}\"")
        buildConfigField("String", "YFXENC", "\"${properties.getProperty("YFXENC")}\"")
        buildConfigField("String", "YFXDEC", "\"${properties.getProperty("YFXDEC")}\"")
    }
}

dependencies {
    implementation("com.google.android.material:material:1.13.0")
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

     description = "#1 best extention based on MultiAPI"
     authors = listOf("Phisher98", "Hexated")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
        "Cartoon",
        "AnimeMovie"
    )

    iconUrl = "https://i3.wp.com/yt3.googleusercontent.com/ytc/AIdro_nCBArSmvOc6o-k2hTYpLtQMPrKqGtAw_nC20rxm70akA=s900-c-k-c0x00ffffff-no-rj?ssl=1"

    requiresResources = true
    isCrossPlatform = false

}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    implementation("com.google.android.material:material:1.13.0")
    implementation("androidx.browser:browser:1.9.0")
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: StreamPlay/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/ProvidersList.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.StreamPlayExtractor.invokBidsrc
import com.phisher98.StreamPlayExtractor.invokFlixindia
import com.phisher98.StreamPlayExtractor.invoke2embed
import com.phisher98.StreamPlayExtractor.invoke4khdhub
import com.phisher98.StreamPlayExtractor.invokeAllMovieland
import com.phisher98.StreamPlayExtractor.invokeAnimes
import com.phisher98.StreamPlayExtractor.invokeBollyflix
import com.phisher98.StreamPlayExtractor.invokeCinemaOS
import com.phisher98.StreamPlayExtractor.invokeDahmerMovies
import com.phisher98.StreamPlayExtractor.invokeEmbedMaster
import com.phisher98.StreamPlayExtractor.invokeFilm1k
import com.phisher98.StreamPlayExtractor.invokeHdmovie2
import com.phisher98.StreamPlayExtractor.invokeHexa
import com.phisher98.StreamPlayExtractor.invokeHindmoviez
import com.phisher98.StreamPlayExtractor.invokeKimcartoon
import com.phisher98.StreamPlayExtractor.invokeKisskh
import com.phisher98.StreamPlayExtractor.invokeKisskhAsia
import com.phisher98.StreamPlayExtractor.invokeMoflix
import com.phisher98.StreamPlayExtractor.invokeMovieBox
import com.phisher98.StreamPlayExtractor.invokeMoviehubAPI
import com.phisher98.StreamPlayExtractor.invokeMoviesApi
import com.phisher98.StreamPlayExtractor.invokeMoviesdrive
import com.phisher98.StreamPlayExtractor.invokeMoviesmod
import com.phisher98.StreamPlayExtractor.invokeMultiEmbed
import com.phisher98.StreamPlayExtractor.invokeMultimovies
import com.phisher98.StreamPlayExtractor.invokeNepu
import com.phisher98.StreamPlayExtractor.invokeNinetv
import com.phisher98.StreamPlayExtractor.invokeNuvioStreams
import com.phisher98.StreamPlayExtractor.invokePlaydesi
import com.phisher98.StreamPlayExtractor.invokePrimeSrc
import com.phisher98.StreamPlayExtractor.invokeRidomovies
import com.phisher98.StreamPlayExtractor.invokeRiveStream
import com.phisher98.StreamPlayExtractor.invokeShowflix
import com.phisher98.StreamPlayExtractor.invokeSoapy
import com.phisher98.StreamPlayExtractor.invokeSuperstream
import com.phisher98.StreamPlayExtractor.invokeToonstream
import com.phisher98.StreamPlayExtractor.invokeTopMovies
import com.phisher98.StreamPlayExtractor.invokeUhdmovies
import com.phisher98.StreamPlayExtractor.invokeVegamovies
import com.phisher98.StreamPlayExtractor.invokeVidFast
import com.phisher98.StreamPlayExtractor.invokeVidPlus
import com.phisher98.StreamPlayExtractor.invokeVidSrcXyz
import com.phisher98.StreamPlayExtractor.invokeVideasy
import com.phisher98.StreamPlayExtractor.invokeVidlink
import com.phisher98.StreamPlayExtractor.invokeVidsrccc
import com.phisher98.StreamPlayExtractor.invokeVidzee
import com.phisher98.StreamPlayExtractor.invokeWatch32APIHQ
import com.phisher98.StreamPlayExtractor.invokeWatchsomuch
import com.phisher98.StreamPlayExtractor.invokeXDmovies
import com.phisher98.StreamPlayExtractor.invokeYflix
import com.phisher98.StreamPlayExtractor.invokeZoechip
import com.phisher98.StreamPlayExtractor.invokeZshow
import com.phisher98.StreamPlayExtractor.invokecinemacity
import com.phisher98.StreamPlayExtractor.invokehdhub4u
import com.phisher98.StreamPlayExtractor.invokemorph
import com.phisher98.StreamPlayExtractor.invokemp4hydra
import com.phisher98.StreamPlayExtractor.invokevidrock

data class Provider(
    val id: String,
    val name: String,
    val invoke: suspend (
        res: StreamPlay.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        token: String,
        dahmerMoviesAPI: String
    ) -> Unit
)


@RequiresApi(Build.VERSION_CODES.O)
fun buildProviders(): List<Provider> {
    return listOf(
        Provider("uhdmovies", "UHD Movies (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeUhdmovies(res.title, res.year, res.season, res.episode, callback, subtitleCallback)
        },
        Provider("anime", "All Anime Sources") { res, subtitleCallback, callback, _, _ ->
            if (res.isAnime) invokeAnimes(res.title, res.jpTitle, res.date, res.airedDate, res.season, res.episode, subtitleCallback, callback, res.isDub,res.isMovie)
        },
        Provider("vidsrccc", "Vidsrccc") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeVidsrccc(res.id, res.season, res.episode, callback)
        },
        Provider("topmovies", "Top Movies") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeTopMovies(res.imdbId, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("moviesmod", "MoviesMod") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeMoviesmod(res.title,res.imdbId, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("bollyflix", "Bollyflix") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeBollyflix(res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("watchsomuch", "WatchSoMuch") { res, subtitleCallback, _, _, _ ->
            if (!res.isAnime) invokeWatchsomuch(res.imdbId, res.season, res.episode, subtitleCallback)
        },
        Provider("ninetv", "NineTV") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeNinetv(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("ridomovies", "RidoMovies") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeRidomovies(res.id, res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("moviehubapi", "MovieHub API") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeMoviehubAPI(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("allmovieland", "AllMovieland") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeAllMovieland(res.imdbId, res.season, res.episode, callback)
        },
        Provider("multiembed", "MultiEmbed") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeMultiEmbed(res.imdbId, res.season, res.episode, subtitleCallback,callback)
        },
        Provider("vegamovies", "VegaMovies (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isBollywood) invokeVegamovies("VegaMovies",res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("Rogmovies", "RogMovies (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (res.isBollywood) invokeVegamovies("RogMovies",res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("multimovies", "MultiMovies (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeMultimovies(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("2embed", "2Embed") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invoke2embed(res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("zshow", "ZShow") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeZshow(res.title, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("showflix", "ShowFlix (South Indian)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeShowflix(res.title, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("moflix", "Moflix (Multi)") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeMoflix(res.id, res.season, res.episode, callback)
        },
        Provider("zoechip", "ZoeChip") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeZoechip(res.title, res.year, res.season, res.episode, callback)
        },
        Provider("nepu", "Nepu") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeNepu(res.title, res.airedYear ?: res.year, res.season, res.episode, callback)
        },
        Provider("playdesi", "PlayDesi") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokePlaydesi(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("moviesdrive", "MoviesDrive (Multi)") { res, subtitleCallback, callback, _, _ ->
            invokeMoviesdrive(res.title, res.season, res.episode,
                res.imdbId, subtitleCallback, callback)
        },
        Provider("watch32APIHQ", "Watch32 API HQ (English)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeWatch32APIHQ(res.title, res.season, res.episode,
                subtitleCallback, callback)
        },
        Provider("primesrc", "PrimeSrc") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokePrimeSrc(res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("film1k", "Film1k") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeFilm1k(res.title, res.season, res.year, subtitleCallback, callback)
        },
        Provider("superstream", "SuperStream") { res, _, callback, token, _ ->
            if (!res.isAnime && res.imdbId != null) invokeSuperstream(token, res.imdbId, res.season, res.episode, callback)
        },
        Provider("vidsrcxyz", "VidSrcXyz (English)") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeVidSrcXyz(res.imdbId, res.season, res.episode, callback)
        },
        Provider("vidzeeapi", "Vidzee API") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeVidzee(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("4khdhub", "4kHdhub (Multi)") { res, subtitleCallback, callback, _, _ ->
            invoke4khdhub(res.title, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("hdhub4u", "Hdhub4u (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokehdhub4u(res.imdbId, res.title, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("hdmovie2", "Hdmovie2") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeHdmovie2(res.title, res.year,
                res.episode, subtitleCallback, callback)
        },
        Provider("rivestream", "RiveStream") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeRiveStream(res.id, res.season, res.episode, callback)
        },
        Provider("moviebox", "MovieBox (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeMovieBox(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("morph", "Morph") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokemorph(res.title, res.year, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("vidrock", "Vidrock") { res, _, callback, _, _ ->
            if (!res.isAnime) invokevidrock(res.id, res.season, res.episode, callback)
        },
        Provider("soapy", "Soapy") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeSoapy(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("vidlink", "Vidlink") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeVidlink(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("kisskh", "KissKH (Asian Drama)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeKisskh(res.title, res.season, res.episode, res.lastSeason, subtitleCallback, callback)
        },
        Provider("cinemaos", "CinemaOS") { res, _, callback, _, _ ->
            invokeCinemaOS(res.imdbId, res.id, res.title, res.season, res.episode, res.year, callback)
        },
        Provider("dahmermovies", "DahmerMovies") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeDahmerMovies(res.title, res.year, res.season, res.episode, callback)
        },
        Provider("KisskhAsia", "KissKhAsia (Asian Drama)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeKisskhAsia(res.id, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("mp4hydra", "MP4Hydra") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokemp4hydra(res.title, res.year,res.season, res.episode, subtitleCallback, callback)
        },
        Provider("vidfast", "VidFast") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeVidFast(res.id, res.season,res.episode, callback)
        },
        Provider("vidplus", "VidPlus") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeVidPlus(res.id, res.season,res.episode,  callback)
        },
        Provider("toonstream", "Toonstream (Hindi Anime)") { res, subtitleCallback, callback, _, _ ->
            if (res.isAnime || res.isCartoon) invokeToonstream(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("NuvioStreams", "NuvioStreams") { res, _, callback, _, _ ->
            invokeNuvioStreams(res.imdbId, res.season,res.episode,  callback)
        },
        Provider("VidEasy", "VidEasy") { res, subtitleCallback, callback, _, _ ->
            invokeVideasy(res.id, res.imdbId, res.title, res.year, res.season,res.episode,  callback, subtitleCallback)
        },
        Provider("XDMovies", "XDMovies") { res, subtitleCallback, callback, _, _ ->
            invokeXDmovies(res.title,res.id, res.season, res.episode,  callback, subtitleCallback)
        },
        Provider("KimCartoon", "KimCartoon") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeKimcartoon(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("YFlix", "YFlix") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeYflix(res.title, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("moviesapi", "MoviesApi Club") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeMoviesApi(res.id, res.season, res.episode, callback)
        },
        Provider("CinemaCity", "CinemaCity") { res, _, callback, _, _ ->
            invokecinemacity(res.imdbId, res.season,res.episode,  callback)
        },
        Provider("EmbedMaster", "EmbedMaster") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokeEmbedMaster(res.imdbId, res.season, res.episode, subtitleCallback, callback)
        },
        Provider("HexaSU", "HexaSU") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeHexa(res.id, res.season, res.episode, callback)
        },
        Provider("BidSrc", "BidSrc") { res, _, callback, _, _ ->
            if (!res.isAnime) invokBidsrc(res.id, res.season, res.episode, callback)
        },
        Provider("flixindia", "FlixIndia (Multi)") { res, subtitleCallback, callback, _, _ ->
            if (!res.isAnime) invokFlixindia(res.title,res.year, res.season, res.episode, subtitleCallback,callback)
        },
        Provider("Hindmoviez", "HindMoviez (Multi)") { res, _, callback, _, _ ->
            if (!res.isAnime) invokeHindmoviez(res.imdbId, res.season, res.episode,callback)
        },
    )
}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlay.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addKitsuId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import kotlinx.coroutines.sync.withLock
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.StreamPlayExtractor.invokeSubtitleAPI
import com.phisher98.StreamPlayExtractor.invokeWyZIESUBAPI
import kotlinx.coroutines.async
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.withTimeoutOrNull
import org.json.JSONObject
import kotlinx.coroutines.*
open class StreamPlay(val sharedPref: SharedPreferences? = null) : TmdbProvider() {
    override var name = "StreamPlay"
    override val hasMainPage = true
    override val instantLinkLoading = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.Cartoon,
    )

    val token: String? = sharedPref?.getString("token", null)
    val langCode = sharedPref?.getString("tmdb_language_code", "en-US")

    val wpRedisInterceptor by lazy { CloudflareKiller() }

    /** AUTHOR : hexated & Phisher & Code */
    companion object {
        /** TOOLS */
        private const val OFFICIAL_TMDB_URL = "https://api.themoviedb.org/3"
        private const val Cinemeta = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb"
        private const val REMOTE_PROXY_LIST = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Proxylist.txt"
        private const val apiKey = BuildConfig.TMDB_API
        private var currentBaseUrl: String? = null


        private val apiMutex = Mutex() // Prevents race conditions
        private const val TAG = "StreamPlay"

        suspend fun getApiBase(): String {
            currentBaseUrl?.let { return it }
            return apiMutex.withLock {
                currentBaseUrl?.let { return it }

                // 1. Try Official Fast
                if (checkConnectivity(OFFICIAL_TMDB_URL)) {
                    Log.d(TAG, "✅ Using official TMDB API")
                    currentBaseUrl = OFFICIAL_TMDB_URL
                    return OFFICIAL_TMDB_URL
                }

                // 2. Fetch Proxies
                val proxies = fetchProxyList()
                if (proxies.isEmpty()) {
                    Log.e(TAG, "❌ No proxies found, falling back to official")
                    return OFFICIAL_TMDB_URL
                }

                // 3. Parallel Race: Check all proxies at the same time
                val workingProxy = coroutineScope {
                    val deferredChecks = proxies.map { proxy ->
                        async {
                            if (checkConnectivity(proxy)) proxy else null
                        }
                    }
                    deferredChecks.awaitAll().firstOrNull { it != null }
                }

                if (workingProxy != null) {
                    Log.d(TAG, "✅ Switched to proxy: $workingProxy")
                    currentBaseUrl = workingProxy
                    return workingProxy
                }

                // 4. Ultimate Fallback
                Log.e(TAG, "❌ All proxies failed, fallback to official")
                currentBaseUrl = OFFICIAL_TMDB_URL
                OFFICIAL_TMDB_URL
            }
        }

        private suspend fun checkConnectivity(url: String): Boolean {
            val testUrl = "$url/configuration?api_key=$apiKey"

            return withTimeoutOrNull(2000) { // 2s timeout max
                try {
                    val response = app.get(
                        testUrl,
                        timeout = 1500, // Fast socket timeout
                        headers = mapOf("Cache-Control" to "no-cache")
                    )
                    response.code == 200 || response.code == 304
                } catch (_: Exception) {
                    false
                }
            } ?: false
        }

        private suspend fun fetchProxyList(): List<String> = try {
            val response = app.get(REMOTE_PROXY_LIST, timeout = 5000).text
            val json = JSONObject(response)
            val arr = json.getJSONArray("proxies")

            // Convert to list and clean strings
            (0 until arr.length()).map { arr.getString(it).trim().removeSuffix("/") }
                .filter { it.isNotEmpty() }
        } catch (e: Exception) {
            Log.e(TAG, "Error fetching proxy list: ${e.message}")
            emptyList()
        }

        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        private var cachedDomains: DomainsParser? = null

        suspend fun getDomains(forceRefresh: Boolean = false): DomainsParser? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<DomainsParser>()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            return cachedDomains
        }

        const val anilistAPI = "https://graphql.anilist.co"
        const val malsyncAPI = "https://api.malsync.moe"
        const val jikanAPI = "https://api.jikan.moe/v4"

        /** ALL SOURCES */
        const val twoEmbedAPI = "https://www.2embed.cc"
        const val MOVIE_API = BuildConfig.MOVIE_API
        val hianimeAPIs = listOf(
            "https://hianimez.is",
            "https://hianime.to",
            "https://hianime.nz",
            "https://hianime.bz",
            "https://hianime.pe"
        )
        val animekaiAPIs = listOf(
            "https://animekai.im",
            "https://animekai.in",
            "https://animekai.la",
            "https://animekai.nl",
            "https://animekai.vc",
            "https://anikai.to"
        )
        const val MultiEmbedAPI = "https://multiembed.mov"
        const val kissKhAPI = "https://kisskh.ovh"
        const val PlaydesiAPI = "https://playdesi.info"
        const val watchSomuchAPI = "https://watchsomuch.tv" // sub only
        const val nineTvAPI = "https://moviesapi.club"
        const val zshowAPI = BuildConfig.ZSHOW_API
        const val ridomoviesAPI = "https://ridomovies.tv"
        const val allmovielandAPI = "https://allmovieland.io"
        const val vidsrctoAPI = "https://vidsrc.cc"
        const val animetoshoAPI = "https://animetosho.org"
        const val showflixAPI = "https://showflix.store"
        const val moflixAPI = "https://moflix-stream.xyz"
        const val zoechipAPI = "https://www1.zoechip.to"
        const val nepuAPI = "https://nepu.to"
        const val dahmerMoviesAPI = "https://a.111477.xyz"
        const val animepaheAPI = "https://animepahe.si"
        const val SubtitlesAPI = "https://opensubtitles-v3.strem.io"
        const val WyZIESUBAPI = "https://sub.wyzie.ru"
        const val RiveStreamAPI = "https://rivestream.org"
        const val PrimeSrcApi = "https://primesrc.me"
        const val Film1kApi = "https://www.film1k.com"
        const val thrirdAPI = BuildConfig.SUPERSTREAM_THIRD_API
        const val fourthAPI = BuildConfig.SUPERSTREAM_FOURTH_API
        const val KickassAPI = "https://kaa.to"
        const val Vidsrcxyz = "https://vidsrc-embed.su"
        const val Elevenmovies = "https://111movies.com"
        const val Watch32 = "https://watch32.sx"
        const val movieBox= "https://api.inmoviebox.com"
        const val vidrock = "https://vidrock.net"
        const val soapy = "https://soapy.to"
        const val vidlink = "https://vidlink.pro"
        const val cinemaOSApi = "https://cinemaos.tech"
        const val mappleTvApi = "https://mapple.uk"
        const val mp4hydra = "https://mp4hydra.org"
        const val vidfastProApi = "https://vidfast.pro"
        const val vidPlusApi = "https://player.vidplus.to"
        const val Videasy = "https://api.videasy.net"
        const val XDmoviesAPI = "https://new.xdmovies.wtf"
        const val kimcartoonAPI = "https://kimcartoon.si"
        const val yFlix = "https://yflix.to"
        const val moviesClubApi = "https://moviesapi.club"
        const val cinemacity = "https://cinemacity.cc"
        const val embedmaster = "https://embedmaster.link"
        const val hexaSU = "https://themoviedb.hexa.su"
        const val bidSrc = "https://bidsrc.pro"
        const val flixindia = "https://m.flixindia.xyz"
        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }


    }

    override val mainPage = mainPageOf(
        "/trending/all/day?api_key=$apiKey&region=US" to "Trending",
        "/trending/movie/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular Movies",
        "/trending/tv/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows",
        "/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows",
        "/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix",
        "/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon",
        "/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+",
        "/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu",
        "/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+",
        "/discover/tv?api_key=$apiKey&with_networks=49" to "HBO",
        "/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+",
        "/discover/tv?api_key=$apiKey&with_networks=3353" to "Peacock",
        "/discover/movie?api_key=$apiKey&language=en-US&page=1&sort_by=popularity.desc&with_origin_country=IN&release_date.gte=${getDate().lastWeekStart}&release_date.lte=${getDate().today}" to "Trending Indian Movies",
        "/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().today}&air_date.gte=${getDate().today}" to "Airing Today Anime",
        "/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().nextWeek}&air_date.gte=${getDate().today}" to "On The Air Anime",
        "/discover/movie?api_key=$apiKey&with_keywords=210024|222243" to "Anime Movies",
        "/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies",
        "/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows",
        "/discover/tv?api_key=$apiKey&with_original_language=ko" to "Korean Shows",
        "/discover/tv?api_key=$apiKey&with_genres=99" to "Documentary",
    )

    private fun getImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val tmdbAPI =getApiBase()
        val adultQuery =
            if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669"
        val type = if (request.data.contains("/movie")) "movie" else "tv"
        val home = app.get("$tmdbAPI${request.data}$adultQuery&language=$langCode&page=$page", timeout = 10000)
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse(type)
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath)
            this.score= Score.from10(voteAverage)
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        val tmdbAPI = getApiBase()
        return app.get("$tmdbAPI/search/multi?api_key=$apiKey&language=$langCode&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse()
            }?.toNewSearchResponseList()
    }

    override suspend fun load(url: String): LoadResponse? {
        val tmdbAPI = getApiBase()
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val append = "alternative_titles,credits,external_ids,videos,recommendations"

        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&language=$langCode&append_to_response=$append"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&language=$langCode&append_to_response=$append"
        }

        val enResUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&language=en-US"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&language=en-US"
        }

        val enRes = app.get(enResUrl).parsedSafe<MediaDetail>()
        val enTitle = enRes?.title ?: enRes?.name

        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")
        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath)
        val bgPoster = getOriImageUrl(res.backdropPath)
        val orgTitle = res.originalTitle ?: res.originalName ?: return null
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val genres = res.genres?.mapNotNull { it.name }

        val isCartoon = genres?.contains("Animation") ?: false
        val isAnime = isCartoon && (res.original_language == "zh" || res.original_language == "ja")
        val isAsian = !isAnime && (res.original_language == "zh" || res.original_language == "ko")
        val isBollywood = res.production_countries?.any { it.name == "India" } ?: false

        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            val name = cast.name ?: cast.originalName ?: return@mapNotNull null
            ActorData(
                Actor(name, getImageUrl(cast.profilePath)), roleString = cast.character
            )
        } ?: emptyList()

        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer = res.videos?.results.orEmpty()
            .filter { it.type == "Trailer" }
            .map { "https://www.youtube.com/watch?v=${it.key}" }
            .reversed()
            .ifEmpty {
                res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" } ?: emptyList()
            }
        val logoUrl = fetchTmdbLogoUrl(
            tmdbAPI = "https://api.themoviedb.org/3",
            apiKey = "98ae14df2b8d8f8f8136499daf79f0e0",
            type = type,
            tmdbId = res.id,
            appLangCode = langCode ?: "en"
        )
        val cinetype = if (type == TvType.TvSeries) "series" else "movie"
        val cineRes = app.get("$Cinemeta/meta/$cinetype/${res.external_ids?.imdb_id}.json").parsedSafe<CinemetaRes>()

        if (type == TvType.TvSeries) {
            val lastSeason = res.last_episode_to_air?.season_number
            val episodes = coroutineScope {
                res.seasons?.map { season ->
                    async {
                        app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey&language=$langCode")
                            .parsedSafe<MediaDetailEpisodes>()
                            ?.episodes
                            ?.map { eps ->
                                newEpisode(
                                    LinkData(
                                        data.id,
                                        res.external_ids?.imdb_id,
                                        res.external_ids?.tvdb_id,
                                        data.type,
                                        eps.seasonNumber,
                                        eps.episodeNumber,
                                        eps.id,
                                        title = enTitle,
                                        year = season.airDate?.split("-")?.first()?.toIntOrNull(),
                                        orgTitle = orgTitle,
                                        isAnime = isAnime,
                                        airedYear = year,
                                        lastSeason = lastSeason,
                                        epsTitle = eps.name,
                                        jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title,
                                        date = season.airDate,
                                        airedDate = res.releaseDate ?: res.firstAirDate,
                                        isAsian = isAsian,
                                        isBollywood = isBollywood,
                                        isCartoon = isCartoon,
                                        alttitle = res.title,
                                        nametitle = res.name
                                    ).toJson()
                                ) {
                                    this.name = eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                                    this.season = eps.seasonNumber
                                    this.episode = eps.episodeNumber
                                    this.posterUrl = getImageUrl(eps.stillPath)
                                    this.score = Score.from10(eps.voteAverage)
                                    this.description = eps.overview
                                    this.runTime = eps.runTime
                                }.apply {
                                    this.addDate(eps.airDate)
                                }
                            }
                    }
                }?.awaitAll()?.filterNotNull()?.flatten() ?: listOf()
            }
            if (isAnime) {
                val animeType = if (data.type?.contains("tv", ignoreCase = true) == true) "series" else "movie"
                val imdbId = res.external_ids?.imdb_id.orEmpty()
                val cineRes = app.get("$Cinemeta/meta/$animeType/$imdbId.json").parsedSafe<CinemetaRes>()
                val animeVideos = cineRes?.meta?.videos?.filter { it.season != 0 } ?: emptyList()
                val jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title
                    ?: cineRes?.meta?.name
                val syncMetaData = app.get("https://api.ani.zip/mappings?imdb_id=$imdbId").toString()
                val animeMetaData = parseAnimeData(syncMetaData)
                val kitsuid = animeMetaData?.mappings?.kitsuid
                fun buildEpisodeList(isDub: Boolean) = animeVideos.map { video ->
                    val videoYear = video.released?.split("-")?.firstOrNull()?.toIntOrNull()
                        ?: cineRes?.meta?.year?.toIntOrNull() ?: 0

                    newEpisode(
                        LinkData(
                            id = data.id,
                            imdbId = imdbId,
                            tvdbId = res.external_ids?.tvdb_id,
                            type = data.type,
                            season = video.season,
                            episode = video.episode,
                            title = title,
                            year = videoYear,
                            orgTitle = orgTitle,
                            isAnime = true,
                            airedYear = year,
                            epsTitle = video.title,
                            jpTitle = jpTitle,
                            date = video.released,
                            airedDate = res.releaseDate ?: res.firstAirDate,
                            isAsian = isAsian,
                            isBollywood = isBollywood,
                            isCartoon = isCartoon,
                            alttitle = res.title,
                            nametitle = res.name,
                            isDub = isDub
                        ).toJson()
                    ) {
                        this.name = video.title + if (isUpcoming(video.released)) " • [UPCOMING]" else ""
                        this.season = video.season
                        this.episode = video.episode
                        this.posterUrl = video.thumbnail
                        this.description = video.overview
                        addDate(video.released)
                    }
                }

                return newAnimeLoadResponse(title, url, TvType.Anime) {
                    addEpisodes(DubStatus.Subbed, buildEpisodeList(isDub = false))
                    addEpisodes(DubStatus.Dubbed, buildEpisodeList(isDub = true))
                    this.posterUrl = poster
                    this.backgroundPosterUrl = bgPoster
                    try { this.logoUrl = logoUrl } catch(_:Throwable){}
                    this.year = year
                    this.plot = res.overview
                    this.tags = keywords?.map { it.replaceFirstChar { c -> c.titlecase() } }
                        ?.takeIf { it.isNotEmpty() } ?: genres
                    this.score = Score.from10(res.vote_average.toString())
                    this.showStatus = getStatus(res.status)
                    this.recommendations = recommendations
                    this.actors = actors
                    addTrailer(trailer)
                    try { addKitsuId(kitsuid) } catch(_:Throwable){}
                    this.contentRating = cineRes?.meta?.appExtras?.certification
                    addImdbId(imdbId)
                }
            } else {
                return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                    this.posterUrl = poster
                    this.backgroundPosterUrl = bgPoster
                    this.year = year
                    this.plot = res.overview
                    this.tags = keywords?.map { word -> word.replaceFirstChar { it.titlecase() } }
                        ?.takeIf { it.isNotEmpty() } ?: genres
                    this.score = Score.from10(res.vote_average.toString())
                    this.showStatus = getStatus(res.status)
                    this.recommendations = recommendations
                    this.actors = actors
                    try { this.logoUrl = logoUrl } catch(_:Throwable){}
                    this.contentRating = cineRes?.meta?.appExtras?.certification
                    addTrailer(trailer)
                    addImdbId(res.external_ids?.imdb_id)
                }
            }
        } else {
            return newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LinkData(
                    data.id,
                    res.external_ids?.imdb_id,
                    res.external_ids?.tvdb_id,
                    data.type,
                    title = enTitle,
                    year = year,
                    orgTitle = orgTitle,
                    isAnime = isAnime,
                    jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title,
                    airedDate = res.releaseDate ?: res.firstAirDate,
                    isAsian = isAsian,
                    isBollywood = isBollywood,
                    alttitle = res.title,
                    nametitle = res.name,
                    isMovie = true
                ).toJson(),
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.comingSoon = isUpcoming(releaseDate)
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords?.map { word -> word.replaceFirstChar { it.titlecase() } }
                    ?.takeIf { it.isNotEmpty() } ?: genres
                try { this.logoUrl = logoUrl } catch(_:Throwable){}
                this.score = Score.from10(res.vote_average.toString())
                this.recommendations = recommendations
                this.actors = actors
                this.contentRating = cineRes?.meta?.appExtras?.certification
                addTrailer(trailer)
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = parseJson<LinkData>(data)
        val disabledProviderIds = sharedPref
            ?.getStringSet("disabled_providers", emptySet())
            ?.toSet() ?: emptySet()
        val providersList = buildProviders().filter { it.id !in disabledProviderIds }
        val authToken = token
        runLimitedAsync( concurrency = 10,
            {
                try {
                    if (!res.isAnime) {
                        invokeSubtitleAPI(res.imdbId, res.season, res.episode, subtitleCallback)
                    }
                } catch (_: Throwable) {
                    // ignore failure but do not cancel the rest
                }
            },
            {
                try {
                    if (!res.isAnime) {
                        invokeWyZIESUBAPI(res.imdbId, res.season, res.episode, subtitleCallback)
                    }
                } catch (_: Throwable) {
                    // ignore failure
                }
            },
            *providersList.map { provider ->
                suspend {
                    try {
                        provider.invoke(
                            res,
                            subtitleCallback,
                            callback,
                            authToken ?: "",
                            dahmerMoviesAPI
                        )
                    } catch (_: Throwable) {
                        // provider failure shouldn't kill others
                    }
                }
            }.toTypedArray()
        )

        return true
    }



    data class LinkData(
        val id: Int? = null,
        val imdbId: String? = null,
        val tvdbId: Int? = null,
        val type: String? = null,
        val season: Int? = null,
        val episode: Int? = null,
        val epid: Int? = null,
        val aniId: String? = null,
        val animeId: String? = null,
        val title: String? = null,
        val year: Int? = null,
        val orgTitle: String? = null,
        val isAnime: Boolean = false,
        val airedYear: Int? = null,
        val lastSeason: Int? = null,
        val epsTitle: String? = null,
        val jpTitle: String? = null,
        val date: String? = null,
        val airedDate: String? = null,
        val isAsian: Boolean = false,
        val isBollywood: Boolean = false,
        val isCartoon: Boolean = false,
        val alttitle: String? = null,
        val nametitle: String? = null,
        val isDub: Boolean = false,
        val isMovie: Boolean? = false,
    )

    data class Data(
        val id: Int? = null,
        val type: String? = null,
        val aniId: String? = null,
        val malId: Int? = null,
    )

    data class Results(
        @param:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @param:JsonProperty("id") val id: Int? = null,
        @param:JsonProperty("name") val name: String? = null,
        @param:JsonProperty("title") val title: String? = null,
        @param:JsonProperty("original_title") val originalTitle: String? = null,
        @param:JsonProperty("media_type") val mediaType: String? = null,
        @param:JsonProperty("poster_path") val posterPath: String? = null,
        @param:JsonProperty("vote_average") val voteAverage: Double? = null,
    )

    data class Genres(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("name") val name: String? = null,
    )

    data class Keywords(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("name") val name: String? = null,
    )

    data class KeywordResults(
        @get:JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
        @get:JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
    )

    data class Seasons(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("name") val name: String? = null,
        @get:JsonProperty("season_number") val seasonNumber: Int? = null,
        @get:JsonProperty("air_date") val airDate: String? = null,
    )

    data class Cast(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("name") val name: String? = null,
        @get:JsonProperty("original_name") val originalName: String? = null,
        @get:JsonProperty("character") val character: String? = null,
        @get:JsonProperty("known_for_department") val knownForDepartment: String? = null,
        @get:JsonProperty("profile_path") val profilePath: String? = null,
    )

    data class Episodes(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("name") val name: String? = null,
        @get:JsonProperty("overview") val overview: String? = null,
        @get:JsonProperty("air_date") val airDate: String? = null,
        @get:JsonProperty("still_path") val stillPath: String? = null,
        @get:JsonProperty("vote_average") val voteAverage: Double? = null,
        @get:JsonProperty("episode_number") val episodeNumber: Int? = null,
        @get:JsonProperty("season_number") val seasonNumber: Int? = null,
        @get:JsonProperty("runtime") val runTime: Int? = null
    )

    data class MediaDetailEpisodes(
        @get:JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
    )

    data class Trailers(
        @get:JsonProperty("key") val key: String? = null,
        @get:JsonProperty("type") val type: String? = null,
    )

    data class ResultsTrailer(
        @get:JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
    )

    data class AltTitles(
        @get:JsonProperty("iso_3166_1") val iso_3166_1: String? = null,
        @get:JsonProperty("title") val title: String? = null,
        @get:JsonProperty("type") val type: String? = null,
    )

    data class ResultsAltTitles(
        @get:JsonProperty("results") val results: ArrayList<AltTitles>? = arrayListOf(),
    )

    data class ExternalIds(
        @get:JsonProperty("imdb_id") val imdb_id: String? = null,
        @get:JsonProperty("tvdb_id") val tvdb_id: Int? = null,
    )

    data class Credits(
        @get:JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
    )

    data class ResultsRecommendations(
        @get:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class LastEpisodeToAir(
        @get:JsonProperty("episode_number") val episode_number: Int? = null,
        @get:JsonProperty("season_number") val season_number: Int? = null,
    )

    data class ProductionCountries(
        @get:JsonProperty("name") val name: String? = null,
    )

    data class MediaDetail(
        @get:JsonProperty("id") val id: Int? = null,
        @get:JsonProperty("imdb_id") val imdbId: String? = null,
        @get:JsonProperty("title") val title: String? = null,
        @get:JsonProperty("name") val name: String? = null,
        @get:JsonProperty("original_title") val originalTitle: String? = null,
        @get:JsonProperty("original_name") val originalName: String? = null,
        @get:JsonProperty("poster_path") val posterPath: String? = null,
        @get:JsonProperty("backdrop_path") val backdropPath: String? = null,
        @get:JsonProperty("release_date") val releaseDate: String? = null,
        @get:JsonProperty("first_air_date") val firstAirDate: String? = null,
        @get:JsonProperty("overview") val overview: String? = null,
        @get:JsonProperty("runtime") val runtime: Int? = null,
        @get:JsonProperty("vote_average") val vote_average: Any? = null,
        @get:JsonProperty("original_language") val original_language: String? = null,
        @get:JsonProperty("status") val status: String? = null,
        @get:JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
        @get:JsonProperty("keywords") val keywords: KeywordResults? = null,
        @get:JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
        @get:JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
        @get:JsonProperty("videos") val videos: ResultsTrailer? = null,
        @get:JsonProperty("external_ids") val external_ids: ExternalIds? = null,
        @get:JsonProperty("credits") val credits: Credits? = null,
        @get:JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
        @get:JsonProperty("alternative_titles") val alternative_titles: ResultsAltTitles? = null,
        @get:JsonProperty("production_countries") val production_countries: ArrayList<ProductionCountries>? = arrayListOf(),
    )
}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayAnime.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.CommonActivity.activity
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addKitsuId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import com.phisher98.StreamPlay.Companion.anilistAPI
import com.phisher98.StreamPlay.Companion.malsyncAPI
import com.phisher98.StreamPlayExtractor.invokeAniXL
import com.phisher98.StreamPlayExtractor.invokeAnichi
import com.phisher98.StreamPlayExtractor.invokeAnimeKai
import com.phisher98.StreamPlayExtractor.invokeAnimepahe
import com.phisher98.StreamPlayExtractor.invokeAnimetosho
import com.phisher98.StreamPlayExtractor.invokeAnizone
import com.phisher98.StreamPlayExtractor.invokeHianime
import com.phisher98.StreamPlayExtractor.invokeKickAssAnime
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import java.util.Calendar

class StreamPlayAnime : MainAPI() {
    override var name = "StreamPlay-Anime"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist,SyncIdName.MyAnimeList)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.aniListApi)
    private val apiUrl = "https://graphql.anilist.co"
    private val mediaLimit = 20
    private val isAdult = false
    private val headerJSON =
        mapOf("Accept" to "application/json", "Content-Type" to "application/json")

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun anilistAPICall(query: String): AnilistAPIResponse {
        val data = mapOf("query" to query)
        val test = app.post(apiUrl, headers = headerJSON, data = data)
        val res =
            test.parsedSafe<AnilistAPIResponse>()
                ?: throw Exception("Unable to fetch or parse Anilist api response")
        return res
    }

    private fun Media.toSearchResponse(): SearchResponse {
        val title = this.title.english ?: this.title.romaji ?: ""
        val url = "$mainUrl/anime/${this.id}"
        val posterUrl = this.coverImage.large
        val rating = this.averageScore
        return newAnimeSearchResponse(title, url, TvType.Anime) {
            this.posterUrl = posterUrl
            this.score= Score.from100(rating)
        }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
        page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val res = anilistAPICall(this.data.replace("###", "$page"))
        val data =
            res.data.page?.media?.map { it.toSearchResponse() }
                ?: throw Exception("Unable to read media data")
        val hasNextPage = res.data.page.pageInfo.hasNextPage ?: false
        return data to hasNextPage
    }

    private val currentYear = Calendar.getInstance().get(Calendar.YEAR)

    override val mainPage =
        mainPageOf(
            "query (\$page: Int = ###, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Trending Now",
            "query (\$page: Int = ###, \$seasonYear: Int = $currentYear, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, seasonYear: \$seasonYear, season: SPRING, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Popular This Season",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "All Time Popular",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [SCORE_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Top 100 Anime",
            "Personal" to "Personal"
        )

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        val res =
            anilistAPICall(
                "query (\$search: String = \"$query\") { Page(page: $page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(search: \$search, isAdult: $isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }"
            )
        return res.data.page?.media?.map { it.toSearchResponse() }?.toNewSearchResponseList()
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                ?: return newHomePageResponse(
                    "Login required for personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            val homePageList =
                repo.library().getOrThrow()!!.allLibraryLists.mapNotNull {
                    if (it.items.isEmpty()) return@mapNotNull null
                    val libraryName =
                        it.name.asString(activity ?: return@mapNotNull null)
                    HomePageList("${request.name}: $libraryName", it.items)
                }
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is
            // overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data = anilistAPICall(
            "query (\$id: Int = $id) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore status bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val anititle = data.getTitle()
        val aniyear = data.startDate.year
        val posterurl = data.coverImage.extraLarge
        val backgroundUrl = data.bannerImage

        val anitype = if (data.format!!.contains("MOVIE", ignoreCase = true)) TvType.AnimeMovie else TvType.TvSeries
        val ids = tmdbToAnimeId(anititle, aniyear, anitype)

        val jpTitle = data.title.romaji

        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=${ids.id}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)
        val tmdbid = animeMetaData?.mappings?.themoviedbId?.toIntOrNull()
        val kitsuid = animeMetaData?.mappings?.kitsuid

        val type = if (data.format.contains("Movie",ignoreCase = true)) TvType.Movie else TvType.TvSeries

        val logoUrl = fetchTmdbLogoUrl(
            tmdbAPI = "https://api.themoviedb.org/3",
            apiKey = "98ae14df2b8d8f8f8136499daf79f0e0",
            type = type,
            tmdbId = tmdbid,
            appLangCode = "en"
        )
        val anidbEid = getAnidbEid(syncMetaData, 1) ?: 0
        val href = LinkData(
            malId = ids.idMal,
            aniId = ids.id,
            title = data.getTitle(),
            jpTitle = jpTitle,
            year = data.startDate.year,
            isAnime = true,
            anidbEid = anidbEid,
            episode = 1
        ).toStringData()

        // --- Helper to get best episode title ---
        fun resolveTitle(epData: MetaEpisode?): String {
            val jsonTitle = epData?.title?.get("en")
                ?: epData?.title?.get("ja")
                ?: epData?.title?.get("x-jat")
                ?: animeMetaData?.titles?.get("en")
                ?: animeMetaData?.titles?.get("ja")
                ?: animeMetaData?.titles?.get("x-jat")
                ?: ""
            return jsonTitle.ifBlank { "Episode ${epData?.episode ?: ""}" }
        }

        fun createEpisode(i: Int, isDub: Boolean): Episode {
            val anidbEid = getAnidbEid(syncMetaData, i) ?: 0
            val epData = animeMetaData?.episodes?.get(i.toString())
            val linkData = LinkData(
                malId = ids.idMal,
                aniId = ids.id,
                title = data.getTitle(),
                jpTitle = jpTitle,
                year = data.startDate.year,
                season = 1,
                episode = i,
                isAnime = true,
                isDub = isDub,
                anidbEid = anidbEid
            ).toStringData()

            return newEpisode(linkData) {
                this.season = 1
                this.episode = i
                this.name = resolveTitle(epData)
                this.posterUrl = epData?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
                this.description = epData?.overview ?: "No summary available"
                this.score = Score.from10(epData?.rating)
                this.runTime = epData?.runtime
                this.addDate(epData?.airdate)
            }
        }

        val episodes = (1..data.totalEpisodes()).map { createEpisode(it, false) }
        val episodesDub = (1..data.totalEpisodes()).map { createEpisode(it, true) }

        return if (data.format.contains("Movie",ignoreCase = true)) {
            newMovieLoadResponse(data.getTitle(), url, TvType.AnimeMovie, href) {
                addAniListId(id.toInt())
                addMalId(ids.idMal)
                try { addKitsuId(kitsuid) } catch(_:Throwable){}
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = backgroundUrl ?: animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl =  posterurl ?: data.getCoverImage() ?: animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                try { this.logoUrl = logoUrl } catch(_:Throwable){}
                this.tags = data.genres
                this.score = Score.from100(data.averageScore)
            }
        } else {
            newAnimeLoadResponse(data.getTitle(), url, TvType.Anime) {
                addAniListId(id.toInt())
                addMalId(ids.idMal)
                try { addKitsuId(kitsuid) } catch(_:Throwable){}
                addEpisodes(DubStatus.Subbed, episodes)
                addEpisodes(DubStatus.Dubbed, episodesDub)
                try { this.logoUrl = logoUrl } catch(_:Throwable){}
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl = data.getCoverImage() ?: animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                this.tags = data.genres
                this.score = Score.from100(data.averageScore)
                this.showStatus = getStatus(data.status)
                this.recommendations = data.recommendations?.edges
                    ?.mapNotNull { edge ->
                        val recommendation = edge.node.mediaRecommendation ?: return@mapNotNull null
                        val title = recommendation.title?.english
                            ?: recommendation.title?.romaji
                            ?: "Unknown"
                        val recommendationUrl = "$mainUrl/anime/${recommendation.id}"
                        newAnimeSearchResponse(title, recommendationUrl, TvType.Anime).apply {
                            this.posterUrl = recommendation.coverImage?.large
                        }
                    }
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        val malId = mediaData.malId
        val episode = mediaData.episode
        val jpTitle = mediaData.jpTitle
        val anititle = mediaData.title
        val anidbEid = mediaData.anidbEid
        val season= jpTitle?.let { extractSeason(it) }
        val year=mediaData.year
        val malsync = app.get("$malsyncAPI/mal/anime/$malId").parsedSafe<MALSyncResponses>()?.sites
        val zoro = malsync?.zoro
        val zorotitle = zoro?.values?.firstNotNullOfOrNull { it["title"] }?.replace(":", " ")
        val aniXL = malsync?.AniXL?.values?.firstNotNullOfOrNull { it["url"] }
        val kaasSlug = malsync?.KickAssAnime?.values?.firstNotNullOfOrNull { it["identifier"] }

        val dubStatus: String? =
            if (mediaData.season == null) "Movie"
            else if (mediaData.isDub) "DUB"
            else "SUB"

        runAllAsync(
            { invokeHianime(zoro?.keys?.toList(), episode, subtitleCallback, callback, dubStatus) },
            {
                malsync?.animepahe?.values?.firstNotNullOfOrNull { it["url"] }?.let {
                    invokeAnimepahe(it, episode, subtitleCallback, callback, dubStatus)
                }
            },

            { invokeAnizone(jpTitle,zorotitle, episode, callback, dubStatus) },
            { invokeAnichi(jpTitle, anititle, year, episode, subtitleCallback, callback, dubStatus) },
            { invokeKickAssAnime(zorotitle,kaasSlug, episode, subtitleCallback, callback, dubStatus) },
            { invokeAnimeKai(jpTitle, zorotitle, episode, subtitleCallback, callback, dubStatus) },

            {

                malId?.let {
                    invokeAnimetosho(
                        it,
                        episode,
                        subtitleCallback,
                        callback,
                        dubStatus,
                        anidbEid
                    )
                }
            },
            {
                if (aniXL != null) {
                    invokeAniXL(aniXL, episode, callback, dubStatus)
                }
            }
        )
        return true
    }

    fun getStatus(t: String?): ShowStatus {
        return when {
            t?.contains("Returning", ignoreCase = true) == true -> ShowStatus.Ongoing
            t?.contains("RELEASING", ignoreCase = true) == true -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }

    data class AnilistAPIResponse(
        @JsonProperty("data") val data: AnilistData,
    ) {
        data class AnilistData(
            @JsonProperty("Page") val page: AnilistPage?,
            @JsonProperty("Media") val media: anilistMedia?,
        ) {
            data class AnilistPage(
                @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
                @JsonProperty("media") val media: List<Media>,
            )
        }

        data class anilistMedia(
            @JsonProperty("id") val id: Int,
            @JsonProperty("startDate") val startDate: StartDate,
            @JsonProperty("episodes") val episodes: Int?,
            @JsonProperty("title") val title: Title,
            @JsonProperty("season") val season: String?,
            @JsonProperty("genres") val genres: List<String>,
            @JsonProperty("averageScore") val averageScore: Int,
            @JsonProperty("status") val status: String,
            @JsonProperty("description") val description: String?,
            @JsonProperty("coverImage") val coverImage: CoverImage,
            @JsonProperty("bannerImage") val bannerImage: String?,
            @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
            @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
            @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
            @JsonProperty("format") val format: String?,
        ) {
            data class StartDate(@JsonProperty("year") val year: Int)

            data class AiringScheduleNodes(
                @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
            )

            fun totalEpisodes(): Int {
                return nextAiringEpisode?.episode?.minus(1)
                    ?: episodes
                    ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                    ?: 0
            }

            fun getTitle(): String {
                return title.english
                    ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
            }

            fun getCoverImage(): String? {
                return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
            }
        }
    }

    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: Int? = null,
        @JsonProperty("malId") val malId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
        @JsonProperty("isDub") val isDub: Boolean = false,
        @JsonProperty("anidbEid") val anidbEid: Int? = null,
        )

    data class Media(
        @JsonProperty("id") val id: Int,
        @JsonProperty("idMal") val idMal: Int?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("seasonYear") val seasonYear: Int,
        @JsonProperty("format") val format: String?,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("episodes") val episodes: Int,
        @JsonProperty("title") val title: Title,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("synonyms") val synonyms: List<String>,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
    )

    private suspend fun tmdbToAnimeId(title: String?, year: Int?, type: TvType): AniIds {
        if (title.isNullOrBlank()) return AniIds(null, null)

        val query = """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}seasonYear: Int
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              seasonYear: ${'$'}seasonYear
              format_in: ${'$'}format
            ) {
              id
              idMal
            }
          }
        }
    """.trimIndent()

        val variables = mutableMapOf(
            "search" to title,
            "sort" to listOf("SEARCH_MATCH"),
            "type" to "ANIME",
            "format" to listOf(
                if (type == TvType.AnimeMovie) "MOVIE" else "TV",
                "ONA",
                "OVA"
            )
        )

        val data = mapOf(
            "query" to query,
            "variables" to variables
        ).toJson().toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val res = app.post(anilistAPI, requestBody = data)
            .parsedSafe<AniSearch>()
            ?.data
            ?.let { it.Page?.media ?: it.media }
            ?.firstOrNull()

        return AniIds(res?.id, res?.idMal)
    }

    private fun extractSeason(title: String): Int? {
        val regex = Regex("""(?i)(?:season\s*(\d+)|(\d+)(?:st|nd|rd|th)?\s*season)""")
        val match = regex.find(title)
        val seasonStr = match?.groups?.get(1)?.value ?: match?.groups?.get(2)?.value ?: "1"
        return seasonStr.toIntOrNull()
    }
}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayLite.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.StreamPlayExtractor.invoke2embed
import com.phisher98.StreamPlayExtractor.invokeAllMovieland
import com.phisher98.StreamPlayExtractor.invokeAnimes
import com.phisher98.StreamPlayExtractor.invokeElevenmovies
import com.phisher98.StreamPlayExtractor.invokeKisskh
import com.phisher98.StreamPlayExtractor.invokeKisskhAsia
import com.phisher98.StreamPlayExtractor.invokeMovieBox
import com.phisher98.StreamPlayExtractor.invokeNepu
import com.phisher98.StreamPlayExtractor.invokeNinetv
import com.phisher98.StreamPlayExtractor.invokeRidomovies
import com.phisher98.StreamPlayExtractor.invokeRiveStream
import com.phisher98.StreamPlayExtractor.invokeShowflix
import com.phisher98.StreamPlayExtractor.invokeSoapy
import com.phisher98.StreamPlayExtractor.invokeStreamPlay
import com.phisher98.StreamPlayExtractor.invokeSubtitleAPI
import com.phisher98.StreamPlayExtractor.invokeSuperstream
import com.phisher98.StreamPlayExtractor.invokeVidSrcXyz
import com.phisher98.StreamPlayExtractor.invokeVidlink
import com.phisher98.StreamPlayExtractor.invokeVidsrccc
import com.phisher98.StreamPlayExtractor.invokeVidzee
import com.phisher98.StreamPlayExtractor.invokeWatch32APIHQ
import com.phisher98.StreamPlayExtractor.invokeWatchsomuch
import com.phisher98.StreamPlayExtractor.invokeWyZIESUBAPI
import com.phisher98.StreamPlayExtractor.invokeZoechip
import com.phisher98.StreamPlayExtractor.invokeZshow
import com.phisher98.StreamPlayExtractor.invokemorph
import com.phisher98.StreamPlayExtractor.invokevidrock
import com.phisher98.StreamPlayExtractor.sharedPref

class StreamPlayLite() : StreamPlay(sharedPref) {
    override var name = "StreamPlay-Lite"

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val token = sharedPref?.getString("token", null)
        val res = AppUtils.parseJson<LinkData>(data)
        runAllAsync(
            {
                if (!res.isAnime) invokeWatchsomuch(
                    res.imdbId,
                    res.season,
                    res.episode,
                    subtitleCallback
                )
            },
            {
                if (!res.isAnime) invokeNinetv(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (res.isAnime) invokeAnimes(
                    res.title,
                    res.jpTitle,
                    res.date,
                    res.airedDate,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback,
                    res.isDub,
                    res.isMovie
                )
            },
            {
                if (res.isAsian) invokeKisskh(
                    res.title,
                    res.season,
                    res.episode,
                    res.lastSeason,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeRidomovies(
                    res.id,
                    res.imdbId,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeAllMovieland(res.imdbId, res.season, res.episode, callback)
            },
            {
                if (!res.isAnime) invoke2embed(
                    res.imdbId,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAsian && !res.isBollywood &&!res.isAnime) invokeZshow(
                    res.title,
                    res.year,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeShowflix(
                    res.title,
                    res.year,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeZoechip(
                    res.title,
                    res.year,
                    res.season,
                    res.episode,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeNepu(
                    res.title,
                    res.airedYear ?: res.year,
                    res.season,
                    res.episode,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeWatch32APIHQ(
                    res.title,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeVidsrccc(
                    res.id,
                    res.season,
                    res.episode,
                    callback
                )
            },
            {
                invokeRiveStream(
                    res.id,
                    res.season,
                    res.episode,
                    callback
                )

            },
            {
                invokeSuperstream(
                    token,
                    res.imdbId,
                    res.season,
                    res.episode,
                    callback
                )
            },
            {
                invokeStreamPlay(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeVidSrcXyz(
                    res.imdbId,
                    res.season,
                    res.episode,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeElevenmovies(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeVidzee(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },
            {
                if (!res.isAnime) invokeMovieBox(res.title, res.season, res.episode, subtitleCallback, callback)
            },
            {
                if (!res.isAnime) invokemorph(res.title,res.year, res.season, res.episode, subtitleCallback, callback)
            },
            {
                if (!res.isAnime) invokevidrock(res.id, res.season, res.episode, callback)
            },
            {
                if (!res.isAnime) invokeSoapy(res.id, res.season, res.episode, subtitleCallback,callback)
            },
            {
                if (!res.isAnime) invokeVidlink(res.id, res.season, res.episode, subtitleCallback,callback)
            },
            {
                if (!res.isAnime) invokeKisskhAsia(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            },

            //Subtitles Invokes
            {
                invokeSubtitleAPI(
                    res.imdbId,
                    res.season,
                    res.episode,
                    subtitleCallback
                )
            },
            {
                invokeWyZIESUBAPI(
                    res.imdbId,
                    res.season,
                    res.episode,
                    subtitleCallback,
                )
            },
        )
        return true
    }

}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

//Anichi

data class AnichiRoot(
    val data: AnichiData,
)

data class AnichiData(
    val shows: AnichiShows,
)

data class AnichiShows(
    val pageInfo: PageInfo,
    val edges: List<Edge>,
)

data class PageInfo(
    val total: Long,
)

data class Edge(
    @JsonProperty("_id")
    val id: String,
    val name: String,
    val englishName: String,
    val nativeName: String,
)

//Anichi Ep Parser

data class AnichiEP(
    val data: AnichiEPData,
)

data class AnichiEPData(
    val episode: AnichiEpisode,
)

data class AnichiEpisode(
    val sourceUrls: List<SourceUrl>,
)

data class SourceUrl(
    val sourceUrl: String,
    val sourceName: String,
    val downloads: AnichiDownloads?,
)

data class AnichiDownloads(
    val sourceName: String,
    val downloadUrl: String,
)

data class AniIds(var id: Int? = null, var idMal: Int? = null)

data class TmdbDate(
    val today: String,
    val nextWeek: String,
    val lastWeekStart: String,
    val monthStart: String
)

data class MoflixResponse(
    @JsonProperty("title") val title: Episode? = null,
    @JsonProperty("episode") val episode: Episode? = null,
) {
    data class Episode(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("videos") val videos: ArrayList<Videos>? = arrayListOf(),
    ) {
        data class Videos(
            @JsonProperty("name") val name: String? = null,
            @JsonProperty("category") val category: String? = null,
            @JsonProperty("src") val src: String? = null,
            @JsonProperty("quality") val quality: String? = null,
        )
    }
}

data class AniMedia(
    @JsonProperty("id") var id: Int? = null,
    @JsonProperty("idMal") var idMal: Int? = null
)

data class AniPage(
    @JsonProperty("media") var media: ArrayList<AniMedia> = arrayListOf()
)

data class AniData(
    @JsonProperty("Page") var Page: AniPage? = null,
    @JsonProperty("media") var media: ArrayList<AniMedia>? = null
)

data class AniSearch(
    @JsonProperty("data") var data: AniData? = null
)


//WyZIESUBAPI

data class WyZIESUB(
    val id: String,
    val url: String,
    val flagUrl: String,
    val format: String,
    val display: String,
    val language: String,
    val media: String,
    val isHearingImpaired: Boolean,
)

data class ResponseHash(
    @JsonProperty("embed_url") val embed_url: String,
    @JsonProperty("key") val key: String? = null,
    @JsonProperty("type") val type: String? = null,
)

data class KisskhSources(
    @JsonProperty("Video") val video: String?,
    @JsonProperty("ThirdParty") val thirdParty: String?,
)

data class KisskhSubtitle(
    @JsonProperty("src") val src: String?,
    @JsonProperty("label") val label: String?,
)

data class KisskhEpisodes(
    @JsonProperty("id") val id: Int?,
    @JsonProperty("number") val number: Int?,
)

data class KisskhDetail(
    @JsonProperty("episodes") val episodes: ArrayList<KisskhEpisodes>? = arrayListOf(),
)

data class KisskhResults(
    @JsonProperty("id") val id: Int?,
    @JsonProperty("title") val title: String?,
)

data class ZShowEmbed(
    @JsonProperty("m") val meta: String? = null,
)

data class WatchsomuchTorrents(
    @JsonProperty("id") val id: Int? = null,
    @JsonProperty("movieId") val movieId: Int? = null,
    @JsonProperty("season") val season: Int? = null,
    @JsonProperty("episode") val episode: Int? = null,
)

data class WatchsomuchMovies(
    @JsonProperty("torrents") val torrents: ArrayList<WatchsomuchTorrents>? = arrayListOf(),
)

data class WatchsomuchResponses(
    @JsonProperty("movie") val movie: WatchsomuchMovies? = null,
)

data class WatchsomuchSubtitles(
    @JsonProperty("url") val url: String? = null,
    @JsonProperty("label") val label: String? = null,
)

data class WatchsomuchSubResponses(
    @JsonProperty("subtitles") val subtitles: ArrayList<WatchsomuchSubtitles>? = arrayListOf(),
)

data class IndexMedia(
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("driveId") val driveId: String? = null,
    @JsonProperty("mimeType") val mimeType: String? = null,
    @JsonProperty("size") val size: String? = null,
    @JsonProperty("name") val name: String? = null,
    @JsonProperty("modifiedTime") val modifiedTime: String? = null,
)

data class IndexData(
    @JsonProperty("files") val files: ArrayList<IndexMedia>? = arrayListOf(),
)

data class IndexSearch(
    @JsonProperty("data") val data: IndexData? = null,
)

data class JikanExternal(
    @JsonProperty("name") val name: String? = null,
    @JsonProperty("url") val url: String? = null,
)

data class JikanData(
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("external") val external: List<JikanExternal>? = null,
    @JsonProperty("season") val season: String? = null,
)

data class JikanResponse(
    @JsonProperty("data") val data: JikanData? = null,
)

//Hianime

data class EpisodeServers(
    val type: String,
    val link: String,
    val server: Long,
    val sources: List<Any?>,
    val tracks: List<Any?>,
    val htmlGuide: String,
)


//anime animepahe parser

data class animepahe(
    val total: Long,
    @JsonProperty("per_page")
    val perPage: Long,
    @JsonProperty("current_page")
    val currentPage: Long,
    @JsonProperty("last_page")
    val lastPage: Long,
    @JsonProperty("next_page_url")
    val nextPageUrl: Any?,
    @JsonProperty("prev_page_url")
    val prevPageUrl: Any?,
    val from: Long,
    val to: Long,
    val data: List<Daum>,
)

data class Daum(
    val id: Long,
    @JsonProperty("anime_id")
    val animeId: Long,
    val episode: Int,
    val episode2: Long,
    val edition: String,
    val title: String,
    val snapshot: String,
    val disc: String,
    val audio: String,
    val duration: String,
    val session: String,
    val filler: Long,
    @JsonProperty("created_at")
    val createdAt: String,
)


data class MALSyncSites(
    @JsonProperty("AniXL") val AniXL: HashMap<String?, HashMap<String, String?>>? = hashMapOf(),
    @JsonProperty("Zoro") val zoro: HashMap<String?, HashMap<String, String?>>? = hashMapOf(),
    @JsonProperty("9anime") val nineAnime: HashMap<String?, HashMap<String, String?>>? = hashMapOf(),
    @JsonProperty("animepahe") val animepahe: HashMap<String?, HashMap<String, String?>>? = hashMapOf(),
    @JsonProperty("KickAssAnime") val KickAssAnime: HashMap<String?, HashMap<String, String?>>? = hashMapOf(),
)

data class MALSyncResponses(
    @JsonProperty("Sites") val sites: MALSyncSites? = null,
)

data class HianimeResponses(
    @JsonProperty("html") val html: String? = null,
    @JsonProperty("link") val link: String? = null,
)

data class AllMovielandEpisodeFolder(
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("file") val file: String? = null,
)

data class AllMovielandSeasonFolder(
    @JsonProperty("episode") val episode: String? = null,
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("folder") val folder: ArrayList<AllMovielandEpisodeFolder>? = arrayListOf(),
)

data class AllMovielandServer(
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("file") val file: String? = null,
    @JsonProperty("folder") val folder: ArrayList<AllMovielandSeasonFolder>? = arrayListOf(),
)

data class AllMovielandPlaylist(
    @JsonProperty("file") val file: String? = null,
    @JsonProperty("key") val key: String? = null,
    @JsonProperty("href") val href: String? = null,
)

data class ShowflixSearchMovies(
    @JsonProperty("results")
    val resultsMovies: ArrayList<ShowflixResultsMovies>? = arrayListOf()
)

data class ShowflixResultsMovies(
    @JsonProperty("objectId")
    val objectId: String? = null,
    @JsonProperty("name")
    val name: String? = null,
    @JsonProperty("releaseYear")
    val releaseYear: Int? = null,
    @JsonProperty("tmdbId")
    val tmdbId: Int? = null,
    @JsonProperty("embedLinks")
    val embedLinks: Map<String, String>? = null,
    @JsonProperty("languages")
    val languages: List<String>? = null,
    @JsonProperty("genres")
    val genres: List<String>? = null,
    @JsonProperty("backdropURL")
    val backdropURL: String? = null,
    @JsonProperty("posterURL")
    val posterURL: String? = null,
    @JsonProperty("hdLink")
    val hdLink: String? = null,
    @JsonProperty("hubCloudLink")
    val hubCloudLink: String? = null,
    @JsonProperty("storyline")
    val storyline: String? = null,
    @JsonProperty("rating")
    val rating: String? = null,
    @JsonProperty("createdAt")
    val createdAt: String? = null,
    @JsonProperty("updatedAt")
    val updatedAt: String? = null
)

data class ShowflixSearchSeries(
    @JsonProperty("results")
    val resultsSeries: ArrayList<ShowflixResultsSeries>? = arrayListOf()
)

data class ShowflixResultsSeries(
    @JsonProperty("objectId")
    val objectId: String? = null,
    @JsonProperty("seriesName")
    val seriesName: String? = null,
    @JsonProperty("releaseYear")
    val releaseYear: Int? = null,
    @JsonProperty("tmdbId")
    val tmdbId: Int? = null,
    @JsonProperty("streamwish")
    val streamwish: Map<String, List<String>>? = null,
    @JsonProperty("filelions")
    val filelions: Map<String, List<String>>? = null,
    @JsonProperty("streamruby")
    val streamruby: Map<String, List<String>>? = null,
    @JsonProperty("languages")
    val languages: List<String>? = null,
    @JsonProperty("genres")
    val genres: List<String>? = null,
    @JsonProperty("backdropURL")
    val backdropURL: String? = null,
    @JsonProperty("posterURL")
    val posterURL: String? = null,
    @JsonProperty("hdLink")
    val hdLink: String? = null,
    @JsonProperty("hubCloudLink")
    val hubCloudLink: String? = null,
    @JsonProperty("storyline")
    val storyline: String? = null,
    @JsonProperty("rating")
    val rating: String? = null,
    @JsonProperty("createdAt")
    val createdAt: String? = null,
    @JsonProperty("updatedAt")
    val updatedAt: String? = null
)

data class RidoContentable(
    @JsonProperty("imdbId") var imdbId: String? = null,
    @JsonProperty("tmdbId") var tmdbId: Int? = null,
)

data class RidoItems(
    @JsonProperty("slug") var slug: String? = null,
    @JsonProperty("contentable") var contentable: RidoContentable? = null,
)

data class RidoData(
    @JsonProperty("url") var url: String? = null,
    @JsonProperty("items") var items: ArrayList<RidoItems>? = arrayListOf(),
)

data class RidoResponses(
    @JsonProperty("data") var data: ArrayList<RidoData>? = arrayListOf(),
)

data class RidoSearch(
    @JsonProperty("data") var data: RidoData? = null,
)

data class NepuSearch(
    @JsonProperty("data") val data: ArrayList<Data>? = arrayListOf(),
) {
    data class Data(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("type") val type: String? = null,
    )
}
data class SubtitlesAPI(
    val subtitles: List<Subtitle>,
    val cacheMaxAge: Long,
)
data class Subtitle(
    val id: String,
    val url: String,
    @JsonProperty("SubEncoding")
    val subEncoding: String,
    val lang: String,
    val m: String,
    val g: String,
)

data class RiveStreamSource(
    val data: List<String>
)

data class KisskhKey(
    val id: String,
    val version: String,
    val key: String,
)

//SuperStream

data class ER(
    @JsonProperty("code") val code: Int? = null,
    @JsonProperty("msg") val msg: String? = null,
    @JsonProperty("server_runtime") val serverRuntime: Double? = null,
    @JsonProperty("server_name") val serverName: String? = null,
    @JsonProperty("data") val data: DData? = null,
)

data class DData(
    @JsonProperty("link") val link: String? = null,
    @JsonProperty("file_list") val fileList: List<FileList>? = null,
)

data class FileList(
    @JsonProperty("fid") val fid: Long? = null,
    @JsonProperty("file_name") val fileName: String? = null,
    @JsonProperty("oss_fid") val ossFid: Long? = null,
)

data class ExternalResponse(
    @JsonProperty("code") val code: Int? = null,
    @JsonProperty("msg") val msg: String? = null,
    @JsonProperty("server_runtime") val serverRuntime: Double? = null,
    @JsonProperty("server_name") val serverName: String? = null,
    @JsonProperty("data") val data: Data? = null,
) {
    data class Data(
        @JsonProperty("link") val link: String? = null,
        @JsonProperty("file_list") val fileList: List<FileList>? = null,
    ) {
        data class FileList(
            @JsonProperty("fid") val fid: Long? = null,
            @JsonProperty("file_name") val fileName: String? = null,
            @JsonProperty("oss_fid") val ossFid: Long? = null,
        )
    }
}

data class ExternalSourcesWrapper(
    @JsonProperty("sources") val sources: List<ExternalSources>? = null
)

data class ExternalSources(
    @JsonProperty("source") val source: String? = null,
    @JsonProperty("file") val file: String? = null,
    @JsonProperty("label") val label: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("size") val size: String? = null,
)

data class EpisoderesponseKAA(
    val slug: String,
    val title: String,
    val duration_ms: Long,
    val episode_number: Number,
    val episode_string: String,
    val thumbnail: ThumbnailKAA
)

data class ThumbnailKAA(
    val formats: List<String>,
    val sm: String,
    val aspectRatio: Double,
    val hq: String
)


data class ServersResKAA(
    val servers: List<ServerKAA>,

    )

data class ServerKAA(
    val name: String,
    val shortName: String,
    val src: String,
)


data class EncryptedKAA(
    val data: String,
)


data class m3u8KAA(
    val hls: String,
    val subtitles: List<SubtitleKAA>,
    val key: String,
)

data class SubtitleKAA(
    val language: String,
    val name: String,
    val src: String,
)

//
//StremplayAPI

data class StremplayAPI(
    val name: String,
    val fields: StremplayFields,
    val createTime: String,
    val updateTime: String,
)

data class StremplayFields(
    val links: StremplayLinks,
)

data class StremplayLinks(
    val arrayValue: StremplayArrayValue,
)

data class StremplayArrayValue(
    val values: List<StremplayValue>,
)

data class StremplayValue(
    val mapValue: StremplayMapValue,
)

data class StremplayMapValue(
    val fields: StremplayFields2,
)

data class StremplayFields2(
    val href: StremplayHref,
    val quality: StremplayQuality,
    val source: StremplaySource,
)

data class StremplayHref(
    val stringValue: String,
)

data class StremplayQuality(
    val stringValue: String,
)

data class StremplaySource(
    val stringValue: String,
)

data class AnimeKaiResponse(
    @JsonProperty("status") val status: Boolean,
    @JsonProperty("result") val result: String
) {
    fun getDocument(): Document {
        return Jsoup.parse(result)
    }
}

fun extractVideoUrlFromJsonAnimekai(jsonData: String): String {
    val jsonObject = JSONObject(jsonData)
    return jsonObject.getString("url")
}
data class AnichiStream(
    @JsonProperty("format") val format: String? = null,
    @JsonProperty("audio_lang") val audio_lang: String? = null,
    @JsonProperty("hardsub_lang") val hardsub_lang: String? = null,
    @JsonProperty("url") val url: String? = null,
)

data class PortData(
    @JsonProperty("streams") val streams: ArrayList<AnichiStream>? = arrayListOf(),
)

data class AnichiSubtitles(
    @JsonProperty("lang") val lang: String?,
    @JsonProperty("label") val label: String?,
    @JsonProperty("src") val src: String?,
)

data class AnichiLinks(
    @JsonProperty("link") val link: String,
    @JsonProperty("hls") val hls: Boolean? = null,
    @JsonProperty("resolutionStr") val resolutionStr: String,
    @JsonProperty("src") val src: String? = null,
    @JsonProperty("headers") val headers: Headers? = null,
    @JsonProperty("portData") val portData: PortData? = null,
    @JsonProperty("subtitles") val subtitles: ArrayList<AnichiSubtitles>? = arrayListOf(),
)

data class Headers(
    @JsonProperty("Referer") val referer: String? = null,
    @JsonProperty("Origin") val origin: String? = null,
    @JsonProperty("user-agent") val userAgent: String? = null,
)


data class AnichiVideoApiResponse(@JsonProperty("links") val links: List<AnichiLinks>)


data class ElevenmoviesServerEntry(
    val name: String,
    val description: String,
    val image: String,
    val data: String,
)

data class ElevenmoviesStreamResponse(
    val url: String?,
    val tracks: List<ElevenmoviesSubtitle>?
)

data class ElevenmoviesSubtitle(
    val label: String?,
    val file: String?
)

data class Elevenmoviesjson(
    val src: String,
    val dst: String,
    val static_path: String,
    val http_method: String,
    val key_hex: String,
    val iv_hex: String,
    val xor_key: String,
    val content_types: String,
)


//Domains Parser
data class DomainsParser(
    val moviesdrive: String,
    @JsonProperty("HDHUB4u")
    val hdhub4u: String,
    @JsonProperty("4khdhub")
    val n4khdhub: String,
    @JsonProperty("MultiMovies")
    val multiMovies: String,
    val bollyflix: String,
    @JsonProperty("UHDMovies")
    val uhdmovies: String,
    val moviesmod: String,
    val topMovies: String,
    val hdmovie2: String,
    val vegamovies: String,
    val rogmovies: String,
    val luxmovies: String,
    val movierulzhd: String,
    val extramovies: String,
    val dramadrip: String,
    val banglaplex: String,
    val toonstream: String,
    val telugumv: String,
    val filmycab: String,
    val tellyhd: String,
    val hindmoviez: String,
    @JsonProperty("hubcloud")
    val hubcloud: String,
)

//OXXFile

data class oxxfile(
    val id: String,
    val code: String,
    val fileName: String,
    val size: Long,
    val driveLinks: List<DriveLink>,
    val metadata: Metadata,
    val createdAt: String,
    val views: Long,
    val status: String,
    val gdtotLink: String?, // formerly Any?
    val gdtotName: String?, // formerly Any?
    val hubcloudLink: String,
    val filepressLink: String,
    val vikingLink: String?, // formerly Any?
    val pixeldrainLink: String?, // formerly Any?
    @SerializedName("credential_index")
    val credentialIndex: Long,
    val duration: String?, // safer to assume it's String for now
    val userName: String,
)

data class DriveLink(
    val fileId: String,
    val webViewLink: String,
    val driveLabel: String,
    val credentialIndex: Int,
    val isLoginDrive: Boolean,
    val isDrive2: Boolean
)

data class Metadata(
    val mimeType: String,
    val fileExtension: String,
    val modifiedTime: String,
    val createdTime: String,
    val pixeldrainConversionFailed: Boolean,
    val pixeldrainConversionFailedAt: String,
    val pixeldrainConversionError: String,
    val vikingConversionFailed: Boolean,
    val vikingConversionFailedAt: String
)

// CinemetaRes

data class CinemetaRes(
    val meta: Meta? = null
) {

    data class Meta(
        val id: String? = null,
        val type: String? = null,
        val name: String? = null,

        @JsonProperty("imdb_id")
        val imdbId: String? = null,

        val slug: String? = null,

        val director: String? = null,
        val writer: String? = null,

        val description: String? = null,
        val year: String? = null,
        val releaseInfo: String? = null,
        val released: String? = null,
        val runtime: String? = null,
        val status: String? = null,
        val country: String? = null,
        val imdbRating: String? = null,
        val genres: List<String>? = null,
        val poster: String? = null,
        @JsonProperty("_rawPosterUrl")
        val rawPosterUrl: String? = null,

        val background: String? = null,
        val logo: String? = null,

        val videos: List<Video>? = null,
        val trailers: List<Trailer>? = null,
        val trailerStreams: List<TrailerStream>? = null,
        val links: List<Link>? = null,

        val behaviorHints: BehaviorHints? = null,

        @JsonProperty("app_extras")
        val appExtras: AppExtras? = null,
    ) {

        data class BehaviorHints(
            val defaultVideoId: Any? = null,
            val hasScheduledVideos: Boolean? = null
        )

        data class Link(
            val name: String? = null,
            val category: String? = null,
            val url: String? = null
        )

        data class Trailer(
            val source: String? = null,
            val type: String? = null,
            val name: String? = null
        )

        data class TrailerStream(
            val ytId: String? = null,
            val title: String? = null
        )

        data class Video(
            val id: String? = null,
            val title: String? = null,
            val season: Int? = null,
            val episode: Int? = null,
            val thumbnail: String? = null,
            val overview: String? = null,
            val released: String? = null,
            val available: Boolean? = null,
            val runtime: String? = null
        )

        data class AppExtras(
            val cast: List<Cast>? = null,
            val directors: List<Any?>? = null,
            val writers: List<Any?>? = null,
            val seasonPosters: List<String?>? = null,
            val certification: String? = null
        )

        data class Cast(
            val name: String? = null,
            val character: String? = null,
            val photo: String? = null
        )
    }
}

data class Watch32(
    val type: String,
    val link: String,
)

data class Morph(
    @JsonProperty("error_code")
    val errorCode: Long,
    val message: String,
    val data: List<MorphDaum>,
)

data class MorphDaum(
    val title: String,
    val link: String,
)

data class CinemaOsSecretKeyRequest(
    val tmdbId: String,

    val imdbId: String,
    val seasonId: String,
    val episodeId: String
)


data class CinemaOSReponse(
    val data: CinemaOSReponseData,
    val encrypted: Boolean,
)

data class CinemaOSReponseData(
    val encrypted: String,
    val cin: String,
    val mao: String,
    val salt: String,
)


data class Vidlink(
    val sourceId: String,
    val stream: VidlinkStream,
)

data class VidlinkStream(
    val id: String,
    val type: String,
    val playlist: String,
    val flags: List<String>,
    val captions: List<VidlinkCaption>,
    @JsonProperty("TTL")
    val ttl: Long,
)

data class VidlinkCaption(
    val id: String,
    val url: String,
    val language: String,
    val type: String,
    val hasCorsRestrictions: Boolean,
)

data class PrimeSrcServerList(
    val servers: List<PrimeSrcServer>,
)

data class PrimeSrcServer(
    val name: String,
    val key: String,
    @JsonProperty("file_size")
    val fileSize: String?,
    @JsonProperty("file_name")
    val fileName: String?,
)

data class VidFastServer(
    val name: String,
    val description: String,
    val image: String,
    val data: String,
)

data class KeyIvResult(
    val keyBytes: ByteArray,
    val ivBytes: ByteArray,
    val keyHex: String,
    val ivHex: String
)

data class NuvioStreams(
    val streams: List<NuvioStreamsStream>,
)

data class NuvioStreamsStream(
    val name: String,
    val title: String,
    val url: String,
    val type: String,
    val availability: Long,
    val behaviorHints: NuvioStreamsBehaviorHints,
)

data class NuvioStreamsBehaviorHints(
    val notWebReady: Boolean,
)

data class YflixResponse(
    @get:JsonProperty("result") val result: String
) {
    fun getDocument(): Document {
        return Jsoup.parse(result)
    }
}

class SearchData : ArrayList<SearchData.SearchDataItem>() {
    data class SearchDataItem(
        val audio_languages: String,
        val exact_match: Int,
        val id: Int,
        val path: String,
        val poster: String,
        val qualities: List<String>,
        val release_year: String,
        val title: String,
        val tmdb_id: Int,
        val type: String
    )
}

@JsonIgnoreProperties(ignoreUnknown = true)
data class EmbedmasterSourceItem(
    val id: Any? = null,
    val type: String? = null,
    @JsonProperty("source_type")
    val sourceType: Long? = null,
    @JsonProperty("source_quality")
    val sourceQuality: String? = null,
    @JsonProperty("source_name")
    val sourceName: String? = null,
    @JsonProperty("source_title")
    val sourceTitle: String? = null,
    @JsonProperty("source_subtitle")
    val sourceSubtitle: Boolean? = null,
    @JsonProperty("source_icon")
    val sourceIcon: Long? = null,
    @JsonProperty("source_url")
    val sourceUrl: String,
)

data class VideasySource(
    val key: String,
    val name: String,
    val language: String,
    val movieOnly: Boolean = false
)

data class BidSrcResponse(
    val total: Long,
    val sources: List<String>,
    val servers: List<Server>,
)

data class Server(
    val name: String,
    val quality: String,
    val type: String,
    val url: String,
    val headers: BidSrcHeaders?,
)

data class BidSrcHeaders(
    @JsonProperty("Referer")
    val referer: String,
    @JsonProperty("Origin")
    val origin: String,
)

data class Flixindia(
    val results: List<FlixindiaResult>,
    val query: String,
    val count: Long,
)

data class FlixindiaResult(
    val id: Long,
    val title: String,
    val url: String,
    @JsonProperty("created_at")
    val createdAt: String,
)





================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayPlugin.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.DoodYtExtractor
import com.lagradost.cloudstream3.extractors.FileMoon
import com.lagradost.cloudstream3.extractors.MixDrop
import com.lagradost.cloudstream3.extractors.Mp4Upload
import com.lagradost.cloudstream3.extractors.OkRuHTTP
import com.lagradost.cloudstream3.extractors.OkRuSSL
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamSB8
import com.lagradost.cloudstream3.extractors.StreamTape
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.Streamlare
import com.lagradost.cloudstream3.extractors.VidHidePro6
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.Vidmolyme
import com.lagradost.cloudstream3.extractors.Voe
import com.lagradost.cloudstream3.plugins.Plugin
import androidx.core.content.edit
import com.lagradost.api.Log
import com.lagradost.cloudstream3.MainActivity
import com.lagradost.cloudstream3.extractors.FilemoonV2
import com.lagradost.cloudstream3.extractors.Vidguardto2
import com.lagradost.cloudstream3.plugins.PluginData
import com.lagradost.cloudstream3.plugins.PluginManager
import org.json.JSONArray

@CloudstreamPlugin
class StreamPlayPlugin: Plugin() {
    private val registeredMainApis = mutableListOf<MainAPI>()
    private val PREF_FILE = "StreamPlay"
    private val PREF_KEY_LINKS = "streamplay_stremio_saved_links"

    override fun load(context: Context) {

        val sharedPref = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE)
        val mainApis = listOf(
            StreamPlay(sharedPref),
            StreamPlayAnime(), StreamPlayStremioCatelog("","StreamPlay StremioC",sharedPref)
        )
        val savedSet = sharedPref.getStringSet("enabled_plugins_saved", null)
        val defaultEnabled = mainApis.map { it.name }.toSet()
        val enabledSet = savedSet ?: defaultEnabled

        Log.d("StreamPlay", "SavedSet: $savedSet, DefaultEnabled: $defaultEnabled")
        Log.d("StreamPlay", "Final enabled set: $enabledSet")

        for (api in mainApis) {
            if (enabledSet.contains(api.name)) {
                registerMainAPI(api)
                registeredMainApis.add(api)
                Log.d("StreamPlay", "Registered plugin: ${api.name}")
            } else {
                Log.d("StreamPlay", "Not enabled: ${api.name}")
            }
        }

        sharedPref.edit { remove("enabled_plugins_set") }
        reload(context)
        //=====================MainAPI============================//

        //registerMainAPI(StreamPlayTest(sharedPref))

        //=====================Extractors=========================//

        registerExtractorAPI(Animefever())
        registerExtractorAPI(Multimovies())
        registerExtractorAPI(MultimoviesSB())
        registerExtractorAPI(Yipsu())
        registerExtractorAPI(Mwish())
        registerExtractorAPI(TravelR())
        registerExtractorAPI(Playm4u())
        registerExtractorAPI(FileMoon())
        registerExtractorAPI(VCloud())
        registerExtractorAPI(Kwik())
        registerExtractorAPI(VCloudGDirect())
        registerExtractorAPI(Filelions())
        registerExtractorAPI(Snolaxstream())
        registerExtractorAPI(Pixeldra())
        registerExtractorAPI(Mp4Upload())
        registerExtractorAPI(Graceaddresscommunity())
        registerExtractorAPI(M4ufree())
        registerExtractorAPI(Streamruby())
        registerExtractorAPI(StreamWishExtractor())
        registerExtractorAPI(Filelion())
        registerExtractorAPI(DoodYtExtractor())
        registerExtractorAPI(dlions())
        registerExtractorAPI(MixDrop())
        registerExtractorAPI(dwish())
        registerExtractorAPI(UqloadsXyz())
        registerExtractorAPI(Uploadever())
        registerExtractorAPI(Netembed())
        registerExtractorAPI(Flaswish())
        registerExtractorAPI(Comedyshow())
        registerExtractorAPI(Ridoo())
        registerExtractorAPI(Streamvid())
        registerExtractorAPI(StreamTape())
        registerExtractorAPI(do0od())
        registerExtractorAPI(doodre())
        registerExtractorAPI(Embedrise())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(FilemoonNl())
        registerExtractorAPI(Alions())
        registerExtractorAPI(Vidmolyme())
        registerExtractorAPI(AllinoneDownloader())
        registerExtractorAPI(Tellygossips())
        registerExtractorAPI(Tvlogy())
        registerExtractorAPI(Voe())
        registerExtractorAPI(Gofile())
        registerExtractorAPI(Animezia())
        registerExtractorAPI(PixelDrain())
        registerExtractorAPI(Modflix())
        registerExtractorAPI(Sethniceletter())
        registerExtractorAPI(GDFlix())
        registerExtractorAPI(fastdlserver())
        registerExtractorAPI(GDFlix1())
        registerExtractorAPI(GDFlix2())
        registerExtractorAPI(furher())
        registerExtractorAPI(Servertwo())
        registerExtractorAPI(MultimoviesAIO())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(Driveseed())
        registerExtractorAPI(Driveleech())
        registerExtractorAPI(VidHidePro6())
        registerExtractorAPI(MixDropSi())
        registerExtractorAPI(MixDropPs())
        registerExtractorAPI(Streamlare())
        registerExtractorAPI(StreamSB8())
        registerExtractorAPI(StreamSB())
        registerExtractorAPI(OkRuSSL())
        registerExtractorAPI(OkRuHTTP())
        registerExtractorAPI(Embtaku())
        registerExtractorAPI(bulbasaur())
        registerExtractorAPI(Megacloud())
        registerExtractorAPI(Cdnstreame())
        registerExtractorAPI(Rapidplayers())
        registerExtractorAPI(Maxfinishseveral())
        registerExtractorAPI(Pahe())
        registerExtractorAPI(MegaUp())
        registerExtractorAPI(oxxxfile())
        registerExtractorAPI(Hblinks())
        registerExtractorAPI(VidStack())
        registerExtractorAPI(Videostr())
        registerExtractorAPI(DriveleechPro())
        registerExtractorAPI(DriveleechNet())
        registerExtractorAPI(Molop())
        registerExtractorAPI(showflixupnshare())
        registerExtractorAPI(Embedwish())
        registerExtractorAPI(Rubyvidhub())
        registerExtractorAPI(smoothpre())
        registerExtractorAPI(Akirabox())
        registerExtractorAPI(BuzzServer())
        registerExtractorAPI(FilemoonV2())
        registerExtractorAPI(Vidguardto2())
        registerExtractorAPI(Hubstreamdad())
        registerExtractorAPI(StreamwishHG())
        registerExtractorAPI(PixelServer())
        registerExtractorAPI(Streameeeeee())
        registerExtractorAPI(Vidora())
        registerExtractorAPI(Fourspromax())
        registerExtractorAPI(XdMoviesExtractor())
        registerExtractorAPI(Hubdrive())
        registerExtractorAPI(Rapidairmax())
        registerExtractorAPI(Rapidshare())
        registerExtractorAPI(HdStream4u())
        registerExtractorAPI(Hubstream())
        registerExtractorAPI(Hubcdnn())
        registerExtractorAPI(HUBCDN())
        registerExtractorAPI(PixelDrainDev())
        registerExtractorAPI(Krakenfiles())
        registerExtractorAPI(MegaUpTwoTwo())
        registerExtractorAPI(Movearnpre())
        registerExtractorAPI(StreamwishTO())
        registerExtractorAPI(mixdrop21())
        registerExtractorAPI(m1xdrop())

        openSettings = { ctx ->
            val act = ctx as AppCompatActivity
            if (!act.isFinishing && !act.isDestroyed) {
                val frag = MainSettingsFragment(this, sharedPref)
                frag.show(act.supportFragmentManager, "Frag")
            } else {
                Log.e("Plugin", "Activity is not valid anymore, cannot show settings dialog")
            }
        }
    }


    fun reload(context: Context) {
        try {
            val prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE)
            val json = prefs.getString(PREF_KEY_LINKS, null) ?: "[]"
            val arr = JSONArray(json)
            val links = mutableListOf<LinkEntry>()
            for (i in 0 until arr.length()) {
                val obj = arr.optJSONObject(i) ?: continue
                links.add(
                    LinkEntry(
                        id = obj.optLong("id", System.currentTimeMillis()),
                        name = obj.optString("name", ""),
                        link = obj.optString("link", ""),
                        type = obj.optString("type", "StremioX")
                    )
                )
            }
            for (item in links) {
                val pluginsOnline: Array<PluginData> = PluginManager.getPluginsOnline()
                var found: PluginData? = null
                for (p in pluginsOnline) {
                    if (p.internalName.contains(item.name, ignoreCase = true)) {
                        found = p
                        break
                    }
                }
                if (found != null) {
                    try {
                        PluginManager.unloadPlugin(found.filePath)
                    } catch (e: Throwable) {
                        Log.e("StreamplayStremioXPlugin", "unload failed ${e.message}")
                    }
                } else {
                    try {
                        when (item.type) {
                            "StremioC" -> {
                                try {
                                    registerMainAPI(StreamPlayStremioCatelog(
                                        item.link,
                                        item.name,
                                        sharedPref = prefs
                                    ))
                                } catch (_: Throwable) {
                                    try { registerMainAPI(StreamPlayStremioCatelog(
                                        "",
                                        item.name,
                                        sharedPref = prefs
                                    )) } catch (_: Throwable) {}
                                }
                            }
                            else -> {
                                try { registerMainAPI(StreamPlayStremioCatelog(
                                    item.link,
                                    item.name,
                                    sharedPref = prefs
                                )) } catch (_: Throwable) {}
                            }
                        }
                    } catch (e: Throwable) {
                        Log.e("StreamplayStremioXPlugin", "register failed ${e.message}")
                    }
                }
            }
            try {
                MainActivity.afterPluginsLoadedEvent.invoke(true)
            } catch (e: Throwable) {
                Log.w("StreamplayStremioXPlugin", "afterPluginsLoaded invoke failed ${e.message}")
            }
        } catch (e: Throwable) {
            Log.e("StreamplayStremioXPlugin", "reload error ${e.message}")
        }
    }
    data class LinkEntry(
        val id: Long,
        val name: String,
        val link: String,
        val type: String
    )
}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayStremioCatelog.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixTitle
import com.lagradost.cloudstream3.imdbUrlToIdNullable
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.StreamPlay.Companion.dahmerMoviesAPI
import com.phisher98.StreamPlayExtractor.invokeSubtitleAPI
import com.phisher98.StreamPlayExtractor.invokeWyZIESUBAPI
import com.phisher98.StreamPlayExtractor.token
import org.json.JSONObject
import java.net.URLEncoder


class StreamPlayStremioCatelog(
    override var mainUrl: String,
    override var name: String,
    val sharedPref: SharedPreferences? = null
) : MainAPI() {
    override val supportedTypes = setOf(TvType.Others,TvType.Movie,
        TvType.TvSeries)
    override val hasMainPage = true

    companion object {
        private const val cinemataUrl = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb"
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        if (mainUrl.isEmpty()) {
            throw IllegalArgumentException("Configure in StreamPlay Catalogs Addon in Extension Settings\n")
        }
        mainUrl = mainUrl.fixSourceUrl()

        val pageSize = 100
        val skip = (page - 1) * pageSize

        val manifest = app
            .get("$mainUrl/manifest.json")
            .parsedSafe<Manifest>()

        val lists = mutableListOf<HomePageList>()

        manifest?.catalogs?.amap { catalog ->
            catalog.toHomePageList(
                provider = this,
                skip = skip
            ).let {
                if (it.list.isNotEmpty()) {
                    lists.add(it)
                }
            }
        }

        return newHomePageResponse(
            lists,
            hasNext = true
        )
    }

    override suspend fun search(query: String): List<SearchResponse> {
        mainUrl = mainUrl.fixSourceUrl()
        val res = app.get("${mainUrl}/manifest.json").parsedSafe<Manifest>()
        val list = mutableListOf<SearchResponse>()
        res?.catalogs?.amap { catalog ->
            list.addAll(catalog.search(query, this))
        }
        return list.distinct()
    }

    override suspend fun load(url: String): LoadResponse {
        val res: CatalogEntry = if (url.startsWith("{")) {
            parseJson(url)
        } else {
            val json = app.get(url).text
            val metaJson = JSONObject(json).getJSONObject("meta").toString()
            parseJson(metaJson)
        }

        val encodedId = URLEncoder.encode(res.id, "UTF-8")

        val response = app.get("${mainUrl}/meta/${res.type}/$encodedId.json")
            .parsedSafe<CatalogResponse>()
            ?: throw RuntimeException("Failed to load meta")

        val entry = response.meta
            ?: response.metas?.firstOrNull { it.id == res.id }
            ?: response.metas?.firstOrNull()
            ?: throw RuntimeException("Meta not found")

        return entry.toLoadResponse(this, res.id)
    }

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = parseJson<LoadData>(data)
        val imdb = res.resolveImdbId()
        val cinemeta = imdb?.let {
            fetchCinemetaMeta(it, res.type)
        }

        val resolved = res.copy(
            imdbId = imdb,
            title = cinemeta?.title
        )

        val disabledProviderIds = sharedPref
            ?.getStringSet("disabled_providers", emptySet())
            ?.toSet() ?: emptySet()
        val providersList = buildProviders().filter { it.id !in disabledProviderIds }
        val authToken = token
        runLimitedAsync( concurrency = 10,
            {
                try {
                    invokeSubtitleAPI(imdb, resolved.season, resolved.episode, subtitleCallback)
                } catch (_: Throwable) {
                    // ignore failure but do not cancel the rest
                }
            },
            {
                try {
                    invokeWyZIESUBAPI(imdb, res.season, res.episode, subtitleCallback)
                } catch (_: Throwable) {
                    // ignore failure
                }
            },
            *providersList.map { provider ->
                suspend {
                    try {
                        provider.invoke(
                            resolved.toLinkData(),
                            subtitleCallback,
                            callback,
                            authToken ?: "",
                            dahmerMoviesAPI
                        )
                    } catch (_: Throwable) {
                        // provider failure shouldn't kill others
                    }
                }
            }.toTypedArray()
        )

        return true
    }

    data class LoadData(
        val type: String? = null,
        val id: String? = null,
        val season: Int? = null,
        val episode: Int? = null,
        val imdbId: String? = null,
        val year: Int? = null,
        val title: String? = null
    )


    private fun LoadData.toLinkData(): StreamPlay.LinkData {
        return StreamPlay.LinkData(
            imdbId = imdbId,
            type = type,
            season = season,
            episode = episode,
            title = title,
            year = year,
        )
    }






    // check if id is imdb/tmdb cause stremio addons like torrentio works base on imdbId
    private fun isImdborTmdb(url: String?): Boolean {
        return imdbUrlToIdNullable(url) != null || url?.startsWith("tmdb:") == true
    }

    private fun isImdb(url: String?): Boolean {
        return imdbUrlToIdNullable(url) != null
    }


    private data class Manifest(val catalogs: List<Catalog>)
    private data class Catalog(
        var name: String?,
        val id: String,
        val type: String?,
        val types: MutableList<String> = mutableListOf()
    ) {
        init {
            if (type != null) types.add(type)
        }

        suspend fun search(query: String, provider: StreamPlayStremioCatelog): List<SearchResponse> {
            val entries = mutableListOf<SearchResponse>()
            types.forEach { type ->
                val res = app.get(
                    "${provider.mainUrl}/catalog/${type}/${id}/search=${query}.json",
                    timeout = 120L
                ).parsedSafe<CatalogResponse>()
                res?.metas?.forEach { entry ->
                    entries.add(entry.toSearchResponse(provider))
                }
            }
            return entries
        }

        suspend fun toHomePageList(provider: StreamPlayStremioCatelog, skip: Int): HomePageList {
            val entries = mutableMapOf<String, SearchResponse>()

            types.forEach { type ->
                val url = if (skip > 0) {
                    "${provider.mainUrl}/catalog/$type/$id/skip=$skip.json"
                } else {
                    "${provider.mainUrl}/catalog/$type/$id.json"
                }

                val res = app.get(
                    url,
                    timeout = 120L
                ).parsedSafe<CatalogResponse>()

                res?.metas?.forEach { entry ->
                    if (!entries.containsKey(entry.id)) {
                        entries[entry.id] = entry.toSearchResponse(provider)
                    }
                }
            }

            return HomePageList(
                name ?: id,
                entries.values.toList()
            )
        }
    }

    private data class CatalogResponse(val metas: List<CatalogEntry>?, val meta: CatalogEntry?)

    private data class Trailer(
        val source: String?,
        val type: String?
    )

    private data class CatalogEntry(
        @JsonProperty("name") val name: String,
        @JsonProperty("id") val id: String,
        @JsonProperty("poster") val poster: String?,
        @JsonProperty("background") val background: String?,
        @JsonProperty("description") val description: String?,
        @JsonProperty("imdbRating") val imdbRating: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("videos") val videos: List<Video>?,
        @JsonProperty("genre") val genre: List<String>?,
        @JsonProperty("genres") val genres: List<String> = emptyList(),
        @JsonProperty("cast") val cast: List<String> = emptyList(),
        @JsonProperty("trailers") val trailersSources: List<Trailer> = emptyList(),
        @JsonProperty("year") val yearNum: String? = null
    ) {
        fun toSearchResponse(provider: StreamPlayStremioCatelog): SearchResponse {
            return provider.newMovieSearchResponse(
                name,
                this.toJson(),
                TvType.Others
            ) {
                posterUrl = poster
            }
        }

        suspend fun toLoadResponse(provider: StreamPlayStremioCatelog, imdbId: String?): LoadResponse {
            if (videos.isNullOrEmpty()) {
                return provider.newMovieLoadResponse(
                    name,
                    "${provider.mainUrl}/meta/${type}/${id}.json",
                    TvType.Movie,
                    LoadData(type, id, imdbId = imdbId, year = yearNum?.toIntOrNull())
                ) {
                    posterUrl = poster
                    backgroundPosterUrl = background
                    score = Score.from10(imdbRating)
                    plot = description
                    year = yearNum?.toIntOrNull()
                    tags = genre ?: genres
                    addActors(cast)
                    addTrailer(trailersSources.map { "https://www.youtube.com/watch?v=${it.source}" })
                    addImdbId(imdbId)
                }
            } else {
                return provider.newTvSeriesLoadResponse(
                    name,
                    "${provider.mainUrl}/meta/${type}/${id}.json",
                    TvType.TvSeries,
                    videos.map {
                        it.toEpisode(provider, type, imdbId)
                    }
                ) {
                    posterUrl = poster
                    backgroundPosterUrl = background
                    score = Score.from10(imdbRating)
                    plot = description
                    year = yearNum?.toIntOrNull()
                    tags = genre ?: genres
                    addActors(cast)
                    addTrailer(trailersSources.map { "https://www.youtube.com/watch?v=${it.source}" }
                        ?.randomOrNull())
                    addImdbId(imdbId)
                }
            }

        }
    }

    private data class Video(
        @JsonProperty("id") val id: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("season") val seasonNumber: Int? = null,
        @JsonProperty("number") val number: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("thumbnail") val thumbnail: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("description") val description: String? = null,
    ) {
        fun toEpisode(provider: StreamPlayStremioCatelog, type: String?, imdbId: String?): Episode {
            return provider.newEpisode(
                LoadData(type, id, seasonNumber, episode ?: number, imdbId)
            ) {
                this.name = this@Video.name ?: title
                this.posterUrl = thumbnail
                this.description = overview ?:  this@Video.description
                this.season = seasonNumber
                this.episode =  this@Video.episode ?: number
            }
        }
    }

    suspend fun LoadData.resolveImdbId(): String? {
        val source = imdbId ?: id ?: return null
        val imdb: String? = imdbUrlToIdNullable(source)
        if (imdb != null) return imdb
        return when {
            source.startsWith("tt") -> source
            source.startsWith("tmdb:") -> tmdbToImdb(source.removePrefix("tmdb:"), type)
            source.startsWith("kitsu:") -> kitsuToImdb(source.removePrefix("kitsu:"))
            else -> null
        }
    }




    suspend fun tmdbToImdb(tmdbId: String, type: String?): String? {
        val mediaType = if (type == "series") "tv" else "movie"

        val res = app.get(
            "https://api.themoviedb.org/3/$mediaType/$tmdbId/external_ids",
            params = mapOf("api_key" to "98ae14df2b8d8f8f8136499daf79f0e0")
        ).parsedSafe<TmdbExternalIds>()

        return res?.imdb_id
    }

    data class TmdbExternalIds(
        @JsonProperty("imdb_id") val imdb_id: String?
    )

    suspend fun kitsuToImdb(kitsuId: String): String? {
        val id = kitsuId.removePrefix("kitsu:")

        val res = app.get(
            "https://api.ani.zip/mappings",
            params = mapOf("kitsu_id" to id)
        ).parsedSafe<AniZipResponse>()

        return res?.mappings?.imdb_id
    }

    data class AniZipResponse(
        val mappings: AniZipMappings?
    )

    data class AniZipMappings(
        val imdb_id: String?
    )

    suspend fun fetchCinemetaMeta(
        imdbId: String,
        type: String?
    ): CinemetaMetaData? {
        val mediaType = if (type == "series") "series" else "movie"

        val res = app.get(
            "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta/$mediaType/$imdbId.json"
        ).parsedSafe<CinemetaResponse>()

        return res?.meta?.let {
            CinemetaMetaData(
                title = it.name,
                tmdbId = it.links
                    ?.firstOrNull { link -> link.category == "tmdb" }
                    ?.id
                    ?.toIntOrNull()
            )
        }
    }

    data class CinemetaResponse(
        val meta: CinemetaMeta?
    )

    data class CinemetaMeta(
        val name: String?,
        val links: List<CinemetaLink>?
    )

    data class CinemetaLink(
        val category: String?,
        val id: String?
    )

    data class CinemetaMetaData(
        val title: String?,
        val tmdbId: Int?
    )



}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayTest.kt
================================================
package com.phisher98


import android.content.SharedPreferences
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.StreamPlayExtractor.invokeKisskhAsia

class StreamPlayTest(sharedPreferences:SharedPreferences?=null) : StreamPlay(sharedPreferences) {
    override var name = "StreamPlay-Test"
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = AppUtils.parseJson<LinkData>(data)
        runAllAsync(
            {
                if (!res.isAnime) invokeKisskhAsia(
                    res.id,
                    res.season,
                    res.episode,
                    subtitleCallback,
                    callback
                )
            }
        )
        return true
    }

}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayTorrent.kt
================================================
package com.phisher98

import com.phisher98.StreamPlayExtractor.invokeSubtitleAPI
import com.phisher98.StreamPlayExtractor.invokeWyZIESUBAPI
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.json.JSONObject
import java.net.URLEncoder
import java.nio.charset.StandardCharsets

@Suppress("NAME_SHADOWING")
class StreamPlayTorrent() : StreamPlay() {
    override var name = "StreamPlay-Torrent"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Anime, TvType.AsianDrama,TvType.Torrent)
    override var lang = "en"
    override val hasMainPage = true
    override val hasQuickSearch = false

    companion object
    {
        const val TorrentioAPI="https://torrentio.strem.fun/providers=yts,eztv,rarbg,1337x,thepiratebay,kickasstorrents,torrentgalaxy,magnetdl%7Csort=seeders"
        const val TorrentgalaxyAPI="https://torrentgalaxy.to"
        const val TorrentmovieAPI="https://torrentmovie.net"
        const val OnethreethreesevenxAPI="https://1337x.to"
        const val TorBoxAPI="https://stremio.torbox.app"
        const val BitsearchApi="https://bitsearch.to"
        const val MediafusionApi="https://mediafusion.elfhosted.com"
        const val CometAPI = "https://comet.elfhosted.com"
        const val ThePirateBayApi="https://thepiratebay-plus.strem.fun"
        const val PeerflixApi="https://peerflix.mov"
        const val AnimetoshoAPI="https://feed.animetosho.org"
        const val TorrentioAnimeAPI="https://torrentio.strem.fun/providers=nyaasi,tokyotosho,anidex%7Csort=seeders"
        private const val Uindex = "https://uindex.org"
        private const val Knaben = "https://knaben.org"
        val TRACKER_LIST_URL= listOf(
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best.txt",
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best_ip.txt",
        )

    }


override suspend fun loadLinks(
    data: String,
    isCasting: Boolean,
    subtitleCallback: (SubtitleFile) -> Unit,
    callback: (ExtractorLink) -> Unit
): Boolean {
    val data = AppUtils.parseJson<LinkData>(data)
    val title = data.title
    val season = data.season
    val episode = data.episode
    val id = data.imdbId
    val year = data.year
    val isAnime = data.isAnime
    var type = TvType.TvSeries
    var anijson: String? = null

    try {
        anijson = app.get("https://api.ani.zip/mappings?imdb_id=$id").toString()
        val mappings = JSONObject(anijson).optJSONObject("mappings")
        val rawtype = mappings?.optString("type", "")
        if (rawtype?.contains("MOVIE", ignoreCase = true) == true) {
            type = TvType.Movie
        }
    } catch (e: Exception) {
        println("Error fetching or parsing mapping: ${e.message}")
    }

    val anidbEid = getAnidbEid(anijson ?: "{}", episode) ?: 0
    runAllAsync(
        {
            invokeTorrentio(
                TorrentioAPI,
                id,
                season,
                episode,
                callback
            )
        },

        {
            invoke1337x(
                OnethreethreesevenxAPI,
                title,
                year,
                callback
            )
        },
        {
            invokeThepiratebay(
                ThePirateBayApi,
                id,
                season,
                episode,
                callback
            )

        },
        {
        invokeUindex(
            Uindex,
            title,
            year,
            season,
            episode,
            callback)
        },
        /*
        {
            invokeMediaFusion(
                MediafusionApi,
                id,
                season,
                episode,
                callback
            )

        },


        {
            invokePeerFlix(
                PeerflixApi,
                id,
                season,
                episode,
                callback
            )
        },
        {
            invokeComet(
                CometAPI,
                id,
                season,
                episode,
                callback
            )
        },
         */
        {
            if (data.isAnime) invokeAnimetosho(
                anidbEid,
                callback
            )
        },
        {
            if (data.isAnime) invokeTorrentioAnime(
                TorrentioAnimeAPI,
                type,
                season,
                episode,
                callback
            )
        },
        {
            invokeKnaben(Knaben,
                isAnime,
                title,
                year,
                season,
                episode,
                callback)
        },

        //Source till here
        //Subtitles Invokes
        {
            invokeWyZIESUBAPI(
                id,
                season,
                episode,
                subtitleCallback,
            )
        },
        {
            invokeSubtitleAPI(
                id,
                season,
                episode,
                subtitleCallback
            )
        }
    )
    return true
}
}


suspend fun generateMagnetLink(
    trackerUrls: List<String>,
    hash: String?,
): String {
    require(hash?.isNotBlank() == true)

    val trackers = mutableSetOf<String>()

    trackerUrls.forEach { url ->
        try {
            val response = app.get(url)
            response.text
                .lineSequence()
                .map { it.trim() }
                .filter { it.isNotEmpty() && !it.startsWith("#") }
                .forEach { trackers.add(it) }
        } catch (_: Exception) {
            // ignore bad sources
        }
    }

    return buildString {
        append("magnet:?xt=urn:btih:").append(hash)

        if (hash.isNotBlank()) {
            append("&dn=")
            append(URLEncoder.encode(hash, StandardCharsets.UTF_8.name()))
        }

        trackers
            .take(10) // practical limit
            .forEach { tracker ->
                append("&tr=")
                append(URLEncoder.encode(tracker, StandardCharsets.UTF_8.name()))
            }
    }
}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamplayTorrentAnime.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.CommonActivity.activity
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Media
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import com.phisher98.StreamPlayAnime.LinkData
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.util.Calendar

open class StreamplayTorrentAnime : MainAPI() {
    override var name = "StremplayTorrent-Anime"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.aniListApi)
    private val apiUrl = "https://graphql.anilist.co"
    private val mediaLimit = 20
    private val isAdult = false
    private val headerJSON =
        mapOf("Accept" to "application/json", "Content-Type" to "application/json")

    private val torrentioDebian= "https://torrentio.strem.fun"
    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun anilistAPICall(query: String): AnilistAPIResponse {
        val data = mapOf("query" to query)
        val test = app.post(apiUrl, headers = headerJSON, data = data)
        val res =
            test.parsedSafe<AnilistAPIResponse>()
                ?: throw Exception("Unable to fetch or parse Anilist api response")
        return res
    }

    private fun Media.toSearchResponse(): SearchResponse {
        val title = this.title.english ?: this.title.romaji ?: ""
        val url = "$mainUrl/anime/${this.id}"
        val posterUrl = this.coverImage.large
        return newAnimeSearchResponse(title, url, TvType.Anime) { this.posterUrl = posterUrl }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
        page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val res = anilistAPICall(this.data.replace("###", "$page"))
        val data =
            res.data.page?.media?.map { it.toSearchResponse() }
                ?: throw Exception("Unable to read media data")
        val hasNextPage = res.data.page.pageInfo.hasNextPage ?: false
        return data to hasNextPage
    }

    private val currentYear = Calendar.getInstance().get(Calendar.YEAR)

    override val mainPage =
        mainPageOf(
            "query (\$page: Int = ###, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Trending Now",
            "query (\$page: Int = ###, \$seasonYear: Int = $currentYear, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, seasonYear: \$seasonYear, season: SPRING, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Popular This Season",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "All Time Popular",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [SCORE_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Top 100 Anime",
            "Personal" to "Personal"
        )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res =
            anilistAPICall(
                "query (\$search: String = \"$query\") { Page(page: 1, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(search: \$search, isAdult: $isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }"
            )
        return res.data.page?.media?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                ?: return newHomePageResponse(
                    "Login required for personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            val homePageList =
                repo.library().getOrThrow()!!.allLibraryLists.mapNotNull {
                    if (it.items.isEmpty()) return@mapNotNull null
                    val libraryName =
                        it.name.asString(activity ?: return@mapNotNull null)
                    HomePageList("${request.name}: $libraryName", it.items)
                }
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is
            // overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data = anilistAPICall(
            "query (\$id: Int = $id) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val anititle = data.getTitle()
        val aniyear = data.startDate.year
        val anitype = if (data.format!!.contains("MOVIE", ignoreCase = true)) TvType.AnimeMovie else TvType.TvSeries
        val ids = tmdbToAnimeId(anititle, aniyear, anitype)

        val jpTitle = data.title.romaji
        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=${ids.id}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)

        val href = LinkData(
            malId = ids.idMal,
            aniId = ids.id,
            title = data.getTitle(),
            jpTitle = jpTitle,
            year = data.startDate.year,
            isAnime = true
        ).toStringData()

        // --- Helper to get best episode title ---
        fun resolveTitle(epData: MetaEpisode?): String {
            val jsonTitle = epData?.title?.get("en")
                ?: epData?.title?.get("ja")
                ?: epData?.title?.get("x-jat")
                ?: animeMetaData?.titles?.get("en")
                ?: animeMetaData?.titles?.get("ja")
                ?: animeMetaData?.titles?.get("x-jat")
                ?: ""
            return jsonTitle.ifBlank { "Episode ${epData?.episode ?: ""}" }
        }

        fun createEpisode(i: Int, isDub: Boolean): Episode {
            val epData = animeMetaData?.episodes?.get(i.toString())
            val linkData = LinkData(
                malId = ids.idMal,
                aniId = ids.id,
                title = data.getTitle(),
                jpTitle = jpTitle,
                year = data.startDate.year,
                season = 1,
                episode = i,
                isAnime = true,
                isDub = isDub
            ).toStringData()

            return newEpisode(linkData) {
                this.season = 1
                this.episode = i
                this.name = resolveTitle(epData)
                this.posterUrl = epData?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
                this.description = epData?.overview ?: "No summary available"
                this.score = Score.from10(epData?.rating)
                this.runTime = epData?.runtime
                this.addDate(epData?.airDateUtc)
            }
        }

        val episodes = (1..data.totalEpisodes()).map { createEpisode(it, false) }

        return if (data.format.contains("Movie",ignoreCase = true)) {
            newMovieLoadResponse(data.getTitle(), url, TvType.AnimeMovie, href) {
                addAniListId(id.toInt())
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl = animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                    ?: data.getCoverImage()
                this.tags = data.genres
            }
        } else {
            newAnimeLoadResponse(data.getTitle(), url, TvType.Anime) {
                addAniListId(id.toInt())
                addEpisodes(DubStatus.Subbed, episodes)
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl =
                    animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url
                        ?: data.bannerImage
                this.posterUrl = animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                    ?: data.getCoverImage()
                this.tags = data.genres
                this.recommendations = data.recommendations?.edges
                    ?.mapNotNull { edge ->
                        val recommendation = edge.node.mediaRecommendation ?: return@mapNotNull null
                        val title = recommendation.title?.english
                            ?: recommendation.title?.romaji
                            ?:  "Unknown"
                        val recommendationUrl = "$mainUrl/anime/${recommendation.id}"
                        newAnimeSearchResponse(title, recommendationUrl, TvType.Anime).apply {
                            this.posterUrl = recommendation.coverImage?.large
                        }
                    }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        var episode =mediaData.episode
        val aniid =mediaData.aniId
        var anidbEid: Int? = null
        var type = TvType.TvSeries
        var kitsuId = -1

        try {
            val anijson = app.get("https://api.ani.zip/mappings?anilist_id=$aniid").toString()
            val mappings = JSONObject(anijson).optJSONObject("mappings")
            if (mappings != null) {
                kitsuId = mappings.optInt("kitsu_id", -1)
                val rawtype = mappings.optString("type", "")
                if (rawtype.contains("MOVIE", ignoreCase = true)) {
                    type = TvType.Movie
                    episode = 1
                }
            }
            anidbEid = try { getAnidbEid(anijson, episode) } catch (_: Exception) { null }

        } catch (_: Exception) {
        }
        runAllAsync(
            {
                invokeAnimetosho(
                    anidbEid,
                    callback
                )
            },
            {
                invokeTorrentioAnime(torrentioDebian, type, kitsuId, episode, callback)
            },
        )


        return true
    }

    data class AnilistAPIResponse(
        @JsonProperty("data") val data: AnilistData,
    ) {
        data class AnilistData(
            @JsonProperty("Page") val page: AnilistPage?,
            @JsonProperty("Media") val media: anilistMedia?,
        ) {
            data class AnilistPage(
                @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
                @JsonProperty("media") val media: List<Media>,
            )
        }

        data class anilistMedia(
            @JsonProperty("id") val id: Int,
            @JsonProperty("startDate") val startDate: StartDate,
            @JsonProperty("episodes") val episodes: Int?,
            @JsonProperty("title") val title: Title,
            @JsonProperty("season") val season: String?,
            @JsonProperty("genres") val genres: List<String>,
            @JsonProperty("description") val description: String?,
            @JsonProperty("coverImage") val coverImage: CoverImage,
            @JsonProperty("bannerImage") val bannerImage: String?,
            @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
            @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
            @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
            @JsonProperty("format") val format: String?,
            ) {
            data class StartDate(@JsonProperty("year") val year: Int)

            data class AiringScheduleNodes(
                @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
            )

            fun totalEpisodes(): Int {
                return nextAiringEpisode?.episode?.minus(1)
                    ?: episodes ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                    ?: throw Exception("Unable to calculate total episodes")
            }

            fun getTitle(): String {
                return title.english
                    ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
            }

            fun getCoverImage(): String? {
                return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
            }
        }
    }

    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: Int? = null,
        @JsonProperty("malId") val malId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
    )

    private suspend fun tmdbToAnimeId(title: String?, year: Int?, type: TvType): com.phisher98.AniIds {
        if (title.isNullOrBlank()) return com.phisher98.AniIds(null, null)

        val query = """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}seasonYear: Int
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              seasonYear: ${'$'}seasonYear
              format_in: ${'$'}format
            ) {
              id
              idMal
            }
          }
        }
    """.trimIndent()

        val variables = mutableMapOf(
            "search" to title,
            "sort" to listOf("SEARCH_MATCH"),
            "type" to "ANIME",
            "format" to listOf(
                if (type == TvType.AnimeMovie) "MOVIE" else "TV",
                "ONA",
                "OVA"
            )
        )

        val data = mapOf(
            "query" to query,
            "variables" to variables
        ).toJson().toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val res = app.post(StreamPlay.anilistAPI, requestBody = data)
            .parsedSafe<com.phisher98.AniSearch>()
            ?.data
            ?.let { it.Page?.media ?: it.media }
            ?.firstOrNull()

        return com.phisher98.AniIds(res?.id, res?.idMal)
    }

    data class AniIds(var id: Int? = null, var idMal: Int? = null)

    data class AniMedia(
        @JsonProperty("id") var id: Int? = null,
        @JsonProperty("idMal") var idMal: Int? = null
    )

    data class AniPage(@JsonProperty("media") var media: java.util.ArrayList<AniMedia> = arrayListOf())

    data class AniData(@JsonProperty("Page") var Page: AniPage? = AniPage())

    data class AniSearch(@JsonProperty("data") var data: AniData? = AniData())

}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamplayTorrentExtractor.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.TvType
import com.phisher98.StreamPlayTorrent.Companion.AnimetoshoAPI
import com.phisher98.StreamPlayTorrent.Companion.TRACKER_LIST_URL
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.util.Locale

suspend fun invokeTorrentio(
    mainUrl:String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val torrentioAPI:String = mainUrl
    val url = if(season == null) {
        "$torrentioAPI/stream/movie/$id.json"
    }
    else {
        "$torrentioAPI/stream/series/$id:$season:$episode.json"
    }
    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val formattedTitleName = stream.title
            ?.let { title ->
                val qualityTermsRegex = "(2160p|1080p|720p|WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)".toRegex(RegexOption.IGNORE_CASE)
                val tagsList = qualityTermsRegex.findAll(title).map { it.value.uppercase() }.toList()
                val tags = tagsList.distinct().joinToString(" | ")

                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\n]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"

                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        val qualityMatch = "(2160p|1080p|720p)".toRegex(RegexOption.IGNORE_CASE)
            .find(stream.title ?: "")
            ?.value
            ?.lowercase()

        val magnet = generateMagnetLink(TRACKER_LIST_URL, stream.infoHash)

        callback.invoke(
            newExtractorLink(
                "Torrentio",
                formattedTitleName ?: stream.name ?: "",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}

suspend fun invokeAnimetosho(
    id: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = "$AnimetoshoAPI/json?eid=$id&qx=1&q=!(%22DTS%22|%22TrueHD%22|%22[EMBER]%22)((e*|a*|r*|i*|o*|%221080%22)%20!%22720%22%20!%22540%22%20!%22480%22)"
    val jsonResponse = app.get(url).toString()
    val parsedList = Gson().fromJson(jsonResponse, Array<AnimetoshoItem>::class.java)?.toList() ?: emptyList()
    parsedList.sortedByDescending { it.seeders }.forEach { item ->
        item.magnetUri.let { magnet ->
            val formattedTitleName = item.torrentName
                .let { title ->
                    val tags = "\\[(.*?)]".toRegex().findAll(title)
                        .map { match -> "[${match.groupValues[1]}]" }
                        .joinToString(" | ")
                    val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: ""
                    "Animetosho | $tags | Seeder: $seeder".trim()
                }
            callback.invoke(
                newExtractorLink(
                    "Animetosho",
                    formattedTitleName,
                    url = magnet,
                    INFER_TYPE
                ) {
                    this.quality = getIndexQuality(item.torrentName)
                }
            )

        }
    }
}


suspend fun invokeTorrentgalaxy(
    TorrentgalaxyAPI: String? = null,
    id: String? = null,
    callback: (ExtractorLink) -> Unit
) {

    val Torrentgalaxy="$TorrentgalaxyAPI/torrents.php?search=$id&lang=0&nox=2&sort=seeders&order=desc"
    app.get(Torrentgalaxy).documentLarge.select("div.tgxtablerow.txlight").take(10).map {
        val title=it.select("div.tgxtablecell.clickable-row.click.textshadow a.txlight").attr("title")
        val magnet=it.select("div:nth-child(5) > a:nth-child(2)").attr("href")
        callback.invoke(
            newExtractorLink(
                "Torrentgalaxy",
                "Torrentgalaxy $title",
                url = magnet,
                INFER_TYPE
            ) {
                this.quality = getIndexQuality(title)
            }
        )

    }
}


suspend fun invokeTorrentmovie(
    TorrentmovieAPI: String?=null,
    title: String? = null,
    callback: (ExtractorLink) -> Unit
) {
    app.get("$TorrentmovieAPI/secure/search/$title?limit=20").parsedSafe<Torrentmovie>()?.results?.map {
        val files= mutableListOf<String>()
        files+=it.screenResolution2160p
        files+=it.screenResolution1080p
        files+=it.screenResolution720p
        files.forEach { file ->
            val quality=file.substringAfter("resolution_").substringBefore("ps")
            callback.invoke(
                newExtractorLink(
                    "Torrentmovie",
                    "Torrentmovie",
                    url = "$TorrentmovieAPI/${file}",
                    INFER_TYPE
                ) {
                    this.quality = getQualityFromName(quality)
                }
            )

        }
    }
}


suspend fun invoke1337x(
    OnethreethreesevenxAPI: String? = null,
    title: String? = null,
    year: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    app.get("$OnethreethreesevenxAPI/category-search/${title?.replace(" ", "+")}+$year/Movies/1/")
        .documentLarge.select("tbody > tr > td a:nth-child(2)").amap {
            val iframe = OnethreethreesevenxAPI + it.attr("href")
            val doc = app.get(iframe).documentLarge

            val magnet = doc.select("#openPopup").attr("href").trim()
            val qualityRaw = doc.select("div.box-info ul.list li:contains(Type) span").text()
            val quality = getQuality(qualityRaw)

            val size = doc.select("div.box-info ul.list li:contains(Total size) span").text()
            val language = doc.select("div.box-info ul.list li:contains(Language) span").text()
            val seeders = doc.select("div.box-info ul.list li:contains(Seeders) span.seeds").text()

            val displayName = buildString {
                append("Torrent1337x $qualityRaw")
                if (size.isNotBlank()) append(" | Size: $size")
                if (language.isNotBlank()) append(" | Lang: $language")
                if (seeders.isNotBlank()) append(" | 🟢$seeders")
            }

            callback.invoke(
                newExtractorLink(
                    "Torrent1337x",
                    displayName,
                    url = magnet,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = quality
                }
            )
        }
}


suspend fun invokeMediaFusion(
    mediaFusionApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$mediaFusionApi/stream/movie/$imdbId.json"
        }
        else {
            "$mediaFusionApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<MediafusionResponse>()
        for(stream in res?.streams!!)
        {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            val qualityFromName = getIndexQuality(stream.name)

            callback.invoke(
                newExtractorLink(
                    "MediaFusion",
                    stream.description,
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = qualityFromName
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokeThepiratebay(
    thepiratebayApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$thepiratebayApi/stream/movie/$imdbId.json"
        }
        else {
            "$thepiratebayApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<TBPResponse>()
        for(stream in res?.streams!!)
        {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            callback.invoke(
                newExtractorLink(
                    "ThePirateBay",
                    "ThePirateBay [${stream.title}]",
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.title)
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokePeerFlix(
    peerflixApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if (season == null) {
            "$peerflixApi/stream/movie/$imdbId.json"
        } else {
            "$peerflixApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<PeerflixResponse>()
        for (stream in res?.streams!!) {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            callback.invoke(
                newExtractorLink(
                    "Peerflix",
                    stream.name,
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.description)
                }
            )
        }
    } catch (_: Exception) {
    }
}


suspend fun invokeComet(
    CometAPI: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$CometAPI/stream/movie/$imdbId.json"
        }
        else {
            "$CometAPI/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<MediafusionResponse>()
        for(stream in res?.streams!!)
        {
            val formattedTitleName = stream.description.let { title ->
                val tags = "\\[(.*?)]".toRegex()
                    .findAll(title)
                    .map { it.groupValues[1] }
                    .joinToString(" | ")
                    .takeIf { it.isNotBlank() }

                val quality = "💿\\s*([^\n]+)".toRegex()
                    .find(title)
                    ?.groupValues?.getOrNull(1)
                    ?.trim()
                    ?.takeIf { it.isNotEmpty() && it != "Unknown" }

                val provider = "🔎\\s*([^\n]+)".toRegex()
                    .find(title)
                    ?.groupValues?.getOrNull(1)
                    ?.trim()
                    ?.takeIf { it.isNotEmpty() && it != "Unknown" }

                buildString {
                    append("Comet")
                    if (!tags.isNullOrEmpty()) append(" | $tags")
                    if (!quality.isNullOrEmpty()) append(" | Quality: $quality")
                    if (!provider.isNullOrEmpty()) append(" | Provider: $provider")
                }
            }

            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash)
            callback.invoke(
                newExtractorLink(
                    "Comet",
                    formattedTitleName,
                    url = magnetLink,
                    ExtractorLinkType.MAGNET
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.description)
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokeTorrentioAnime(
    mainUrl: String,
    type: TvType,
    id: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (type == TvType.Movie) {
        "$mainUrl/stream/movie/kitsu:$id.json"
    } else {
        "$mainUrl/stream/series/kitsu:$id:$episode.json"
    }
    Log.d("Phisher",url)
    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val formattedTitleName = stream.title
            ?.let { title ->
                val qualityTermsRegex = "(2160p|1080p|720p|WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)".toRegex(RegexOption.IGNORE_CASE)
                val tagsList = qualityTermsRegex.findAll(title).map { it.value.uppercase() }.toList()
                val tags = tagsList.distinct().joinToString(" | ")

                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\n]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"

                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        val qualityMatch = "(2160p|1080p|720p)".toRegex(RegexOption.IGNORE_CASE)
            .find(stream.title ?: "")
            ?.value
            ?.lowercase()

        val magnet = generateMagnetLink(TRACKER_LIST_URL, stream.infoHash)
        callback.invoke(
            newExtractorLink(
                "Torrentio",
                formattedTitleName ?: stream.name ?: "",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName(qualityMatch)
            }
        )

    }
}

suspend fun invokeUindex(
    uindex: String,
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val isTv = season != null

    val searchQuery = buildString {
        if (!title.isNullOrBlank()) append(title)
        if (year != null) {
            if (isNotEmpty()) append(' ')
            append(year)
        }
    }.replace(' ', '+')

    val url = "$uindex/search.php?search=$searchQuery&c=${if (isTv) 2 else 1}"

    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )

    val rows = app.get(url, headers = headers).documentLarge.select("tr")

    val episodePatterns: List<Regex> = if (isTv && episode != null) {
        val rawPatterns = listOf(
            String.format(Locale.US, "S%02dE%02d", season, episode),
            "S${season}E$episode",
            String.format(Locale.US, "S%02dE%d", season, episode),
            String.format(Locale.US, "S%dE%02d", season, episode),
        )

        rawPatterns.distinct().map {
            Regex("\\b$it\\b", RegexOption.IGNORE_CASE)
        }
    } else {
        emptyList()
    }

    rows.amap { row ->
        val rowTitle = row.select("td:nth-child(2) > a:nth-child(2)").text()
        val magnet = row.select("td:nth-child(2) > a:nth-child(1)").attr("href")

        if (rowTitle.isBlank() || magnet.isBlank()) return@amap

        if (isTv && episodePatterns.isNotEmpty()) {
            if (episodePatterns.none { it.containsMatchIn(rowTitle) }) return@amap
        }

        val qualityMatch = "(2160p|1080p|720p)"
            .toRegex(RegexOption.IGNORE_CASE)
            .find(rowTitle)
            ?.value

        val seeder = row
            .select("td:nth-child(4) > span")
            .text()
            .replace(",", "")
            .ifBlank { "0" }

        val fileSize = row.select("td:nth-child(3)").text()

        val formattedTitleName = run {
            val qualityTermsRegex =
                "(WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)"
                    .toRegex(RegexOption.IGNORE_CASE)

            val tags = qualityTermsRegex.findAll(rowTitle)
                .map { it.value.uppercase() }
                .distinct()
                .joinToString(" | ")

            "UIndex | $tags | Seeder: $seeder | FileSize: $fileSize".trim()
        }

        callback.invoke(
            newExtractorLink(
                "UIndex",
                formattedTitleName.ifBlank { rowTitle },
                url = magnet,
                type = INFER_TYPE
            ) {
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}

suspend fun invokeKnaben(
    knaben: String,
    isAnime: Boolean,
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val isTv = season != null
    val host = knaben.trimEnd('/')

    val baseQuery = buildString {
        val queryText = title?.takeIf { it.isNotBlank() } ?: return@buildString

        append(
            queryText
                .trim()
                .replace("\\s+".toRegex(), "+")
        )

        if (isTv && episode != null) {
            append("+S${season.toString().padStart(2, '0')}")
            append("E${episode.toString().padStart(2, '0')}")
        } else if (!isTv && year != null) {
            append("+$year")
        }
    }

    if (baseQuery.isBlank()) return

    val category = when {
        isAnime -> "6000000"
        isTv -> "2000000"
        else -> "3000000"
    }

    for (page in 1..2) {
        val url = "$host/search/$baseQuery/$category/$page/seeders"

        val doc = app.get(url).document

        doc.select("tr.text-nowrap.border-start").forEach { row ->
            val infoTd = row.selectFirst("td:nth-child(2)") ?: return@forEach

            val titleElement = infoTd.selectFirst("a[title]") ?: return@forEach
            val rawTitle = titleElement.attr("title").ifBlank { titleElement.text() }

            val magnet = infoTd.selectFirst("a[href^=magnet:?]")?.attr("href") ?: return@forEach

            val source = row
                .selectFirst("td.d-sm-none.d-xl-table-cell a")
                ?.text()
                ?.trim()
                .orEmpty()

            val tds = row.select("td")
            val sizeText = tds.getOrNull(2)?.text().orEmpty()
            val seedsText = tds.getOrNull(4)?.text().orEmpty()
            val seeds = seedsText.toIntOrNull() ?: 0

            val formattedTitleName = buildString {
                append("Knaben | ")
                append(rawTitle)

                if (seeds > 0) {
                    append(" | Seeds: ")
                    append(seeds)
                }

                if (sizeText.isNotBlank()) {
                    append(" | ")
                    append(sizeText)
                }

                if (source.isNotBlank()) {
                    append(" | ")
                    append(source)
                }
            }

            callback(
                newExtractorLink(
                    "Knaben",
                    formattedTitleName.ifBlank { rawTitle },
                    url = magnet,
                    type = INFER_TYPE
                ) {
                    this.quality = getQualityFromName(rawTitle)
                }
            )
        }
    }
}


================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/StreamPlayTorrentParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName

data class Torrentmovie(
    val results: List<Result>,
    val query: String,
    val status: String,
    val seo: List<Seo>,
)

data class Result(
    val id: Long,
    val name: String,
    val type: String,
    @JsonProperty("release_date")
    val releaseDate: String,
    val year: Long,
    val description: String,
    val genre: Any?,
    val tagline: String,
    val poster: String,
    val backdrop: String,
    val runtime: Long,
    val trailer: Any?,
    val budget: Any?,
    val revenue: Any?,
    val views: Long,
    val popularity: Long,
    @JsonProperty("imdb_id")
    val imdbId: String,
    @JsonProperty("tmdb_id")
    val tmdbId: Long,
    @JsonProperty("season_count")
    val seasonCount: Long,
    @JsonProperty("fully_synced")
    val fullySynced: Boolean,
    @JsonProperty("allow_update")
    val allowUpdate: Boolean,
    @JsonProperty("created_at")
    val createdAt: String,
    @JsonProperty("updated_at")
    val updatedAt: String,
    val language: String,
    val country: Any?,
    @JsonProperty("original_title")
    val originalTitle: String,
    @JsonProperty("affiliate_link")
    val affiliateLink: Any?,
    val certification: Any?,
    @JsonProperty("episode_count")
    val episodeCount: Long,
    @JsonProperty("series_ended")
    val seriesEnded: Boolean,
    @JsonProperty("is_series")
    val isSeries: Boolean,
    @JsonProperty("show_videos")
    val showVideos: Boolean,
    val adult: Boolean,
    @JsonProperty("screen_resolution_720p")
    val screenResolution720p: String,
    @JsonProperty("screen_resolution_1080p")
    val screenResolution1080p: String,
    @JsonProperty("screen_resolution_2160p")
    val screenResolution2160p: String,
    @JsonProperty("screen_resolution_3D")
    val screenResolution3D: Any?,
    val rating: String,
    @JsonProperty("model_type")
    val modelType: String,
    @JsonProperty("vote_count")
    val voteCount: Long,
)

data class Seo(
    val property: String?,
    val content: String?,
    val nodeName: String,
    val name: String?,
    val rel: String?,
    val href: String?,
    @JsonProperty("_text")
    val text: String?,
)


//TorBox


data class TorBox(
    val streams: List<TorBoxStream>,
)

data class TorBoxStream(
    val name: String,
    val url: String,
    val magnet: String?,
    val nzb: String?,
    val seeders: Long?,
    val peers: Long?,
    val quality: String?,
    val resolution: String?,
    val language: String?,
    @JsonProperty("is_cached")
    val isCached: Boolean,
    val size: Long?,
    val hash: String,
    val adult: Boolean,
    val description: String,
    val type: String?,
    val behaviorHints: TorBoxBehaviorHints?,
)

data class TorBoxBehaviorHints(
    val notWebReady: Boolean,
    val videoSize: Long,
    val filename: String,
)


data class TorrentioResponse(val streams: List<TorrentioStream>)

data class TorrentioStream(
    val name: String?,
    val title: String?,
    val infoHash: String?,
    val fileIdx: Int?,
)

data class DebianRoot(
    val streams: List<Stream>,
    val cacheMaxAge: Long,
    val staleRevalidate: Long,
    val staleError: Long,
)

data class Stream(
    val name: String,
    val title: String,
    val url: String,
    val behaviorHints: BehaviorHints,
)

data class BehaviorHints(
    val bingeGroup: String,
    val filename: String?,
)

//Subtitles


data class AnimetoshoItem(
    val id: Long,
    val title: String,
    val link: String,
    val timestamp: Long,
    val status: String,
    @SerializedName("tosho_id")
    val toshoId: Long?,
    @SerializedName("nyaa_id")
    val nyaaId: Long,
    @SerializedName("nyaa_subdom")
    val nyaaSubdom: Any?,
    @SerializedName("anidex_id")
    val anidexId: Any?,
    @SerializedName("torrent_url")
    val torrentUrl: String,
    @SerializedName("torrent_name")
    val torrentName: String,
    @SerializedName("info_hash")
    val infoHash: String,
    @SerializedName("info_hash_v2")
    val infoHashV2: Any?,
    @SerializedName("magnet_uri")
    val magnetUri: String,
    val seeders: Long,
    val leechers: Long,
    @SerializedName("torrent_downloaded_count")
    val torrentDownloadedCount: Long,
    @SerializedName("tracker_updated")
    val trackerUpdated: Long?,
    @SerializedName("nzb_url")
    val nzbUrl: String,
    @SerializedName("total_size")
    val totalSize: Long,
    @SerializedName("num_files")
    val numFiles: Long,
    @SerializedName("anidb_aid")
    val anidbAid: Long,
    @SerializedName("anidb_eid")
    val anidbEid: Long,
    @SerializedName("anidb_fid")
    val anidbFid: Long?,
    @SerializedName("article_url")
    val articleUrl: Any?,
    @SerializedName("article_title")
    val articleTitle: Any?,
    @SerializedName("website_url")
    val websiteUrl: String?
)


data class MediafusionResponse(
    val streams: List<MediafusionStream>,
)

data class MediafusionStream(
    val name: String,
    val description: String,
    val infoHash: String,
    val fileIdx: Long?,
    val behaviorHints: MediafusionBehaviorHints,
    val sources: List<String>,
)

data class MediafusionBehaviorHints(
    val bingeGroup: String,
    val filename: String,
    val videoSize: Long,
)

data class TBPResponse(
    val streams: List<TBPStream>,
    val cacheMaxAge: Long,
    val staleRevalidate: Long,
    val staleError: Long,
)

data class TBPStream(
    val name: String,
    val title: String,
    val infoHash: String,
    val tag: String,
)

data class PeerflixResponse(
    val streams: List<PeerflixStream>,
)

data class PeerflixStream(
    val name: String,
    val description: String,
    val infoHash: String,
    val sources: List<String>,
    val fileIdx: Long?,
    val language: String,
    val quality: String,
    val seed: Long,
    val sizebytes: Long?,
)








================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/LanguageSelectFragment.kt
================================================
package com.Phisher98

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.RadioButton
import android.widget.Toast
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig
import com.phisher98.StreamPlayPlugin
import androidx.core.content.edit
import androidx.core.widget.addTextChangedListener

class LanguageSelectFragment(
    plugin: StreamPlayPlugin,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {

    private val res = plugin.resources ?: throw Exception("Unable to access plugin resources")

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("View ID $name not found.")
        return this.findViewById(id)
    }

    // Language Display List
    private val languages = listOf(
        "South Africa (Afrikaans)" to "af-ZA",
        "United Arab Emirates (Arabic)" to "ar-AE",
        "Saudi Arabia (Arabic)" to "ar-SA",
        "Azerbaijan (Azerbaijani)" to "az-AZ",
        "Bulgaria (Bulgarian)" to "bg-BG",
        "India (Bengali)" to "bn-IN",
        "Spain (Catalan)" to "ca-ES",
        "Czech Republic (Czech)" to "cs-CZ",
        "United Kingdom (Welsh)" to "cy-GB",
        "Denmark (Danish)" to "da-DK",
        "Germany (German)" to "de-DE",
        "Greece (Greek)" to "el-GR",
        "United States (English)" to "en-US",
        "United Kingdom (English)" to "en-GB",
        "Spain (Spanish)" to "es-ES",
        "Latin America (Spanish)" to "es-419",
        "Estonia (Estonian)" to "et-EE",
        "Spain (Basque)" to "eu-ES",
        "Iran (Persian)" to "fa-IR",
        "Finland (Finnish)" to "fi-FI",
        "Philippines (Filipino)" to "fil-PH",
        "France (French)" to "fr-FR",
        "Spain (Galician)" to "gl-ES",
        "India (Gujarati)" to "gu-IN",
        "Israel (Hebrew)" to "he-IL",
        "India (Hindi)" to "hi-IN",
        "Croatia (Croatian)" to "hr-HR",
        "Hungary (Hungarian)" to "hu-HU",
        "Indonesia (Indonesian)" to "id-ID",
        "Iceland (Icelandic)" to "is-IS",
        "Italy (Italian)" to "it-IT",
        "Japan (Japanese)" to "ja-JP",
        "India (Kannada)" to "kn-IN",
        "South Korea (Korean)" to "ko-KR",
        "Lithuania (Lithuanian)" to "lt-LT",
        "Latvia (Latvian)" to "lv-LV",
        "India (Malayalam)" to "ml-IN",
        "Malaysia (Malay)" to "ms-MY",
        "Norway (Norwegian)" to "no-NO",
        "Netherlands (Dutch)" to "nl-NL",
        "Poland (Polish)" to "pl-PL",
        "Brazil (Portuguese)" to "pt-BR",
        "Portugal (Portuguese)" to "pt-PT",
        "Romania (Romanian)" to "ro-RO",
        "Russia (Russian)" to "ru-RU",
        "Slovakia (Slovak)" to "sk-SK",
        "Slovenia (Slovenian)" to "sl-SI",
        "Serbia (Serbian)" to "sr-RS",
        "Sweden (Swedish)" to "sv-SE",
        "India (Tamil)" to "ta-IN",
        "India (Telugu)" to "te-IN",
        "Thailand (Thai)" to "th-TH",
        "Turkey (Turkish)" to "tr-TR",
        "Ukraine (Ukrainian)" to "uk-UA",
        "Vietnam (Vietnamese)" to "vi-VN",
        "China (Chinese Simplified)" to "zh-CN",
        "Taiwan (Chinese Traditional)" to "zh-TW"
    ).sortedBy { it.first.lowercase() }


    private lateinit var adapter: LanguageAdapter

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {

        val root = getLayout("fragment_language_select", inflater, container)

        val recycler: RecyclerView = root.findView("languageRecycler")
        val search: EditText = root.findView("searchLanguage")
        recycler.makeTvCompatible()
        search.makeTvCompatible()

        recycler.layoutManager = LinearLayoutManager(requireContext())

        val savedCode = sharedPref.getString("tmdb_language_code", "en-US") ?: "en-US"

        adapter = LanguageAdapter(
            languages.sortedBy { it.first.lowercase() }, // << SORT HERE
            savedCode
        ) { code ->
            sharedPref.edit { putString("tmdb_language_code", code) }
            Toast.makeText(requireContext(), "Language set to $code", Toast.LENGTH_SHORT).show()
            dismiss()
        }


        recycler.adapter = adapter

        search.addTextChangedListener { text ->
            adapter.filter(text.toString())
        }

        return root
    }


    // ---------------------------------------------------------------------- ADAPTER ------------------ //

    inner class LanguageAdapter(
        private val originalList: List<Pair<String, String>>,
        private val selectedCode: String,
        private val onClick: (String) -> Unit
    ) : RecyclerView.Adapter<LanguageAdapter.VH>() {

        private var filteredList = originalList.toMutableList()

        inner class VH(val v: View) : RecyclerView.ViewHolder(v) {
            val radio: RadioButton = v.findView("radio_language")
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
            val view = getLayout("item_language", LayoutInflater.from(parent.context), parent)
            return VH(view)
        }

        override fun onBindViewHolder(holder: VH, position: Int) {
            val (name, code) = filteredList[position]

            holder.radio.text = name
            holder.radio.isChecked = code == selectedCode

            holder.radio.setOnClickListener {
                onClick(code)
            }
        }

        override fun getItemCount() = filteredList.size
        @SuppressLint("NotifyDataSetChanged")
        fun filter(query: String) {
            filteredList = if (query.isBlank()) {
                originalList.toMutableList()
            } else {
                originalList.filter { it.first.contains(query, ignoreCase = true) }.toMutableList()
            }
            notifyDataSetChanged()
        }
    }

}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/MainSettingsFragment.kt
================================================
package com.phisher98

import android.content.Intent
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import androidx.appcompat.app.AlertDialog
import com.Phisher98.LanguageSelectFragment
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.settings.SettingsFragment
import com.phisher98.settings.ToggleFragment

class MainSettingsFragment(
    private val plugin: StreamPlayPlugin,
    private val sharedPref: android.content.SharedPreferences
) : BottomSheetDialogFragment() {

    private val res = plugin.resources ?: throw Exception("Unable to access plugin resources")

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("View ID $name not found.")
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val view = getLayout("fragment_main_settings", inflater, container)

        val loginCard: ImageView = view.findView("loginCard")
        val featureCard: ImageView = view.findView("featureCard")
        val toggleproviders: ImageView = view.findView("toggleproviders")
        val languagechange: ImageView = view.findView("languageCard")
        val stremioaddon: ImageView = view.findView("stremioaddons")

        val saveIcon: ImageView = view.findView("saveIcon")

        loginCard.setImageDrawable(getDrawable("settings_icon"))
        languagechange.setImageDrawable(getDrawable("settings_icon"))
        featureCard.setImageDrawable(getDrawable("settings_icon"))
        toggleproviders.setImageDrawable(getDrawable("settings_icon"))
        stremioaddon.setImageDrawable(getDrawable("settings_icon"))
        saveIcon.setImageDrawable(getDrawable("save_icon"))

        loginCard.makeTvCompatible()
        featureCard.makeTvCompatible()
        toggleproviders.makeTvCompatible()
        languagechange.makeTvCompatible()
        stremioaddon.makeTvCompatible()

        saveIcon.makeTvCompatible()

        loginCard.setOnClickListener {
            val loginSettings = SettingsFragment(plugin, sharedPref)
            loginSettings.show(
                activity?.supportFragmentManager ?: throw Exception("No FragmentManager"),
                "settings_fragment"
            )
        }

        featureCard.setOnClickListener {
            val toggleFragment = ToggleFragment(plugin, sharedPref)
            toggleFragment.show(
                activity?.supportFragmentManager ?: throw Exception("No FragmentManager"),
                "fragment_toggle_extensions"
            )
        }

        toggleproviders.setOnClickListener {
            val providersFragment = ProvidersFragment(plugin, sharedPref)
            providersFragment.show(
                activity?.supportFragmentManager ?: throw Exception("No FragmentManager"),
                "fragment_toggle_providers"
            )
        }

        languagechange.setOnClickListener {
            LanguageSelectFragment(plugin, sharedPref).show(
                activity?.supportFragmentManager!!,
                "fragment_language_list"
            )
        }

        stremioaddon.setOnClickListener {
            val providersFragment = StreamPlayStremioCatelogFrag(plugin, sharedPref)
            providersFragment.show(
                activity?.supportFragmentManager ?: throw Exception("No FragmentManager"),
                "stremio_bottom_sheet_layout"
            )
        }

        saveIcon.setOnClickListener {
            val context = this.context ?: return@setOnClickListener

            AlertDialog.Builder(context)
                .setTitle("Save & Reload")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No", null)
                .show()
        }
        return view
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/ProvidersFragment.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.CheckBox
import android.widget.ImageButton
import android.widget.LinearLayout
import android.widget.SearchView
import androidx.annotation.RequiresApi
import androidx.core.content.edit
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import androidx.core.view.isNotEmpty
import com.lagradost.cloudstream3.CommonActivity.showToast


private val PREFS_PROFILES = "provider_profiles"

class ProvidersFragment(
    private val plugin: StreamPlayPlugin,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {

    private val res = plugin.resources ?: throw Exception("Unable to access plugin resources")
    private lateinit var btnSave: ImageButton
    private lateinit var btnSelectAll: Button
    private lateinit var btnDeselectAll: Button
    private lateinit var adapter: ProviderAdapter
    private lateinit var container: LinearLayout
    private var providers: List<Provider> = emptyList()
    private val PREFS_DISABLED = "disabled_providers"

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("View ID $name not found.")
        return this.findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        return getLayout("fragment_providers", inflater, container)
    }

    override fun onStart() {
        super.onStart()
        dialog?.let { dlg ->
            val bottomSheet = dlg.findViewById<View>(com.google.android.material.R.id.design_bottom_sheet)
            bottomSheet?.let { sheet ->
                val behavior = BottomSheetBehavior.from(sheet)
                behavior.state = BottomSheetBehavior.STATE_EXPANDED
                behavior.isDraggable = true
                behavior.skipCollapsed = true
                sheet.layoutParams.height = ViewGroup.LayoutParams.WRAP_CONTENT
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    @SuppressLint("SetTextI18n")
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        btnSave = view.findView("btn_save")
        btnSave.setImageDrawable(getDrawable("save_icon"))
        btnSave.makeTvCompatible()

        btnSelectAll = view.findView("btn_select_all")
        btnDeselectAll = view.findView("btn_deselect_all")
        //btnSelectAll.makeTvCompatible()
        //btnDeselectAll.makeTvCompatible()
        container = view.findView("list_container")
        container.makeTvCompatible()
        providers = buildProviders().sortedBy { it.name.lowercase() }

        // --- Load disabled providers ---
        val savedDisabled = sharedPref.getStringSet(PREFS_DISABLED, emptySet()) ?: emptySet()

        adapter = ProviderAdapter(providers, savedDisabled) { disabled ->
            sharedPref.edit { putStringSet(PREFS_DISABLED, disabled) }
            updateUI()
        }

        val chkId = res.getIdentifier("chk_provider", "id", BuildConfig.LIBRARY_PACKAGE_NAME)

        // --- Add provider items ---
        providers.forEach { provider ->
            val item = getLayout("item_provider_checkbox", layoutInflater, container)
            val chk = item.findViewById<CheckBox>(chkId)
            item.makeTvCompatible()
            chk.makeTvCompatible()
            chk.text = provider.name
            // Enabled if NOT in disabled list
            chk.isChecked = !adapter.isDisabled(provider.id)

            item.setOnClickListener { chk.toggle() }

            chk.setOnCheckedChangeListener { _, isChecked ->
                // Checked → remove from disabled, Unchecked → add to disabled
                adapter.setDisabled(provider.id, !isChecked)
            }

            container.addView(item)
        }
        container.post {
            if (container.isNotEmpty()) {
                val firstItem = container.getChildAt(0)
                firstItem.isFocusable = true
                firstItem.requestFocusFromTouch()
                firstItem.nextFocusUpId = btnSave.id
            }
        }

        btnSelectAll.setOnClickListener { adapter.setAll(true) }
        btnDeselectAll.setOnClickListener { adapter.setAll(false) }
        btnSave.setOnClickListener { dismissFragment() }


        //Profile

        val btnSaveProfile = view.findView<Button>("btn_save_profile")
        val btnLoadProfile = view.findView<Button>("btn_load_profile")
        val btnDeleteProfile = view.findView<Button>("btn_delete_profile")

        btnSaveProfile.setOnClickListener {
            val input = android.widget.EditText(requireContext())

            val dialog = android.app.AlertDialog.Builder(requireContext())
                .setTitle("Save Profile")
                .setMessage("Enter a name for your profile:")
                .setView(input)
                .setPositiveButton("Save") { _, _ ->
                    val name = input.text.toString().trim()
                    if (name.isNotEmpty()) {
                        saveProfile(name)
                        showMessage("Profile \"$name\" saved.")
                    } else {
                        showMessage("Profile name cannot be empty.")
                    }
                }
                .setNegativeButton("Cancel", null)
                .create()

            dialog.setOnShowListener {
                input.isFocusableInTouchMode = true
                input.requestFocus()
            }

            dialog.show()
        }


        btnLoadProfile.setOnClickListener {
            val profiles = getAllProfiles().keys.toTypedArray()
            if (profiles.isEmpty()) {
                showToast("No profiles saved.")
                return@setOnClickListener
            }

            android.app.AlertDialog.Builder(requireContext())
                .setTitle("Select Profile")
                .setItems(profiles) { _, which ->
                    loadProfile(profiles[which])
                }
                .show()
        }


        btnDeleteProfile.setOnClickListener {
            val profiles = getAllProfiles().keys.toTypedArray()
            if (profiles.isEmpty()) {
                showToast("No profiles to delete.")
                return@setOnClickListener
            }
            val dialog = android.app.AlertDialog.Builder(requireContext())
                .setTitle("Delete Profile")
                .setItems(profiles) { _, which ->
                    deleteProfile(profiles[which])
                }
                .setNegativeButton("Cancel", null)
                .create()
            dialog.setOnShowListener {
                dialog.listView?.let { list ->
                    if (list.isNotEmpty()) {
                        list.getChildAt(0)?.requestFocus()
                    }
                }
            }
            dialog.show()
        }

        val searchView = view.findView<SearchView>("search_provider")

        searchView.setOnQueryTextListener(object : SearchView.OnQueryTextListener {
            override fun onQueryTextSubmit(query: String?): Boolean = false

            override fun onQueryTextChange(newText: String?): Boolean {
                val query = newText.orEmpty().trim().lowercase()

                for (i in 0 until container.childCount) {
                    val item = container.getChildAt(i)
                    val chk = item.findViewById<CheckBox>(
                        res.getIdentifier("chk_provider", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
                    )
                    val isVisible = chk.text.toString().lowercase().contains(query)
                    item.visibility = if (isVisible) View.VISIBLE else View.GONE
                }

                return true
            }
        })

        //
    }

    private fun updateUI() {
        val chkId = res.getIdentifier("chk_provider", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        for (i in 0 until container.childCount) {
            val chk = container.getChildAt(i).findViewById<CheckBox>(chkId)
            chk.isChecked = !adapter.isDisabled(providers[i].id)
        }
    }

    private fun dismissFragment() {
        parentFragmentManager.beginTransaction().remove(this).commitAllowingStateLoss()
    }

    inner class ProviderAdapter(
        private val items: List<Provider>,
        initiallyDisabled: Set<String>,
        private val onChange: (Set<String>) -> Unit
    ) {
        private val disabled = initiallyDisabled.toMutableSet()

        fun isDisabled(id: String) = id in disabled

        fun setDisabled(id: String, value: Boolean) {
            if (value) disabled.add(id) else disabled.remove(id)
            onChange(disabled)
        }

        fun setAll(value: Boolean) {
            disabled.clear()
            if (!value) disabled.addAll(items.map { it.id })
            onChange(disabled)
        }
    }

    private fun saveProfile(name: String) {
        val disabled = sharedPref.getStringSet(PREFS_DISABLED, emptySet()) ?: emptySet()
        val allProfiles = getAllProfiles().toMutableMap()
        allProfiles[name] = disabled

        // Convert to a JSON-like string for compact storage
        val encoded = allProfiles.entries.joinToString("|") { (key, value) ->
            "$key:${value.joinToString(",")}"
        }
        sharedPref.edit { putString(PREFS_PROFILES, encoded) }
    }

    private fun getAllProfiles(): Map<String, Set<String>> {
        val encoded = sharedPref.getString(PREFS_PROFILES, "") ?: return emptyMap()
        if (encoded.isEmpty()) return emptyMap()

        return encoded.split("|").mapNotNull { entry ->
            val parts = entry.split(":")
            if (parts.size < 2) return@mapNotNull null
            val name = parts[0]
            val ids = if (parts[1].isEmpty()) emptySet() else parts[1].split(",").toSet()
            name to ids
        }.toMap()
    }

    private fun loadProfile(name: String) {
        val profiles = getAllProfiles()
        val disabled = profiles[name] ?: return
        sharedPref.edit { putStringSet(PREFS_DISABLED, disabled) }
        adapter = ProviderAdapter(providers, disabled) { updated ->
            sharedPref.edit { putStringSet(PREFS_DISABLED, updated) }
            updateUI()
        }
        updateUI()
        showMessage("Profile \"$name\" loaded.")
    }

    private fun deleteProfile(name: String) {
        val allProfiles = getAllProfiles().toMutableMap()
        if (allProfiles.remove(name) != null) {
            val encoded = allProfiles.entries.joinToString("|") { (key, value) ->
                "$key:${value.joinToString(",")}"
            }
            sharedPref.edit { putString(PREFS_PROFILES, encoded) }
            showMessage("Profile \"$name\" deleted.")
        } else {
            showMessage("Profile not found.")
        }
    }


    private fun showMessage(msg: String) {
        android.widget.Toast.makeText(requireContext(), msg, android.widget.Toast.LENGTH_SHORT).show()
    }


}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.*
import android.widget.Button
import android.widget.EditText
import androidx.annotation.RequiresApi
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig
import com.phisher98.StreamPlayPlugin
import com.lagradost.cloudstream3.CommonActivity.showToast

class SettingsFragment(
    plugin: StreamPlayPlugin,
    private val sharedPref: SharedPreferences,
) : BottomSheetDialogFragment() {
    private val res = plugin.resources ?: throw Exception("Unable to read resources")

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?,
    ): View? {
        val id = res.getIdentifier("settings_fragment", "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    override fun onStart() {
        super.onStart()
        (dialog as? BottomSheetDialog)?.behavior?.apply {
            state = BottomSheetBehavior.STATE_EXPANDED
            skipCollapsed = true
            isDraggable = false // optional: prevent dragging at all
        }
    }


    @SuppressLint("SetJavaScriptEnabled", "SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val tokenInput = view.findView<EditText>("tokenInput")
        val addButton = view.findView<Button>("addButton")
        val resetButton = view.findView<Button>("resetButton")
        val loginButton = view.findView<Button>("loginButton")
        val webView = view.findView<WebView>("authWebView")
        val savedToken = sharedPref.getString("token", null)
        if (!savedToken.isNullOrEmpty()) {
            tokenInput.setText(savedToken)
        }

        setupWebView(webView)

        loginButton.setOnClickListener {
            webView.visibility = View.VISIBLE
            webView.loadUrl("https://www.febbox.com/login/google?jump=%2F")
        }

        addButton.setOnClickListener {
            var token = tokenInput.text.toString().trim()
            if (token.isNotEmpty()) {
                if (!token.startsWith("ui=")) {
                    token = "ui=$token"
                }
                sharedPref.edit()?.apply {
                    putString("token", token)
                    apply()
                }
                showToast("Token saved successfully. Restart the app.")
                dismiss()
            } else {
                showToast("Please enter a valid token")
            }
        }

        resetButton.setOnClickListener {
            sharedPref.edit()?.apply {
                remove("token")
                apply()
            }
            tokenInput.setText("ui=")
            showToast("Token reset successfully. Restart the app.")
            dismiss()
        }
    }

    @SuppressLint("SetJavaScriptEnabled")
    private fun setupWebView(webView: WebView) {
        webView.settings.javaScriptEnabled = true
        webView.settings.domStorageEnabled = true
        webView.settings.userAgentString =
            "Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36"

        CookieManager.getInstance().setAcceptThirdPartyCookies(webView, true)

        webView.webViewClient = object : WebViewClient() {
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)

                // Resize WebView to content height
                view?.evaluateJavascript(
                    "(function() { return document.body.scrollHeight; })();"
                ) { value ->
                    val height = value.replace("\"", "").toFloatOrNull()
                    if (height != null) {
                        val density = resources.displayMetrics.density
                        val layoutParams = view.layoutParams
                        layoutParams.height = (height * density).toInt()
                        view.layoutParams = layoutParams
                    }
                }

                // Existing token scraping logic
                val cookieManager = CookieManager.getInstance()
                val cookies = cookieManager.getCookie(url ?: "")

                val token = cookies?.split(";")
                    ?.map { it.trim() }
                    ?.find { it.startsWith("ui=") }
                    ?.removePrefix("ui=")

                if (!token.isNullOrEmpty() && view != null) {
                    val finalToken = "ui=$token"

                    activity?.runOnUiThread {
                        val tokenInput = requireView().findViewById<EditText>(
                            res.getIdentifier("tokenInput", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
                        )
                        tokenInput.setText(finalToken)

                        sharedPref.edit()?.apply {
                            putString("token", finalToken)
                            apply()
                        }

                        showToast("Login successful!")
                        webView.visibility = View.GONE
                    }
                }
            }
        }
    }
}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/StreamPlayStremioCatelogFrag.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.core.content.edit
import androidx.core.net.toUri
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.api.Log
import com.lagradost.cloudstream3.CommonActivity.showToast

class StreamPlayStremioCatelogFrag(
    plugin: StreamPlayPlugin,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {
    private val PREF_KEY_LINKS = "streamplay_stremio_saved_links"

    private val res = plugin.resources ?: throw Exception("Unable to access plugin resources")

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("View ID $name not found.")
        return this.findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("DiscouragedApi")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val view = getLayout("stremio_bottom_sheet_layout", inflater, container)

        listOf("addlinks", "showlinks", "saveIcon").forEach { name ->
            val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
            if (id == 0) Log.w("StreamPlayStremioCatelogFrag", "View id '$name' not found")
            else Log.d("StreamPlayStremioCatelogFrag", "View id '$name' -> $id")
        }

        // safe find helpers (throws clear exceptions if missing)
        val addlinks: ImageView = try { view.findView("addlinks") } catch (e: Throwable) {
            throw Exception("addlinks ImageView not found in bottom_sheet_layout", e)
        }
        val showlinks: ImageView = try { view.findView("showlinks") } catch (e: Throwable) {
            throw Exception("showlinks ImageView not found in bottom_sheet_layout", e)
        }
        val saveIcon: ImageView = try { view.findView("saveIcon") } catch (e: Throwable) {
            throw Exception("saveIcon ImageView not found in bottom_sheet_layout", e)
        }

        addlinks.setImageDrawable(getDrawable("settings_icon"))
        showlinks.setImageDrawable(getDrawable("settings_icon"))
        saveIcon.setImageDrawable(getDrawable("save_icon"))

        addlinks.makeTvCompatible()
        showlinks.makeTvCompatible()
        saveIcon.makeTvCompatible()

        // ---------- ADD dialog ----------
        addlinks.setOnClickListener {
            val dialogView = getLayout("streamio_addon_addlinks", inflater, container)
            val etName: EditText
            val etLink: EditText
            try {
                etName = dialogView.findView("etName")
                etLink = dialogView.findView("etLink")
            } catch (t: Throwable) {
                Toast.makeText(requireContext(), "Dialog fields not found", Toast.LENGTH_SHORT).show()
                Log.e("SettingsBottomFragment", "Missing dialog views $t")
                return@setOnClickListener
            }


            val dlg = AlertDialog.Builder(requireContext())
                .setView(dialogView)
                .setPositiveButton("Save", null)
                .setNegativeButton("Cancel", null)
                .create()

            dlg.setOnShowListener {
                val btnSave = dlg.getButton(AlertDialog.BUTTON_POSITIVE)
                btnSave.setOnClickListener {
                    val name = etName.text.toString().trim()
                    val link = etLink.text.toString().trim()
                    val type = "StremioC"

                    if (link.isEmpty()) {
                        showToast("Please enter a link")
                        return@setOnClickListener
                    }

                    val valid = try {
                        val uri = link.toUri()
                        val scheme = uri.scheme?.lowercase()
                        scheme == "http" || scheme == "https"
                    } catch (_: Exception) {
                        false
                    }

                    if (!valid) {
                        showToast("Enter a valid URL (http/https)")
                        return@setOnClickListener
                    }

                    val item = LinkItem(name = name.ifBlank { link }, link = link, type = type)
                    try {
                        val list = loadLinks().toMutableList()
                        list.add(0, item)
                        saveLinks(list)
                        Toast.makeText(requireContext(), "Link saved", Toast.LENGTH_SHORT).show()
                        dlg.dismiss()
                    } catch (e: Throwable) {
                        Log.e("SettingsBottomFragment", "Failed to save link $e")
                        showToast("Failed to save link")
                    }
                }
            }

            dlg.show()
        }

        // ---------- SHOW list dialog ----------
        showlinks.setOnClickListener {
            val dialogView = getLayout("stremio_dialog_list_links", inflater, container)
            val dlg = AlertDialog.Builder(requireContext())
                .setView(dialogView)
                .setPositiveButton("Close", null)
                .create()

            val rv: RecyclerView = dialogView.findView("rvLinks")
            val tvNoLinks: TextView = dialogView.findView("tvNoLinks")
            val list = loadLinks().toMutableList()
            Log.d("SettingsBottomFragment", "Loaded ${list.size} saved links")

            if (list.isEmpty()) {
                tvNoLinks.visibility = View.VISIBLE
                rv.visibility = View.GONE
            } else {
                tvNoLinks.visibility = View.GONE
                rv.visibility = View.VISIBLE

                rv.layoutManager = LinearLayoutManager(requireContext())

                val adapter = LinksAdapter(list) { itemToDelete ->
                    val updatedList = loadLinks().toMutableList()
                    val removed = updatedList.removeAll { it.id == itemToDelete.id }

                    if (removed) {
                        saveLinks(updatedList)
                        (rv.adapter as? LinksAdapter)?.remove(itemToDelete)
                        showToast("Deleted")
                        if (updatedList.isEmpty()) {
                            tvNoLinks.visibility = View.VISIBLE
                            rv.visibility = View.GONE
                        }
                    }
                }


                rv.adapter = adapter
            }
            dlg.show()
        }


        // ---------- SAVE & RESTART ----------
        saveIcon.setOnClickListener {
            val context = this.context ?: return@setOnClickListener

            AlertDialog.Builder(context)
                .setTitle("Save & Reload")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No", null)
                .show()
        }

        return view
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }

    data class LinkItem(
        val id: Long = System.currentTimeMillis(),
        val name: String,
        val link: String,
        val type: String
    )

    private fun loadLinks(): MutableList<LinkItem> {
        val json = sharedPref.getString(PREF_KEY_LINKS, null) ?: return mutableListOf()
        val list = mutableListOf<LinkItem>()

        return try {
            val arr = org.json.JSONArray(json)

            for (i in 0 until arr.length()) {
                val obj = arr.getJSONObject(i)

                list.add(
                    LinkItem(
                        id   = obj.optLong("id", System.currentTimeMillis()),
                        name = obj.optString("name", ""),
                        link = obj.optString("link", ""),
                        type = obj.optString("type", "StremioX")
                    )
                )
            }

            list
        } catch (_: Exception) {
            mutableListOf()
        }
    }


    private fun saveLinks(list: List<LinkItem>) {
        val arr = org.json.JSONArray()

        for (item in list) {
            val obj = org.json.JSONObject().apply {
                put("id", item.id)
                put("name", item.name)
                put("link", item.link)
                put("type", item.type)
            }
            arr.put(obj)
        }

        sharedPref.edit { putString(PREF_KEY_LINKS, arr.toString()) }
    }

    inner class LinksAdapter(
        private val items: MutableList<LinkItem>,
        private val onDelete: (LinkItem) -> Unit
    ) : RecyclerView.Adapter<LinksAdapter.VH>() {

        inner class VH(v: View) : RecyclerView.ViewHolder(v) {
            val tvName: TextView = v.findView("tvName")
            val tvLink: TextView = v.findView("tvLink")
            val tvType: TextView = v.findView("tvType")
            val btnDelete: ImageButton = v.findView("btnDelete")
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
            val layoutId = res.getIdentifier("stremio_item_saved_link", "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
            val v = layoutInflater.inflate(res.getLayout(layoutId), parent, false)
            return VH(v)
        }

        override fun onBindViewHolder(holder: VH, position: Int) {
            val item = items[position]

            holder.tvName.text = item.name
            holder.tvLink.text = item.link
            holder.tvType.text = item.type

            holder.btnDelete.setOnClickListener {
                onDelete(item)
            }
        }

        override fun getItemCount(): Int = items.size

        fun remove(item: LinkItem) {
            val idx = items.indexOfFirst { it.id == item.id }
            if (idx >= 0) {
                items.removeAt(idx)
                notifyItemRemoved(idx)
            }
        }
    }


}



================================================
FILE: StreamPlay/src/main/kotlin/com/Phisher98/settings/ToggleFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.SharedPreferences
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import androidx.core.content.edit
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import com.phisher98.StreamPlay
import com.phisher98.StreamPlayAnime
import com.phisher98.StreamPlayPlugin
import com.phisher98.StreamPlayStremioCatelog

class ToggleFragment(
    plugin: StreamPlayPlugin,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {

    private val res: Resources = plugin.resources ?: throw Exception("Unable to access plugin resources")

    @SuppressLint("DiscouragedApi")
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("Layout $name not found.")
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }


    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
            ?: throw Resources.NotFoundException("Drawable $name not found.")
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Resources.NotFoundException("View ID $name not found.")
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    @SuppressLint("UseSwitchCompatOrMaterialCode")
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val root = getLayout("fragment_toggle_extensions", inflater, container)
        val extensionList = root.findView<LinearLayout>("toggle_list_container")

        val apis = listOf(
            StreamPlay(sharedPref),
            //StreamPlayLite(),
            //StreamPlayTorrent(),
            StreamPlayAnime(),
            StreamPlayStremioCatelog("", "", sharedPref)
            //StreamplayTorrentAnime()
        )

        val savedKey = "enabled_plugins_saved"
        val savedSet = sharedPref.getStringSet(savedKey, null)
        val defaultEnabled = apis.map { it.name }.toSet()
        val currentSet = savedSet?.toSet() ?: defaultEnabled


        for (api in apis) {
            val toggleItem = getLayout("list_toggle_item", inflater, container)
            val toggleSwitch = toggleItem.findView<Switch>("toggle_item")
            toggleItem.makeTvCompatible()
            toggleSwitch.text = api.name
            toggleSwitch.isChecked = currentSet.contains(api.name)

            toggleSwitch.makeTvCompatible()

            toggleItem.setOnClickListener {
                toggleSwitch.isChecked = !toggleSwitch.isChecked
            }

            extensionList.addView(toggleItem)
        }


        val saveBtn = root.findView<ImageView>("saveIcon")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()

        saveBtn.setOnClickListener {
            val enabledPluginNames = mutableListOf<String>()

            for (i in 0 until extensionList.childCount) {
                val toggleItem = extensionList.getChildAt(i)
                val toggleSwitch = toggleItem.findViewById<Switch>(
                    res.getIdentifier("toggle_item", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
                )
                if (toggleSwitch.isChecked) {
                    enabledPluginNames.add(toggleSwitch.text.toString())
                }
            }

            if (enabledPluginNames.isEmpty()) {
                showToast("At least one extension must stay enabled")
                return@setOnClickListener
            }

            sharedPref.edit {
                putStringSet(savedKey, enabledPluginNames.toSet())
                commit()
            }

            showToast("Settings saved")
            dismiss()
        }
        return root
    }
}



================================================
FILE: StreamPlay/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: StreamPlay/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: StreamPlay/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: StreamPlay/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: StreamPlay/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: StreamPlay/src/main/res/drawable/toggle_item_background.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- Focused state -->
    <item android:state_focused="true">
        <shape android:shape="rectangle">
            <solid android:color="#121212" />
            <stroke android:width="2dp" android:color="#FFFFFF" />
            <corners android:radius="8dp" />
        </shape>
    </item>

    <!-- Checked state -->
    <item android:state_checked="true">
        <shape android:shape="rectangle">
            <solid android:color="#1E1E1E" />
        </shape>
    </item>

    <!-- Default state -->
    <item>
        <shape android:shape="rectangle">
            <solid android:color="#121212" />
        </shape>
    </item>
</selector>



================================================
FILE: StreamPlay/src/main/res/layout/fragment_language_select.xml
================================================
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="12dp"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/select_language_label"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Select Language"
        android:textSize="16sp"
        android:textStyle="bold"
        android:padding="8dp" />

    <EditText
        android:id="@+id/searchLanguage"
        android:autofillHints=""
        android:hint="Search language…"
        android:padding="10dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/languageRecycler"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

</LinearLayout>



================================================
FILE: StreamPlay/src/main/res/layout/fragment_main_settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Streamplay Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/saveIcon"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true" />
            </LinearLayout>
        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <!-- Febbox -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Febbox Login"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/loginCard"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:focusable="true"
                    android:padding="5dp" />
            </LinearLayout>
        </LinearLayout>

        <!-- Toggle Extensions -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Toggle Extensions"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/featureCard"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/loginCard" />
            </LinearLayout>
        </LinearLayout>

        <!-- Enable/Disable Sources -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Enable/Disable Sources"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/toggleproviders"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/loginCard" />
            </LinearLayout>
        </LinearLayout>

        <!-- ✅ NEW: Language Change -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Change Language (Native)"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/languageCard"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/toggleproviders" />
            </LinearLayout>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Stramio Catelog Addons (Beta)"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/stremioaddons"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/languageCard" />
            </LinearLayout>
        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: StreamPlay/src/main/res/layout/fragment_providers.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/scroll_root"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fillViewport="true"
    android:background="#121212"
    android:padding="16dp"
    android:focusable="true"
    android:focusableInTouchMode="true">

    <LinearLayout
        android:id="@+id/root_layout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:descendantFocusability="afterDescendants">

        <!-- Header Title -->
        <TextView
            android:id="@+id/tv_title"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Select Sources"
            android:textColor="#FFFFFF"
            android:textSize="20sp"
            android:textStyle="bold"
            android:focusable="false"
            android:layout_marginBottom="10dp" />

        <!-- Top Buttons Row -->
        <LinearLayout
            android:id="@+id/buttons_row"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginBottom="10dp">

            <Button
                android:id="@+id/btn_select_all"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="SELECT ALL"
                android:textAllCaps="true"
                android:backgroundTint="#1F6FEB"
                android:textColor="#FFFFFF"
                android:focusable="true"
                android:nextFocusRight="@id/btn_deselect_all" />

            <Button
                android:id="@+id/btn_deselect_all"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="SELECT NONE"
                android:textAllCaps="true"
                android:backgroundTint="#BB2D3B"
                android:textColor="#FFFFFF"
                android:layout_marginStart="8dp"
                android:focusable="true"
                android:nextFocusLeft="@id/btn_select_all" />

            <ImageButton
                android:id="@+id/btn_save"
                android:layout_width="40dp"
                android:layout_height="40dp"
                android:padding="8dp"
                android:background="?android:attr/selectableItemBackgroundBorderless"
                android:scaleType="centerInside" />

        </LinearLayout>

        <!-- Subtext -->
        <TextView
            android:id="@+id/tv_subtext"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Enable or Disable Sources"
            android:textSize="14sp"
            android:textColor="#CCCCCC"
            android:layout_marginBottom="10dp" />

        <!-- Divider -->
        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginBottom="12dp" />

        <!-- Profile Buttons Row -->
        <LinearLayout
            android:id="@+id/profile_buttons"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginBottom="16dp">

            <Button
                android:id="@+id/btn_save_profile"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="SAVE PROFILE"
                android:textAllCaps="true"
                android:backgroundTint="#1E88E5"
                android:textColor="#FFFFFF"
                android:focusable="true"
                android:layout_marginEnd="8dp" />

            <Button
                android:id="@+id/btn_load_profile"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="LOAD PROFILE"
                android:textAllCaps="true"
                android:backgroundTint="#2E7D32"
                android:textColor="#FFFFFF"
                android:focusable="true"
                android:layout_marginEnd="8dp" />

            <Button
                android:id="@+id/btn_delete_profile"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="DELETE PROFILE"
                android:textAllCaps="true"
                android:backgroundTint="#C62828"
                android:textColor="#FFFFFF"
                android:focusable="true" />
        </LinearLayout>

        <SearchView
            android:id="@+id/search_provider"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:queryHint="Search providers..."
            android:iconifiedByDefault="false"
            android:background="@android:color/transparent"
            android:layout_marginBottom="8dp"
            android:layout_marginTop="4dp"
            android:focusable="true"
            android:imeOptions="actionDone"
            android:inputType="text" />

        <!-- Divider -->
        <View
            android:layout_width="match_parent"
            android:layout_height="1dp"
            android:background="#333333"
            android:layout_marginBottom="12dp" />

        <!-- Providers List -->
        <LinearLayout
            android:id="@+id/list_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:dividerPadding="4dp"
            android:showDividers="none"
            android:focusable="false" />
    </LinearLayout>

</ScrollView>



================================================
FILE: StreamPlay/src/main/res/layout/fragment_toggle_extensions.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr"
    android:background="#121212"
    android:fillViewport="true">

    <LinearLayout
        android:id="@+id/toggle_root"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp">

        <!-- Header with Title and Save Icon -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="5dp">

            <TextView
                android:id="@+id/title"
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Toggle Extensions"
                android:textSize="20sp"
                android:textStyle="bold"
                android:textColor="#FFFFFF" />

            <ImageView
                android:id="@+id/saveIcon"
                android:layout_width="40dp"
                android:layout_height="40dp"
                android:padding="8dp"
                android:layout_marginStart="8dp"
                android:layout_marginEnd="4dp"
                android:focusable="true"
                android:clickable="true"
                android:background="?android:attr/selectableItemBackgroundBorderless"
                android:contentDescription="Save"
                android:nextFocusDown="@id/toggle_item"
                android:scaleType="centerInside" />
        </LinearLayout>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Enable or disable extensions to show in selection"
            android:textSize="14sp"
            android:textColor="#CCCCCC"
            android:layout_marginBottom="10dp" />

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <!-- Scrollable container for toggles -->
        <LinearLayout
            android:id="@+id/toggle_list_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp" />
    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: StreamPlay/src/main/res/layout/item_language.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<RadioButton xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/radio_language"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="12dp"
    android:textSize="17sp"
    android:textColor="#FFFFFF" />



================================================
FILE: StreamPlay/src/main/res/layout/item_provider_checkbox.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <CheckBox
        android:id="@+id/chk_provider"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:text="Provider Name"
        android:textColor="#FFFFFF"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:focusable="true"
        android:clickable="true"
        tools:ignore="TouchTargetSizeCheck" />
</LinearLayout>



================================================
FILE: StreamPlay/src/main/res/layout/list_toggle_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <Switch
        android:id="@+id/toggle_item"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:text="test"
        android:focusable="true"
        tools:ignore="UseSwitchCompatOrMaterialXml" />
</LinearLayout>



================================================
FILE: StreamPlay/src/main/res/layout/settings_fragment.xml
================================================
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:padding="16dp"
    tools:context=".settings.SettingsFragment">


    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="8dp">

        <LinearLayout
            android:id="@+id/settings_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="24dp"
            tools:ignore="WebViewLayout">

            <!-- Card 1: Google Login -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:text="Login Options"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Enable Google login to access SuperStream 4K content."
                        android:textSize="14sp"
                        android:textColor="#AAAAAA"
                        android:layout_marginTop="4dp"
                        android:layout_marginBottom="8dp" />

                    <Button
                        android:id="@+id/loginButton"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Login with Google"
                        android:backgroundTint="#4285F4"
                        android:textColor="#FFFFFF" />
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <!-- Card 2: Token Settings -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:layout_marginStart="4dp"
                        android:text="Token Management"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />
                    <!-- WebView (Hidden) -->
                    <WebView
                        android:id="@+id/authWebView"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:visibility="gone"
                        android:background="#FFFFFF"
                        android:layout_marginTop="16dp"
                        android:layout_marginBottom="8dp"
                        android:scrollbars="none" />


                    <EditText
                        android:id="@+id/tokenInput"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Paste Token or use Login"
                        android:textColorHint="#AAAAAA"
                        android:textColor="#FFFFFF"
                        android:inputType="text"
                        android:padding="12dp"
                        android:textSize="16sp"
                        android:layout_marginTop="8dp" />

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:layout_marginTop="8dp">

                        <Button
                            android:id="@+id/addButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Save Token"
                            android:backgroundTint="#6200EE"
                            android:textColor="#FFFFFF" />

                        <Space
                            android:layout_width="8dp"
                            android:layout_height="wrap_content" />

                        <Button
                            android:id="@+id/resetButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Reset"
                            android:backgroundTint="#D32F2F"
                            android:textColor="#FFFFFF" />
                    </LinearLayout>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>
        </LinearLayout>
    </ScrollView>
</RelativeLayout>


================================================
FILE: StreamPlay/src/main/res/layout/streamio_addon_addlinks.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="18dp"
    android:background="@android:color/transparent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Add link"
        android:textSize="18sp"
        android:textStyle="bold" />

    <EditText
        android:id="@+id/etName"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        android:autofillHints=""
        android:hint="Extension Name"
        android:inputType="text"
        android:layout_marginTop="12dp"
        android:textColorHint="#666" />

    <EditText
        android:id="@+id/etLink"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        android:autofillHints="Manifest URL"
        android:hint="Link (https://...)"
        android:inputType="textUri"
        android:layout_marginTop="8dp"
        android:textColorHint="#666" />

    <RadioGroup
        android:id="@+id/radioGroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="12dp"/>
</LinearLayout>



================================================
FILE: StreamPlay/src/main/res/layout/stremio_bottom_sheet_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Stremio Catalogs Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/saveIcon"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true" />
            </LinearLayout>
        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="All Link"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/addlinks"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:focusable="true"
                    android:padding="5dp" />

            </LinearLayout>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="List Link"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/showlinks"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/addlinks" />
            </LinearLayout>
        </LinearLayout>
    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: StreamPlay/src/main/res/layout/stremio_dialog_list_links.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="16dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="#2E3440">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Saved Links"
        android:textColor="#ECEFF4"
        android:textSize="20sp"
        android:textStyle="bold"
        android:gravity="center"
        android:paddingBottom="12dp"/>

    <TextView
        android:id="@+id/tvNoLinks"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="There are no links yet."
        android:textColor="#8FBCBB"
        android:gravity="center"
        android:padding="24dp"
        android:visibility="gone"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvLinks"
        android:layout_width="match_parent"
        android:layout_height="300dp"
        android:scrollbars="vertical"/>
</LinearLayout>


================================================
FILE: StreamPlay/src/main/res/layout/stremio_item_saved_link.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:layout_marginVertical="2dp"
    android:layout_marginHorizontal="2dp"
    android:padding="0dp"
    android:background="#4C566A">

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingStart="12dp"
        android:paddingTop="8dp"
        android:paddingEnd="8dp"
        android:paddingBottom="8dp">

        <ImageButton
            android:id="@+id/btnDelete"
            android:layout_width="32dp"
            android:layout_height="32dp"
            android:layout_alignParentTop="true"
            android:layout_alignParentEnd="true"
            android:layout_marginStart="8dp"
            android:contentDescription="Delete"
            android:src="@android:drawable/ic_menu_delete" />

        <TextView
            android:id="@+id/tvType"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/btnDelete"
            android:layout_alignParentEnd="true"
            android:layout_marginTop="2dp"
            android:text="StremioX"
            android:textColor="#88C0D0"
            android:textSize="10sp"
            android:paddingHorizontal="6dp"
            android:paddingVertical="1dp"
            android:gravity="center"/>

        <TextView
            android:id="@+id/tvName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_toStartOf="@id/btnDelete"
            android:layout_alignParentStart="true"
            android:text="Link Name"
            android:textColor="#ECEFF4"
            android:textSize="14sp"
            android:textStyle="bold"
            android:singleLine="true"
            android:ellipsize="end" />

        <TextView
            android:id="@+id/tvLink"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_below="@id/tvName"
            android:layout_toStartOf="@id/tvType"
            android:layout_alignParentStart="true"
            android:layout_marginTop="2dp"
            android:text="https://example.com/very/long/url"
            android:textColor="#A3BE8C"
            android:textSize="11sp"
            android:singleLine="true"
            android:ellipsize="end" />

    </RelativeLayout>
</LinearLayout>


================================================
FILE: StreamPlay/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="settings">Settings</string>
    <string name="notification_preferences">Notification Preferences</string>
    <string name="other_settings">Other Settings</string>
    <string name="reset">Reset</string>
    <string name="save_token">Save Token</string>
    <string name="paste_token_or_use_login">Paste Token or use Login</string>
    <string name="token_management">Token Management</string>
    <string name="toggle_extensions">Toggle Extensions</string>
    <string name="login">Login</string>
    <string name="go_to_login">Go to Login</string>
</resources>


================================================
FILE: StremioAddon/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

version = 9

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "TMDB_API", "\"${properties.getProperty("TMDB_API")}\"")
    }
}

cloudstream {
    language = "en"

     description = "[!] Requires Setup \n- Allows you to use any Stremio addon by pasting their manifest.json url"
     authors = listOf("Hexated,phisher98,erynith")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie",
        "Torrent"
    )
    requiresResources = true
    iconUrl = "https://files.catbox.moe/ol63rm.png"
}

dependencies {
    implementation("androidx.appcompat:appcompat:1.7.1")
    implementation("com.google.android.material:material:1.13.0")
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: StremioAddon/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: StremioAddon/src/main/kotlin/com/phisher98/StremioAddon.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import android.os.Build
import android.webkit.URLUtil
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import java.time.LocalDate
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.SubsExtractors.invokeOpenSubs
import com.phisher98.SubsExtractors.invokeWatchsomuch

class StremioAddon(private val sharedPref: SharedPreferences) : TmdbProvider() {
    override var mainUrl = "https://example.com"
    override var name = "Stremio"
    override val hasMainPage = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Torrent)

    companion object {
        const val TRACKER_LIST_URL = "https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt"
        private const val tmdbAPI = "https://api.themoviedb.org/3"
        private const val apiKey = BuildConfig.TMDB_API

        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.O)
    override val mainPage = run {
        val categories = mutableListOf<Pair<String, String>>()
        val currentMonth = LocalDate.now().monthValue

        categories += "$tmdbAPI/trending/all/day?api_key=$apiKey&region=US" to "Trending"
        categories += "$tmdbAPI/movie/popular?api_key=$apiKey&region=US" to "Popular Movies"
        if (currentMonth == 11 || currentMonth == 12) {
            categories += "$tmdbAPI/discover/movie?api_key=$apiKey&with_keywords=207317&region=US" to "Christmas Movies"
        }
        if (currentMonth == 10) {
            categories += "$tmdbAPI/discover/movie?api_key=$apiKey&with_genres=27&region=US" to "Halloween Horror Movies"
        }
        categories += "$tmdbAPI/tv/popular?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows"
        categories += "$tmdbAPI/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon Prime"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=49" to "HBO Max"
        categories += "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+"
        categories += "$tmdbAPI/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies"
        categories += "$tmdbAPI/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows"
        categories += "$tmdbAPI/movie/upcoming?api_key=$apiKey&region=US" to "Upcoming Movies"

        mainPageOf(*(categories).toTypedArray())
    }

    private fun getImageUrl(link: String?, fallback: String?): String? {
        if (link == null) return fallback
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?, fallback: String?): String? {
        if (link == null) return fallback
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val adultQuery =
            if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669|190370"
        val type = if (request.data.contains("/movie")) "movie" else "tv"
        val home = app.get("${request.data}$adultQuery&page=$page")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse(type)
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath, "https://files.catbox.moe/90n81c.jpg")
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        return app.get(
            "$tmdbAPI/search/multi?api_key=$apiKey&language=en-US&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}"
        ).parsedSafe<Results>()?.results?.mapNotNull { media ->
            media.toSearchResponse()
        }?.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse? {
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        }
        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")

        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath, "https://files.catbox.moe/32gthr.jpg")
        val bgPoster = getOriImageUrl(res.backdropPath, "https://files.catbox.moe/9qao8w.jpg")
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val genres = res.genres?.mapNotNull { it.name }
        val isAnime =
            genres?.contains("Animation") == true && (res.original_language == "zh" || res.original_language == "ja")
        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            ActorData(
                Actor(
                    cast.name ?: cast.originalName ?: return@mapNotNull null,
                    getImageUrl(cast.profilePath, "https://files.catbox.moe/90n81c.jpg")
                ), roleString = cast.character
            )
        } ?: return null
        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer = res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" }?.randomOrNull()

        return if (type == TvType.TvSeries) {
            val episodes = res.seasons?.mapNotNull { season ->
                app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey")
                    .parsedSafe<MediaDetailEpisodes>()?.episodes?.map { eps ->
                        newEpisode(LoadData(
                            res.external_ids?.imdb_id,
                            eps.seasonNumber,
                            eps.episodeNumber
                        ).toJson())
                        {
                            this.name = eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                            this.season = eps.seasonNumber
                            this.episode = eps.episodeNumber
                            this.posterUrl = getImageUrl(eps.stillPath, "https://files.catbox.moe/qbz6xd.jpg")
                            this.score = Score.from10(eps.voteAverage)
                            this.description = eps.overview
                            this.runTime = eps.runtime
                            this.addDate(eps.airDate)
                        }
                    }
            }?.flatten() ?: listOf()
            newTvSeriesLoadResponse(
                title, url, if (isAnime) TvType.Anime else TvType.TvSeries, episodes
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.tags =  keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.showStatus = getStatus(res.status)
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addImdbId(res.external_ids?.imdb_id)
            }
        } else {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LoadData(res.external_ids?.imdb_id).toJson()
            ) {
                this.posterUrl = poster
                this.comingSoon = isUpcoming(releaseDate)
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = parseJson<LoadData>(data)

        runAllAsync(
            suspend { invokeMainSource(res.imdbId, res.season, res.episode, subtitleCallback, callback) },
            suspend { invokeWatchsomuch(res.imdbId, res.season, res.episode, subtitleCallback) },
            suspend { invokeOpenSubs(res.imdbId, res.season, res.episode, subtitleCallback) }
        )

        return true
    }

    private suspend fun invokeMainSource(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val addonList = buildList {
            var index = 0
            while (true) {
                val key = if (index == 0) "stremio_addon" else "stremio_addon${index + 1}"
                if (!sharedPref.contains(key)) break
                add(key)
                index++
            }
        }

        for (addonPref in addonList) {
            val fixMainUrl = sharedPref.getString(addonPref, "")?.fixSourceUrl()

            if (fixMainUrl.isNullOrBlank()) continue

            val url = if (season == null) {
                "$fixMainUrl/stream/movie/$imdbId.json"
            } else {
                "$fixMainUrl/stream/series/$imdbId:$season:$episode.json"
            }

            if (!URLUtil.isValidUrl(url)) continue

            runCatching {
                app.get(url, timeout = 10L).parsedSafe<StreamsResponse>()
            }.onSuccess { res ->
                res?.streams?.forEach { stream ->
                    stream.runCallback(subtitleCallback, callback)
                }
            }.onFailure { _ ->
                Log.e(name, "Error loading from $addonPref")
            }
        }

    }

    private data class StreamsResponse(val streams: List<Stream>)
    private data class Subtitle(
        val url: String?,
        val lang: String?,
        val id: String?,
    )

    private data class ProxyHeaders(
        val request: Map<String, String>?,
    )

    private data class BehaviorHints(
        val proxyHeaders: ProxyHeaders?,
        val headers: Map<String, String>?,
    )

    private data class Stream(
        val name: String?,
        val title: String?,
        val url: String?,
        val description: String?,
        val ytId: String?,
        val externalUrl: String?,
        val behaviorHints: BehaviorHints?,
        val infoHash: String?,
        val sources: List<String> = emptyList(),
        val subtitles: List<Subtitle> = emptyList()
    ) {
        suspend fun runCallback(
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            if (url != null) {
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        fixSourceName(name, title, description),
                        url,
                        INFER_TYPE,
                    )
                    {
                        this.quality=getQuality(listOf(description,title,name))
                        this.headers=behaviorHints?.proxyHeaders?.request ?: behaviorHints?.headers ?: mapOf()
                    }
                )
                subtitles.map { sub ->
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                            ?: "",
                            sub.url ?: return@map
                        )
                    )
                }
            }
            if (ytId != null) {
                loadExtractor("https://www.youtube.com/watch?v=$ytId", subtitleCallback, callback)
            }
            if (externalUrl != null) {
                loadExtractor(externalUrl, subtitleCallback, callback)
            }
            if (infoHash != null) {
                val resp = app.get(TRACKER_LIST_URL).text
                val otherTrackers = resp
                    .split("\n")
                    .filterIndexed { i, _ -> i % 2 == 0 }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val sourceTrackers = sources
                    .filter { it.startsWith("tracker:") }
                    .map { it.removePrefix("tracker:") }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val magnet = "magnet:?xt=urn:btih:${infoHash}${sourceTrackers}${otherTrackers}"
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        title ?: name ?: "",
                        magnet,
                    )
                    {
                        this.quality=Qualities.Unknown.value
                    }
                )
            }
        }
    }

    data class LoadData(
        val imdbId: String? = null,
        val season: Int? = null,
        val episode: Int? = null,
    )

    data class Data(
        val id: Int? = null,
        val type: String? = null,
        val aniId: String? = null,
        val malId: Int? = null,
    )

    data class Results(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("media_type") val mediaType: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
    )

    data class Genres(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class Keywords(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class KeywordResults(
        @JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
    )

    data class Seasons(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
        @JsonProperty("air_date") val airDate: String? = null,
    )

    data class Cast(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("character") val character: String? = null,
        @JsonProperty("known_for_department") val knownForDepartment: String? = null,
        @JsonProperty("profile_path") val profilePath: String? = null,
    )

    data class Episodes(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("air_date") val airDate: String? = null,
        @JsonProperty("still_path") val stillPath: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("vote_average") val voteAverage: Double? = null,
        @JsonProperty("episode_number") val episodeNumber: Int? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
    )

    data class MediaDetailEpisodes(
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
    )

    data class Trailers(
        @JsonProperty("key") val key: String? = null,
    )

    data class ResultsTrailer(
        @JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
    )

    data class ExternalIds(
        @JsonProperty("imdb_id") val imdb_id: String? = null,
        @JsonProperty("tvdb_id") val tvdb_id: String? = null,
    )

    data class Credits(
        @JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
    )

    data class ResultsRecommendations(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class LastEpisodeToAir(
        @JsonProperty("episode_number") val episode_number: Int? = null,
        @JsonProperty("season_number") val season_number: Int? = null,
    )

    data class MediaDetail(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
        @JsonProperty("backdrop_path") val backdropPath: String? = null,
        @JsonProperty("release_date") val releaseDate: String? = null,
        @JsonProperty("first_air_date") val firstAirDate: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("vote_average") val vote_average: Any? = null,
        @JsonProperty("original_language") val original_language: String? = null,
        @JsonProperty("status") val status: String? = null,
        @JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: KeywordResults? = null,
        @JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
        @JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
        @JsonProperty("videos") val videos: ResultsTrailer? = null,
        @JsonProperty("external_ids") val external_ids: ExternalIds? = null,
        @JsonProperty("credits") val credits: Credits? = null,
        @JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
    )

}



================================================
FILE: StremioAddon/src/main/kotlin/com/phisher98/StremioAddonProvider.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import com.phisher98.settings.SettingsFragment

@CloudstreamPlugin
class StremioAddonProvider: Plugin() {
    override fun load(context: Context) {
        val sharedPref = context.getSharedPreferences("StremioAddon", Context.MODE_PRIVATE)
        registerMainAPI(StremioAddon(sharedPref))

        openSettings = { ctx ->
            val activity = ctx as AppCompatActivity
            val frag = SettingsFragment(this, sharedPref)
            frag.show(activity.supportFragmentManager, "Frag")
        }
    }
}



================================================
FILE: StremioAddon/src/main/kotlin/com/phisher98/StremioAddonUtils.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.getQualityFromName
import okhttp3.Interceptor
import okhttp3.Response
import java.text.SimpleDateFormat
import java.util.Locale
import java.util.concurrent.TimeUnit

fun String.fixSourceUrl(): String {
    return this.replace("/manifest.json", "").replace("stremio://", "https://")
}

fun fixSourceName(name: String?, title: String?, description: String?): String {
    return when {
        !name.isNullOrEmpty() && !title.isNullOrEmpty() -> "$name\n$title"
        !name.isNullOrEmpty() && !description.isNullOrEmpty() -> "$name\n$description"
        else -> title ?: description ?: name ?: ""
    }
}

fun getQuality(qualities: List<String?>): Int {
    fun String.getQuality(): String? {
        return Regex("(\\d{3,4}[pP])").find(this)?.groupValues?.getOrNull(1)
    }
    val quality = qualities.firstNotNullOfOrNull { it?.getQuality() }
    return getQualityFromName(quality)
}

fun getEpisodeSlug(
    season: Int? = null,
    episode: Int? = null,
): Pair<String, String> {
    return if (season == null && episode == null) {
        "" to ""
    } else {
        (if (season!! < 10) "0$season" else "$season") to (if (episode!! < 10) "0$episode" else "$episode")
    }
}

fun isUpcoming(dateString: String?): Boolean {
    return try {
        val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val dateTime = dateString?.let { format.parse(it)?.time } ?: return false
        unixTimeMS < dateTime
    } catch (t: Throwable) {
        logError(t)
        false
    }

}

fun fixUrl(url: String, domain: String): String {
    if (url.startsWith("http")) {
        return url
    }
    if (url.isEmpty()) {
        return ""
    }

    val startsWithNoHttp = url.startsWith("//")
    if (startsWithNoHttp) {
        return "https:$url"
    } else {
        if (url.startsWith('/')) {
            return domain + url
        }
        return "$domain/$url"
    }
}



================================================
FILE: StremioAddon/src/main/kotlin/com/phisher98/SubsExtractors.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.SubtitleHelper

const val openSubAPI = "https://opensubtitles-v3.strem.io"
const val watchSomuchAPI = "https://watchsomuch.tv"

object SubsExtractors {
    suspend fun invokeOpenSubs(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val slug = if(season == null) {
            "movie/$imdbId"
        } else {
            "series/$imdbId:$season:$episode"
        }
        app.get("${openSubAPI}/subtitles/$slug.json", timeout = 120L).parsedSafe<OsResult>()?.subtitles?.map { sub ->
            subtitleCallback.invoke(
                newSubtitleFile(
                    SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                    ?: return@map,
                    sub.url ?: return@map
                )
            )
        }
    }

    suspend fun invokeWatchsomuch(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val id = imdbId?.removePrefix("tt")
        val epsId = app.post(
            "${watchSomuchAPI}/Watch/ajMovieTorrents.aspx", data = mapOf(
                "index" to "0",
                "mid" to "$id",
                "wsk" to "30fb68aa-1c71-4b8c-b5d4-4ca9222cfb45",
                "lid" to "",
                "liu" to ""
            ), headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).parsedSafe<WatchsomuchResponses>()?.movie?.torrents?.let { eps ->
            if (season == null) {
                eps.firstOrNull()?.id
            } else {
                eps.find { it.episode == episode && it.season == season }?.id
            }
        } ?: return

        val (seasonSlug, episodeSlug) = getEpisodeSlug(season, episode)

        val subUrl = if (season == null) {
            "${watchSomuchAPI}/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part="
        } else {
            "${watchSomuchAPI}/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part=S${seasonSlug}E${episodeSlug}"
        }

        app.get(subUrl).parsedSafe<WatchsomuchSubResponses>()?.subtitles?.map { sub ->
            subtitleCallback.invoke(
                newSubtitleFile(
                    sub.label ?: "", fixUrl(sub.url ?: return@map null, watchSomuchAPI)
                )
            )
        }


    }

    data class OsSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("lang") val lang: String? = null,
    )

    data class OsResult(
        @JsonProperty("subtitles") val subtitles: ArrayList<OsSubtitles>? = arrayListOf(),
    )

    data class WatchsomuchTorrents(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("movieId") val movieId: Int? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
    )

    data class WatchsomuchMovies(
        @JsonProperty("torrents") val torrents: ArrayList<WatchsomuchTorrents>? = arrayListOf(),
    )

    data class WatchsomuchResponses(
        @JsonProperty("movie") val movie: WatchsomuchMovies? = null,
    )

    data class WatchsomuchSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("label") val label: String? = null,
    )

    data class WatchsomuchSubResponses(
        @JsonProperty("subtitles") val subtitles: ArrayList<WatchsomuchSubtitles>? = arrayListOf(),
    )
}



================================================
FILE: StremioAddon/src/main/kotlin/com/phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.*
import android.widget.*
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.content.edit
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import com.phisher98.StremioAddonProvider

class SettingsFragment(
    plugin: StremioAddonProvider,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {

    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        return inflater.inflate(res.getLayout(id), container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View?.makeTvCompatible() {
        if (this == null) return
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (outlineId != 0) {
            val drawable = res.getDrawable(outlineId, null)
            if (drawable != null) background = drawable
        }
    }

    /** Load all stremio_addon* keys as a list */
    private fun loadAddonsFromPrefs(): MutableList<String> {
        val addons = mutableListOf<String>()
        var index = 0

        while (true) {
            val key = if (index == 0) "stremio_addon" else "stremio_addon${index + 1}"
            if (!sharedPref.contains(key)) break

            val value = sharedPref.getString(key, "")?.trim().orEmpty()
            if (value.isNotEmpty()) {
                addons.add(value)
            }
            index++
        }

        return addons
    }

    /** Save list back to stremio_addon, stremio_addon2, stremio_addon3, ... */
    private fun saveAddonsToPrefs(addons: List<String>) {
        sharedPref.edit {
            // remove existing stremio_addon* keys
            sharedPref.all.keys
                .filter { it.startsWith("stremio_addon") }
                .forEach { remove(it) }

            // write current list sequentially
            addons.forEachIndexed { index, url ->
                val key = if (index == 0) "stremio_addon" else "stremio_addon${index + 1}"
                putString(key, url)
            }
        }
    }

    @SuppressLint("NotifyDataSetChanged")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val root = getLayout("settings", inflater, container)

        val stremioAddonInput = root.findView<EditText>("stremio_addon_input")
        val addAddonButton = root.findView<Button>("add_addon_button")
        stremioAddonInput.makeTvCompatible()
        addAddonButton.makeTvCompatible()

        val addonList = loadAddonsFromPrefs()
        val addonRecyclerView = root.findView<RecyclerView>("stremio_addon_list")
        addonRecyclerView.layoutManager = LinearLayoutManager(requireContext())
        val addonAdapter = AddonAdapter(addonList)
        addonRecyclerView.adapter = addonAdapter

        addAddonButton.setOnClickListener {
            val text = stremioAddonInput.text.toString().trim()
            if (text.isNotEmpty()) {
                addonList.add(text)
                addonAdapter.notifyItemInserted(addonList.size - 1)
                stremioAddonInput.text.clear()
            }
        }

        val saveBtn = root.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            saveAddonsToPrefs(addonList)

            AlertDialog.Builder(requireContext())
                .setTitle("Restart Required")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    showToast("Saved and Restarting...")
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No") { dialog, _ ->
                    showToast("Saved. Restart later to apply changes.")
                    dialog.dismiss()
                    dismiss()
                }
                .show()
        }

        val resetBtn = root.findView<View>("delete_img")
        resetBtn.makeTvCompatible()
        resetBtn.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Reset")
                .setMessage("This will delete all saved addons.")
                .setPositiveButton("Reset") { _, _ ->

                    sharedPref.edit(commit = true) {
                        sharedPref.all.keys
                            .filter { it.startsWith("stremio_addon") }
                            .forEach { remove(it) }
                    }
                    val size = addonList.size
                    if (size > 0) {
                        addonList.clear()
                        addonAdapter.notifyItemRangeRemoved(0, size)
                    }
                    stremioAddonInput.text.clear()
                    restartApp()
                }
                .setNegativeButton("Cancel", null)
                .show()
        }

        return root
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component
        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }

    inner class AddonAdapter(
        private val items: MutableList<String>
    ) : RecyclerView.Adapter<AddonAdapter.AddonViewHolder>() {

        inner class AddonViewHolder(view: View) : RecyclerView.ViewHolder(view) {
            val urlText: TextView = view.findViewById(
                res.getIdentifier("addon_url_text", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
            )
            val deleteButton: Button = view.findViewById(
                res.getIdentifier("delete_addon_button", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
            )
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): AddonViewHolder {
            val inflater = LayoutInflater.from(parent.context)
            val view = getLayout("item_stremio_addon", inflater, parent)
            view.makeTvCompatible()
            return AddonViewHolder(view)
        }

        override fun onBindViewHolder(holder: AddonViewHolder, position: Int) {
            val url = items[position]
            holder.urlText.text = url

            holder.deleteButton.setOnClickListener {
                val pos = holder.bindingAdapterPosition
                if (pos != RecyclerView.NO_POSITION) {
                    items.removeAt(pos)
                    notifyItemRemoved(pos)
                }
            }
        }

        override fun getItemCount(): Int = items.size
    }
}



================================================
FILE: StremioAddon/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: StremioAddon/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: StremioAddon/src/main/res/drawable/ic_android_24dp.xml
================================================
<vector android:height="24dp" android:tint="#000000"
    android:viewportHeight="24" android:viewportWidth="24"
    android:width="24dp" xmlns:android="http://schemas.android.com/apk/res/android">
    <path android:fillColor="#FF000000" android:pathData="M17.6,11.48 L19.44,8.3a0.63,0.63 0,0 0,-1.09 -0.63l-1.88,3.24a11.43,11.43 0,0 0,-8.94 0L5.65,7.67a0.63,0.63 0,0 0,-1.09 0.63L6.4,11.48A10.81,10.81 0,0 0,1 20L23,20A10.81,10.81 0,0 0,17.6 11.48ZM7,17.25A1.25,1.25 0,1 1,8.25 16,1.25 1.25,0 0,1 7,17.25ZM17,17.25A1.25,1.25 0,1 1,18.25 16,1.25 1.25,0 0,1 17,17.25Z"/>
</vector>


================================================
FILE: StremioAddon/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: StremioAddon/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: StremioAddon/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: StremioAddon/src/main/res/layout/item_stremio_addon.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="8dp"
    android:gravity="center_vertical">

    <TextView
        android:id="@+id/addon_url_text"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="14sp"
        android:maxLines="2"
        android:ellipsize="end" />

    <Button
        android:id="@+id/delete_addon_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Remove" />
</LinearLayout>



================================================
FILE: StremioAddon/src/main/res/layout/settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:gravity="center_vertical">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="StremioAddon Settings"
            android:textSize="20sp"
            android:textStyle="bold"
            android:layout_marginBottom="10dp" />

        <ImageView
            android:id="@+id/save"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:contentDescription="Save Settings"
            android:padding="5dp" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="8dp">

        <EditText
            android:id="@+id/stremio_addon_input"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:hint="Enter Addon Manifest URL"
            android:inputType="textUri"
            android:padding="8dp" />

        <Button
            android:id="@+id/add_addon_button"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginStart="8dp"
            android:text="Add"
            android:backgroundTint="#D32F2F"
            android:textColor="@android:color/white" />
    </LinearLayout>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/stremio_addon_list"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:layout_marginTop="16dp" />

    <Button
        android:id="@+id/delete_img"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginTop="12dp"
        android:text="Remove All" />

</LinearLayout>



================================================
FILE: StremioAddon/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_fragment">Hello funny fragment!!</string>
    <string name="loaded_from_app_trans">[loaded from app trans]</string>
</resources>


================================================
FILE: StremioAddon/src/main/res/values-pl/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="hello_fragment">Witaj zabawny fragmencie!!</string>
    <string name="loaded_from_app_trans">[Załadowane z aplikacji trans]</string>
</resources>


================================================
FILE: StremioX/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 12

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "TMDB_API", "\"${properties.getProperty("TMDB_API")}\"")
    }
}

dependencies {
    implementation("com.google.android.material:material:1.13.0")
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

     description = "[!] Requires Setup \n- StremioX allows you to use stream addons \n- StremioC allows you to use catalog addons"
     authors = listOf("Hexated,phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie",
    )
    requiresResources = true
    iconUrl = "https://raw.githubusercontent.com/hexated/cloudstream-extensions-hexated/master/StremioX/icon.png"
}


================================================
FILE: StremioX/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: StremioX/src/main/kotlin/com/phisher98/StremioC.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.AcraApplication
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixTitle
import com.lagradost.cloudstream3.imdbUrlToIdNullable
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper
import com.lagradost.cloudstream3.utils.USER_PROVIDER_API
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.StremioC.Companion.TRACKER_LIST_URLS
import com.phisher98.SubsExtractors.invokeOpenSubs
import com.phisher98.SubsExtractors.invokeWatchsomuch
import org.json.JSONObject
import java.net.URLEncoder
import java.util.Locale


class StremioC(override var mainUrl: String, override var name: String) : MainAPI() {
    override val supportedTypes = setOf(TvType.Others)
    override val hasMainPage = true

    companion object {
        private const val cinemeta = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb"
        val TRACKER_LIST_URLS = listOf(
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best.txt",
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best_ip.txt",
        )
        private const val TRACKER_LIST_URL = "https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt"
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        if (mainUrl.isEmpty()) {
            throw IllegalArgumentException("Configure in Extension Settings\n")
        }
        mainUrl = mainUrl.fixSourceUrl()

        val pageSize = 100
        val skip = (page - 1) * pageSize

        val manifest = app
            .get("$mainUrl/manifest.json")
            .parsedSafe<Manifest>()

        val lists = mutableListOf<HomePageList>()

        manifest?.catalogs?.amap { catalog ->
            catalog.toHomePageList(
                provider = this,
                skip = skip
            ).let {
                if (it.list.isNotEmpty()) {
                    lists.add(it)
                }
            }
        }

        return newHomePageResponse(
            lists,
            hasNext = true
        )
    }


    override suspend fun search(query: String): List<SearchResponse> {
        mainUrl = mainUrl.fixSourceUrl()
        val res = app.get("${mainUrl}/manifest.json").parsedSafe<Manifest>()
        val list = mutableListOf<SearchResponse>()
        res?.catalogs?.amap { catalog ->
            list.addAll(catalog.search(query, this))
        }
        return list.distinct()
    }

    override suspend fun load(url: String): LoadResponse {
        val res: CatalogEntry = if (url.startsWith("{")) {
            parseJson(url)
        } else {
            val json = app.get(url).text
            val metaJson = JSONObject(json).getJSONObject("meta").toString()
            parseJson(metaJson)
        }

        val encodedId = URLEncoder.encode(res.id, "UTF-8")

        val response = app.get("$mainUrl/meta/${res.type}/$encodedId.json")
            .parsedSafe<CatalogResponse>()
            ?: throw RuntimeException("Failed to load meta")

        val entry = response.meta
            ?: response.metas?.firstOrNull { it.id == res.id }
            ?: response.metas?.firstOrNull()
            ?: run {
                val fallback = app.get(
                    "$cinemeta/meta/${res.type}/$encodedId.json",
                    timeout = 120L
                ).parsedSafe<CatalogResponse>()

                fallback?.meta
                    ?: fallback?.metas?.firstOrNull()
                    ?: throw RuntimeException("Meta not found (primary + fallback)")
            }

        return entry.toLoadResponse(this, res.id)
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val loadData = parseJson<LoadData>(data)
        val encodedId = URLEncoder.encode(loadData.id, "UTF-8")
        val request = app.get(
            "${mainUrl}/stream/${loadData.type}/$encodedId.json",
            timeout = 120L
        )

        val res = if (request.isSuccessful)
            request.parsedSafe<StreamsResponse>()
        else
            null

        if (!res?.streams.isNullOrEmpty()) {
            res.streams.forEach { stream ->
                stream.runCallback(subtitleCallback, callback)
            }
        } else {
            runAllAsync(
                    {
                        invokeStremioX(loadData.type, loadData.id, subtitleCallback, callback)
                    },{
                        invokeTorrentio(loadData.imdbId, loadData.season, loadData.episode, callback)
                    },
                    {
                        invokeKnaben(loadData.imdbId, loadData.year,loadData.season, loadData.episode, callback)
                    },
                    {
                        invokeUindex(loadData.imdbId, loadData.year,loadData.season, loadData.episode, callback)
                    },
                    {
                        invokeWatchsomuch(
                            loadData.imdbId,
                            loadData.season,
                            loadData.episode,
                            subtitleCallback
                        )
                    },
                    {
                        invokeOpenSubs(
                            loadData.imdbId,
                            loadData.season,
                            loadData.episode,
                            subtitleCallback
                        )
                    }
            )
        }

        return true
    }

    private suspend fun invokeStremioX(
        type: String?,
        id: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val sites = AcraApplication.getKey<Array<CustomSite>>(USER_PROVIDER_API)?.toMutableList()
            ?: mutableListOf()
        sites.filter { it.parentJavaClass == "StremioX" }.amap { site ->
            val res = app.get(
                "${site.url.fixSourceUrl()}/stream/${type}/${id}.json",
                timeout = 120L
            ).parsedSafe<StreamsResponse>()
            res?.streams?.forEach { stream ->
                stream.runCallback(subtitleCallback, callback)
            }
        }
    }

    data class LoadData(
        val type: String? = null,
        val id: String? = null,
        val season: Int? = null,
        val episode: Int? = null,
        val imdbId: String? = null,
        val year: Int? = null
    )

    data class CustomSite(
        @JsonProperty("parentJavaClass") val parentJavaClass: String,
        @JsonProperty("name") val name: String,
        @JsonProperty("url") val url: String,
        @JsonProperty("lang") val lang: String,
    )

    // check if id is imdb/tmdb cause stremio addons like torrentio works base on imdbId
    private fun isImdborTmdb(url: String?): Boolean {
        return imdbUrlToIdNullable(url) != null || url?.startsWith("tmdb:") == true
    }

    private fun isImdb(url: String?): Boolean {
        return imdbUrlToIdNullable(url) != null
    }


    private data class Manifest(val catalogs: List<Catalog>)
    private data class Catalog(
        var name: String?,
        val id: String,
        val type: String?,
        val types: MutableList<String> = mutableListOf()
    ) {
        init {
            if (type != null) types.add(type)
        }

        suspend fun search(query: String, provider: StremioC): List<SearchResponse> {
            val entries = mutableListOf<SearchResponse>()
            types.forEach { type ->
                val res = app.get(
                    "${provider.mainUrl}/catalog/${type}/${id}/search=${query}.json",
                    timeout = 120L
                ).parsedSafe<CatalogResponse>()
                res?.metas?.forEach { entry ->
                    entries.add(entry.toSearchResponse(provider))
                }
            }
            return entries
        }

        suspend fun toHomePageList(
            provider: StremioC,
            skip: Int
        ): HomePageList {
            val entries = mutableMapOf<String, SearchResponse>()

            types.forEach { type ->
                val url = if (skip > 0) {
                    "${provider.mainUrl}/catalog/$type/$id/skip=$skip.json"
                } else {
                    "${provider.mainUrl}/catalog/$type/$id.json"
                }

                val res = app.get(
                    url,
                    timeout = 120L
                ).parsedSafe<CatalogResponse>()

                res?.metas?.forEach { entry ->
                    if (!entries.containsKey(entry.id)) {
                        entries[entry.id] = entry.toSearchResponse(provider)
                    }
                }
            }

            return HomePageList(
                name ?: id,
                entries.values.toList()
            )
        }
    }

    private data class CatalogResponse(val metas: List<CatalogEntry>?, val meta: CatalogEntry?)

    private data class Trailer(
        val source: String?,
        val type: String?
    )

    private data class CatalogEntry(
        @JsonProperty("name") val name: String,
        @JsonProperty("id") val id: String,
        @JsonProperty("poster") val poster: String?,
        @JsonProperty("background") val background: String?,
        @JsonProperty("description") val description: String?,
        @JsonProperty("imdbRating") val imdbRating: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("videos") val videos: List<Video>?,
        @JsonProperty("genre") val genre: List<String>?,
        @JsonProperty("genres") val genres: List<String> = emptyList(),
        @JsonProperty("cast") val cast: List<String> = emptyList(),
        @JsonProperty("trailers") val trailersSources: List<Trailer> = emptyList(),
        @JsonProperty("year") val yearNum: String? = null
    ) {
        fun toSearchResponse(provider: StremioC): SearchResponse {
            return provider.newMovieSearchResponse(
                name,
                this.toJson(),
                TvType.Others
            ) {
                posterUrl = poster
            }
        }

        suspend fun toLoadResponse(provider: StremioC, imdbId: String?): LoadResponse {
            if (videos.isNullOrEmpty()) {
                return provider.newMovieLoadResponse(
                    name,
                    "${provider.mainUrl}/meta/${type}/${id}.json",
                    TvType.Movie,
                    LoadData(type, id, imdbId = imdbId, year = yearNum?.toIntOrNull())
                ) {
                    posterUrl = poster
                    backgroundPosterUrl = background
                    score = Score.from10(imdbRating)
                    plot = description
                    year = yearNum?.toIntOrNull()
                    tags = genre ?: genres
                    addActors(cast)
                    addTrailer(trailersSources.map { "https://www.youtube.com/watch?v=${it.source}" })
                    addImdbId(imdbId)
                }
            } else {
                return provider.newTvSeriesLoadResponse(
                    name,
                    "${provider.mainUrl}/meta/${type}/${id}.json",
                    TvType.TvSeries,
                    videos.map {
                        it.toEpisode(provider, type, imdbId)
                    }
                ) {
                    posterUrl = poster
                    backgroundPosterUrl = background
                    score = Score.from10(imdbRating)
                    plot = description
                    year = yearNum?.toIntOrNull()
                    tags = genre ?: genres
                    addActors(cast)
                    addTrailer(trailersSources.map { "https://www.youtube.com/watch?v=${it.source}" }
                        .randomOrNull())
                    addImdbId(imdbId)
                }
            }

        }
    }

    private data class Video(
        @JsonProperty("id") val id: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("season") val seasonNumber: Int? = null,
        @JsonProperty("number") val number: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("thumbnail") val thumbnail: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("description") val description: String? = null,
    ) {
        fun toEpisode(provider: StremioC, type: String?, imdbId: String?): Episode {
            return provider.newEpisode(
                LoadData(type, id, seasonNumber, episode ?: number, imdbId)
            ) {
                this.name = this@Video.name ?: title
                this.posterUrl = thumbnail
                this.description = overview ?:  this@Video.description
                this.season = seasonNumber
                this.episode =  this@Video.episode ?: number
            }
        }
    }

    private data class StreamsResponse(val streams: List<Stream>)
    private data class Subtitle(
        val url: String?,
        val lang: String?,
        val id: String?,
    )

    private data class ProxyHeaders(
        val request: Map<String, String>?,
    )

    private data class BehaviorHints(
        val proxyHeaders: ProxyHeaders?,
        val headers: Map<String, String>?,
    )

    private data class Stream(
        val name: String?,
        val title: String?,
        val url: String?,
        val description: String?,
        val ytId: String?,
        val externalUrl: String?,
        val behaviorHints: BehaviorHints?,
        val infoHash: String?,
        val sources: List<String> = emptyList(),
        val subtitles: List<Subtitle> = emptyList()
    ) {
        suspend fun runCallback(
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            if (url != null) {
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        fixSourceName(name, title),
                        url,
                        INFER_TYPE,
                    )
                    {
                        this.quality=getQuality(listOf(description,title,name))
                        this.headers=behaviorHints?.proxyHeaders?.request ?: behaviorHints?.headers ?: mapOf()
                    }
                )
                subtitles.map { sub ->
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                            ?: "",
                            sub.url ?: return@map
                        )
                    )
                }
            }
            if (ytId != null) {
                loadExtractor("https://www.youtube.com/watch?v=$ytId", subtitleCallback, callback)
            }
            if (externalUrl != null) {
                loadExtractor(externalUrl, subtitleCallback, callback)
            }
            if (infoHash != null) {
                val resp = app.get(TRACKER_LIST_URL).text
                val otherTrackers = resp
                    .split("\n")
                    .filterIndexed { i, _ -> i % 2 == 0 }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val sourceTrackers = sources
                    .filter { it.startsWith("tracker:") }
                    .map { it.removePrefix("tracker:") }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val magnet = "magnet:?xt=urn:btih:${infoHash}${sourceTrackers}${otherTrackers}"
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        title ?: name ?: "",
                        magnet,
                    )
                    {
                        this.quality=Qualities.Unknown.value
                    }
                )
            }
        }
    }
}

suspend fun invokeUindex(
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val uindex = "https://uindex.org"
    val isTv = season != null

    val searchQuery = buildString {
        if (!title.isNullOrBlank()) append(title)
        if (year != null) {
            if (isNotEmpty()) append(' ')
            append(year)
        }
    }.replace(' ', '+')

    val url = "$uindex/search.php?search=$searchQuery&c=${if (isTv) 2 else 1}"

    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )

    val rows = app.get(url, headers = headers).documentLarge.select("tr")

    val episodePatterns: List<Regex> = if (isTv && episode != null) {
        val rawPatterns = listOf(
            String.format(Locale.US, "S%02dE%02d", season, episode),
            "S${season}E$episode",
            String.format(Locale.US, "S%02dE%d", season, episode),
            String.format(Locale.US, "S%dE%02d", season, episode),
        )

        rawPatterns.distinct().map {
            Regex("\\b$it\\b", RegexOption.IGNORE_CASE)
        }
    } else {
        emptyList()
    }

    rows.amap { row ->
        val rowTitle = row.select("td:nth-child(2) > a:nth-child(2)").text()
        val magnet = row.select("td:nth-child(2) > a:nth-child(1)").attr("href")

        if (rowTitle.isBlank() || magnet.isBlank()) return@amap

        if (isTv && episodePatterns.isNotEmpty()) {
            if (episodePatterns.none { it.containsMatchIn(rowTitle) }) return@amap
        }

        val qualityMatch = "(2160p|1080p|720p)"
            .toRegex(RegexOption.IGNORE_CASE)
            .find(rowTitle)
            ?.value

        val seeder = row
            .select("td:nth-child(4) > span")
            .text()
            .replace(",", "")
            .ifBlank { "0" }

        val fileSize = row.select("td:nth-child(3)").text()

        val formattedTitleName = run {
            val qualityTermsRegex =
                "(WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)"
                    .toRegex(RegexOption.IGNORE_CASE)

            val tags = qualityTermsRegex.findAll(rowTitle)
                .map { it.value.uppercase() }
                .distinct()
                .joinToString(" | ")

            "UIndex | $tags | Seeder: $seeder | FileSize: $fileSize".trim()
        }

        callback.invoke(
            newExtractorLink(
                "UIndex",
                formattedTitleName.ifBlank { rowTitle },
                url = magnet,
                type = INFER_TYPE
            ) {
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}

suspend fun invokeKnaben(
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val knaben = "https://knaben.org"
    val isTv = season != null
    val host = knaben.trimEnd('/')

    val baseQuery = buildString {
        val queryText = title?.takeIf { it.isNotBlank() } ?: return@buildString

        append(
            queryText
                .trim()
                .replace("\\s+".toRegex(), "+")
        )

        if (isTv && episode != null) {
            append("+S${season.toString().padStart(2, '0')}")
            append("E${episode.toString().padStart(2, '0')}")
        } else if (!isTv && year != null) {
            append("+$year")
        }
    }

    if (baseQuery.isBlank()) return

    val category = when {
        isTv -> "2000000"
        else -> "3000000"
    }

    for (page in 1..2) {
        val url = "$host/search/$baseQuery/$category/$page/seeders"

        val doc = app.get(url).document

        doc.select("tr.text-nowrap.border-start").forEach { row ->
            val infoTd = row.selectFirst("td:nth-child(2)") ?: return@forEach

            val titleElement = infoTd.selectFirst("a[title]") ?: return@forEach
            val rawTitle = titleElement.attr("title").ifBlank { titleElement.text() }

            val magnet = infoTd.selectFirst("a[href^=magnet:?]")?.attr("href") ?: return@forEach

            val source = row
                .selectFirst("td.d-sm-none.d-xl-table-cell a")
                ?.text()
                ?.trim()
                .orEmpty()

            val tds = row.select("td")
            val sizeText = tds.getOrNull(2)?.text().orEmpty()
            val seedsText = tds.getOrNull(4)?.text().orEmpty()
            val seeds = seedsText.toIntOrNull() ?: 0
            val qualityMatch = "(2160p|1080p|720p)"
                .toRegex(RegexOption.IGNORE_CASE)
                .find(rawTitle)
                ?.value
            val formattedTitleName = buildString {
                append("Knaben | ")
                append(rawTitle)

                if (seeds > 0) {
                    append(" | Seeds: ")
                    append(seeds)
                }

                if (sizeText.isNotBlank()) {
                    append(" | ")
                    append(sizeText)
                }

                if (source.isNotBlank()) {
                    append(" | ")
                    append(source)
                }
            }

            callback(
                newExtractorLink(
                    "Knaben",
                    formattedTitleName.ifBlank { rawTitle },
                    url = magnet,
                    type = INFER_TYPE
                ) {
                    this.quality = getQualityFromName(qualityMatch)
                }
            )
        }
    }
}

suspend fun invokeTorrentio(
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if(season == null) {
        "https://torrentio.strem.fun/stream/movie/$id.json"
    }
    else {
        "https://torrentio.strem.fun/stream/series/$id:$season:$episode.json"
    }
    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val formattedTitleName = stream.title
            ?.let { title ->
                val qualityTermsRegex = "(2160p|1080p|720p|WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)".toRegex(RegexOption.IGNORE_CASE)
                val tagsList = qualityTermsRegex.findAll(title).map { it.value.uppercase() }.toList()
                val tags = tagsList.distinct().joinToString(" | ")

                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\n]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"

                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        val qualityMatch = "(2160p|1080p|720p)".toRegex(RegexOption.IGNORE_CASE)
            .find(stream.title ?: "")
            ?.value
            ?.lowercase()

        val magnet = generateMagnetLink(TRACKER_LIST_URLS, stream.infoHash)

        callback.invoke(
            newExtractorLink(
                "Torrentio",
                formattedTitleName ?: stream.name ?: "",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}


================================================
FILE: StremioX/src/main/kotlin/com/phisher98/StremioX.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.SubsExtractors.invokeOpenSubs
import com.phisher98.SubsExtractors.invokeWatchsomuch

class StremioX(override var mainUrl: String, override var name: String) : TmdbProvider() {
    override val hasMainPage = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(TvType.Others)

    companion object {
        const val TRACKER_LIST_URL = "https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt"
        private const val tmdbAPI = "https://api.themoviedb.org/3"
        private const val apiKey = BuildConfig.TMDB_API

        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage = mainPageOf(
        "$tmdbAPI/trending/all/day?api_key=$apiKey&region=US" to "Trending",
        "$tmdbAPI/movie/popular?api_key=$apiKey&region=US" to "Popular Movies",
        "$tmdbAPI/tv/popular?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows",
        "$tmdbAPI/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=49" to "HBO",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+",
        "$tmdbAPI/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies",
        "$tmdbAPI/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows",
        "$tmdbAPI/movie/upcoming?api_key=$apiKey&region=US" to "Upcoming Movies",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_original_language=ko" to "Korean Shows",
    )

    private fun getImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val adultQuery =
            if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669|190370"
        val type = if (request.data.contains("/movie")) "movie" else "tv"
        val home = app.get("${request.data}$adultQuery&page=$page")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse(type)
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath)
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        return app.get(
            "$tmdbAPI/search/multi?api_key=$apiKey&language=en-US&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}"
        ).parsedSafe<Results>()?.results?.mapNotNull { media ->
            media.toSearchResponse()
        }?.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse? {
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        }
        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")

        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath)
        val bgPoster = getOriImageUrl(res.backdropPath)
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val genres = res.genres?.mapNotNull { it.name }
        val isAnime =
            genres?.contains("Animation") == true && (res.original_language == "zh" || res.original_language == "ja")
        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            ActorData(
                Actor(
                    cast.name ?: cast.originalName ?: return@mapNotNull null,
                    getImageUrl(cast.profilePath)
                ), roleString = cast.character
            )
        } ?: return null
        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer =
            res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" }?.randomOrNull()

        return if (type == TvType.TvSeries) {
            val episodes = res.seasons?.mapNotNull { season ->
                app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey")
                    .parsedSafe<MediaDetailEpisodes>()?.episodes?.map { eps ->
                        newEpisode(LoadData(
                            res.external_ids?.imdb_id,
                            eps.seasonNumber,
                            eps.episodeNumber
                        ).toJson())
                        {
                            this.name = eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                            this.season = eps.seasonNumber
                            this.episode = eps.episodeNumber
                            this.posterUrl = getImageUrl(eps.stillPath)
                            this.score = Score.from10(eps.voteAverage)
                            this.description = eps.overview
                            this.addDate(eps.airDate)
                        }
                    }
            }?.flatten() ?: listOf()
            newTvSeriesLoadResponse(
                title, url, if (isAnime) TvType.Anime else TvType.TvSeries, episodes
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.tags =  keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.showStatus = getStatus(res.status)
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addTMDbId(data.id.toString())
                addImdbId(res.external_ids?.imdb_id)
            }
        } else {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LoadData(res.external_ids?.imdb_id).toJson()
            ) {
                this.posterUrl = poster
                this.comingSoon = isUpcoming(releaseDate)
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addTMDbId(data.id.toString())
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val res = parseJson<LoadData>(data)

        runAllAsync(
            {
                invokeMainSource(res.imdbId, res.season, res.episode, subtitleCallback, callback)
            },
            {
                invokeWatchsomuch(res.imdbId, res.season, res.episode, subtitleCallback)
            },
            {
                invokeOpenSubs(res.imdbId, res.season, res.episode, subtitleCallback)
            },
        )

        return true
    }

    private suspend fun invokeMainSource(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val fixMainUrl = mainUrl.fixSourceUrl()
        val url = if (season == null) {
            "$fixMainUrl/stream/movie/$imdbId.json"
        } else {
            "$fixMainUrl/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 120L).parsedSafe<StreamsResponse>()
        res?.streams?.forEach { stream ->
            stream.runCallback(subtitleCallback, callback)
        }
    }

    private data class StreamsResponse(val streams: List<Stream>)
    private data class Subtitle(
        val url: String?,
        val lang: String?,
        val id: String?,
    )

    private data class ProxyHeaders(
        val request: Map<String, String>?,
    )

    private data class BehaviorHints(
        val proxyHeaders: ProxyHeaders?,
        val headers: Map<String, String>?,
    )

    private data class Stream(
        val name: String?,
        val title: String?,
        val url: String?,
        val description: String?,
        val ytId: String?,
        val externalUrl: String?,
        val behaviorHints: BehaviorHints?,
        val infoHash: String?,
        val sources: List<String> = emptyList(),
        val subtitles: List<Subtitle> = emptyList()
    ) {
        suspend fun runCallback(
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            if (url != null) {
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        fixSourceName(name, title),
                        url,
                        INFER_TYPE,
                    )
                    {
                        this.quality=getQuality(listOf(description,title,name))
                        this.headers=behaviorHints?.proxyHeaders?.request ?: behaviorHints?.headers ?: mapOf()
                    }
                )
                subtitles.map { sub ->
                    subtitleCallback.invoke(
                        newSubtitleFile(
                            SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                            ?: "",
                            sub.url ?: return@map
                        )
                    )
                }
            }
            if (ytId != null) {
                loadExtractor("https://www.youtube.com/watch?v=$ytId", subtitleCallback, callback)
            }
            if (externalUrl != null) {
                loadExtractor(externalUrl, subtitleCallback, callback)
            }
            if (infoHash != null) {
                val resp = app.get(TRACKER_LIST_URL).text
                val otherTrackers = resp
                    .split("\n")
                    .filterIndexed { i, _ -> i % 2 == 0 }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val sourceTrackers = sources
                    .filter { it.startsWith("tracker:") }
                    .map { it.removePrefix("tracker:") }
                    .filter { s -> s.isNotEmpty() }.joinToString("") { "&tr=$it" }

                val magnet = "magnet:?xt=urn:btih:${infoHash}${sourceTrackers}${otherTrackers}"
                callback.invoke(
                    newExtractorLink(
                        name ?: "",
                        title ?: name ?: "",
                        magnet,
                    )
                    {
                        this.quality=Qualities.Unknown.value
                    }
                )
            }
        }
    }

    data class LoadData(
        val imdbId: String? = null,
        val season: Int? = null,
        val episode: Int? = null,
    )

    data class Data(
        val id: Int? = null,
        val type: String? = null,
        val aniId: String? = null,
        val malId: Int? = null,
    )

    data class Results(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("media_type") val mediaType: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
    )

    data class Genres(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class Keywords(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class KeywordResults(
        @JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
    )

    data class Seasons(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
        @JsonProperty("air_date") val airDate: String? = null,
    )

    data class Cast(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("character") val character: String? = null,
        @JsonProperty("known_for_department") val knownForDepartment: String? = null,
        @JsonProperty("profile_path") val profilePath: String? = null,
    )

    data class Episodes(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("air_date") val airDate: String? = null,
        @JsonProperty("still_path") val stillPath: String? = null,
        @JsonProperty("vote_average") val voteAverage: Double? = null,
        @JsonProperty("episode_number") val episodeNumber: Int? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
    )

    data class MediaDetailEpisodes(
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
    )

    data class Trailers(
        @JsonProperty("key") val key: String? = null,
    )

    data class ResultsTrailer(
        @JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
    )

    data class ExternalIds(
        @JsonProperty("imdb_id") val imdb_id: String? = null,
        @JsonProperty("tvdb_id") val tvdb_id: String? = null,
    )

    data class Credits(
        @JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
    )

    data class ResultsRecommendations(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class LastEpisodeToAir(
        @JsonProperty("episode_number") val episode_number: Int? = null,
        @JsonProperty("season_number") val season_number: Int? = null,
    )

    data class MediaDetail(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
        @JsonProperty("backdrop_path") val backdropPath: String? = null,
        @JsonProperty("release_date") val releaseDate: String? = null,
        @JsonProperty("first_air_date") val firstAirDate: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("vote_average") val vote_average: Any? = null,
        @JsonProperty("original_language") val original_language: String? = null,
        @JsonProperty("status") val status: String? = null,
        @JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: KeywordResults? = null,
        @JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
        @JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
        @JsonProperty("videos") val videos: ResultsTrailer? = null,
        @JsonProperty("external_ids") val external_ids: ExternalIds? = null,
        @JsonProperty("credits") val credits: Credits? = null,
        @JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
    )

}



================================================
FILE: StremioX/src/main/kotlin/com/phisher98/StremioXPlugin.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.api.Log
import com.lagradost.cloudstream3.MainActivity
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import com.lagradost.cloudstream3.plugins.PluginData
import com.lagradost.cloudstream3.plugins.PluginManager
import org.json.JSONArray

@CloudstreamPlugin
class StremioXPlugin : Plugin() {
    private val PREF_FILE = "StremioX"
    private val PREF_KEY_LINKS = "stremio_saved_links"

    override fun load(context: Context) {
        try {
            registerMainAPI(StremioX("", "StremioX"))
        } catch (_: Throwable) {}
        try {
            registerMainAPI(StremioC("", "StremioC"))
        } catch (_: Throwable) {}
        reload(context)
        val activity = context as? AppCompatActivity
        openSettings = {
            val frag = SettingsBottomFragment(this, context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE))
            activity?.supportFragmentManager?.let { fm -> frag.show(fm, "Frag") }
        }
    }

    fun reload(context: Context) {
        try {
            val prefs = context.getSharedPreferences(PREF_FILE, Context.MODE_PRIVATE)
            val json = prefs.getString(PREF_KEY_LINKS, null) ?: "[]"
            val arr = JSONArray(json)
            val links = mutableListOf<LinkEntry>()
            for (i in 0 until arr.length()) {
                val obj = arr.optJSONObject(i) ?: continue
                links.add(
                    LinkEntry(
                        id = obj.optLong("id", System.currentTimeMillis()),
                        name = obj.optString("name", ""),
                        link = obj.optString("link", ""),
                        type = obj.optString("type", "StremioX")
                    )
                )
            }
            for (item in links) {
                val pluginsOnline: Array<PluginData> = PluginManager.getPluginsOnline()
                var found: PluginData? = null
                for (p in pluginsOnline) {
                    if (p.internalName.contains(item.name, ignoreCase = true)) {
                        found = p
                        break
                    }
                }
                if (found != null) {
                    try {
                        PluginManager.unloadPlugin(found.filePath)
                    } catch (e: Throwable) {
                        Log.e("StremioXPlugin", "unload failed ${e.message}")
                    }
                } else {
                    try {
                        when (item.type) {
                            "StremioX" -> {
                                try {
                                    registerMainAPI(StremioX(item.link, item.name))
                                } catch (_: Throwable) {
                                    try { registerMainAPI(StremioX("", item.name)) } catch (_: Throwable) {}
                                }
                            }
                            "StremioC" -> {
                                try {
                                    registerMainAPI(StremioC(item.link, item.name))
                                } catch (_: Throwable) {
                                    try { registerMainAPI(StremioC("", item.name)) } catch (_: Throwable) {}
                                }
                            }
                            else -> {
                                try { registerMainAPI(StremioX(item.link, item.name)) } catch (_: Throwable) {}
                            }
                        }
                    } catch (e: Throwable) {
                        Log.e("StremioXPlugin", "register failed ${e.message}")
                    }
                }
            }
            try {
                MainActivity.afterPluginsLoadedEvent.invoke(true)
            } catch (e: Throwable) {
                Log.w("StremioXPlugin", "afterPluginsLoaded invoke failed ${e.message}")
            }
        } catch (e: Throwable) {
            Log.e("StremioXPlugin", "reload error ${e.message}")
        }
    }

    data class LinkEntry(
        val id: Long,
        val name: String,
        val link: String,
        val type: String
    )
}



================================================
FILE: StremioX/src/main/kotlin/com/phisher98/SubsExtractors.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.SubtitleHelper

const val openSubAPI = "https://opensubtitles-v3.strem.io"
const val watchSomuchAPI = "https://watchsomuch.tv"

object SubsExtractors {
    suspend fun invokeOpenSubs(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val slug = if(season == null) {
            "movie/$imdbId"
        } else {
            "series/$imdbId:$season:$episode"
        }
        app.get("${openSubAPI}/subtitles/$slug.json", timeout = 120L).parsedSafe<OsResult>()?.subtitles?.map { sub ->
            subtitleCallback.invoke(
                newSubtitleFile(
                    SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                    ?: return@map,
                    sub.url ?: return@map
                )
            )
        }
    }

    suspend fun invokeWatchsomuch(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val id = imdbId?.removePrefix("tt")
        val epsId = app.post(
            "${watchSomuchAPI}/Watch/ajMovieTorrents.aspx", data = mapOf(
                "index" to "0",
                "mid" to "$id",
                "wsk" to "30fb68aa-1c71-4b8c-b5d4-4ca9222cfb45",
                "lid" to "",
                "liu" to ""
            ), headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).parsedSafe<WatchsomuchResponses>()?.movie?.torrents?.let { eps ->
            if (season == null) {
                eps.firstOrNull()?.id
            } else {
                eps.find { it.episode == episode && it.season == season }?.id
            }
        } ?: return

        val (seasonSlug, episodeSlug) = getEpisodeSlug(season, episode)

        val subUrl = if (season == null) {
            "${watchSomuchAPI}/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part="
        } else {
            "${watchSomuchAPI}/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part=S${seasonSlug}E${episodeSlug}"
        }

        app.get(subUrl).parsedSafe<WatchsomuchSubResponses>()?.subtitles?.map { sub ->
            subtitleCallback.invoke(
                newSubtitleFile(
                    sub.label ?: "", fixUrl(sub.url ?: return@map null, watchSomuchAPI)
                )
            )
        }


    }

    data class OsSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("lang") val lang: String? = null,
    )

    data class OsResult(
        @JsonProperty("subtitles") val subtitles: ArrayList<OsSubtitles>? = arrayListOf(),
    )

    data class WatchsomuchTorrents(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("movieId") val movieId: Int? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
    )

    data class WatchsomuchMovies(
        @JsonProperty("torrents") val torrents: ArrayList<WatchsomuchTorrents>? = arrayListOf(),
    )

    data class WatchsomuchResponses(
        @JsonProperty("movie") val movie: WatchsomuchMovies? = null,
    )

    data class WatchsomuchSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("label") val label: String? = null,
    )

    data class WatchsomuchSubResponses(
        @JsonProperty("subtitles") val subtitles: ArrayList<WatchsomuchSubtitles>? = arrayListOf(),
    )
}


================================================
FILE: StremioX/src/main/kotlin/com/phisher98/Utils.kt
================================================
package com.phisher98

import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.getQualityFromName

import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import java.text.SimpleDateFormat
import java.util.Locale
import kotlin.sequences.forEach

fun String.fixSourceUrl(): String {
    return this.replace("/manifest.json", "").replace("stremio://", "https://")
}

fun fixSourceName(name: String?, title: String?): String {
    return when {
        name?.contains("[RD+]", true) == true -> "[RD+] $title"
        name?.contains("[RD download]", true) == true -> "[RD download] $title"
        !name.isNullOrEmpty() && !title.isNullOrEmpty() -> "$name $title"
        else -> title ?: name ?: ""
    }
}

fun getQuality(qualities: List<String?>): Int {
    fun String.getQuality(): String? {
        return Regex("(\\d{3,4}[pP])").find(this)?.groupValues?.getOrNull(1)
    }
    val quality = qualities.firstNotNullOfOrNull { it?.getQuality() }
    return getQualityFromName(quality)
}

fun getEpisodeSlug(
    season: Int? = null,
    episode: Int? = null,
): Pair<String, String> {
    return if (season == null && episode == null) {
        "" to ""
    } else {
        (if (season!! < 10) "0$season" else "$season") to (if (episode!! < 10) "0$episode" else "$episode")
    }
}

fun isUpcoming(dateString: String?): Boolean {
    return try {
        val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val dateTime = dateString?.let { format.parse(it)?.time } ?: return false
        unixTimeMS < dateTime
    } catch (t: Throwable) {
        logError(t)
        false
    }

}

fun fixUrl(url: String, domain: String): String {
    if (url.startsWith("http")) {
        return url
    }
    if (url.isEmpty()) {
        return ""
    }

    val startsWithNoHttp = url.startsWith("//")
    if (startsWithNoHttp) {
        return "https:$url"
    } else {
        if (url.startsWith('/')) {
            return domain + url
        }
        return "$domain/$url"
    }
}

data class TorrentioResponse(
    @SerializedName("streams") val streams: List<TorrentioStream> = emptyList()
)

data class TorrentioStream(
    @SerializedName("name") val name: String? = null,
    @SerializedName("title") val title: String? = null,
    @SerializedName("infoHash") val infoHash: String? = null,
    @SerializedName("fileIdx") val fileIdx: Int? = null
)


suspend fun generateMagnetLink(
    trackerUrls: List<String>,
    hash: String?,
): String {
    require(hash?.isNotBlank() == true)

    val trackers = mutableSetOf<String>()

    trackerUrls.forEach { url ->
        try {
            val response = app.get(url)
            response.text
                .lineSequence()
                .map { it.trim() }
                .filter { it.isNotEmpty() && !it.startsWith("#") }
                .forEach { trackers.add(it) }
        } catch (_: Exception) {
            // ignore bad sources
        }
    }

    return buildString {
        append("magnet:?xt=urn:btih:").append(hash)

        if (hash.isNotBlank()) {
            append("&dn=")
            append(URLEncoder.encode(hash, StandardCharsets.UTF_8.name()))
        }

        trackers
            .take(10) // practical limit
            .forEach { tracker ->
                append("&tr=")
                append(URLEncoder.encode(tracker, StandardCharsets.UTF_8.name()))
            }
    }
}



================================================
FILE: StremioX/src/main/kotlin/com/phisher98/settings/SettingsBottomFragment.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.ImageButton
import android.widget.ImageView
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import androidx.core.net.toUri
import androidx.core.content.edit
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView
import com.lagradost.api.Log
import com.lagradost.cloudstream3.CommonActivity.showToast

class SettingsBottomFragment(
    plugin: StremioXPlugin,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {
    private val PREF_KEY_LINKS = "stremio_saved_links"

    private val res = plugin.resources ?: throw Exception("Unable to access plugin resources")

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (id == 0) throw Exception("View ID $name not found.")
        return this.findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("DiscouragedApi")
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val view = getLayout("bottom_sheet_layout", inflater, container)

        listOf("addlinks", "showlinks", "saveIcon").forEach { name ->
            val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
            if (id == 0) Log.w("SettingsBottomFragment", "View id '$name' not found")
            else Log.d("SettingsBottomFragment", "View id '$name' -> $id")
        }

        // safe find helpers (throws clear exceptions if missing)
        val addlinks: ImageView = try { view.findView("addlinks") } catch (e: Throwable) {
            throw Exception("addlinks ImageView not found in bottom_sheet_layout", e)
        }
        val showlinks: ImageView = try { view.findView("showlinks") } catch (e: Throwable) {
            throw Exception("showlinks ImageView not found in bottom_sheet_layout", e)
        }
        val saveIcon: ImageView = try { view.findView("saveIcon") } catch (e: Throwable) {
            throw Exception("saveIcon ImageView not found in bottom_sheet_layout", e)
        }

        addlinks.setImageDrawable(getDrawable("settings_icon"))
        showlinks.setImageDrawable(getDrawable("settings_icon"))
        saveIcon.setImageDrawable(getDrawable("save_icon"))

        addlinks.makeTvCompatible()
        showlinks.makeTvCompatible()
        saveIcon.makeTvCompatible()

        // ---------- ADD dialog ----------
        addlinks.setOnClickListener {
            val dialogView = getLayout("addlinks", inflater, container)
            val etName: EditText
            val etLink: EditText
            val rg: RadioGroup
            try {
                etName = dialogView.findView("etName")
                etLink = dialogView.findView("etLink")
                rg = dialogView.findView("radioGroup")
            } catch (t: Throwable) {
                Toast.makeText(requireContext(), "Dialog fields not found", Toast.LENGTH_SHORT).show()
                Log.e("SettingsBottomFragment", "Missing dialog views $t")
                return@setOnClickListener
            }

            val rbXId = res.getIdentifier("rbX", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
            try { dialogView.findView<RadioButton>("rbX").isChecked = true } catch (_: Throwable) {}

            val dlg = AlertDialog.Builder(requireContext())
                .setView(dialogView)
                .setPositiveButton("Save", null)
                .setNegativeButton("Cancel", null)
                .create()

            dlg.setOnShowListener {
                val btnSave = dlg.getButton(AlertDialog.BUTTON_POSITIVE)
                btnSave.setOnClickListener {
                    val name = etName.text.toString().trim()
                    val link = etLink.text.toString().trim()
                    val type = if (rg.checkedRadioButtonId == rbXId) "StremioX" else "StremioC"

                    if (link.isEmpty()) {
                        showToast("Please enter a link")
                        return@setOnClickListener
                    }

                    val valid = try {
                        val uri = link.toUri()
                        val scheme = uri.scheme?.lowercase()
                        scheme == "http" || scheme == "https"
                    } catch (_: Exception) {
                        false
                    }

                    if (!valid) {
                        showToast("Enter a valid URL (http/https)")
                        return@setOnClickListener
                    }

                    val item = LinkItem(name = name.ifBlank { link }, link = link, type = type)
                    try {
                        val list = loadLinks().toMutableList()
                        list.add(0, item)
                        saveLinks(list)
                        Toast.makeText(requireContext(), "Link saved", Toast.LENGTH_SHORT).show()
                        dlg.dismiss()
                    } catch (e: Throwable) {
                        Log.e("SettingsBottomFragment", "Failed to save link $e")
                        showToast("Failed to save link")
                    }
                }
            }

            dlg.show()
        }

        // ---------- SHOW list dialog ----------
        showlinks.setOnClickListener {
            val dialogView = getLayout("dialog_list_links", inflater, container)
            val dlg = AlertDialog.Builder(requireContext())
                .setView(dialogView)
                .setPositiveButton("Close", null)
                .create()

            val rv: RecyclerView = dialogView.findView("rvLinks")
            val tvNoLinks: TextView = dialogView.findView("tvNoLinks")
            val list = loadLinks().toMutableList()
            Log.d("SettingsBottomFragment", "Loaded ${list.size} saved links")

            if (list.isEmpty()) {
                tvNoLinks.visibility = View.VISIBLE
                rv.visibility = View.GONE
            } else {
                tvNoLinks.visibility = View.GONE
                rv.visibility = View.VISIBLE

                rv.layoutManager = LinearLayoutManager(requireContext())

                val adapter = LinksAdapter(list) { itemToDelete ->
                    val updatedList = loadLinks().toMutableList()
                    val removed = updatedList.removeAll { it.id == itemToDelete.id }

                    if (removed) {
                        saveLinks(updatedList)
                        (rv.adapter as? LinksAdapter)?.remove(itemToDelete)
                        showToast("Deleted")
                        if (updatedList.isEmpty()) {
                            tvNoLinks.visibility = View.VISIBLE
                            rv.visibility = View.GONE
                        }
                    }
                }


                rv.adapter = adapter
            }
            dlg.show()
        }


        // ---------- SAVE & RESTART ----------
        saveIcon.setOnClickListener {
            val context = this.context ?: return@setOnClickListener

            AlertDialog.Builder(context)
                .setTitle("Save & Reload")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No", null)
                .show()
        }

        return view
    }


    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }

    data class LinkItem(
        val id: Long = System.currentTimeMillis(),
        val name: String,
        val link: String,
        val type: String
    )

    private fun loadLinks(): MutableList<LinkItem> {
        val json = sharedPref.getString(PREF_KEY_LINKS, null) ?: return mutableListOf()
        val list = mutableListOf<LinkItem>()

        return try {
            val arr = org.json.JSONArray(json)

            for (i in 0 until arr.length()) {
                val obj = arr.getJSONObject(i)

                list.add(
                    LinkItem(
                        id   = obj.optLong("id", System.currentTimeMillis()),
                        name = obj.optString("name", ""),
                        link = obj.optString("link", ""),
                        type = obj.optString("type", "StremioX")
                    )
                )
            }

            list
        } catch (_: Exception) {
            mutableListOf()
        }
    }


    private fun saveLinks(list: List<LinkItem>) {
        val arr = org.json.JSONArray()

        for (item in list) {
            val obj = org.json.JSONObject().apply {
                put("id", item.id)
                put("name", item.name)
                put("link", item.link)
                put("type", item.type)
            }
            arr.put(obj)
        }

        sharedPref.edit { putString(PREF_KEY_LINKS, arr.toString()) }
    }

    inner class LinksAdapter(
        private val items: MutableList<LinkItem>,
        private val onDelete: (LinkItem) -> Unit
    ) : RecyclerView.Adapter<LinksAdapter.VH>() {

        inner class VH(v: View) : RecyclerView.ViewHolder(v) {
            val tvName: TextView = v.findView("tvName")
            val tvLink: TextView = v.findView("tvLink")
            val tvType: TextView = v.findView("tvType")
            val btnDelete: ImageButton = v.findView("btnDelete")
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): VH {
            val layoutId = res.getIdentifier("item_saved_link", "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
            val v = layoutInflater.inflate(res.getLayout(layoutId), parent, false)
            return VH(v)
        }

        override fun onBindViewHolder(holder: VH, position: Int) {
            val item = items[position]

            holder.tvName.text = item.name
            holder.tvLink.text = item.link
            holder.tvType.text = item.type

            holder.btnDelete.setOnClickListener {
                onDelete(item)
            }
        }

        override fun getItemCount(): Int = items.size

        fun remove(item: LinkItem) {
            val idx = items.indexOfFirst { it.id == item.id }
            if (idx >= 0) {
                items.removeAt(idx)
                notifyItemRemoved(idx)
            }
        }
    }


}



================================================
FILE: StremioX/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: StremioX/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: StremioX/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: StremioX/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: StremioX/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: StremioX/src/main/res/layout/addlinks.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:padding="18dp"
    android:background="@android:color/transparent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Add link"
        android:textSize="18sp"
        android:textStyle="bold" />

    <EditText
        android:id="@+id/etName"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        android:autofillHints=""
        android:hint="Extension Name"
        android:inputType="text"
        android:layout_marginTop="12dp"
        android:textColorHint="#666" />

    <EditText
        android:id="@+id/etLink"
        android:layout_width="match_parent"
        android:layout_height="48dp"
        android:autofillHints="Manifest URL"
        android:hint="Link (https://...)"
        android:inputType="textUri"
        android:layout_marginTop="8dp"
        android:textColorHint="#666" />

    <RadioGroup
        android:id="@+id/radioGroup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:layout_marginTop="12dp">

        <RadioButton
            android:id="@+id/rbX"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="StremioX" />

        <RadioButton
            android:id="@+id/rbC"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="StremioC"
            android:layout_marginStart="24dp"/>
    </RadioGroup>
</LinearLayout>



================================================
FILE: StremioX/src/main/res/layout/bottom_sheet_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Stremio Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/saveIcon"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true" />
            </LinearLayout>
        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="All Link"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/addlinks"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:focusable="true"
                    android:padding="5dp" />

            </LinearLayout>
        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="List Link"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/showlinks"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusUp="@id/addlinks" />
            </LinearLayout>
        </LinearLayout>
    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: StremioX/src/main/res/layout/dialog_list_links.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:padding="16dp"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="#2E3440">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Saved Links"
        android:textColor="#ECEFF4"
        android:textSize="20sp"
        android:textStyle="bold"
        android:gravity="center"
        android:paddingBottom="12dp"/>

    <TextView
        android:id="@+id/tvNoLinks"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="There are no links yet."
        android:textColor="#8FBCBB"
        android:gravity="center"
        android:padding="24dp"
        android:visibility="gone"/>

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/rvLinks"
        android:layout_width="match_parent"
        android:layout_height="300dp"
        android:scrollbars="vertical"/>
</LinearLayout>


================================================
FILE: StremioX/src/main/res/layout/item_saved_link.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical"
    android:layout_marginVertical="2dp"
    android:layout_marginHorizontal="2dp"
    android:padding="0dp"
    android:background="#4C566A">

    <RelativeLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingStart="12dp"
        android:paddingTop="8dp"
        android:paddingEnd="8dp"
        android:paddingBottom="8dp">

        <ImageButton
            android:id="@+id/btnDelete"
            android:layout_width="32dp"
            android:layout_height="32dp"
            android:layout_alignParentTop="true"
            android:layout_alignParentEnd="true"
            android:layout_marginStart="8dp"
            android:contentDescription="Delete"
            android:src="@android:drawable/ic_menu_delete" />

        <TextView
            android:id="@+id/tvType"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_below="@id/btnDelete"
            android:layout_alignParentEnd="true"
            android:layout_marginTop="2dp"
            android:text="StremioX"
            android:textColor="#88C0D0"
            android:textSize="10sp"
            android:paddingHorizontal="6dp"
            android:paddingVertical="1dp"
            android:gravity="center"/>

        <TextView
            android:id="@+id/tvName"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_toStartOf="@id/btnDelete"
            android:layout_alignParentStart="true"
            android:text="Link Name"
            android:textColor="#ECEFF4"
            android:textSize="14sp"
            android:textStyle="bold"
            android:singleLine="true"
            android:ellipsize="end" />

        <TextView
            android:id="@+id/tvLink"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_below="@id/tvName"
            android:layout_toStartOf="@id/tvType"
            android:layout_alignParentStart="true"
            android:layout_marginTop="2dp"
            android:text="https://example.com/very/long/url"
            android:textColor="#A3BE8C"
            android:textSize="11sp"
            android:singleLine="true"
            android:ellipsize="end" />

    </RelativeLayout>
</LinearLayout>


================================================
FILE: SuperStream/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties

version = 29

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "TMDB_API", "\"${properties.getProperty("TMDB_API")}\"")
        buildConfigField("String", "SUPERSTREAM_THIRD_API", "\"${properties.getProperty("SUPERSTREAM_THIRD_API")}\"")
        buildConfigField("String", "SUPERSTREAM_FOURTH_API", "\"${properties.getProperty("SUPERSTREAM_FOURTH_API")}\"")
        buildConfigField("String", "SUPERSTREAM_FIRST_API", "\"${properties.getProperty("SUPERSTREAM_FIRST_API")}\"")
        buildConfigField("String", "CatflixAPI", "\"${properties.getProperty("CatflixAPI")}\"")

    }
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them
     description = "SuperStream (Retrieve the cookie using Login with Google to properly utilize SuperStream."
     authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
        "Cartoon",
        "AnimeMovie"
    )

    iconUrl = "https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://www.showbox.media/&size=256"

    requiresResources = true
    isCrossPlatform = false

}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    implementation("com.google.android.material:material:1.13.0")
    implementation("androidx.leanback:leanback:1.2.0")
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: SuperStream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/SuperStream.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.SharedPreferences
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.SuperStreamExtractor.invokeSubtitleAPI
import com.phisher98.SuperStreamExtractor.invokeSuperstream
import kotlinx.coroutines.withTimeoutOrNull
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Locale
import java.util.regex.Pattern
open class SuperStream(sharedPref: SharedPreferences? = null) : TmdbProvider() {
    override var name = "SuperStream"
    override val hasMainPage = true
    override val instantLinkLoading = true
    override val useMetaLoadResponse = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.Cartoon,
    )

    val token = sharedPref?.getString("token", null)

    companion object {
        /** TOOLS */
        private const val Cinemeta = "https://v3-cinemeta.strem.io"
        private const val OFFICIAL_TMDB_URL = "https://api.themoviedb.org/3"
        private const val REMOTE_PROXY_LIST = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Proxylist.txt"
        private const val apiKey = BuildConfig.TMDB_API
        const val febbox="https://www.febbox.com"

        suspend fun getApiBase(): String {
            return if (isOfficialAvailable()) {
                OFFICIAL_TMDB_URL
            } else {
                val proxy = fetchProxyList().randomOrNull()
                if (proxy != null) {
                    Log.d("Error:", "Official unavailable, using proxy: $proxy")
                    proxy
                } else {
                    OFFICIAL_TMDB_URL
                }
            }
        }

        private suspend fun isOfficialAvailable(): Boolean = withTimeoutOrNull(5000) {
            try {
                val testUrl = "$OFFICIAL_TMDB_URL/configuration?api_key=$apiKey"
                val response = app.get(
                    testUrl,
                    timeout = 1000,
                    headers = mapOf(
                        "Cache-Control" to "no-cache",
                        "Pragma" to "no-cache"
                    )
                )
                response.okhttpResponse.code in listOf(200,304)
            } catch (e: Exception) {
                Log.d("Error", "Official TMDB unavailable: ${e.message}")
                false
            }
        } ?: false


        private suspend fun fetchProxyList(): List<String> = try {
            val response = app.get(REMOTE_PROXY_LIST).text
            val json = JSONObject(response)
            val arr = json.getJSONArray("proxies")

            val proxies = List(arr.length()) { arr.getString(it).trim() }
                .filter { it.isNotEmpty() }
                .map { proxyUrl ->
                    val clean = proxyUrl.removeSuffix("/")
                    clean
                }
            proxies
        } catch (_: Exception) {
            Log.e("Error:", "Error fetching proxy list")
            emptyList()
        }


        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }

    }

    override val mainPage = mainPageOf(
        "/trending/all/day?api_key=$apiKey&region=US" to "Trending",
        "/movie/popular?api_key=$apiKey&region=US" to "Popular Movies",
        "/tv/popular?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows",
        "/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows",
        "/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix",
        "/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon",
        "/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+",
        "/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu",
        "/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+",
        "/discover/tv?api_key=$apiKey&with_networks=49" to "HBO",
        "/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+",
        "/discover/tv?api_key=$apiKey&with_networks=3353" to "Peacock",
        "/discover/movie?api_key=$apiKey&language=en-US&page=1&sort_by=popularity.desc&with_origin_country=IN" to "Indian Movies",
        "/discover/tv?api_key=$apiKey&with_networks=4008" to "JioCinema",
        "/discover/tv?api_key=$apiKey&with_networks=5920" to "Amazon MiniTV",
        "/discover/tv?api_key=$apiKey&with_networks=1112" to "Crunchyroll",
        "/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies",
        "/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows",
        "/discover/tv?api_key=$apiKey&with_original_language=ko" to "Korean Shows",
        "/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().today}&air_date.gte=${getDate().today}" to "Airing Today Anime",
        "/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().nextWeek}&air_date.gte=${getDate().today}" to "On The Air Anime",
        "/discover/tv?api_key=$apiKey&with_genres=16&sort_by=air_date.desc&air_date.lte=${getDate().nextWeek}&air_date.gte=${getDate().today}&language=jp" to "Recently Updated Anime",
        "/discover/tv?api_key=$apiKey&with_keywords=210024|222243" to "Anime",
        "/discover/movie?api_key=$apiKey&with_keywords=210024|222243" to "Anime Movies",
        //"/movie/upcoming?api_key=$apiKey&region=US" to "Upcoming Movies",
        "Personal" to "Personal Febbox Content"
        )
    private fun getImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }
    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val tmdbAPI =getApiBase()
        if (request.name.contains("Personal")) {
            if (token.isNullOrEmpty()) {
                return newHomePageResponse(
                    "Login required for Febbox Personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            }

            val htmlResponse = app.get(
                "$febbox/console/file_list",
                headers = mapOf("cookie" to token)
            ).parsedSafe<HTML>()

            val document = Jsoup.parse(htmlResponse?.html.orEmpty())
            val parsedHtmlContent = document.select("div.list_scroll > div > div")
            val filesFromHtml = parsedHtmlContent.mapNotNull { div ->
                div.toSearchResponse()
             }

            return newHomePageResponse(
                listOf(
                    HomePageList(
                        request.name,
                        filesFromHtml,
                        true
                    )
                )
            )
        }
        else {
            val adultQuery =
                if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669"
            val type = if (request.data.contains("/movie")) "movie" else "tv"
            val home = app.get("$tmdbAPI${request.data}$adultQuery&page=$page", timeout = 10000)
                .parsedSafe<Results>()?.results?.mapNotNull { media ->
                    media.toSearchResponse(type)
                } ?: throw ErrorLoadingException("Invalid Json reponse")
            return newHomePageResponse(request.name, home)
        }
    }


    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath)
            this.score= Score.from10(voteAverage)
        }
    }


    private fun Element.toSearchResponse(): SearchResponse {
        val title=this.select("p.file_name_show").text()
        val poster=this.select("div.file_icon").attr("style").substringAfter("(").substringBefore(")")
        val href="$febbox/console/share_file_comment?fid="+this.select("div").attr("data-id")
        return newMovieSearchResponse(
            title,
            href,
            TvType.Movie,
        ) {
            this.posterUrl = poster
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String,page: Int): SearchResponseList? {
        val tmdbAPI = getApiBase()
        return app.get("$tmdbAPI/search/multi?api_key=$apiKey&language=en-US&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse()
            }?.toNewSearchResponseList()
    }

    override suspend fun load(url: String): LoadResponse? {
        if (url.startsWith("$febbox/console/share_file_comment?fid")) {
            val gson = Gson()
            val jsonString = app.get(url, headers = mapOf("cookie" to (token ?: ""))).text
            val response = gson.fromJson(jsonString, PersonalComments::class.java)
            val media = response?.file

            if (media != null) {
                return newMovieLoadResponse(
                    media.file_name,
                    "$febbox|"+media.fid.toString(),
                    TvType.Movie,
                    "$febbox|"+media.fid
                ) {
                    this.posterUrl = media.thumb_big
                    this.plot = "Added: ${media.add_time} | Updated: ${media.update_time} | Size: ${media.file_size}"
                }
            }
        }
        val tmdbAPI = getApiBase()
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val append = "alternative_titles,credits,external_ids,videos,recommendations"

        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&append_to_response=$append"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&append_to_response=$append"
        }

        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")
        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath)
        val bgPoster = getOriImageUrl(res.backdropPath)
        val orgTitle = res.originalTitle ?: res.originalName ?: return null
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val rating = res.vote_average.toString()
        val genres = res.genres?.mapNotNull { it.name }

        val isCartoon = genres?.contains("Animation") ?: false
        val isAnime = isCartoon && (res.original_language == "zh" || res.original_language == "ja")
        val isAsian = !isAnime && (res.original_language == "zh" || res.original_language == "ko")
        val isBollywood = res.production_countries?.any { it.name == "India" } ?: false

        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            val name = cast.name ?: cast.originalName ?: return@mapNotNull null
            ActorData(
                Actor(name, getImageUrl(cast.profilePath)), roleString = cast.character
            )
        } ?: emptyList()

        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer = res.videos?.results.orEmpty()
            .filter { it.type == "Trailer" }
            .map { "https://www.youtube.com/watch?v=${it.key}" }
            .reversed()
            .ifEmpty {
                res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" } ?: emptyList()
            }

        if (type == TvType.TvSeries) {
            val lastSeason = res.last_episode_to_air?.season_number
            val episodes = res.seasons?.mapNotNull { season ->
                app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey")
                    .parsedSafe<MediaDetailEpisodes>()?.episodes?.map { eps ->
                        Log.d("Phisher",eps.toJson())
                        newEpisode(
                            LinkData(
                                data.id,
                                res.external_ids?.imdb_id,
                                res.external_ids?.tvdb_id,
                                data.type,
                                eps.seasonNumber,
                                eps.episodeNumber,
                                eps.id,
                                title = title,
                                year = season.airDate?.split("-")?.first()?.toIntOrNull(),
                                orgTitle = orgTitle,
                                isAnime = isAnime,
                                airedYear = year,
                                lastSeason = lastSeason,
                                epsTitle = eps.name,
                                jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title,
                                date = season.airDate,
                                airedDate = res.releaseDate ?: res.firstAirDate,
                                isAsian = isAsian,
                                isBollywood = isBollywood,
                                isCartoon = isCartoon,
                                alttitle = res.title,
                                nametitle = res.name
                            ).toJson()
                        ) {
                            this.name =
                                eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                            this.season = eps.seasonNumber
                            this.episode = eps.episodeNumber
                            this.posterUrl = getImageUrl(eps.stillPath)
                            this.score = Score.from10(eps.voteAverage)
                            this.description = eps.overview
                        }.apply {
                            this.addDate(eps.airDate)
                        }
                    }
            }?.flatten() ?: listOf()
            if (isAnime) {
                val gson = Gson()
                val animeType = if (data.type?.contains("tv", ignoreCase = true) == true) "series" else "movie"
                val imdbId = res.external_ids?.imdb_id.orEmpty()
                val cineJsonText = app.get("$Cinemeta/meta/$animeType/$imdbId.json").text
                val cinejson = runCatching {
                    gson.fromJson(cineJsonText, CinemetaRes::class.java)
                }.getOrNull()
                val animevideos = cinejson?.meta?.videos

                val animeepisodes = animevideos
                    ?.filter { it.season!= 0 }
                    ?.map { video ->
                        newEpisode(
                            LinkData(
                                id = data.id,
                                imdbId = res.external_ids?.imdb_id,
                                tvdbId = res.external_ids?.tvdb_id,
                                type = data.type,
                                season = video.season,
                                episode = video.number,
                                epid = null,
                                aniId = null,
                                animeId = null,
                                title = title,
                                year = video.released.split("-").firstOrNull()?.toIntOrNull(),
                                orgTitle = orgTitle,
                                isAnime = true,
                                airedYear = year,
                                lastSeason = null,
                                epsTitle = video.name,
                                jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title,
                                date = video.released,
                                airedDate = res.releaseDate ?: res.firstAirDate,
                                isAsian = isAsian,
                                isBollywood = isBollywood,
                                isCartoon = isCartoon,
                                alttitle = res.title,
                                nametitle = res.name
                            ).toJson()
                        ) {
                            this.name = video.name + if (isUpcoming(video.released)) " • [UPCOMING]" else ""
                            this.season = video.season
                            this.episode = video.number
                            this.posterUrl = video.thumbnail
                            this.score = Score.from10(video.rating)
                            this.description = video.description
                        }.apply {
                            this.addDate(video.released)
                        }
                    } ?: emptyList()

                return newAnimeLoadResponse(title, url, TvType.Anime) {
                    addEpisodes(DubStatus.Subbed, animeepisodes)
                    this.posterUrl = poster
                    this.backgroundPosterUrl = bgPoster
                    this.year = year
                    this.plot = res.overview
                    this.tags = keywords?.map { it.replaceFirstChar { it.titlecase() } }
                        ?.takeIf { it.isNotEmpty() } ?: genres
                    this.score = Score.from10(rating)
                    this.showStatus = getStatus(res.status)
                    this.recommendations = recommendations
                    this.actors = actors
                    addTrailer(trailer)
                    addTMDbId(data.id.toString())
                    addImdbId(res.external_ids?.imdb_id)
                }
            } else {
                return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                    this.posterUrl = poster
                    this.backgroundPosterUrl = bgPoster
                    this.year = year
                    this.plot = res.overview
                    this.tags = keywords?.map { word -> word.replaceFirstChar { it.titlecase() } }
                        ?.takeIf { it.isNotEmpty() } ?: genres
                    this.score = Score.from10(rating)
                    this.showStatus = getStatus(res.status)
                    this.recommendations = recommendations
                    this.actors = actors
                    addTrailer(trailer)
                    addTMDbId(data.id.toString())
                    addImdbId(res.external_ids?.imdb_id)
                }
            }
        } else {
            return newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LinkData(
                    data.id,
                    res.external_ids?.imdb_id,
                    res.external_ids?.tvdb_id,
                    data.type,
                    title = title,
                    year = year,
                    orgTitle = orgTitle,
                    isAnime = isAnime,
                    jpTitle = res.alternative_titles?.results?.find { it.iso_3166_1 == "JP" }?.title,
                    airedDate = res.releaseDate ?: res.firstAirDate,
                    isAsian = isAsian,
                    isBollywood = isBollywood,
                    alttitle = res.title,
                    nametitle = res.name
                ).toJson(),
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.comingSoon = isUpcoming(releaseDate)
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords?.map { word -> word.replaceFirstChar { it.titlecase() } }
                    ?.takeIf { it.isNotEmpty() } ?: genres
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US") ?: "Not Rated"
                addTrailer(trailer)
                addTMDbId(data.id.toString())
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }

    @SuppressLint("SuspiciousIndentation")
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        Log.d("Phisher",data.toJson())

        if (data.startsWith(febbox))
        {
            val fid=data.substringAfterLast("|")
            val postdata = mapOf(
                "fid" to fid,
                "share" to "",
                "imdb_id" to "",
                "quality" to ""
            )
            val source = app.post(url = "$febbox/console/player", data = postdata, headers = mapOf("cookie" to (token ?: ""))).text
            val regex = """\{"type":"([^"]+)","file":"([^"]+)","label":"([^"]+)"\}"""
            val pattern = Pattern.compile(regex)
            val matcher = pattern.matcher(source)
            while (matcher.find()) {
                val file = matcher.group(2)
                    ?.replace("\\/", "/")
                val label = matcher.group(3)
                if (file!=null)
                callback.invoke(
                    newExtractorLink(
                        "$name $label",
                        "$name $label",
                        file,
                        INFER_TYPE
                    )
                    {
                        this.quality= Qualities.P1080.value
                    }
                )
            }
        }
        else {
            val res = parseJson<LinkData>(data)
            runAllAsync(
                {
                    invokeSubtitleAPI(
                        res.imdbId,
                        res.season,
                        res.episode,
                        subtitleCallback,
                    )
                },
                {
                    if (res.imdbId!==null)
                    {
                        invokeSuperstream(
                            token,
                            res.imdbId,
                            res.season,
                            res.episode,
                            callback
                        )
                    }
                },
            )
        }
        return true
    }
    data class LinkData(
val id: Int? = null,
val imdbId: String? = null,
val tvdbId: Int? = null,
val type: String? = null,
val season: Int? = null,
val episode: Int? = null,
val epid: Int? = null,
val aniId: String? = null,
val animeId: String? = null,
val title: String? = null,
val year: Int? = null,
val orgTitle: String? = null,
val isAnime: Boolean = false,
val airedYear: Int? = null,
val lastSeason: Int? = null,
val epsTitle: String? = null,
val jpTitle: String? = null,
val date: String? = null,
val airedDate: String? = null,
val isAsian: Boolean = false,
val isBollywood: Boolean = false,
val isCartoon: Boolean = false,
val alttitle: String? = null,
val nametitle: String? = null
)

data class Data(
val id: Int? = null,
val type: String? = null,
val aniId: String? = null,
val malId: Int? = null,
)

    data class Results(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("media_type") val mediaType: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
        @JsonProperty("vote_average") val voteAverage: Double? = null,
    )

    data class Genres(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class Keywords(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
    )

    data class KeywordResults(
        @JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
    )

    data class Seasons(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
        @JsonProperty("air_date") val airDate: String? = null,
    )

    data class Cast(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("character") val character: String? = null,
        @JsonProperty("known_for_department") val knownForDepartment: String? = null,
        @JsonProperty("profile_path") val profilePath: String? = null,
    )

    data class Episodes(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("air_date") val airDate: String? = null,
        @JsonProperty("still_path") val stillPath: String? = null,
        @JsonProperty("vote_average") val voteAverage: Double? = null,
        @JsonProperty("episode_number") val episodeNumber: Int? = null,
        @JsonProperty("season_number") val seasonNumber: Int? = null,
    )

    data class MediaDetailEpisodes(
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
    )

    data class Trailers(
        @JsonProperty("key") val key: String? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class ResultsTrailer(
        @JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
    )

    data class AltTitles(
        @JsonProperty("iso_3166_1") val iso_3166_1: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class ResultsAltTitles(
        @JsonProperty("results") val results: ArrayList<AltTitles>? = arrayListOf(),
    )

    data class ExternalIds(
        @JsonProperty("imdb_id") val imdb_id: String? = null,
        @JsonProperty("tvdb_id") val tvdb_id: Int? = null,
    )

    data class Credits(
        @JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
    )

    data class ResultsRecommendations(
        @JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
    )

    data class LastEpisodeToAir(
        @JsonProperty("episode_number") val episode_number: Int? = null,
        @JsonProperty("season_number") val season_number: Int? = null,
    )

    data class ProductionCountries(
        @JsonProperty("name") val name: String? = null,
    )

    data class MediaDetail(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("original_title") val originalTitle: String? = null,
        @JsonProperty("original_name") val originalName: String? = null,
        @JsonProperty("poster_path") val posterPath: String? = null,
        @JsonProperty("backdrop_path") val backdropPath: String? = null,
        @JsonProperty("release_date") val releaseDate: String? = null,
        @JsonProperty("first_air_date") val firstAirDate: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("vote_average") val vote_average: Any? = null,
        @JsonProperty("original_language") val original_language: String? = null,
        @JsonProperty("status") val status: String? = null,
        @JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
        @JsonProperty("keywords") val keywords: KeywordResults? = null,
        @JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
        @JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
        @JsonProperty("videos") val videos: ResultsTrailer? = null,
        @JsonProperty("external_ids") val external_ids: ExternalIds? = null,
        @JsonProperty("credits") val credits: Credits? = null,
        @JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
        @JsonProperty("alternative_titles") val alternative_titles: ResultsAltTitles? = null,
        @JsonProperty("production_countries") val production_countries: ArrayList<ProductionCountries>? = arrayListOf(),
    )



    private fun getDate(): TmdbDate {
        val formatter = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
        val calender = Calendar.getInstance()
        val today = formatter.format(calender.time)
        calender.add(Calendar.WEEK_OF_YEAR, 1)
        val nextWeek = formatter.format(calender.time)
        return TmdbDate(today, nextWeek)
    }

    data class TmdbDate(
        val today: String,
        val nextWeek: String,
    )

    private fun isUpcoming(dateString: String?): Boolean {
        return try {
            val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
            val dateTime = dateString?.let { format.parse(it)?.time } ?: return false
            unixTimeMS < dateTime
        } catch (t: Throwable) {
            logError(t)
            false
        }
    }

}



================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/SuperStreamExtractor.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.amapIndexed
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.BuildConfig.SUPERSTREAM_FOURTH_API
import com.phisher98.BuildConfig.SUPERSTREAM_THIRD_API
import org.json.JSONArray
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import java.util.Locale

object SuperStreamExtractor : SuperStream() {

    suspend fun invokeSuperstream(
        token: String? = null,
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        callback: (ExtractorLink) -> Unit
    ) {
        val searchUrl = "$SUPERSTREAM_FOURTH_API/search?keyword=$imdbId"
        val href = app.get(searchUrl).documentLarge.selectFirst("h2.film-name a")?.attr("href")
            ?.let { SUPERSTREAM_FOURTH_API + it }
        val mediaId = href?.let {
            app.get(it).documentLarge.selectFirst("h2.heading-name a")?.attr("href")
                ?.substringAfterLast("/")?.toIntOrNull()
        }
        mediaId?.let {
            invokeExternalSource(it, if (season == null) 1 else 2, season, episode, callback, token)
        }
    }

    private suspend fun invokeExternalSource(
        mediaId: Int? = null,
        type: Int? = null,
        season: Int? = null,
        episode: Int? = null,
        callback: (ExtractorLink) -> Unit,
        token: String? = null
    ) {
        val thirdAPI = SUPERSTREAM_THIRD_API
        val fourthAPI = SUPERSTREAM_FOURTH_API
        val (seasonSlug, episodeSlug) = getEpisodeSlug(season, episode)
        val headers = mapOf("Accept-Language" to "en")
        val videoheaders = mapOf(
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.8",
            "Connection" to "keep-alive",
            "Range" to "bytes=0-",
            "Referer" to thirdAPI,
            "Sec-Fetch-Dest" to "video",
            "Sec-Fetch-Mode" to "no-cors",
            "Sec-Fetch-Site" to "cross-site",
            "Sec-Fetch-Storage-Access" to "none",
            "Sec-GPC" to "1",
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
            "sec-ch-ua" to "\"Not;A=Brand\";v=\"99\", \"Brave\";v=\"139\", \"Chromium\";v=\"139\"",
            "sec-ch-ua-mobile" to "?0",
            "sec-ch-ua-platform" to "\"Windows\""
        )

        val shareKey =
            app.get("$fourthAPI/index/share_link?id=${mediaId}&type=$type", headers = headers)
                .parsedSafe<ER>()?.data?.link?.substringAfterLast("/") ?: return

        val shareRes =
            app.get("$thirdAPI/file/file_share_list?share_key=$shareKey", headers = headers)
                .parsedSafe<ExternalResponse>()?.data ?: return
        val fids = if (season == null) {
            shareRes.fileList
        } else {
            shareRes.fileList?.find {
                it.fileName.equals(
                    "season $season",
                    true
                )
            }?.fid?.let { parentId ->
                app.get(
                    "$thirdAPI/file/file_share_list?share_key=$shareKey&parent_id=$parentId&page=1",
                    headers = headers
                )
                    .parsedSafe<ExternalResponse>()?.data?.fileList?.filter {
                        it.fileName?.contains("s${seasonSlug}e${episodeSlug}", true) == true
                    }
            }
        } ?: return

        fids.amapIndexed { index, fileList ->
            val superToken = token?.let {
                if (it.startsWith("ui=")) it else "ui=$it"
            } ?: ""
            val player = app.get(
                "$thirdAPI/console/video_quality_list?fid=${fileList.fid}&share_key=$shareKey",
                headers = mapOf("Cookie" to superToken)
            ).text
            val json = try {
                JSONObject(player)
            } catch (e: Exception) {
                Log.e("Error:", "Invalid JSON response $e")
                return@amapIndexed
            }
            val htmlContent = json.optString("html", "")
            if (htmlContent.isEmpty()) return@amapIndexed

            val document: Document = Jsoup.parse(htmlContent)
            val sourcesWithQualities = mutableListOf<Triple<String, String, String>>() // url, quality, size

            document.select("div.file_quality").forEach { element ->
                val url = element.attr("data-url").takeIf { it.isNotEmpty() } ?: return@forEach
                val qualityAttr = element.attr("data-quality").takeIf { it.isNotEmpty() }
                val size = element.selectFirst(".size")?.text()?.takeIf { it.isNotEmpty() } ?: return@forEach

                val quality = if (qualityAttr.equals("ORG", ignoreCase = true)) {
                    Regex("""(\d{3,4}p)""", RegexOption.IGNORE_CASE).find(url)?.groupValues?.get(1) ?: "2160p"
                } else {
                    qualityAttr ?: return@forEach
                }

                sourcesWithQualities.add(Triple(url, quality, size))
            }

            val sourcesJsonArray = JSONArray().apply {
                sourcesWithQualities.forEach { (url, quality, size) ->
                    put(JSONObject().apply {
                        put("file", url)
                        put("label", quality)
                        put("type", "video/mp4")
                        put("size", size)
                    })
                }
            }
            val jsonObject = JSONObject().put("sources", sourcesJsonArray)
            listOf(jsonObject.toString()).forEach {
                val parsedSources =
                    tryParseJson<ExternalSourcesWrapper>(it)?.sources ?: return@forEach
                parsedSources.forEach org@{ source ->
                    val format =
                        if (source.type == "video/mp4") ExtractorLinkType.VIDEO else ExtractorLinkType.M3U8
                    if (!(source.label == "AUTO" || format == ExtractorLinkType.VIDEO)) return@org
                    callback.invoke(
                        newExtractorLink(
                            "⌜ SuperStream ⌟",
                            "⌜ SuperStream ⌟ [Server ${index + 1}] ${source.size}",
                            source.file?.replace("\\/", "/") ?: return@org,
                            format
                        )
                        {
                            this.quality = getIndexQuality(if (format == ExtractorLinkType.M3U8) fileList.fileName else source.label)
                            this.headers = videoheaders
                        }
                    )
                }
            }
        }
    }

    suspend fun invokeSubtitleAPI(
        id: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val url = if (season == null) {
            "https://opensubtitles-v3.strem.io/subtitles/movie/$id.json"
        } else {
            "https://opensubtitles-v3.strem.io/subtitles/series/$id:$season:$episode.json"
        }
        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )
        app.get(url, headers = headers, timeout = 100L)
            .parsedSafe<SubtitlesAPI>()?.subtitles?.amap {
                val lan = getLanguage(it.lang) ?: "Unknown"
                val suburl = it.url
                subtitleCallback.invoke(
                    newSubtitleFile(
                        lan.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },  // Use label for the name
                        suburl     // Use extracted URL
                    )
                )
            }
    }


    suspend fun invokeWyZIESUBAPI(
        id: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val WyZIESUBAPI = "https://sub.wyzie.ru"
        val url = if (season == null) {
            "$WyZIESUBAPI/search?id=$id"
        } else {
            "$WyZIESUBAPI/search?id=$id&season=$season&episode=$episode"
        }

        val res = app.get(url).toString()
        val gson = Gson()
        val listType = object : TypeToken<List<WyZIESUB>>() {}.type
        val subtitles: List<WyZIESUB> = gson.fromJson(res, listType)
        subtitles.map {
            val lan = it.display
            val suburl = it.url
            subtitleCallback.invoke(
                newSubtitleFile(
                    lan.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },  // Use label for the name
                    suburl     // Use extracted URL
                )
            )
        }
    }
}



================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/SuperStreamParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty

//SuperStream

data class ER(
    @JsonProperty("code") val code: Int? = null,
    @JsonProperty("msg") val msg: String? = null,
    @JsonProperty("server_runtime") val serverRuntime: Double? = null,
    @JsonProperty("server_name") val serverName: String? = null,
    @JsonProperty("data") val data: DData? = null,
)

data class DData(
    @JsonProperty("link") val link: String? = null,
    @JsonProperty("file_list") val fileList: List<FileList>? = null,
)

data class FileList(
    @JsonProperty("fid") val fid: Long? = null,
    @JsonProperty("file_name") val fileName: String? = null,
    @JsonProperty("oss_fid") val ossFid: Long? = null,
)

data class ExternalResponse(
    @JsonProperty("code") val code: Int? = null,
    @JsonProperty("msg") val msg: String? = null,
    @JsonProperty("server_runtime") val serverRuntime: Double? = null,
    @JsonProperty("server_name") val serverName: String? = null,
    @JsonProperty("data") val data: Data? = null,
) {
    data class Data(
        @JsonProperty("link") val link: String? = null,
        @JsonProperty("file_list") val fileList: List<FileList>? = null,
    ) {
        data class FileList(
            @JsonProperty("fid") val fid: Long? = null,
            @JsonProperty("file_name") val fileName: String? = null,
            @JsonProperty("oss_fid") val ossFid: Long? = null,
        )
    }
}

data class ExternalSourcesWrapper(
    @JsonProperty("sources") val sources: List<ExternalSources>? = null
)

data class ExternalSources(
    @JsonProperty("source") val source: String? = null,
    @JsonProperty("file") val file: String? = null,
    @JsonProperty("label") val label: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("size") val size: String? = null,
)


data class SubtitlesAPI(
    val subtitles: List<Subtitle>,
    val cacheMaxAge: Long,
)

data class Subtitle(
    val id: String,
    val url: String,
    @JsonProperty("SubEncoding")
    val subEncoding: String,
    val lang: String,
    val m: String,
    val g: String,
)

data class WyZIESUB(
    val id: String,
    val url: String,
    val flagUrl: String,
    val format: String,
    val display: String,
    val language: String,
    val media: String,
    val isHearingImpaired: Boolean,
)

data class PersonalComments(
    val code: Int,
    val file: FileData?,
    val html2: String?,
    val id: String?
)

data class FileData(
    val fid: Long,
    val uid: Long,
    val file_size: String?,
    val path: String?,
    val file_name: String,
    val ext: String?,
    val add_time: String?,
    val file_create_time: Long?,
    val file_update_time: Long?,
    val parent_id: Long?,
    val update_time: String?,
    val last_open_time: String?,
    val is_dir: Int?,
    val epub: Int?,
    val is_music_list: Int?,
    val oss_fid: Long?,
    val faststart: Int?,
    val has_video_quality: Int?,
    val total_download: Int?,
    val status: Int?,
    val remark: String?,
    val old_hash: String?,
    val hash: String?,
    val hash_type: String?,
    val from_uid: Long?,
    val fid_org: Long?,
    val share_id: Long?,
    val invite_permission: Int?,
    val comment_table: String?,
    val is_delete: Int?,
    val thumb_small: String?,
    val thumb_small_width: Int?,
    val thumb_small_height: Int?,
    val thumb: String?,
    val thumb_width: Int?,
    val thumb_height: Int?,
    val thumb_big: String?,
    val thumb_big_width: Int?,
    val thumb_big_height: Int?,
    val is_custom_thumb: Int?,
    val fix_thumb: Int?,
    val ffmpeg_ing: Int?,
    val quality: String?,
    val runtime: Int?,
    val ffmpeg_info: String?,
    val attribute: String?,
    val data: String?,
    val ffmpeg_status: Int?,
    val allow_delete: Int?,
    val allow_download: Int?,
    val allow_comment: Int?,
    val hide_location: Int?,
    val hide_email: Int?,
    val allow_copy: Int?,
    val error_video: Int?,
    val third_data: String?,
    val photos: Int?,
    val is_album: Int?,
    val is_cloud_sync_dir: Int?,
    val ai_tags: String?,
    val maybe_tags: String?,
    val ai_tag_last_time: Long?,
    val user_tags: String?,
    val is_collect: Int?,
    val sub_fid: Long?,
    val read_only: Int?,
    val is_shared: Int?,
    val bind_imdb_id: String?,
    val top_is_shared: Int?,
    val type: String?,
    val update_time2: String?,
    val file_icon: String?,
    val param2: String?
)


//html

data class HTML(
    val code: Long,
    val html: String,
    @JsonProperty("path_html")
    val pathHtml: String,
    @JsonProperty("path_html2")
    val pathHtml2: String,
    @JsonProperty("file_name")
    val fileName: String,
    val starttime: Double,
    val starttime2: Double,
    val endtime: Double,
)


//CinemetaRes

data class CinemetaRes(
    val meta: Meta
) {
    data class Meta(
        val awards: String,
        val background: String,
        val behaviorHints: BehaviorHints,
        val cast: List<String>,
        val country: String,
        val description: String,
        val director: Any,
        val dvdRelease: Any,
        val genre: List<String>,
        val genres: List<String>,
        val id: String,
        val imdbRating: String,
        val imdb_id: String,
        val links: List<Link>,
        val logo: String,
        val moviedb_id: Int,
        val name: String,
        val popularities: Popularities,
        val popularity: Double,
        val poster: String,
        val releaseInfo: String,
        val released: String,
        val runtime: String,
        val slug: String,
        val status: String,
        val trailerStreams: List<TrailerStream>,
        val trailers: List<Trailer>,
        val tvdb_id: String,
        val type: String,
        val videos: List<Video>,
        val writer: Any,
        val year: String
    ) {
        data class BehaviorHints(
            val defaultVideoId: Any,
            val hasScheduledVideos: Boolean
        )

        data class Link(
            val category: String,
            val name: String,
            val url: String
        )

        data class Popularities(
            val ALLIANCE: Int,
            val EJD: Int,
            val EXMD: Int,
            val PXS_TEST: Int,
            val moviedb: Double,
            val stremio: Double,
            val stremio_lib: Int,
            val trakt: Int
        )

        data class TrailerStream(
            val title: String,
            val ytId: String
        )

        data class Trailer(
            val source: String,
            val type: String
        )

        data class Video(
            val episode: Int,
            val firstAired: String,
            val id: String,
            val name: String,
            val number: Int,
            val rating: String,
            val released: String,
            val season: Int,
            val thumbnail: String,
            val tvdb_id: Int,
            val description: String
        )
    }
}


================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/SuperStreamPlugin.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.phisher98.settings.SettingsFragment
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin

@CloudstreamPlugin
class SuperStreamPlugin: Plugin() {
    override fun load(context: Context) {
        val sharedPref = context.getSharedPreferences("SuperStream", Context.MODE_PRIVATE)
        registerMainAPI(SuperStream(sharedPref))

        openSettings = { ctx ->
            val activity = ctx as AppCompatActivity
            val frag = SettingsFragment(this, sharedPref)
            frag.show(activity.supportFragmentManager, "Frag")
        }
    }
}


================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/SuperStreamUtils.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.utils.Qualities

fun getLanguage(language: String?): String? {
    language ?: return null
    val normalizedLang = language.substringBefore("-")
    return languageMap.entries.find { it.value.first == normalizedLang || it.value.second == normalizedLang }?.key
}

private val languageMap = mapOf(
    "Afrikaans" to Pair("af", "afr"),
    "Albanian" to Pair("sq", "sqi"),
    "Amharic" to Pair("am", "amh"),
    "Arabic" to Pair("ar", "ara"),
    "Armenian" to Pair("hy", "hye"),
    "Azerbaijani" to Pair("az", "aze"),
    "Basque" to Pair("eu", "eus"),
    "Belarusian" to Pair("be", "bel"),
    "Bengali" to Pair("bn", "ben"),
    "Bosnian" to Pair("bs", "bos"),
    "Bulgarian" to Pair("bg", "bul"),
    "Catalan" to Pair("ca", "cat"),
    "Chinese" to Pair("zh", "zho"),
    "Croatian" to Pair("hr", "hrv"),
    "Czech" to Pair("cs", "ces"),
    "Danish" to Pair("da", "dan"),
    "Dutch" to Pair("nl", "nld"),
    "English" to Pair("en", "eng"),
    "Estonian" to Pair("et", "est"),
    "Filipino" to Pair("tl", "tgl"),
    "Finnish" to Pair("fi", "fin"),
    "French" to Pair("fr", "fra"),
    "Galician" to Pair("gl", "glg"),
    "Georgian" to Pair("ka", "kat"),
    "German" to Pair("de", "deu"),
    "Greek" to Pair("el", "ell"),
    "Gujarati" to Pair("gu", "guj"),
    "Hebrew" to Pair("he", "heb"),
    "Hindi" to Pair("hi", "hin"),
    "Hungarian" to Pair("hu", "hun"),
    "Icelandic" to Pair("is", "isl"),
    "Indonesian" to Pair("id", "ind"),
    "Italian" to Pair("it", "ita"),
    "Japanese" to Pair("ja", "jpn"),
    "Kannada" to Pair("kn", "kan"),
    "Kazakh" to Pair("kk", "kaz"),
    "Korean" to Pair("ko", "kor"),
    "Latvian" to Pair("lv", "lav"),
    "Lithuanian" to Pair("lt", "lit"),
    "Macedonian" to Pair("mk", "mkd"),
    "Malay" to Pair("ms", "msa"),
    "Malayalam" to Pair("ml", "mal"),
    "Maltese" to Pair("mt", "mlt"),
    "Marathi" to Pair("mr", "mar"),
    "Mongolian" to Pair("mn", "mon"),
    "Nepali" to Pair("ne", "nep"),
    "Norwegian" to Pair("no", "nor"),
    "Persian" to Pair("fa", "fas"),
    "Polish" to Pair("pl", "pol"),
    "Portuguese" to Pair("pt", "por"),
    "Punjabi" to Pair("pa", "pan"),
    "Romanian" to Pair("ro", "ron"),
    "Russian" to Pair("ru", "rus"),
    "Serbian" to Pair("sr", "srp"),
    "Sinhala" to Pair("si", "sin"),
    "Slovak" to Pair("sk", "slk"),
    "Slovenian" to Pair("sl", "slv"),
    "Spanish" to Pair("es", "spa"),
    "Swahili" to Pair("sw", "swa"),
    "Swedish" to Pair("sv", "swe"),
    "Tamil" to Pair("ta", "tam"),
    "Telugu" to Pair("te", "tel"),
    "Thai" to Pair("th", "tha"),
    "Turkish" to Pair("tr", "tur"),
    "Ukrainian" to Pair("uk", "ukr"),
    "Urdu" to Pair("ur", "urd"),
    "Uzbek" to Pair("uz", "uzb"),
    "Vietnamese" to Pair("vi", "vie"),
    "Welsh" to Pair("cy", "cym"),
    "Yiddish" to Pair("yi", "yid")
)


fun getEpisodeSlug(
    season: Int? = null,
    episode: Int? = null,
): Pair<String, String> {
    return if (season == null && episode == null) {
        "" to ""
    } else {
        (if (season!! < 10) "0$season" else "$season") to (if (episode!! < 10) "0$episode" else "$episode")
    }
}

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
        ?: Qualities.Unknown.value
}

fun String?.createSlug(): String? {
    return this?.filter { it.isWhitespace() || it.isLetterOrDigit() }
        ?.trim()
        ?.replace("\\s+".toRegex(), "-")
        ?.lowercase()
}


//Catflix

fun CathexToBinary(hex: String): String {
    val binary = StringBuilder()
    for (i in hex.indices step 2) {
        val hexPair = hex.substring(i, i + 2)
        val charValue = hexPair.toInt(16).toChar()
        binary.append(charValue)
    }
    return binary.toString()
}

fun CatxorDecrypt(binary: String, key: String): String {
    val decrypted = StringBuilder()
    val keyLength = key.length

    for (i in binary.indices) {
        val decryptedChar = binary[i].code xor key[i % keyLength].code
        decrypted.append(decryptedChar.toChar())
    }

    return decrypted.toString()
}

fun CatdecryptHexWithKey(hex: String, key: String): String {
    val binary = CathexToBinary(hex)
    return CatxorDecrypt(binary, key)
}



================================================
FILE: SuperStream/src/main/kotlin/com/phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.*
import android.widget.Button
import android.widget.EditText
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.cloudstream3.utils.AppContextUtils.setDefaultFocus
import com.phisher98.SuperStreamPlugin
import androidx.core.content.edit

class SettingsFragment(
    plugin: SuperStreamPlugin,
    private val sharedPref: SharedPreferences,
) : BottomSheetDialogFragment() {
    private val res = plugin.resources ?: throw Exception("Unable to read resources")

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?,
    ): View? {
        val id = res.getIdentifier("settings_fragment", "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    override fun onStart() {
        super.onStart()
        (dialog as? BottomSheetDialog)?.behavior?.apply {
            state = BottomSheetBehavior.STATE_EXPANDED
            skipCollapsed = true
            isDraggable = false // optional: prevent dragging at all
        }
    }


    @SuppressLint("SetJavaScriptEnabled", "SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val tokenInput = view.findView<EditText>("tokenInput")
        val addButton = view.findView<Button>("addButton")
        val resetButton = view.findView<Button>("resetButton")
        val loginButton = view.findView<Button>("loginButton")
        val webView = view.findView<WebView>("authWebView")
        val savedToken = sharedPref.getString("token", null)
        if (!savedToken.isNullOrEmpty()) {
            tokenInput.setText(savedToken)
        }

        setupWebView(webView)

        loginButton.setOnClickListener {
            webView.visibility = View.VISIBLE
            webView.loadUrl("https://www.febbox.com/login/google?jump=%2F")
        }

        addButton.setOnClickListener {
            val token = tokenInput.text.toString().trim()
            if (token.isNotEmpty()) {
                val finalToken = if (token.startsWith("ui=")) token else "ui=$token"

                sharedPref.edit { putString("token", finalToken) }

                val ctx = context ?: run {
                    showToast("Error: Context is null")
                    return@setOnClickListener
                }

                AlertDialog.Builder(ctx)
                    .setTitle("Save & Reload")
                    .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                    .setPositiveButton("Yes") { _, _ ->
                        dismiss()
                        restartApp()
                    }
                    .setNegativeButton("No") { _, _ ->
                        dismiss()
                    }
                    .show()
            } else {
                showToast("Please enter a valid token")
            }
        }

        resetButton.setOnClickListener {
            sharedPref.edit()?.apply {
                remove("token")
                apply()
            }
            tokenInput.setText("ui=")
            showToast("Token reset successfully. Restart the app.")
            dismiss()
        }
    }

    @SuppressLint("SetJavaScriptEnabled")
    private fun setupWebView(webView: WebView) {
        webView.settings.javaScriptEnabled = true
        webView.settings.domStorageEnabled = true
        webView.settings.userAgentString =
            "Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36"

        CookieManager.getInstance().setAcceptThirdPartyCookies(webView, true)

        webView.webViewClient = object : WebViewClient() {
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)

                // Resize WebView to content height
                view?.evaluateJavascript(
                    "(function() { return document.body.scrollHeight; })();"
                ) { value ->
                    val height = value.replace("\"", "").toFloatOrNull()
                    if (height != null) {
                        val density = resources.displayMetrics.density
                        val layoutParams = view.layoutParams
                        layoutParams.height = (height * density).toInt()
                        view.layoutParams = layoutParams
                    }
                }

                // Existing token scraping logic
                val cookieManager = CookieManager.getInstance()
                val cookies = cookieManager.getCookie(url ?: "")

                val token = cookies?.split(";")
                    ?.map { it.trim() }
                    ?.find { it.startsWith("ui=") }
                    ?.removePrefix("ui=")

                if (!token.isNullOrEmpty() && view != null) {
                    val finalToken = "ui=$token"

                    activity?.runOnUiThread {
                        val tokenInput = requireView().findViewById<EditText>(
                            res.getIdentifier("tokenInput", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
                        )
                        tokenInput.setText(finalToken)

                        sharedPref.edit()?.apply {
                            putString("token", finalToken)
                            apply()
                        }

                        showToast("Login successful!")
                        webView.visibility = View.GONE
                    }
                }
            }
        }
    }

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: SuperStream/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: SuperStream/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: SuperStream/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: SuperStream/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: SuperStream/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: SuperStream/src/main/res/layout/settings_fragment.xml
================================================
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:padding="16dp"
    tools:context=".settings.SettingsFragment">

    <ImageView
        android:id="@+id/settingsIcon"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@android:drawable/ic_menu_preferences"
        android:layout_alignParentEnd="true"
        android:contentDescription="Settings"
        android:padding="8dp"
        android:background="?android:attr/selectableItemBackgroundBorderless"
        android:layout_marginBottom="8dp" />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/settingsIcon"
        android:layout_marginTop="8dp">

        <LinearLayout
            android:id="@+id/settings_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="24dp"
            tools:ignore="WebViewLayout">

            <!-- Card 1: Google Login -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:text="Login Options"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Enable Google login to access SuperStream 4K content."
                        android:textSize="14sp"
                        android:textColor="#AAAAAA"
                        android:layout_marginTop="4dp"
                        android:layout_marginBottom="8dp" />

                    <Button
                        android:id="@+id/loginButton"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Login with Google"
                        android:backgroundTint="#4285F4"
                        android:textColor="#FFFFFF" />
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <!-- Card 2: Token Settings -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:layout_marginStart="4dp"
                        android:text="Token Management"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />
                    <!-- WebView (Hidden) -->
                    <WebView
                        android:id="@+id/authWebView"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:visibility="gone"
                        android:background="#FFFFFF"
                        android:layout_marginTop="16dp"
                        android:layout_marginBottom="8dp"
                        android:scrollbars="none" />


                    <EditText
                        android:id="@+id/tokenInput"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Paste Token or use Login"
                        android:textColorHint="#AAAAAA"
                        android:textColor="#FFFFFF"
                        android:inputType="text"
                        android:padding="12dp"
                        android:textSize="16sp"
                        android:layout_marginTop="8dp" />

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:layout_marginTop="8dp">

                        <Button
                            android:id="@+id/addButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Save Token"
                            android:backgroundTint="#6200EE"
                            android:textColor="#FFFFFF" />

                        <Space
                            android:layout_width="8dp"
                            android:layout_height="wrap_content" />

                        <Button
                            android:id="@+id/resetButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Reset"
                            android:backgroundTint="#D32F2F"
                            android:textColor="#FFFFFF" />
                    </LinearLayout>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>
        </LinearLayout>
    </ScrollView>
</RelativeLayout>


================================================
FILE: SuperStream/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="header_tw">Login</string>
    <string name="text_hint">Token</string>
    <string name="Text_Token">Get Token from Febbox</string>
    <string name="insert_token">Insert Token</string>
    <string name="save_token">Save Token</string>
    <string name="reset_token">Reset Token</string>
</resources>


================================================
FILE: SuperstreamBeta/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 8

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "SUPERSTREAM_FIRST_API", "\"${properties.getProperty("SUPERSTREAM_FIRST_API")}\"")
        buildConfigField("String", "SUPERSTREAM_SECOND_API", "\"${properties.getProperty("SUPERSTREAM_SECOND_API")}\"")
        buildConfigField("String", "SUPERSTREAM_THIRD_API", "\"${properties.getProperty("SUPERSTREAM_THIRD_API")}\"")
        buildConfigField("String", "SUPERSTREAM_FOURTH_API", "\"${properties.getProperty("SUPERSTREAM_FOURTH_API")}\"")
        buildConfigField("String", "SuperToken", "\"${properties.getProperty("SuperToken")}\"")

    }
}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    implementation("com.google.android.material:material:1.13.0")
    implementation("androidx.leanback:leanback:1.2.0")
    cloudstream("com.lagradost:cloudstream3:pre-release")
}

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them
    description = "SuperStream Beta (Retrieve the cookie using Login with Google to properly utilize SuperStream."

    // description = "Lorem Ipsum"
    authors = listOf("Phisher98")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "Anime",
        "TvSeries",
        "Movie",
    )
    requiresResources = true
    isCrossPlatform = false

    iconUrl = "https://t2.gstatic.com/faviconV2?client=SOCIAL&type=FAVICON&fallback_opts=TYPE,SIZE,URL&url=https://www.showbox.media/&size=256"
}



================================================
FILE: SuperstreamBeta/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: SuperstreamBeta/src/main/kotlin/com/phisher98/Extractors.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document


object SuperStreamExtractor : Superstream() {

    suspend fun invokeInternalSource(
        id: Int? = null,
        type: Int? = null,
        season: Int? = null,
        episode: Int? = null,
        superToken: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ) {

        val videoheaders = mapOf(
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.8",
            "Connection" to "keep-alive",
            "Range" to "bytes=0-",
            "Referer" to thirdAPI,
            "Sec-Fetch-Dest" to "video",
            "Sec-Fetch-Mode" to "no-cors",
            "Sec-Fetch-Site" to "cross-site",
            "Sec-Fetch-Storage-Access" to "none",
            "Sec-GPC" to "1",
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
            "sec-ch-ua" to "\"Not;A=Brand\";v=\"99\", \"Brave\";v=\"139\", \"Chromium\";v=\"139\"",
            "sec-ch-ua-mobile" to "?0",
            "sec-ch-ua-platform" to "\"Windows\""
        )
        suspend fun LinkList.toExtractorLink(): ExtractorLink? {
            val quality = this.quality
            if (this.path.isNullOrBlank()) return null
            return newExtractorLink(
                "⌜ SuperStream ⌟ Internal",
                "⌜ SuperStream ⌟ Internal [${this.size}]",
                this.path.replace("\\/", ""),
                INFER_TYPE,
            )
            {
                this.quality = getQualityFromName(quality)
                this.headers=videoheaders
            }
        }
        val query = if (type == ResponseTypes.Movies.value) {
            """{"childmode":"0","uid":"","app_version":"11.5","appid":"$appId","module":"Movie_downloadurl_v3","channel":"Website","mid":"$id","lang":"","expired_date":"${getExpiryDate()}","platform":"android","oss":"1","uid":"$superToken","open_udid":"59e139fd173d9045a2b5fc13b40dfd87","group":""}"""
        } else {
            """{"childmode":"0","app_version":"11.5","module":"TV_downloadurl_v3","channel":"Website","episode":"$episode","expired_date":"${getExpiryDate()}","platform":"android","tid":"$id","oss":"1","uid":"$superToken","open_udid":"59e139fd173d9045a2b5fc13b40dfd87","appid":"$appId","season":"$season","lang":"en","group":""}"""
        }

        val linkData = queryApiParsed<LinkDataProp>(query)

        linkData.data?.list?.forEach { link ->
            val extractorLink = link.toExtractorLink() ?: return@forEach
            callback.invoke(extractorLink)
        }

        val fid = linkData.data?.list?.firstOrNull { it.fid != null }?.fid

        val subtitleQuery = if (type == ResponseTypes.Movies.value) {
            """{"childmode":"0","fid":"$fid","uid":"","app_version":"11.5","appid":"$appId","module":"Movie_srt_list_v2","channel":"Website","mid":"$id","lang":"en","uid":"$superToken","open_udid":"59e139fd173d9045a2b5fc13b40dfd87","expired_date":"${getExpiryDate()}","platform":"android"}"""
        } else {
            """{"childmode":"0","fid":"$fid","app_version":"11.5","module":"TV_srt_list_v2","channel":"Website","episode":"$episode","expired_date":"${getExpiryDate()}","platform":"android","tid":"$id","uid":"$superToken","open_udid":"59e139fd173d9045a2b5fc13b40dfd87","appid":"$appId","season":"$season","lang":"en"}"""
        }

        val subtitles = queryApiParsed<SubtitleDataProp>(subtitleQuery).data
        subtitles?.list?.forEach { subs ->
            val sub = subs.subtitles.maxByOrNull { it.support_total ?: 0 }
            subtitleCallback.invoke(
                newSubtitleFile(
                    sub?.language ?: sub?.lang ?: return@forEach,
                    sub?.filePath ?: return@forEach
                )
            )
        }
    }


    suspend fun invokeExternalSource(
        mediaId: Int? = null,
        type: Int? = null,
        season: Int? = null,
        episode: Int? = null,
        uitoken: String?,
        callback: (ExtractorLink) -> Unit,
    ) {
        val videoheaders = mapOf(
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.8",
            "Connection" to "keep-alive",
            "Range" to "bytes=0-",
            "Referer" to thirdAPI,
            "Sec-Fetch-Dest" to "video",
            "Sec-Fetch-Mode" to "no-cors",
            "Sec-Fetch-Site" to "cross-site",
            "Sec-Fetch-Storage-Access" to "none",
            "Sec-GPC" to "1",
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36",
            "sec-ch-ua" to "\"Not;A=Brand\";v=\"99\", \"Brave\";v=\"139\", \"Chromium\";v=\"139\"",
            "sec-ch-ua-mobile" to "?0",
            "sec-ch-ua-platform" to "\"Windows\""
        )
        val (seasonSlug, episodeSlug) = getEpisodeSlug(season, episode)
        val shareKey = app.get("$thirdAPI/mbp/to_share_page?box_type=${type}&mid=$mediaId&json=1")
            .parsedSafe<ExternalResponse>()?.data?.link
            ?: app.get("$thirdAPI/mbp/to_share_page?box_type=${type}&mid=$mediaId&json=1")
                .parsedSafe<ExternalResponse>()?.data?.shareLink
                ?.substringAfterLast("/") ?: return
        val headers = mapOf("Accept-Language" to "en")
        val shareRes =
            app.get("$thirdAPI/file/file_share_list?share_key=$shareKey", headers = headers)
                .parsedSafe<ExternalResponse>()?.data ?: return

        val fids = if (season == null) {
            shareRes.file_list
        } else {
            val parentId =
                shareRes.file_list?.find { it.file_name.equals("season $season", true) }?.fid
            app.get(
                "$thirdAPI/file/file_share_list?share_key=$shareKey&parent_id=$parentId&page=1",
                headers = headers
            )
                .parsedSafe<ExternalResponse>()?.data?.file_list?.filter {
                    it.file_name?.contains("s${seasonSlug}e${episodeSlug}", true) == true
                }
        } ?: return

        fids.amapIndexed { index, fileList ->
            val superToken = uitoken?.let {
                if (it.startsWith("ui=")) it else "ui=$it"
            } ?: ""
            val player = app.get(
                "$thirdAPI/console/video_quality_list?fid=${fileList.fid}&share_key=$shareKey",
                headers = mapOf("Cookie" to superToken)
            ).text
            val json = try {
                JSONObject(player)
            } catch (e: Exception) {
                Log.e("Error:", "Invalid JSON response $e")
                return@amapIndexed
            }
            val htmlContent = json.optString("html", "")
            if (htmlContent.isEmpty()) return@amapIndexed

            val document: Document = Jsoup.parse(htmlContent)
            val sourcesWithQualities =
                mutableListOf<Triple<String, String, String>>() // url, quality, size

            document.select("div.file_quality").forEach { element ->
                val url = element.attr("data-url").takeIf { it.isNotEmpty() } ?: return@forEach
                val qualityAttr = element.attr("data-quality").takeIf { it.isNotEmpty() }
                val size = element.selectFirst(".size")?.text()?.takeIf { it.isNotEmpty() }
                    ?: return@forEach

                val quality = if (qualityAttr.equals("ORG", ignoreCase = true)) {
                    Regex("""(\d{3,4}p)""", RegexOption.IGNORE_CASE).find(url)?.groupValues?.get(1)
                        ?: "2160p"
                } else {
                    qualityAttr ?: return@forEach
                }

                sourcesWithQualities.add(Triple(url, quality, size))
            }

            val sourcesJsonArray = JSONArray().apply {
                sourcesWithQualities.forEach { (url, quality, size) ->
                    put(JSONObject().apply {
                        put("file", url)
                        put("label", quality)
                        put("type", "video/mp4")
                        put("size", size)
                    })
                }
            }
            val jsonObject = JSONObject().put("sources", sourcesJsonArray)
            listOf(jsonObject.toString()).forEach {
                val parsedSources =
                    tryParseJson<ExternalSourcesWrapper>(it)?.sources ?: return@forEach
                parsedSources.forEach org@{ source ->
                    val format =
                        if (source.type == "video/mp4") ExtractorLinkType.VIDEO else ExtractorLinkType.M3U8
                    if (!(source.label == "AUTO" || format == ExtractorLinkType.VIDEO)) return@org
                    callback.invoke(
                        newExtractorLink(
                            "⌜ SuperStream ⌟ External",
                            "⌜ SuperStream ⌟ External [Server ${index + 1}] ${source.size}",
                            source.file?.replace("\\/", "/") ?: return@org,
                            INFER_TYPE
                        )
                        {
                            this.headers=videoheaders
                            this.quality=getIndexQuality(if (format == ExtractorLinkType.M3U8) fileList.file_name else source.label)
                        }
                    )
                }
            }
        }
    }

    suspend fun invokeExternalM3u8Source(
        mediaId: Int? = null,
        type: Int? = null,
        season: Int? = null,
        episode: Int? = null,
        uitoken: String?,
        callback: (ExtractorLink) -> Unit,
    ) {

        val (seasonSlug, episodeSlug) = getEpisodeSlug(season, episode)
        val shareKey = app.get("$thirdAPI/mbp/to_share_page?box_type=${type}&mid=$mediaId&json=1")
            .parsedSafe<ExternalResponse>()?.data?.link
            ?: app.get("$thirdAPI/mbp/to_share_page?box_type=${type}&mid=$mediaId&json=1")
                .parsedSafe<ExternalResponse>()?.data?.shareLink
                ?.substringAfterLast("/") ?: return
        val headers = mapOf("Accept-Language" to "en")
        val shareRes =
            app.get("$thirdAPI/file/file_share_list?share_key=$shareKey", headers = headers)
                .parsedSafe<ExternalResponse>()?.data ?: return

        val fids = if (season == null) {
            shareRes.file_list
        } else {
            val parentId =
                shareRes.file_list?.find { it.file_name.equals("season $season", true) }?.fid
            app.get(
                "$thirdAPI/file/file_share_list?share_key=$shareKey&parent_id=$parentId&page=1",
                headers = headers
            )
                .parsedSafe<ExternalResponse>()?.data?.file_list?.filter {
                    it.file_name?.contains("s${seasonSlug}e${episodeSlug}", true) == true
                }
        } ?: return

        fids.amapIndexed { index, fileList ->
            val superToken = uitoken?.let {
                if (it.startsWith("ui=")) it else "ui=$it"
            } ?: ""
            val mediaType = "application/x-www-form-urlencoded; charset=UTF-8".toMediaType()
            val body = """fid=${fileList.fid}&share_key=$shareKey""".trimIndent().toRequestBody(mediaType)
            val player = app.post(
                "$thirdAPI/file/player",
                requestBody = body,
                headers = mapOf(
                    "Cookie" to superToken,
                    "content-type" to "application/x-www-form-urlencoded; charset=UTF-8"
                )
            ).text

            val document = Jsoup.parse(player)

            val scriptText = document.select("script")
                .map { it.data() }
                .firstOrNull { it.contains("var sources") }
                ?: return@amapIndexed

            val sourcesJson = Regex("""var\s+sources\s*=\s*(\[[\s\S]*?]);""")
                .find(scriptText)
                ?.groupValues
                ?.get(1)
                ?: return@amapIndexed
            val urls = mutableListOf<String>()

            val jsonArray = org.json.JSONArray(sourcesJson)
            for (i in 0 until jsonArray.length()) {
                val obj = jsonArray.getJSONObject(i)
                val fileUrl = obj.optString("file")
                if (fileUrl.isNotEmpty()) {
                    urls.add(fileUrl)
                }
            }
            /*
            urls.forEach {
                M3u8Helper.generateM3u8(
                    "⌜ SuperStream ⌟ External HLS [Server ${index + 1}]",
                    it,
                    ""
                ).forEach(callback)
            }
            */
        }
    }

    suspend fun invokeWatchsomuch(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val id = imdbId?.removePrefix("tt")
        val epsId = app.post(
            "$watchSomuchAPI/Watch/ajMovieTorrents.aspx",
            data = mapOf(
                "index" to "0",
                "mid" to "$id",
                "wsk" to "30fb68aa-1c71-4b8c-b5d4-4ca9222cfb45",
                "lid" to "",
                "liu" to ""
            ), headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).parsedSafe<WatchsomuchResponses>()?.movie?.torrents?.let { eps ->
            if (season == null) {
                eps.firstOrNull()?.id
            } else {
                eps.find { it.episode == episode && it.season == season }?.id
            }
        } ?: return

        val (seasonSlug, episodeSlug) = getEpisodeSlug(
            season,
            episode
        )

        val subUrl = if (season == null) {
            "$watchSomuchAPI/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part="
        } else {
            "$watchSomuchAPI/Watch/ajMovieSubtitles.aspx?mid=$id&tid=$epsId&part=S${seasonSlug}E${episodeSlug}"
        }

        app.get(subUrl)
            .parsedSafe<WatchsomuchSubResponses>()?.subtitles
            ?.map { sub ->
                subtitleCallback.invoke(
                    newSubtitleFile(
                        sub.label ?: "",
                        fixUrl(sub.url ?: return@map null, watchSomuchAPI)
                    )
                )
            }


    }

    suspend fun invokeOpenSubs(
        imdbId: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val slug = if (season == null) {
            "movie/$imdbId"
        } else {
            "series/$imdbId:$season:$episode"
        }
        app.get("${openSubAPI}/subtitles/$slug.json", timeout = 120L)
            .parsedSafe<OsResult>()?.subtitles?.map { sub ->
                subtitleCallback.invoke(
                    newSubtitleFile(
                        SubtitleHelper.fromTagToEnglishLanguageName(sub.lang ?: "") ?: sub.lang
                        ?: return@map,
                        sub.url ?: return@map
                    )
                )
            }
    }

    private fun fixUrl(url: String, domain: String): String {
        if (url.startsWith("http")) {
            return url
        }
        if (url.isEmpty()) {
            return ""
        }

        val startsWithNoHttp = url.startsWith("//")
        if (startsWithNoHttp) {
            return "https:$url"
        } else {
            if (url.startsWith('/')) {
                return domain + url
            }
            return "$domain/$url"
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }

    private fun getEpisodeSlug(
        season: Int? = null,
        episode: Int? = null,
    ): Pair<String, String> {
        return if (season == null && episode == null) {
            "" to ""
        } else {
            (if (season!! < 10) "0$season" else "$season") to (if (episode!! < 10) "0$episode" else "$episode")
        }
    }
}



================================================
FILE: SuperstreamBeta/src/main/kotlin/com/phisher98/Superstream.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import android.util.Base64
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.APIHolder.unixTime
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.MovieSearchResponse
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.SuperStreamExtractor.invokeExternalM3u8Source
import com.phisher98.SuperStreamExtractor.invokeExternalSource
import com.phisher98.SuperStreamExtractor.invokeInternalSource
import com.phisher98.SuperStreamExtractor.invokeOpenSubs
import com.phisher98.SuperStreamExtractor.invokeWatchsomuch
import com.phisher98.Superstream.CipherUtils.getVerify
import okhttp3.FormBody
import okhttp3.Headers.Companion.toHeaders
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.Response
import java.nio.charset.StandardCharsets
import java.security.KeyFactory
import java.security.KeyStore
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import java.security.SecureRandom
import java.security.cert.CertificateFactory
import java.security.spec.PKCS8EncodedKeySpec
import javax.crypto.Cipher
import javax.crypto.Cipher.ENCRYPT_MODE
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import javax.net.ssl.KeyManagerFactory
import javax.net.ssl.SSLContext
import javax.net.ssl.TrustManagerFactory
import javax.net.ssl.X509TrustManager

open class Superstream(sharedPref: SharedPreferences?=null) : MainAPI() {
    override var name = "SuperStream Beta"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val instantLinkLoading = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AnimeMovie,
    )
    companion object
    {
        private const val Supertoken = BuildConfig.SuperToken
    }
    val uitoken = sharedPref?.getString("token", null)?.substringAfter("ui=")
    enum class ResponseTypes(val value: Int) {
        Series(2),
        Movies(1);

        fun toTvType(): TvType {
            return if (this == Series) TvType.TvSeries else TvType.Movie
        }
        companion object {
            fun getResponseType(value: Int?): ResponseTypes {
                return entries.firstOrNull { it.value == value } ?: Movies
            }
        }
    }
    private val headers = mapOf(
        "Platform" to "android",
        "Accept" to "charset=utf-8",
        "Cookie" to "ci=168aec549ca68e",
    )

    private class UserAgentInterceptor : Interceptor {
        override fun intercept(chain: Interceptor.Chain): Response {
            return chain.proceed(
                chain.request()
                    .newBuilder()
                    .removeHeader("user-agent")
                    .addHeader(
                        "user-agent",
                        value = "okhttp/3.12.6"
                    ).build()
            )
        }
    }

    // Random 32 length string
    private fun randomToken(): String {
        return (0..31).joinToString("") {
            (('0'..'9') + ('a'..'f')).random().toString()
        }
    }

    private val token = randomToken()
    private val cinemeta_url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta"
    private object CipherUtils {
        private const val ALGORITHM = "DESede"
        private const val TRANSFORMATION = "DESede/CBC/PKCS5Padding"
        fun encrypt(str: String, key: String, iv: String): String? {
            return try {
                val cipher: Cipher = Cipher.getInstance(TRANSFORMATION)
                val bArr = ByteArray(24)
                val bytes: ByteArray = key.toByteArray()
                var length = if (bytes.size <= 24) bytes.size else 24
                System.arraycopy(bytes, 0, bArr, 0, length)
                while (length < 24) {
                    bArr[length] = 0
                    length++
                }
                cipher.init(
                    ENCRYPT_MODE,
                    SecretKeySpec(bArr, ALGORITHM),
                    IvParameterSpec(iv.toByteArray())
                )

                String(Base64.encode(cipher.doFinal(str.toByteArray()), 2), StandardCharsets.UTF_8)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        fun md5(str: String): String? {
            return MD5Util.md5(str)?.let { HexDump.toHexString(it).lowercase() }
        }

        fun getVerify(str: String?, str2: String, str3: String): String? {
            if (str != null) {
                return md5(md5(str2) + str3 + str)
            }
            return null
        }
    }

    private object HexDump {
        private val HEX_DIGITS = charArrayOf(
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F'
        )

        @JvmOverloads
        fun toHexString(bArr: ByteArray, i: Int = 0, i2: Int = bArr.size): String {
            val cArr = CharArray(i2 * 2)
            var i3 = 0
            for (i4 in i until i + i2) {
                val b = bArr[i4].toInt()
                val i5 = i3 + 1
                val cArr2 = HEX_DIGITS
                cArr[i3] = cArr2[b ushr 4 and 15]
                i3 = i5 + 1
                cArr[i5] = cArr2[b and 15]
            }
            return String(cArr)
        }
    }

    private object MD5Util {
        fun md5(str: String): ByteArray? {
            return md5(str.toByteArray())
        }

        fun md5(bArr: ByteArray?): ByteArray? {
            return try {
                val digest = MessageDigest.getInstance("MD5")
                digest.update(bArr ?: return null)
                digest.digest()
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
                null
            }
        }
    }

// ================== EMBED CERTS HERE ==================

    private val CLIENT_CERT_PEM = """
-----BEGIN CERTIFICATE-----
MIIEFTCCAv2gAwIBAgIUCrILmXOevO03gUhhbEhG/wZb2uAwDQYJKoZIhvcNAQEL
BQAwgagxCzAJBgNVBAYTAlVTMRMwEQYDVQQIEwpDYWxpZm9ybmlhMRYwFAYDVQQH
Ew1TYW4gRnJhbmNpc2NvMRkwFwYDVQQKExBDbG91ZGZsYXJlLCBJbmMuMRswGQYD
VQQLExJ3d3cuY2xvdWRmbGFyZS5jb20xNDAyBgNVBAMTK01hbmFnZWQgQ0EgM2Q0
ZDQ4ZTQ2ZmI3MGM1NzgxZmI0N2VhNzk4MjMxZDMwHhcNMjQwNjA0MDkxMTAwWhcN
MzkwNjAxMDkxMTAwWjAiMQswCQYDVQQGEwJVUzETMBEGA1UEAxMKQ2xvdWRmbGFy
ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJhpMlr/+IatuBqpuZuA
6QvqdI2QiFb1UMVujb/xiaBC/vqJMlMenLSDysk8xd4fLeC+GC8AyWf1IMJIz6d9
rBjOhN4D+MxvgphufkdIVqs63SqKcrr/ZL0JaRpxxEg/pKqSjH55Ik71keB8tt0m
mQ76WK1swMydOAqn6DIKVAi7wF9acWyX/6Ly+cmxfueLDZvkLigXl3gMHbuoa5Y+
CadqKl2qlijhnvjpuEbAvyDyXWe838TUi0PYMMVuOu7PV4By2LINsm+gKv83od4k
RCSWTrLKlgfqneqnudMrqeWckNUHGVB+3Lruw1ebB/Rs4gJ59VhJYpbNmM2mYT0r
VQkCAwEAAaOBuzCBuDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMBAf8EAjAA
MB0GA1UdDgQWBBSF9Jkz4ZkbS5+LANO3YGWZRuX/PDAfBgNVHSMEGDAWgBTj01Q6
MJPAjpPqCEcv8rjxAUTO9jBTBgNVHR8ETDBKMEigRqBEhkJodHRwOi8vY3JsLmNs
b3VkZmxhcmUuY29tL2U1YTYzNzc5LTQ3NWQtNGI5OS04YzQxLTIwMjE5MmZhNjNj
ZC5jcmwwDQYJKoZIhvcNAQELBQADggEBALD+9MsfANm7fbzYH5/lXl07hwn2KSN8
PH7zxyo87ED62IL9U7YOnhb3rqLS1RXUzyHEmb9kzYgzKzzNrELdKH77vNk172Vk
iRQwGD0MZiYNERWhmmBtjV1oxllz74fL4+aZTYAespIbOekmFn9NZJ+XSdyF9RqS
fzDiz27GP5ZSHHI6xwdUP+a87N/RnfI4UwGxyXvPpHfoAZWjoXDqLKKwEL36/Sqi
nGcp970y0gnZ2zI2ehqivsF7BATMZqvU+LJKCH8NEE2bnbCJ6qlPHZWZFNKYWBOe
I1Crf0gNAWD/q3HKGMVZiyxlhU6SsQS4/08tDXXQjWYfl6i3oviexSk=
-----END CERTIFICATE-----
"""

    private val CLIENT_KEY_PEM = """
-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCYaTJa//iGrbga
qbmbgOkL6nSNkIhW9VDFbo2/8YmgQv76iTJTHpy0g8rJPMXeHy3gvhgvAMln9SDC
SM+nfawYzoTeA/jMb4KYbn5HSFarOt0qinK6/2S9CWkaccRIP6Sqkox+eSJO9ZHg
fLbdJpkO+litbMDMnTgKp+gyClQIu8BfWnFsl/+i8vnJsX7niw2b5C4oF5d4DB27
qGuWPgmnaipdqpYo4Z746bhGwL8g8l1nvN/E1ItD2DDFbjruz1eActiyDbJvoCr/
N6HeJEQklk6yypYH6p3qp7nTK6nlnJDVBxlQfty67sNXmwf0bOICefVYSWKWzZjN
pmE9K1UJAgMBAAECggEAQFvnxjKiJWkVPbkfJjHU91GtnxwB3sqfrYdmN0ANUE4K
MwydYikinj2q87iEi6wZ6PYM60hHRG1oRHKPsZgphJ4s0D3YIagS+0Bpdbtv0cW9
IBovoZR4WzUum1qgOqwZYmgZCM0pNjOPwr6XT6Ldbkw8BxvN/HmFcUZ/ECZ5XugW
cKqKoy0HSlxwXT4PUAgLVfL4KvWy4A4yJJF24zgRKE4QYveOR4nUFvoRdxhuAyYW
xsajItj6sc6Jyr9FJzdw5Ra9EFwcWFM4uDdjHoaQrjwKId9fkCA+9eUCERWKTxCR
P8mU4p2cAJYO+ME9fZfs8H2uqGNj13XUzoT6JzM8UwKBgQDUFZWcfmlgCM2BjU9c
8qhYjD2egT3qxWJLYSUTUZfdOGgB6lxTqnOhsy93xYmVInz6r9XEZsLVoQj/wcZk
p7y+MxjiWNcBcUmviwHee42fe6BQZHaYlAFtlAKNSiHumfq6AtXpZvkQZJWTSRyW
lI4LBEL6fSuqpk88EH9FXJbChwKBgQC3+F/1Qi3EoeohhWD+jMO0r8IblBd7jYbp
2zs17KQsCEyc1qyIaE+a8Ud8zUqsECKWBuSFsQ2qrR3jZW6DZOw8hmp1foYC+Jjr
C/BHyWsyYxrCoxpvSJMXCY6ulyFHjIZboopRVi/jgfowteMW6WyxvOMqVAqZtxRW
HyFbsa+/7wKBgQCGHRwd+SZjr01dZmHQcjaYwB5bNHlWE/nDlyvd2pQBNaE3zN8T
nU8/6tLSl50YLNYBpN22NBFzDEFnkj8F+bh2QlOzFuDnrZ8eHfZRnaoCNyg6jj0c
4UNB6v3uIPnyK3cM16wzy4Umo6SenfYxFsH4H3rHcg4B/OdQIVKKJzHC0wKBgQCj
QxhlX0WeqtJMzUE2pVVIlHF+Z/4u93ozLwts34USTosu5JRYublrl5QJfWY3LFqF
KbjDrEykmt1bYDijAn1jeSYg/xeOq2+JqB6klms7XBfzgyuCdrWSTDkDV7uA84SI
7cYySHpXPJH7iG7vdlevpCE0/0ApCgBSLW49IYMGoQKBgAxVRqAhLdA0RO+nTAC/
whOL5RGy5M2oXKfqNkzEt2k5og7xXY7ZoYTye5Byb3+wLpEJXW+V8FlfXk/u5ZI7
oFuZne+lYcCPMNDXdku6wKdf9gSnOSHOGMu8TvHcud4uIDYmFH5qabJL5GDoQi7Q
12XvK21e6GNOEaRRlTHz0qUB
-----END PRIVATE KEY-----
"""

    // Helper: convert PEM → X509Certificate
    fun loadCertificateFromPem(pem: String): java.security.cert.X509Certificate {
        val cleanPem = pem.replace("-----BEGIN CERTIFICATE-----", "")
            .replace("-----END CERTIFICATE-----", "")
            .replace("\\s+".toRegex(), "")
        val decoded = base64DecodeArray(cleanPem)
        val cf = CertificateFactory.getInstance("X.509")
        return cf.generateCertificate(decoded.inputStream()) as java.security.cert.X509Certificate
    }

    // Helper: convert PEM → PrivateKey
    fun loadPrivateKeyFromPem(pem: String): java.security.PrivateKey {
        val cleanPem = pem.replace("-----BEGIN PRIVATE KEY-----", "")
            .replace("-----END PRIVATE KEY-----", "")
            .replace("\\s+".toRegex(), "")
        val decoded = base64DecodeArray(cleanPem)
        val keySpec = PKCS8EncodedKeySpec(decoded)
        return KeyFactory.getInstance("RSA").generatePrivate(keySpec)
    }

    fun buildClientWithCert(): OkHttpClient {
        val cert = loadCertificateFromPem(CLIENT_CERT_PEM)
        val key = loadPrivateKeyFromPem(CLIENT_KEY_PEM)

        val keyStore = KeyStore.getInstance(KeyStore.getDefaultType())
        keyStore.load(null, null)
        keyStore.setKeyEntry("client", key, "".toCharArray(), arrayOf(cert))

        val kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm())
        kmf.init(keyStore, "".toCharArray())

        val tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm())
        tmf.init(null as KeyStore?)

        val sslContext = SSLContext.getInstance("TLS")
        sslContext.init(kmf.keyManagers, tmf.trustManagers, SecureRandom())

        val trustManager = tmf.trustManagers[0] as X509TrustManager

        return OkHttpClient.Builder()
            .sslSocketFactory(sslContext.socketFactory, trustManager)
            .build()
    }


    fun queryApi(query: String, useAlternativeApi: Boolean): String {
        val encryptedQuery = CipherUtils.encrypt(query, key, iv)!!
        val appKeyHash = CipherUtils.md5(appKey)!!
        val newBody =
            """{"app_key":"$appKeyHash","verify":"${getVerify(encryptedQuery, appKey, key)}","encrypt_data":"$encryptedQuery"}"""
        val base64Body = base64Encode(newBody.toByteArray())

        val data = mapOf(
            "data" to base64Body,
            "appid" to "27",
            "platform" to "android",
            "version" to appVersionCode,
            "medium" to "Website",
            "token" to token
        )

        val url = if (useAlternativeApi) secondAPI else firstAPI

        val client = buildClientWithCert().newBuilder()
            .addInterceptor(UserAgentInterceptor())
            .build()
        val formBody = FormBody.Builder().apply {
            data.forEach { (k, v) -> add(k, v) }
        }.build()

        val request = Request.Builder()
            .url(url)
            .headers(headers.toHeaders())
            .post(formBody)
            .build()

        client.newCall(request).execute().use { resp ->
            return resp.body.string()
        }
    }


    inline fun <reified T : Any> queryApiParsed(query: String): T {
        return try {
            val json = queryApi(query, false)
            Gson().fromJson(json, T::class.java)
        } catch (_: Exception) {
            val jsonAlt = queryApi(query, true)
            Gson().fromJson(jsonAlt, T::class.java)
        }
    }


    fun getExpiryDate(): Long {
        // Current time + 12 hours
        return unixTime + 60 * 60 * 12
    }

    private data class PostJSON(
        @SerializedName("id") val id: Int? = null,
        @SerializedName("title") val title: String? = null,
        @SerializedName("banner_mini") val bannerMini: String? = null,
        @SerializedName("poster") val poster: String? = null,
        @SerializedName("poster_2") val poster2: String? = null,
        @SerializedName("box_type") val boxType: Int? = null,
        @SerializedName("imdb_rating") val imdbRating: String? = null,
        @SerializedName("season_episode") val seasonEpisode: String? = null,
        @SerializedName("update_title") val updateTitle: String? = null,
        @SerializedName("quality_tag") val qualityTag: String? = null,
        @SerializedName("3d") val is3D: Int? = null // Some movie items have "3d"
    )

    private data class ListJSON(
        @SerializedName("code") val code: Int? = null,
        @SerializedName("type") val type: String? = null,
        @SerializedName("name") val name: String? = null,
        @SerializedName("ismore") val isMore: Int? = null,
        @SerializedName("box_type") val boxType: Int? = null,
        @SerializedName("cache") val cache: Boolean? = null,
        @SerializedName("cache_key") val cacheKey: String? = null,
        @SerializedName("list") val list: ArrayList<PostJSON> = arrayListOf()
    )

    private data class DataJSON(
        @SerializedName("code") val code: Int? = null,
        @SerializedName("msg") val msg: String? = null,
        @SerializedName("data") val data: ArrayList<ListJSON> = arrayListOf()
    )

    // We do not want content scanners to notice this scraping going on so we've hidden all constants
    // The source has its origins in China so I added some extra security with banned words
    // Mayhaps a tiny bit unethical, but this source is just too good :)
    // If you are copying this code please use precautions so they do not change their api.

    // Free Tibet, The Tienanmen Square protests of 1989
    private val iv = base64Decode("d0VpcGhUbiE=")
    private val key = base64Decode("MTIzZDZjZWRmNjI2ZHk1NDIzM2FhMXc2")

    private val firstAPI = base64Decode("aHR0cHM6Ly9zaG93Ym94c3NsLnNoZWd1Lm5ldC9hcGkvYXBpX2NsaWVudC8=")

    // Another url because the first one sucks at searching
    // This one was revealed to me in a dream
    val secondAPI = base64Decode("aHR0cHM6Ly9zaG93Ym94YXBpc3NsLnN0c29zby5jb20vYXBpL2FwaV9jbGllbnQv")

    val thirdAPI = base64Decode("aHR0cHM6Ly93d3cuZmViYm94LmNvbQ==")

    val watchSomuchAPI = "https://watchsomuch.tv"
    val openSubAPI = "https://opensubtitles-v3.strem.io"

    private val appKey = base64Decode("bW92aWVib3g=")
    val appId = base64Decode("Y29tLnRkby5zaG93Ym94")
    private val appIdSecond = base64Decode("Y29tLnRkby5zaG93Ym94")
    private val appVersion = "11.7"
    private val appVersionCode = "131"

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val hideNsfw = if (settingsForProvider.enableAdult) 0 else 1
        val data = queryApiParsed<DataJSON>(
            """{"childmode":"$hideNsfw","app_version":"$appVersion","appid":"$appIdSecond","module":"Home_list_type_v2","channel":"Website","page":"$page","lang":"en","type":"all","pagelimit":"20","expired_date":"${getExpiryDate()}","platform":"android"}
            """.trimIndent()
        )
        // Cut off the first row (featured)
        val pages = data.data.let { it.subList(minOf(it.size, 1), it.size) }
            .mapNotNull {
                var name = it.name
                if (name.isNullOrEmpty()) name = "Featured"
                val postList = it.list.mapNotNull second@{ post ->
                    val type = if (post.boxType == 1) TvType.Movie else TvType.TvSeries
                    val normalizedQuality = post.qualityTag?.let { if (it.contains("blu-ray", ignoreCase = true)) "Blueray" else it } ?: ""
                    newMovieSearchResponse(
                        name = post.title ?: return@second null,
                        url = LoadData(post.id ?: return@mapNotNull null, post.boxType).toJson(),
                        type = type,
                        fix = false
                    ) {
                        posterUrl = post.poster ?: post.poster2
                        quality = getQualityFromString(normalizedQuality)
                        this.score= Score.from10(post.imdbRating)
                    }
                }
                if (postList.isEmpty()) return@mapNotNull null
                HomePageList(name, postList)
            }
        return newHomePageResponse(pages, hasNext = !pages.any { it.list.isEmpty() })
    }
    private data class Data(
        @SerializedName("id") val id: Int? = null,
        @SerializedName("mid") val mid: Int? = null,
        @SerializedName("box_type") val boxType: Int? = null,
        @SerializedName("title") val title: String? = null,
        @SerializedName("poster_org") val posterOrg: String? = null,
        @SerializedName("poster") val poster: String? = null,
        @SerializedName("cats") val cats: String? = null,
        @SerializedName("year") val year: Int? = null,
        @SerializedName("imdb_rating") val imdbRating: String? = null,
        @SerializedName("quality_tag") val qualityTag: String? = null
    ) {
        fun toSearchResponse(api: MainAPI): MovieSearchResponse? {
            val actualBoxType = this.boxType ?: ResponseTypes.Movies.value
            return api.newMovieSearchResponse(
                this.title ?: "",
                LoadData(
                    this.id ?: this.mid ?: return null,
                    actualBoxType
                ).toJson(),
                ResponseTypes.getResponseType(actualBoxType).toTvType(),
                false
            ) {
                posterUrl = if (!this@Data.posterOrg.isNullOrEmpty()) this@Data.posterOrg else this@Data.poster
                year = this@Data.year ?: 0
                quality = getQualityFromString(this@Data.qualityTag?.replace("-", "") ?: "")
            }
        }
    }

    private data class MainData(
        @SerializedName("code") val code: Int,
        @SerializedName("msg") val msg: String,
        @SerializedName("data") val data: List<Data>
    )


    override suspend fun search(query: String): List<SearchResponse> {
        val hideNsfw = if (settingsForProvider.enableAdult) 0 else 1
        val apiQuery =
            // Originally 8 pagelimit
            """{"childmode":"$hideNsfw","app_version":"$appVersion","module":"Search3","channel":"Website","page":"1","lang":"en","type":"all","keyword":"$query","pagelimit":"15","expired_date":"${getExpiryDate()}","platform":"android","appid":"$appId"}"""
        val searchResponse = queryApiParsed<MainData>(apiQuery).data.mapNotNull {
            it.toSearchResponse(this)
        }
        return searchResponse
    }

    private data class LoadData(
        val id: Int,
        val box_type: Int?
    )

    private data class MovieData(
        @SerializedName("id") val id: Int? = null,
        @SerializedName("title") var title: String? = null,
        @SerializedName("director") val director: String? = null,
        @SerializedName("writer") val writer: String? = null,
        @SerializedName("actors") val actors: String? = null,
        @SerializedName("runtime") val runtime: Int? = null,
        @SerializedName("poster") val poster: String? = null,
        @SerializedName("description") val description: String? = null,
        @SerializedName("cats") val cats: String? = null,
        @SerializedName("year") val year: Int? = null,
        @SerializedName("imdb_id") val imdbId: String? = null,
        @SerializedName("imdb_rating") val imdbRating: String? = null,
        @SerializedName("trailer") val trailer: String? = null,
        @SerializedName("released") val released: String? = null,
        @SerializedName("content_rating") val contentRating: String? = null,
        @SerializedName("tmdb_id") val tmdbId: Int? = null,
        @SerializedName("tomato_meter") val tomatoMeter: Int? = null,
        @SerializedName("poster_org") val posterOrg: String? = null,
        @SerializedName("trailer_url") val trailerUrl: String? = null,
        @SerializedName("imdb_link") val imdbLink: String? = null,
        @SerializedName("box_type") val boxType: Int? = null,
        @SerializedName("recommend") val recommend: List<Data> = listOf()
    )

    private data class MovieDataProp(
        @SerializedName("data") val data: MovieData? = MovieData()
    )


    private data class SeriesDataProp(
        @SerializedName("code") val code: Int? = null,
        @SerializedName("msg") val msg: String? = null,
        @SerializedName("data") val data: SeriesData? = SeriesData()
    )

    private data class SeriesSeasonProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: ArrayList<SeriesEpisode>? = arrayListOf()
    )

    private data class SeriesEpisode(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("tid") val tid: Int? = null,
        @JsonProperty("mb_id") val mbId: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("imdb_id_status") val imdbIdStatus: Int? = null,
        @JsonProperty("srt_status") val srtStatus: Int? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("state") val state: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("thumbs") val thumbs: String? = null,
        @JsonProperty("thumbs_bak") val thumbsBak: String? = null,
        @JsonProperty("thumbs_original") val thumbsOriginal: String? = null,
        @JsonProperty("poster_imdb") val posterImdb: Int? = null,
        @JsonProperty("synopsis") val synopsis: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("view") val view: Int? = null,
        @JsonProperty("download") val download: Int? = null,
        @JsonProperty("source_file") val sourceFile: Int? = null,
        @JsonProperty("code_file") val codeFile: Int? = null,
        @JsonProperty("add_time") val addTime: Int? = null,
        @JsonProperty("update_time") val updateTime: Int? = null,
        @JsonProperty("released") val released: String? = null,
        @JsonProperty("released_timestamp") val releasedTimestamp: Long? = null,
        @JsonProperty("audio_lang") val audioLang: String? = null,
        @JsonProperty("quality_tag") val qualityTag: String? = null,
        @JsonProperty("3d") val _3d: Int? = null,
        @JsonProperty("remark") val remark: String? = null,
        @JsonProperty("pending") val pending: String? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("display") val display: Int? = null,
        @JsonProperty("sync") val sync: Int? = null,
        @JsonProperty("tomato_meter") val tomatoMeter: Int? = null,
        @JsonProperty("tomato_meter_count") val tomatoMeterCount: Int? = null,
        @JsonProperty("tomato_audience") val tomatoAudience: Int? = null,
        @JsonProperty("tomato_audience_count") val tomatoAudienceCount: Int? = null,
        @JsonProperty("thumbs_min") val thumbsMin: String? = null,
        @JsonProperty("thumbs_org") val thumbsOrg: String? = null,
        @JsonProperty("imdb_link") val imdbLink: String? = null,
    )

    private data class SeriesLanguage(
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("lang") val lang: String? = null
    )

    private data class SeriesData(
        @SerializedName("id") val id: Int? = null,
        @SerializedName("mb_id") val mbId: Int? = null,
        @SerializedName("title") val title: String? = null,
        @SerializedName("display") val display: Int? = null,
        @SerializedName("state") val state: Int? = null,
        @SerializedName("vip_only") val vipOnly: Int? = null,
        @SerializedName("code_file") val codeFile: Int? = null,
        @SerializedName("director") val director: String? = null,
        @SerializedName("writer") val writer: String? = null,
        @SerializedName("actors") val actors: String? = null,
        @SerializedName("add_time") val addTime: Int? = null,
        @SerializedName("poster") val poster: String? = null,
        @SerializedName("poster_imdb") val posterImdb: Int? = null,
        @SerializedName("banner_mini") val bannerMini: String? = null,
        @SerializedName("description") val description: String? = null,
        @SerializedName("imdb_id") val imdbId: String? = null,
        @SerializedName("cats") val cats: String? = null,
        @SerializedName("year") val year: Int? = null,
        @SerializedName("collect") val collect: Int? = null,
        @SerializedName("view") val view: Int? = null,
        @SerializedName("download") val download: Int? = null,
        @SerializedName("update_time") val updateTime: String? = null,
        @SerializedName("released") val released: String? = null,
        @SerializedName("released_timestamp") val releasedTimestamp: Int? = null,
        @SerializedName("episode_released") val episodeReleased: String? = null,
        @SerializedName("episode_released_timestamp") val episodeReleasedTimestamp: Int? = null,
        @SerializedName("max_season") val maxSeason: Int? = null,
        @SerializedName("max_episode") val maxEpisode: Int? = null,
        @SerializedName("remark") val remark: String? = null,
        @SerializedName("imdb_rating") val imdbRating: String? = null,
        @SerializedName("content_rating") val contentRating: String? = null,
        @SerializedName("tmdb_id") val tmdbId: Int? = null,
        @SerializedName("tomato_url") val tomatoUrl: String? = null,
        @SerializedName("tomato_meter") val tomatoMeter: Int? = null,
        @SerializedName("tomato_meter_count") val tomatoMeterCount: Int? = null,
        @SerializedName("tomato_meter_state") val tomatoMeterState: String? = null,
        @SerializedName("reelgood_url") val reelgoodUrl: String? = null,
        @SerializedName("audience_score") val audienceScore: Int? = null,
        @SerializedName("audience_score_count") val audienceScoreCount: Int? = null,
        @SerializedName("no_tomato_url") val noTomatoUrl: Int? = null,
        @SerializedName("order_year") val orderYear: Int? = null,
        @SerializedName("episodate_id") val episodateId: String? = null,
        @SerializedName("weights_day") val weightsDay: Double? = null,
        @SerializedName("poster_min") val posterMin: String? = null,
        @SerializedName("poster_org") val posterOrg: String? = null,
        @SerializedName("banner_mini_min") val bannerMiniMin: String? = null,
        @SerializedName("banner_mini_org") val bannerMiniOrg: String? = null,
        @SerializedName("trailer_url") val trailerUrl: String? = null,
        @SerializedName("years") val years: List<Int> = listOf(),
        @SerializedName("season") val season: List<Int> = listOf(),
        @SerializedName("history") val history: List<String> = listOf(),
        @SerializedName("imdb_link") val imdbLink: String? = null,
        @SerializedName("episode") val episode: List<SeriesEpisode> = listOf(),
        @SerializedName("language") val language: List<SeriesLanguage> = listOf(),
        @SerializedName("box_type") val boxType: Int? = null,
        @SerializedName("year_year") val yearYear: String? = null,
        @SerializedName("season_episode") val seasonEpisode: String? = null
    )


    override suspend fun load(url: String): LoadResponse {
        val loadData = parseJson<LoadData>(url)
        val isMovie = loadData.box_type == ResponseTypes.Movies.value
        val hideNsfw = if (settingsForProvider.enableAdult) 0 else 1
        if (isMovie) { // 1 = Movie
            val apiQuery =
                """{"childmode":"$hideNsfw","uid":"","app_version":"$appVersion","appid":"$appIdSecond","module":"Movie_detail","channel":"Website","mid":"${loadData.id}","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","oss":"","group":""}"""
            val data = (queryApiParsed<MovieDataProp>(apiQuery)).data
                ?: throw RuntimeException("API error")
            val responseData = if (!data.imdbId.isNullOrEmpty()) {
                val jsonResponse = app.get("$cinemeta_url/movie/${data.imdbId}.json").text
                if (jsonResponse.isNotEmpty() && jsonResponse.startsWith("{")) {
                    Gson().fromJson(jsonResponse, ResponseData::class.java)
                } else null
            } else null

            val cast: List<String> = responseData?.meta?.cast ?: emptyList()
            val background: String? = responseData?.meta?.background
            val genre: List<String>? = responseData?.meta?.genre

            return newMovieLoadResponse(
                data.title ?: "",
                url,
                TvType.Movie,
                LinkData(
                    data.id ?: throw RuntimeException("No movie ID"),
                    ResponseTypes.Movies.value,
                    null,
                    null,
                    data.id,
                    data.imdbId
                ),
            ) {
                this.recommendations = data.recommend.mapNotNull { it.toSearchResponse(this@Superstream) }
                this.posterUrl = data.posterOrg ?: data.poster
                this.backgroundPosterUrl = background ?: data.posterOrg ?: data.poster
                        this.year = data.year
                addActors(cast)
                this.plot = data.description
                this.tags = genre ?: data.cats?.split(",")?.map { it.capitalize() }
                this.score = Score.from10(data.imdbRating)
                addTrailer(data.trailerUrl)
                this.addImdbId(data.imdbId)
            }
        } else { // 2 Series
            val apiQuery =
                """{"childmode":"$hideNsfw","uid":"","app_version":"$appVersion","appid":"$appIdSecond","module":"TV_detail_1","display_all":"1","channel":"Website","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","tid":"${loadData.id}"}"""
            val data = queryApiParsed<SeriesDataProp>(apiQuery).data
                ?: throw RuntimeException("API error")
            val responseData = if (!data.imdbId.isNullOrEmpty()) {
                val jsonResponse = app.get("$cinemeta_url/series/${data.imdbId}.json").text
                if (jsonResponse.isNotEmpty() && jsonResponse.startsWith("{")) {
                    Gson().fromJson(jsonResponse, ResponseData::class.java)
                } else null
            } else null

            val cast: List<String> = responseData?.meta?.cast ?: emptyList()
            val background: String? = responseData?.meta?.background
            val genre: List<String>? = responseData?.meta?.genre
            val allEpisodes = mutableListOf<Episode>()
            data.season.forEach { seasonNumber ->
                val seasonApiQuery =
                    """{"childmode":"$hideNsfw","uid":"","app_version":"$appVersion","appid":"$appIdSecond","module":"TV_episode","display_all":"1","season":"$seasonNumber","channel":"Website","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","tid":"${loadData.id}"}"""

                val seasonData = queryApiParsed<SeriesSeasonProp>(seasonApiQuery).data
                    ?: return@forEach

                seasonData.forEach { ep ->
                    allEpisodes.add(
                        newEpisode(
                            LinkData(ep.tid ?: ep.id ?: throw RuntimeException("No Series ID"),
                            ResponseTypes.Series.value,
                            ep.season,
                            ep.episode,
                            data.id,
                            data.imdbId
                        ).toJson()
                        ) {
                            name = ep.title
                            season = ep.season
                            episode = ep.episode
                            posterUrl = ep.thumbsOriginal ?: ep.thumbsBak ?: ep.thumbsMin ?: ep.thumbs ?: ep.thumbsOrg
                            description = ep.synopsis
                            date = ep.releasedTimestamp
                            runTime = ep.runtime
                            score=Score.from10(ep.imdbRating)
                        }
                    )
                }
            }
            return newTvSeriesLoadResponse(
                data.title ?: "",
                url,
                TvType.TvSeries,
                allEpisodes
            ) {
                year = data.year
                plot = data.description
                addActors(cast)
                this.posterUrl = data.posterOrg ?: data.poster
                backgroundPosterUrl = background ?: data.posterOrg ?: data.poster
                score = Score.from10(data.imdbRating)
                tags = genre ?: data.cats?.split(",")?.map { it.capitalize() }
                addImdbId(data.imdbId)
                addImdbUrl(data.imdbLink)
            }
        }
    }

    private data class LinkData(
        val id: Int,
        val type: Int,
        val season: Int?,
        val episode: Int?,
        val mediaId: Int?,
        val imdbId: String?,
    )

    data class LinkDataProp(
        @SerializedName("code") val code: Int? = null,
        @SerializedName("msg") val msg: String? = null,
        @SerializedName("data") val data: ParsedLinkData? = ParsedLinkData()
    )

    data class LinkList(
        @SerializedName("path") val path: String? = null,
        @SerializedName("quality") val quality: String? = null,
        @SerializedName("real_quality") val realQuality: String? = null,
        @SerializedName("format") val format: String? = null,
        @SerializedName("size") val size: String? = null,
        @SerializedName("size_bytes") val sizeBytes: Long? = null,
        @SerializedName("count") val count: Int? = null,
        @SerializedName("dateline") val dateline: Long? = null,
        @SerializedName("fid") val fid: Int? = null,
        @SerializedName("mmfid") val mmfid: Int? = null,
        @SerializedName("h265") val h265: Int? = null,
        @SerializedName("hdr") val hdr: Int? = null,
        @SerializedName("filename") val filename: String? = null,
        @SerializedName("original") val original: Int? = null,
        @SerializedName("colorbit") val colorbit: Int? = null,
        @SerializedName("success") val success: Int? = null,
        @SerializedName("timeout") val timeout: Int? = null,
        @SerializedName("vip_link") val vipLink: Int? = null,
        @SerializedName("fps") val fps: Int? = null,
        @SerializedName("bitstream") val bitstream: String? = null,
        @SerializedName("width") val width: Int? = null,
        @SerializedName("height") val height: Int? = null
    )

    data class ParsedLinkData(
        @JsonProperty("seconds") val seconds: Int? = null,
        @JsonProperty("quality") val quality: ArrayList<String> = arrayListOf(),
        @JsonProperty("list") val list: ArrayList<LinkList> = arrayListOf()
    )

    data class SubtitleDataProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: PrivateSubtitleData? = PrivateSubtitleData()
    )

    data class Subtitles(
        @JsonProperty("sid") val sid: Int? = null,
        @JsonProperty("mid") val mid: String? = null,
        @JsonProperty("file_path") val filePath: String? = null,
        @JsonProperty("lang") val lang: String? = null,
        @JsonProperty("language") val language: String? = null,
        @JsonProperty("delay") val delay: Int? = null,
        @JsonProperty("point") val point: String? = null,
        @JsonProperty("order") val order: Int? = null,
        @JsonProperty("support_total") val support_total: Int? = null,
        @JsonProperty("admin_order") val adminOrder: Int? = null,
        @JsonProperty("myselect") val myselect: Int? = null,
        @JsonProperty("add_time") val addTime: Long? = null,
        @JsonProperty("count") val count: Int? = null
    )

    data class SubtitleList(
        @JsonProperty("language") val language: String? = null,
        @JsonProperty("subtitles") val subtitles: ArrayList<Subtitles> = arrayListOf()
    )

    data class PrivateSubtitleData(
        @JsonProperty("select") val select: ArrayList<String> = arrayListOf(),
        @JsonProperty("list") val list: ArrayList<SubtitleList> = arrayListOf()
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val parsed = parseJson<LinkData>(data)

        runAllAsync(
            {
                invokeExternalSource(
                    parsed.mediaId,
                    parsed.type,
                    parsed.season,
                    parsed.episode,
                    uitoken,
                    callback
                )
            },
            {
                invokeInternalSource(
                    parsed.id,
                    parsed.type,
                    parsed.season,
                    parsed.episode,
                    Supertoken,
                    subtitleCallback,
                    callback
                )
            },
            {
                invokeExternalM3u8Source(
                    parsed.mediaId,
                    parsed.type,
                    parsed.season,
                    parsed.episode,
                    uitoken,
                    callback
                )
            },
            {
                invokeOpenSubs(
                    parsed.imdbId,
                    parsed.season,
                    parsed.episode,
                    subtitleCallback
                )
            },
            {
                invokeWatchsomuch(
                    parsed.imdbId,
                    parsed.season,
                    parsed.episode,
                    subtitleCallback
                )
            }
        )

        return true
    }

    data class ExternalResponse(
        @JsonProperty("data") val data: Data? = null,
    ) {
        data class Data(
            @JsonProperty("link") val link: String? = null,
            @JsonProperty("share_link") val shareLink: String? = null, // add this
            @JsonProperty("file_list") val file_list: ArrayList<FileList>? = arrayListOf(),
        ) {
            data class FileList(
                @JsonProperty("fid") val fid: Long? = null,
                @JsonProperty("file_name") val file_name: String? = null,
                @JsonProperty("oss_fid") val oss_fid: Long? = null,
            )
        }
    }

    data class WatchsomuchTorrents(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("movieId") val movieId: Int? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
    )

    data class WatchsomuchMovies(
        @JsonProperty("torrents") val torrents: ArrayList<WatchsomuchTorrents>? = arrayListOf(),
    )

    data class WatchsomuchResponses(
        @JsonProperty("movie") val movie: WatchsomuchMovies? = null,
    )

    data class WatchsomuchSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("label") val label: String? = null,
    )

    data class WatchsomuchSubResponses(
        @JsonProperty("subtitles") val subtitles: ArrayList<WatchsomuchSubtitles>? = arrayListOf(),
    )

    data class OsSubtitles(
        @JsonProperty("url") val url: String? = null,
        @JsonProperty("lang") val lang: String? = null,
    )

    data class OsResult(
        @JsonProperty("subtitles") val subtitles: ArrayList<OsSubtitles>? = arrayListOf(),
    )

}




================================================
FILE: SuperstreamBeta/src/main/kotlin/com/phisher98/SuperStreamparser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty

data class Meta(
    val id: String?,
    val imdb_id: String?,
    val type: String?,
    val poster: String?,
    val logo: String?,
    val background: String?,
    val moviedb_id: Int?,
    val name: String?,
    val description: String?,
    val genre: List<String>?,
    val releaseInfo: String?,
    val status: String?,
    val runtime: String?,
    val cast: List<String>?,
    val language: String?,
    val country: String?,
    val imdbRating: String?,
    val slug: String?,
    val year: String?,
    val videos: List<EpisodeDetails>?
)

data class EpisodeDetails(
    val id: String?,
    val name: String?,
    val title: String?,
    val season: Int?,
    val episode: Int?,
    val released: String?,
    val overview: String?,
    val thumbnail: String?,
    val moviedb_id: Int?
)

data class ResponseData(
    val meta: Meta?
)


data class ExternalSourcesWrapper(
    @JsonProperty("sources") val sources: List<ExternalSources>? = null
)

data class ExternalSources(
    @JsonProperty("source") val source: String? = null,
    @JsonProperty("file") val file: String? = null,
    @JsonProperty("label") val label: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("size") val size: String? = null,
)


================================================
FILE: SuperstreamBeta/src/main/kotlin/com/phisher98/SuperstreamPlugin.kt
================================================

package com.phisher98

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.phisher98.settings.SettingsFragment

@CloudstreamPlugin
class SuperStreamPlugin: Plugin() {
    override fun load(context: Context) {
        val sharedPref = context.getSharedPreferences("SuperStream", Context.MODE_PRIVATE)
        val api = Superstream(sharedPref) // pass context
        registerMainAPI(api)
        val activity = context as AppCompatActivity
        openSettings = {
            val frag = SettingsFragment(this, sharedPref)
            frag.show(activity.supportFragmentManager, "Frag")
        }
    }
}



================================================
FILE: SuperstreamBeta/src/main/kotlin/com/phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.webkit.CookieManager
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.Button
import android.widget.EditText
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.content.edit
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import com.phisher98.SuperStreamPlugin

class SettingsFragment(
    plugin: SuperStreamPlugin,
    private val sharedPref: SharedPreferences,
) : BottomSheetDialogFragment() {
    private val res = plugin.resources ?: throw Exception("Unable to read resources")

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?,
    ): View? {
        val id = res.getIdentifier("settings_fragment", "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    override fun onStart() {
        super.onStart()
        (dialog as? BottomSheetDialog)?.behavior?.apply {
            state = BottomSheetBehavior.STATE_EXPANDED
            skipCollapsed = true
            isDraggable = false // optional: prevent dragging at all
        }
    }


    @SuppressLint("SetJavaScriptEnabled", "SetTextI18n")
    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val tokenInput = view.findView<EditText>("tokenInput")
        val addButton = view.findView<Button>("addButton")
        val resetButton = view.findView<Button>("resetButton")
        val loginButton = view.findView<Button>("loginButton")
        val webView = view.findView<WebView>("authWebView")
        val savedToken = sharedPref.getString("token", null)
        if (!savedToken.isNullOrEmpty()) {
            tokenInput.setText(savedToken)
        }

        setupWebView(webView)

        loginButton.setOnClickListener {
            webView.visibility = View.VISIBLE
            webView.loadUrl("https://www.febbox.com/login/google?jump=%2F")
        }

        addButton.setOnClickListener {
            val token = tokenInput.text.toString().trim()
            if (token.isNotEmpty()) {
                val finalToken = if (token.startsWith("ui=")) token else "ui=$token"

                sharedPref.edit { putString("token", finalToken) }

                val ctx = context ?: run {
                    showToast("Error: Context is null")
                    return@setOnClickListener
                }

                AlertDialog.Builder(ctx)
                    .setTitle("Save & Reload")
                    .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                    .setPositiveButton("Yes") { _, _ ->
                        dismiss()
                        restartApp()
                    }
                    .setNegativeButton("No") { _, _ ->
                        dismiss()
                    }
                    .show()
            } else {
                showToast("Please enter a valid token")
            }
        }

        resetButton.setOnClickListener {
            sharedPref.edit()?.apply {
                remove("token")
                apply()
            }
            tokenInput.setText("ui=")
            showToast("Token reset successfully. Restart the app.")
            dismiss()
        }
    }

    @SuppressLint("SetJavaScriptEnabled")
    private fun setupWebView(webView: WebView) {
        webView.settings.javaScriptEnabled = true
        webView.settings.domStorageEnabled = true
        webView.settings.userAgentString =
            "Mozilla/5.0 (Linux; Android 10; Mobile) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.90 Mobile Safari/537.36"

        CookieManager.getInstance().setAcceptThirdPartyCookies(webView, true)

        webView.webViewClient = object : WebViewClient() {
            override fun onPageFinished(view: WebView?, url: String?) {
                super.onPageFinished(view, url)

                // Resize WebView to content height
                view?.evaluateJavascript(
                    "(function() { return document.body.scrollHeight; })();"
                ) { value ->
                    val height = value.replace("\"", "").toFloatOrNull()
                    if (height != null) {
                        val density = resources.displayMetrics.density
                        val layoutParams = view.layoutParams
                        layoutParams.height = (height * density).toInt()
                        view.layoutParams = layoutParams
                    }
                }

                // Existing token scraping logic
                val cookieManager = CookieManager.getInstance()
                val cookies = cookieManager.getCookie(url ?: "")

                val token = cookies?.split(";")
                    ?.map { it.trim() }
                    ?.find { it.startsWith("ui=") }
                    ?.removePrefix("ui=")

                if (!token.isNullOrEmpty() && view != null) {
                    val finalToken = "ui=$token"

                    activity?.runOnUiThread {
                        val tokenInput = requireView().findViewById<EditText>(
                            res.getIdentifier("tokenInput", "id", BuildConfig.LIBRARY_PACKAGE_NAME)
                        )
                        tokenInput.setText(finalToken)

                        sharedPref.edit()?.apply {
                            putString("token", finalToken)
                            apply()
                        }

                        showToast("Login successful!")
                        webView.visibility = View.GONE
                    }
                }
            }
        }
    }

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: SuperstreamBeta/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: SuperstreamBeta/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: SuperstreamBeta/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: SuperstreamBeta/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: SuperstreamBeta/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: SuperstreamBeta/src/main/res/layout/settings_fragment.xml
================================================
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#121212"
    android:padding="16dp"
    tools:context=".settings.SettingsFragment">

    <ImageView
        android:id="@+id/settingsIcon"
        android:layout_width="24dp"
        android:layout_height="24dp"
        android:src="@android:drawable/ic_menu_preferences"
        android:layout_alignParentEnd="true"
        android:contentDescription="Settings"
        android:padding="8dp"
        android:background="?android:attr/selectableItemBackgroundBorderless"
        android:layout_marginBottom="8dp" />

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@id/settingsIcon"
        android:layout_marginTop="8dp">

        <LinearLayout
            android:id="@+id/settings_container"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="24dp"
            tools:ignore="WebViewLayout">

            <!-- Card 1: Google Login -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:text="Login Options"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="Enable Google login to access SuperStream 4K content."
                        android:textSize="14sp"
                        android:textColor="#AAAAAA"
                        android:layout_marginTop="4dp"
                        android:layout_marginBottom="8dp" />

                    <Button
                        android:id="@+id/loginButton"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Login with Google"
                        android:backgroundTint="#4285F4"
                        android:textColor="#FFFFFF" />
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>

            <!-- Card 2: Token Settings -->
            <com.google.android.material.card.MaterialCardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginBottom="16dp"
                android:backgroundTint="#1E1E1E"
                android:elevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:layout_marginTop="4dp"
                        android:layout_marginStart="4dp"
                        android:text="Token Management"
                        android:textSize="18sp"
                        android:textStyle="bold"
                        android:textColor="#FFFFFF" />
                    <!-- WebView (Hidden) -->
                    <WebView
                        android:id="@+id/authWebView"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:visibility="gone"
                        android:background="#FFFFFF"
                        android:layout_marginTop="16dp"
                        android:layout_marginBottom="8dp"
                        android:scrollbars="none" />


                    <EditText
                        android:id="@+id/tokenInput"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Paste Token or use Login"
                        android:textColorHint="#AAAAAA"
                        android:textColor="#FFFFFF"
                        android:inputType="text"
                        android:padding="12dp"
                        android:textSize="16sp"
                        android:layout_marginTop="8dp" />

                    <LinearLayout
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:orientation="horizontal"
                        android:layout_marginTop="8dp">

                        <Button
                            android:id="@+id/addButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Save Token"
                            android:backgroundTint="#6200EE"
                            android:textColor="#FFFFFF" />

                        <Space
                            android:layout_width="8dp"
                            android:layout_height="wrap_content" />

                        <Button
                            android:id="@+id/resetButton"
                            android:layout_width="0dp"
                            android:layout_height="wrap_content"
                            android:layout_weight="1"
                            android:text="Reset"
                            android:backgroundTint="#D32F2F"
                            android:textColor="#FFFFFF" />
                    </LinearLayout>
                </LinearLayout>
            </com.google.android.material.card.MaterialCardView>
        </LinearLayout>
    </ScrollView>
</RelativeLayout>


================================================
FILE: SuperstreamBeta/src/main/res/values/strings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="header_tw">Login</string>
    <string name="text_hint">Token</string>
    <string name="Text_Token">Get Token from Febbox</string>
    <string name="insert_token">Insert Token</string>
    <string name="save_token">Save Token</string>
    <string name="reset_token">Reset Token</string>
</resources>


================================================
FILE: Tamilblasters/build.gradle.kts
================================================
// use an integer for version numbers
version = 5

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Movies & Series"
    authors = listOf("rockhero1234,phisher98")
    language    = "ta"
    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","TvSeries")
    iconUrl = "https://i.postimg.cc/FRwFFtyT/logo.png"
}



================================================
FILE: Tamilblasters/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.example"/>


================================================
FILE: Tamilblasters/src/main/kotlin/tamilblasters/Extractor.kt
================================================
package com.tamilblasters

import com.lagradost.cloudstream3.extractors.VidHidePro

class Streamhg: VidHidePro(){
    override var mainUrl = "https://tryzendm.com"
}

class guxhag: VidHidePro(){
    override var mainUrl = "https://cavanhabg.com"
}


================================================
FILE: Tamilblasters/src/main/kotlin/tamilblasters/TamilblastersPlugin.kt
================================================
package com.tamilblasters

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app

@CloudstreamPlugin
class TamilblastersPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TamilblastersProvider())
        registerExtractorAPI(Streamhg())
        registerExtractorAPI(guxhag())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("tamilblasters")
            val tamilblasters: String,
        )
    }
}



================================================
FILE: Tamilblasters/src/main/kotlin/tamilblasters/TamilblastersProvider.kt
================================================
package com.tamilblasters

import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import kotlinx.coroutines.runBlocking
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element

class TamilblastersProvider : MainAPI() {
    override var mainUrl: String = runBlocking {
        TamilblastersPlugin.getDomains()?.tamilblasters ?: "https://www.1tamilblasters.business/"
    }
    private val streamhg = "https://cavanhabg.com"
    override var name = "Tamilblasters"
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries)
    override var lang = "ta"
    override val hasMainPage = true

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = "$mainUrl/page/$page"
        val document = app.get(url).documentLarge
        val home = document.select("div.article-content-col").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse("Home", home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val name = selectFirst("h2>a")?.text() ?: return null
        val posterUrl = selectFirst("img")?.attr("src")
        val href = selectFirst("a")?.attr("href") ?: return null
        return newMovieSearchResponse(name, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchDoc = app.get("$mainUrl/?s=$query").documentLarge
        return searchDoc.select("div.article-content-col").mapNotNull {
            it.toSearchResult()
        }
    }

    data class VideoEntry(val title: String, val url: String)

    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).documentLarge
        val ogdesc = document.selectFirst("meta[property='og:description']")?.attr("content") ?: return null
        val title = ogdesc.substringAfter("Name:").substringBefore("(").trim()
        val year = "\\((\\d{4})\\)".toRegex().find(ogdesc)?.groupValues?.get(1)?.toIntOrNull()
        val type = if (ogdesc.startsWith("Movie")) TvType.Movie else TvType.TvSeries
        val posterUrl = document.selectFirst("meta[property='og:image']")?.attr("content")
        val plotParagraph = document.select("p:has(strong)")
        .firstOrNull { it.selectFirst("strong")?.text()?.contains("plot", ignoreCase = true) == true }
        val desc = plotParagraph?.apply { select("strong").remove() }?.text() ?: ""  
        return if (type == TvType.TvSeries) {
            val episodes = extractVideos(document).map { ep ->
                newEpisode(ep.toJson()) {
                    this.name = ep.title
                }
            }.reversed()
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = desc
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = desc
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data.startsWith("{")) {
            val loadData = tryParseJson<VideoEntry>(data)
            if (loadData != null) {
                var streamurl = loadData.url
                if (streamurl.contains("hg")) {
                    val secondPart = streamurl.substringAfter("/e")
                    streamurl = "$streamhg/e/$secondPart"
                }
                loadExtractor(streamurl, "$mainUrl/", subtitleCallback, callback)
                return true
            }
        } else {
            val doc = app.get(data).documentLarge
            doc.select("iframe").mapNotNull { iframe ->
                var streamurl = iframe.attr("src")
                if (streamurl.contains("hg")) {
                    val secondPart = streamurl.substringAfter("/e")
                    streamurl = "$streamhg/e/$secondPart"
                }
                loadExtractor(streamurl, "$mainUrl/", subtitleCallback, callback)
            }
            return true
        }
        return false
    }

    private fun extractVideos(document: Document): List<VideoEntry> {
        return document.select("iframe").mapNotNull { iframe ->
            val label = iframe.previousElementSiblings()
                .firstOrNull { it.tagName() == "p" }
                ?.text()
            label?.let { VideoEntry(it, iframe.attr("src")) }
        }
    }
}


================================================
FILE: Tamilian/build.gradle.kts
================================================
// use an integer for version numbers
version = 2

cloudstream {
    language = "ta"
    // All of these properties are optional, you can safely remove them
    description = "Movies (Tamil)"
    authors = listOf("Phisher98")
    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "Movies",
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=tamilian.io&sz=%size%"

    isCrossPlatform = false

}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}


================================================
FILE: Tamilian/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Tamilian/src/main/kotlin/com/Tamilian/Tamilian.kt
================================================
package com.Tamilian

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getAndUnpack
import com.lagradost.cloudstream3.utils.newExtractorLink


class Tamilian : TmdbProvider() {
    override var name = "Tamilian"
    override val hasMainPage = true
    override var lang = "ta"
    override val instantLinkLoading = true
    override val useMetaLoadResponse = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(
        TvType.Movie,
    )

    companion object
    {
        const val HOST="https://embedojo.net"
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<TmdbLink>(data).toLinkData()
        val script = app.get("$HOST/tamil/tmdb/${mediaData.tmdbId}")
            .documentLarge.selectFirst("script:containsData(function(p,a,c,k,e,d))")
            ?.data()?.let { getAndUnpack(it) }

        val token = script?.substringAfter("FirePlayer(\"")?.substringBefore("\",")
        val m3u8 = app.post("$HOST/player/index.php?data=$token&do=getVideo", headers = mapOf("X-Requested-With" to "XMLHttpRequest"))
            .parsedSafe<VideoData>()
        val headers= mapOf("Origin" to "https://embedojo.net")
        m3u8?.let {
            safeApiCall {
                callback.invoke(
                    newExtractorLink(
                        name,
                        name,
                        url = it.videoSource,
                        ExtractorLinkType.M3U8
                    ) {
                        this.referer = "$mainUrl/"
                        this.quality = Qualities.P1080.value
                        this.headers = headers
                    }
                )
            }
        }
        return true
    }


    private fun TmdbLink.toLinkData(): LinkData {
        return LinkData(
            imdbId = imdbID,
            tmdbId = tmdbID,
            title = movieName,
            season = season,
            episode = episode
        )
    }


    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: String? = null,
        @JsonProperty("malId") val malId: String? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
    )


    data class VideoData(
        val hls: Boolean,
        val videoImage: String,
        val videoSource: String,
        val securedLink: String,
        val downloadLinks: List<Any?>,
        val attachmentLinks: List<Any?>,
        val ck: String,
    )

}


================================================
FILE: Tamilian/src/main/kotlin/com/Tamilian/TamilianPlugin.kt
================================================
package com.Tamilian

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class HiAnimeProviderPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(Tamilian())
    }
}



================================================
FILE: Telugumv/build.gradle.kts
================================================
// use an integer for version numbers
version = 5

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Telugu Movies and TV Series"
    language = "te"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    iconUrl = "https://telugumv.fun/wp-content/uploads/2024/05/20240509_195734-e1715265186634.png"

    isCrossPlatform = true
}



================================================
FILE: Telugumv/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Telugumv/src/main/kotlin/com/phisher98/Extractors.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.extractors.VidhideExtractor


class smoothpre : VidhideExtractor() {
    override var mainUrl = "https://smoothpre.com"
    override var requiresReferer = true
}

class movearnpre : VidhideExtractor() {
    override var mainUrl = "https://movearnpre.com"
    override var requiresReferer = true
}



================================================
FILE: Telugumv/src/main/kotlin/com/phisher98/Telugumv.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.NiceResponse
import kotlinx.coroutines.runBlocking
import okhttp3.FormBody
import org.jsoup.nodes.Element

class Telugumv : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl: String = runBlocking {
        TelugumvPlugin.getDomains()?.telugumv ?: "https://telugumv.fun"
    }
    override var name = "Telugumv"
    override val hasMainPage = true
    override var lang = "te"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AnimeMovie,
    )

    companion object {
        //val headers= mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:101.0) Gecko/20100101 Firefox/101.0", "X-Requested-With" to "XMLHttpRequest")
    }

    override val mainPage = mainPageOf(
        "$mainUrl/movies/" to "Movies",
        "$mainUrl/tvshows/" to "Tvshows",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = if (page == 1) {
            app.get(request.data).documentLarge
        } else {
            app.get(request.data + "page/$page/").documentLarge
        }

        //Log.d("Document", request.data)
        val home = if (request.data.contains("/movies")) {
            document.select("#archive-content > article").mapNotNull {
                it.toSearchResult()
            }
        } else {
            document.select("div.items > article").mapNotNull {
                it.toSearchResult()
            }
        }
        return newHomePageResponse(arrayListOf(HomePageList(request.name, home)), hasNext = true)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("div.data > h3 > a")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("div.data > h3 > a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("div.poster > img")?.attr("src"))
        val quality = getQualityFromString(this.select("div.poster > div.mepo > span").text())
        return if (href.contains("Movie")) {
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        } else {
            newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?s=$query").documentLarge
        //Log.d("document", document.toString())

        return document.select("div.result-item").mapNotNull {
            val title =
                it.selectFirst("article > div.details > div.title > a")?.text().toString().trim()
            //Log.d("title", titleS)
            val href = fixUrl(
                it.selectFirst("article > div.details > div.title > a")?.attr("href").toString()
            )
            //Log.d("href", href)
            val posterUrl = fixUrlNull(
                it.selectFirst("article > div.image > div.thumbnail > a > img")?.attr("src")
            )
            val quality =
                getQualityFromString(it.select("div.poster > div.mepo > span").text())
            val type = it.select("article > div.image > div.thumbnail > a > span").text()
            if (type.contains("Movie")) {
                newMovieSearchResponse(title, href, TvType.Movie) {
                    this.posterUrl = posterUrl
                    this.quality = quality
                }
            } else {
                newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                    this.posterUrl = posterUrl
                    this.quality = quality
                }
            }
        }
    }

    private suspend fun getEmbed(postid: String?, nume: String, referUrl: String?): NiceResponse {
        val body = FormBody.Builder()
            .addEncoded("action", "doo_player_ajax")
            .addEncoded("post", postid.toString())
            .addEncoded("nume", nume)
            .addEncoded("type", "movie")
            .build()

        return app.post(
            "$mainUrl/wp-admin/admin-ajax.php",
            requestBody = body,
            referer = referUrl
        )
    }

    data class TrailerUrl(
        @JsonProperty("embed_url") var embedUrl: String?,
        @JsonProperty("type") var type: String?
    )

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get(url).documentLarge
        val titleL = doc.selectFirst("div.sheader > div.data > h1")?.text()?.trim()
            ?: return null
        val titleRegex = Regex("(^.*\\)\\d*)")
        val titleClean = titleRegex.find(titleL)?.groups?.get(1)?.value.toString()
        val title = if (titleClean == "null") titleL else titleClean
        val poster = fixUrlNull(
            doc.select("#contenedor").toString().substringAfter("background-image:url(")
                .substringBefore(");")
        )
        val tags = doc.select("div.sgeneros > a").map { it.text() }
        val year =
            doc.selectFirst("span.date")?.text()?.substringAfter(",")?.trim()?.toInt()
        val description = doc.selectFirst("#info div.wp-content p")?.text()?.trim()
        val type = if (url.contains("tvshows")) TvType.TvSeries else TvType.Movie
        val trailerRegex = Regex("\"http.*\"")
        var trailer = if (type == TvType.Movie)
            fixUrlNull(
                getEmbed(
                    doc.select("#report-video-button-field > input[name~=postid]").attr("value"),
                    "trailer",
                    url
                ).parsed<TrailerUrl>().embedUrl
            )
        else fixUrlNull(doc.select("iframe.rptss").attr("src"))
        trailer = trailerRegex.find(trailer.toString())?.value.toString()
        val rating = doc.select("span.dt_rating_vgs").text()
        val duration =
            doc.selectFirst("span.runtime")?.text()?.removeSuffix(" Min.")?.trim()
                ?.toIntOrNull()
        val actors =
            doc.select("div.person").map {
                ActorData(
                    Actor(
                        it.select("div.data > div.name > a").text(),
                        it.select("div.img > a > img").attr("src")
                    ),
                    roleString = it.select("div.data > div.caracter").text(),
                )
            }
        val recommendations = doc.select("#dtw_content_related-2 article").mapNotNull {
            it.toSearchResult()
        }

        val episodes = ArrayList<Episode>()
        doc.select("#seasons ul.episodios").mapIndexed { seasonNum, me ->
            me.select("li").mapIndexed { epNum, it ->
                episodes.add(
                    newEpisode(it.select("div.episodiotitle > a").attr("href"))
                    {
                        this.name=it.select("div.episodiotitle > a").text()
                        this.season=seasonNum + 1
                        this.episode=epNum + 1
                        this.posterUrl=it.select("div.imagen > img").attr("src")
                    }
                )
            }
        }

        return if (type == TvType.Movie) {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = poster?.trim()
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.duration = duration
                this.actors = actors
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster?.trim()
                this.year = year
                this.plot = description
                this.tags = tags
                this.score = Score.from10(rating)
                this.duration = duration
                this.actors = actors
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    @Suppress("NAME_SHADOWING")
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val req = app.get(data).documentLarge
        req.select("ul#playeroptionsul li").map {
                Triple(
                    it.attr("data-post"),
                    it.attr("data-nume"),
                    it.attr("data-type")
                )
            }.amap { (id, nume, type) ->
            if (!nume.contains("trailer")) {
                val source = app.post(
                    url = "$mainUrl/wp-admin/admin-ajax.php",
                    data = mapOf(
                        "action" to "doo_player_ajax",
                        "post" to id,
                        "nume" to nume,
                        "type" to type
                    ),
                    referer = mainUrl,
                    headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                ).parsed<ResponseHash>().embed_url
                Log.d("Phisher", source)
                val link = source.substringBeforeLast("1")
                when {
                    !link.contains("youtube") -> {
                        if (link.contains("gdmirrorbot.nl")) {
                            app.get(link).documentLarge.select("ul#videoLinks li").map {
                                @Suppress("NAME_SHADOWING") val link = it.attr("data-link")
                                loadExtractor(link, referer = mainUrl, subtitleCallback, callback)
                            }
                        } else
                            if (link.contains("autoembed.cc")) {
                                app.get(
                                    link,
                                    referer = mainUrl
                                ).documentLarge.select("div.dropdown-menu > button").map {
                                    val encoded = it.attr("data-server")
                                    val link = base64Decode(encoded)
                                    Log.d("Phisher", link)
                                    if (link.contains("duka.autoembed.cc")) {
                                        val type = link.substringAfter("/").substringBefore("/")
                                        val id = link.substringAfter("/").substringAfter("/")
                                        val trueurl =
                                            "https://duka.autoembed.cc/api/getVideoSource?type=$type&id=$id"
                                        val dukelink =
                                            app.get(trueurl).parsedSafe<Dukeresponse>()?.videoSource
                                                ?: ""
                                        Log.d("Phisher", dukelink)
                                    } else
                                        if (link.contains("hin.autoembed.cc")) {
                                            val linkdoc = app.get(link).documentLarge.toString()
                                            Regex("\"file\":\"(https?://[^\"]+)\"").find(linkdoc)?.groupValues?.get(
                                                1
                                            )?.let { link ->
                                                callback.invoke(
                                                    newExtractorLink(
                                                        this.name,
                                                        this.name,
                                                        url = link,
                                                        INFER_TYPE
                                                    ) {
                                                        this.referer = ""
                                                        this.quality = Qualities.Unknown.value
                                                    }
                                                )
                                            }
                                        } else {
                                            loadExtractor(link, subtitleCallback, callback)
                                        }
                                }
                            } else
                                loadExtractor(link, referer = mainUrl, subtitleCallback, callback)
                    }

                    else -> return@amap
                }
            }
        }
        return true
    }

    data class Dukeresponse(
        val videoSource: String,
        val subtitles: List<Any?>,
        val posterImageUrl: String,
    )

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("key") val key: String? = null,
        @JsonProperty("type") val type: String? = null,
    )
}



================================================
FILE: Telugumv/src/main/kotlin/com/phisher98/TelugumvPlugin.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.VidHidePro6

@CloudstreamPlugin
class TelugumvPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(Telugumv())
        registerExtractorAPI(VidHidePro6())
        registerExtractorAPI(smoothpre())
        registerExtractorAPI(movearnpre())
        }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("telugumv")
            val telugumv: String,
        )
    }
}



================================================
FILE: Tennistream/build.gradle.kts
================================================
// use an integer for version numbers
version = 3


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Tennistream"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Live")

    iconUrl="https://www.google.com/s2/favicons?domain=tennistream.com&sz=%size%"

    isCrossPlatform = true
}



================================================
FILE: Tennistream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Tennistream/src/main/kotlin/com/Tennistream/Extractors.kt
================================================
package com.Tennistream

import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink


open class Quest4play : ExtractorApi() {
    override var name = "Quest4play"
    override var mainUrl = "https://quest4play.xyz"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val res=app.get(url).documentLarge.toString()
        val href=Regex("""source:.'(.*?)'""").find(res)?.groupValues?.get(1) ?:""
        val reallink=app.get(href,referer=mainUrl, allowRedirects = false).headers["location"] ?:""
        callback.invoke(
            newExtractorLink(
                this.name,
                this.name,
                url = reallink,
                ExtractorLinkType.M3U8
            ) {
                this.referer = mainUrl
                this.quality = Qualities.P1080.value
            }
        )
    }
}

class Choosingnothing :Vaguedinosaurs()
{
    override var name = "Choosing Nothing"
    override var mainUrl = "https://choosingnothing.com"

}

open class Vaguedinosaurs : ExtractorApi() {
    override var name = "Vaguedinosaurs"
    override var mainUrl = "https://vaguedinosaurs.com"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val doc= app.get(url, referer = "https://wikisport.best/").text
        val hash=Regex("""player","(.*?)"""").find(doc)?.groupValues?.get(1)
        Log.d("Phisher doc",doc)
        Log.d("Phisher doc", hash.toString())
        val domain=Regex("""\{"([^"]+)""").find(doc)?.groupValues?.get(1)
        val link ="https://$domain/hls/$hash/live.m3u8"
        callback.invoke(
            newExtractorLink(
                this.name,
                this.name,
                url = link,
                ExtractorLinkType.M3U8
            ) {
                this.referer = mainUrl
                this.quality = Qualities.P1080.value
            }
        )
    }
}


================================================
FILE: Tennistream/src/main/kotlin/com/Tennistream/Tennistream.kt
================================================
package com.Tennistream


import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import java.net.URI

class Tennistream : MainAPI() {
    override var mainUrl              = "https://tennistream.com"
    override var name                 = "Tennistream"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val supportedTypes       = setOf(TvType.Live)

    override val mainPage = mainPageOf(
        "live-all-channels" to "All Channels",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}").documentLarge
        val home     = document.select("div.entry-content.cf p a").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.text()
        val href      = fixUrl(this.attr("href"))
        val posterUrl = "https://img.freepik.com/premium-photo/international-sports-day-6-april_10221-18992.jpg"
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()
        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val title= "Tennistream"
        val poster = "https://tennistream.com/wp-content/uploads/2024/01/cropped-AO_Nine_Partnership-1-778x438.png"
        val description="Tennis Live Stream THURSDAY, SEPTEMBER 5 >> WATCH ALL STREAMS<<  WTA – US OPEN 02:00 Navarro E. vs Sabalenka A. SuperSport  ESPN  Sky Sports 03:30 Pegula J. vs Muchova K. SuperSport  ESPN  Sky Sports ATP DOUBLES – US OPEN 23:00 Purcell M./Thompson J. vs Lammons N./Withrow J. WATCH 00:30 Arevalo M./Pavic M. vs Krawietz K./Puetz T. WATCH […]"
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
            this.plot=description
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
       document.select("p a").amap {
           it.attr("href").let { href ->
               val link=app.get(href).documentLarge.selectFirst("iframe")?.attr("src") ?:""
               var trueurl=app.get(link).documentLarge.selectFirst("iframe")?.attr("src") ?:""
               if (trueurl.isEmpty())
               {
                   val fid=app.get(link).text.substringAfter("fid=\"").substringBefore("\"")
                   val url="https://freshwaterdell.com/wiki.php?player=desktop&live=$fid"
                   trueurl= httpsify(app.get(url, referer = "https://wikisport.best/").text.substringAfter("return([").substringBefore("].join").replace("\"","").replace(",",""))
               }
               if (trueurl.contains("quest4play"))
               {
                   loadExtractor(trueurl,referer = getBaseUrl(link),subtitleCallback, callback)
               }
               else if (trueurl.contains("m3u8"))
               {
                   callback.invoke(
                       newExtractorLink(
                           "Server 2",
                           "Server 2",
                           url = trueurl,
                           ExtractorLinkType.M3U8
                       ) {
                           this.referer = "https://freshwaterdell.com"
                           this.quality = Qualities.P1080.value
                       }
                   )
               }
               else
               {
                   loadExtractor(trueurl,subtitleCallback, callback)
               }
           }
       }
        return true
    }

    private fun getBaseUrl(url: String): String {
        return URI(url).let {
            "${it.scheme}://${it.host}"
        }
    }
}



================================================
FILE: Tennistream/src/main/kotlin/com/Tennistream/TennistreamProvider.kt
================================================
package com.Tennistream

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class CloudyProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Tennistream())
        registerExtractorAPI(Quest4play())
        registerExtractorAPI(Vaguedinosaurs())
        registerExtractorAPI(Choosingnothing())
    }
}



================================================
FILE: TokusatsuUltimate/build.gradle.kts
================================================
// use an integer for version numbers
version = 1

cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them

    description = "Stream tokusatsu content including Kamen Rider, Super Sentai, Metal Heroes, and other Japanese special effect series with English subs"
    authors = listOf("Phisher98,YoureMotherHelped-Love-Mom")

    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "TvSeries",
        "Movie",
        "Anime"
    )

    iconUrl = "https://raw.githubusercontent.com/phisher98/cloudstream-extensions-phisher/refs/heads/master/TokusatsuUltimate/TokusatsuUltimateIcon.png"
    isCrossPlatform = false
}


================================================
FILE: TokusatsuUltimate/src/main/kotlin/com/tokusatsu/ultimate/TokusatsuParser.kt
================================================
package com.tokusatsu.ultimate

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

// Data classes for parsing JSON responses from tokusatsu sources
data class TokusatsuSearchResult(
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("original_title") val originalTitle: String? = null,
    @JsonProperty("poster") val poster: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("year") val year: Int? = null,
    @JsonProperty("description") val description: String? = null
)

data class TokusatsuDetail(
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("original_title") val originalTitle: String? = null,
    @JsonProperty("poster") val poster: String? = null,
    @JsonProperty("banner") val banner: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("year") val year: Int? = null,
    @JsonProperty("description") val description: String? = null,
    @JsonProperty("status") val status: String? = null,
    @JsonProperty("genres") val genres: List<String>? = null,
    @JsonProperty("episodes") val episodes: List<TokusatsuEpisode>? = null,
    @JsonProperty("rating") val rating: String? = null
)

data class TokusatsuEpisode(
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("title") val title: String? = null,
    @JsonProperty("episode_number") val episodeNumber: Int? = null,
    @JsonProperty("season_number") val seasonNumber: Int? = null,
    @JsonProperty("description") val description: String? = null,
    @JsonProperty("thumbnail") val thumbnail: String? = null,
    @JsonProperty("air_date") val airDate: String? = null
)

data class TokusatsuLinks(
    @JsonProperty("id") val id: String? = null,
    @JsonProperty("links") val links: List<TokusatsuVideoLink>? = null,
    @JsonProperty("subtitles") val subtitles: List<TokusatsuSubtitle>? = null
)

data class TokusatsuVideoLink(
    @JsonProperty("url") val url: String? = null,
    @JsonProperty("quality") val quality: String? = null,
    @JsonProperty("type") val type: String? = null,
    @JsonProperty("is_m3u8") val isM3u8: Boolean? = null
)

data class TokusatsuSubtitle(
    @JsonProperty("url") val url: String? = null,
    @JsonProperty("language") val language: String? = null,
    @JsonProperty("format") val format: String? = null
)


================================================
FILE: TokusatsuUltimate/src/main/kotlin/com/tokusatsu/ultimate/TokusatsuUltimate.kt
================================================
package com.tokusatsu.ultimate

import android.util.Log
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.fixUrl
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.net.URI
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class TokusatsuUltimate : MainAPI() {
    override var mainUrl = "https://toku555.com"
    override var name = "TokusatsuUltimate"
    override val hasMainPage = true
    override var lang = "en"
    override val hasQuickSearch = false
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Anime, TvType.TvSeries, TvType.Movie)

    companion object {
        private val mapper = jacksonObjectMapper()
        
        fun getType(t: String): TvType {
            return when {
                t.contains("movie", ignoreCase = true) -> TvType.Movie
                t.contains("tv", ignoreCase = true) || t.contains("series", ignoreCase = true) -> TvType.TvSeries
                else -> TvType.Anime
            }
        }

        fun getRating(score: String?): String? {
            if (score == null) return null
            return try {
                (score.toFloat() * 10).toString()
            } catch (e: Exception) {
                score
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when {
                t?.contains("Ongoing", ignoreCase = true) == true -> ShowStatus.Ongoing
                t?.contains("Completed", ignoreCase = true) == true -> ShowStatus.Completed
                else -> ShowStatus.Completed
            }
        }

        fun cleanTitle(title: String): String {
            // Remove common suffixes and clean up the title
            var cleaned = title
            val suffixes = listOf(" - Tokusatsu", " | Tokusatsu", " | Official")
            for (suffix in suffixes) {
                if (cleaned.endsWith(suffix)) {
                    cleaned = cleaned.substring(0, cleaned.length - suffix.length)
                }
            }
            return cleaned.trim()
        }
    }

    override val mainPage = mainPageOf(
        "kamen-rider" to "Kamen Rider Series",
        "super-sentai" to "Super Sentai Series",
        "tokusatsu-anime" to "Tokusatsu Anime",
        "metal-heroes" to "Metal Heroes",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = "${mainUrl}/${request.data}/page/$page/"
        
        val document = app.get(url).document
        val home = document.select("div.film-poster, .item, .series-item").mapNotNull { element ->
            val titleElement = element.selectFirst(".film-title a, .title a, h3 a") ?: element.selectFirst("a")
            
            if (titleElement != null) {
                val title = cleanTitle(titleElement.text().trim())
                val href = fixUrl(titleElement.attr("href"))
                val posterElement = element.selectFirst(".film-poster img, img")
                val posterUrl = fixUrlNull(posterElement?.attr("src") ?: posterElement?.attr("data-src"))

                newAnimeSearchResponse(title, href, TvType.Anime) {
                    this.posterUrl = posterUrl
                }
            } else {
                null
            }
        }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchUrl = "$mainUrl/search/${query}/"
        val document = app.get(searchUrl).document

        return document.select("div.film-poster, .item, .series-item").mapNotNull { element ->
            val titleElement = element.selectFirst(".film-title a, .title a, h3 a") ?: return@mapNotNull null
            val title = cleanTitle(titleElement.text().trim())
            val href = fixUrl(titleElement.attr("href"))
            val posterElement = element.selectFirst(".film-poster img, img")
            val posterUrl = fixUrlNull(posterElement?.attr("src") ?: posterElement?.attr("data-src"))

            newAnimeSearchResponse(title, href, TvType.Anime) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val titleElement = document.selectFirst("h1.heading-title, .title, .film-name,div.row h1") ?:
            throw ErrorLoadingException("No title found")
        val title = cleanTitle(titleElement.text().trim())

        val posterElement = document.selectFirst(".film-poster img, .poster img, img[src*='image'],div.row >div > img")
        val posterUrl = fixUrlNull(posterElement?.attr("src") ?: posterElement?.attr("data-src"))

        val year = document.selectFirst(".year, .date, .released")?.text()?.trim()
            ?.toIntOrNull()

        val description = document.selectFirst("div.row.content > p:nth-child(1),div.row.content > p:nth-child(2)")?.text()?.trim()

        val tags = document.select(".genres a, .tags a, .category a").map { it.text().trim() }

        val episodes = mutableListOf<Episode>()
        
        // Look for episode list
        document.select("ul.pagination.post-tape li").amap { epElement ->
            val epTitle = epElement.select("a").text()
            val epHref = epElement.select("a").attr("href")
            val href= app.get(epHref).document.select("div.player iframe").attr("src")
            val epNum = epTitle.toIntOrNull()

            episodes.add(
                newEpisode(href)
                {
                    this.name = "Episode $epTitle"
                    this.episode = epNum
                }
            )
        }

        // If no episodes found, try to find them in a different structure
        if (episodes.isEmpty()) {
            val iframe=document.select("div.player iframe").attr("src")
            return newMovieLoadResponse(title, url, TvType.AnimeMovie,iframe) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = description
                this.tags = tags

            }
        }

        return newAnimeLoadResponse(title, url, TvType.Anime) {
            this.posterUrl = posterUrl
            this.year = year
            this.plot = description
            this.tags = tags
            addEpisodes(DubStatus.Subbed, episodes.reversed())
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        loadExtractor(data, data, subtitleCallback, callback)
        return true
    }

    class P2pplay : VidStack() {
        override var mainUrl = "https://t1.p2pplay.pro"
        override val requiresReferer = true
    }

    open class VidStack : ExtractorApi() {
        override var name = "Vidstack"
        override var mainUrl = "https://vidstack.io"
        override val requiresReferer = true

        override suspend fun getUrl(
            url: String,
            referer: String?,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        )
        {
            val headers = mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0")
            val hash = url.substringAfterLast("#").substringAfter("/")
            val baseurl = getBaseUrl(url)

            val encoded = app.get("$baseurl/api/v1/video?id=$hash", headers = headers).text.trim()

            val key = "kiemtienmua911ca"
            val ivList = listOf("1234567890oiuytr", "0123456789abcdef")

            val decryptedText = ivList.firstNotNullOfOrNull { iv ->
                try {
                    AesHelper.decryptAES(encoded, key, iv)
                } catch (e: Exception) {
                    null
                }
            } ?: throw Exception("Failed to decrypt with all IVs")

            val m3u8 = Regex("\"source\":\"(.*?)\"").find(decryptedText)
                ?.groupValues?.get(1)
                ?.replace("\\/", "/") ?: ""
            val subtitlePattern = Regex("\"([^\"]+)\":\\s*\"([^\"]+)\"")
            val subtitleSection = Regex("\"subtitle\":\\{(.*?)\\}").find(decryptedText)?.groupValues?.get(1)

            subtitleSection?.let { section ->
                subtitlePattern.findAll(section).forEach { match ->
                    val lang = match.groupValues[1]
                    val rawPath = match.groupValues[2].split("#")[0]
                    if (rawPath.isNotEmpty()) {
                        val path = rawPath.replace("\\/", "/")
                        val subUrl = "$mainUrl$path"
                        subtitleCallback(newSubtitleFile(lang, fixUrl(subUrl)))
                    }
                }
            }

            callback.invoke(
                newExtractorLink(
                    source = this.name,
                    name = this.name,
                    url = m3u8.replace("https","http"),
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = url
                    this.headers = mapOf("referer" to url,"Origin" to url.substringAfterLast("/"))
                    this.quality = Qualities.Unknown.value
                }
            )
        }

        private fun getBaseUrl(url: String): String {
            return try {
                URI(url).let { "${it.scheme}://${it.host}" }
            } catch (e: Exception) {
                Log.e("Vidstack", "getBaseUrl fallback: ${e.message}")
                mainUrl
            }
        }
    }

    object AesHelper {
        private const val TRANSFORMATION = "AES/CBC/PKCS5PADDING"

        fun decryptAES(inputHex: String, key: String, iv: String): String {
            val cipher = Cipher.getInstance(TRANSFORMATION)
            val secretKey = SecretKeySpec(key.toByteArray(Charsets.UTF_8), "AES")
            val ivSpec = IvParameterSpec(iv.toByteArray(Charsets.UTF_8))

            cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
            val decryptedBytes = cipher.doFinal(inputHex.hexToByteArray())
            return String(decryptedBytes, Charsets.UTF_8)
        }

        private fun String.hexToByteArray(): ByteArray {
            check(length % 2 == 0) { "Hex string must have an even length" }
            return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        }
    }

}


================================================
FILE: TokusatsuUltimate/src/main/kotlin/com/tokusatsu/ultimate/TokusatsuUltimatePlugin.kt
================================================
package com.tokusatsu.ultimate

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class TokusatsuUltimatePlugin: Plugin() {
    override fun load(context: Context) {
        // Registers the main API for this plugin
        registerMainAPI(TokusatsuUltimate())
        registerExtractorAPI(TokusatsuUltimate.P2pplay())
    }
}


================================================
FILE: ToonHub/build.gradle.kts
================================================
// use an integer for version numbers
version = 7


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "ToonHub4u Multi Language"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://toonhub4u.me/wp-content/uploads/2024/02/Untitled.png"

    isCrossPlatform = true
}



================================================
FILE: ToonHub/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: ToonHub/src/main/kotlin/com/toonhub4u/Extractor.kt
================================================
package com.toonhub4u

import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidhideExtractor

class MultimoviesAIO: StreamWishExtractor() {
    override var name = "Multimovies Cloud AIO"
    override var mainUrl = "https://allinonedownloader.fun"
    override var requiresReferer = true
}


class Dhtpre : VidhideExtractor() {
    override var name = "Animezia"
    override var mainUrl = "https://dhtpre.com"
    override var requiresReferer = true
}

class Multimovies: StreamWishExtractor() {
    override var name = "Multimovies Cloud"
    override var mainUrl = "https://multimovies.cloud"
    override var requiresReferer = true
}

class Animezia : VidhideExtractor() {
    override var name = "Animezia"
    override var mainUrl = "https://animezia.cloud"
    override var requiresReferer = true
}

class server2 : VidhideExtractor() {
    override var name = "Multimovies Vidhide"
    override var mainUrl = "https://server2.shop"
    override var requiresReferer = true
}

class Asnwish : StreamWishExtractor() {
    override val name = "Streanwish Asn"
    override val mainUrl = "https://asnwish.com"
    override val requiresReferer = true
}

class Multimoviesshg : Filesim() {
    override var name = "Multimoviesshg Vidhide"
    override var mainUrl = "https://multimoviesshg.com"
    override val requiresReferer = true
}

class CdnwishCom : StreamWishExtractor() {
    override val name = "Cdnwish"
    override val mainUrl = "https://cdnwish.com"
    override val requiresReferer = true
}





================================================
FILE: ToonHub/src/main/kotlin/com/toonhub4u/Toonhub4u.kt
================================================
package com.toonhub4u


import com.lagradost.api.Log
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.joinAll
import kotlinx.coroutines.launch
import org.json.JSONArray

class Toonhub4u : MainAPI() {
    override var mainUrl              = "https://toonhub4u.me"
    override var name                 = "ToonHub4u"
    override val hasMainPage          = true
    override var lang                 = "hi"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.Cartoon)

    override val mainPage = mainPageOf(
        "category/anime/anime-series" to "Anime Series",
        "category/anime/anime-movies" to "Anime Movies",
        "category/animated/animation-movies" to "Animated Movies",
        "category/animated/animated-series" to "Animated Series",
        "category/channel-list/cartoon-network" to "Cartoon Network",
        "category/channel-list/disney-xd-india" to "Disney XD India",
        "category/channel-list/disney" to "Disney",
        "category/ott-network/crunchyroll" to "Crunchyroll",
        "category/ott-network/amazon-prime-video" to "Amazon Prime Video",
        "category/ott-network/netflix" to "Netflix",
        "category/ott-network/jio-cinema" to "Jio Cinema",
        "category/language/hindi" to "Hindi Language"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page/").documentLarge
        val home     = document.select("li.post-item").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("a").text().trim().substringBefore("[")
        val href      = fixUrl(this.select("a").attr("href"))
        val posterUrl = this.select("a img").attr("data-src").ifEmpty { this.select("a img").attr("src") }
        return newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("${mainUrl}/?s=$query").documentLarge
        val results = document.select("li.post-item").mapNotNull { it.toSearchResult() }
        return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("meta[property=og:title]")?.attr("content")?.substringBefore("[")?.substringBefore("1080")?.trim().toString()
        val backgroundposter = document.select("meta[property=og:image]").attr("content")
        val poster= document.select("p:nth-child(3) > img").attr("src")
        val description = document.selectFirst("meta[property=og:description]")?.attr("content")?.trim()
        val tvtag=if (document.select("div.entry-content p strong").text().contains("TV Series")) TvType.TvSeries else TvType.Movie
        val hrefs = document.select("div.mks_toggle_content a").map { it.attr("href").replace("/file/","/embed/") }.toJson()
        return if (tvtag == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            document.select(".entry-content.entry.clearfix").forEach { content ->
                content.select("p").forEach { pTag ->
                    val episodeMatch = Regex("Episode\\s*(\\d+)").find(pTag.text())
                    if (episodeMatch != null) {
                        val episodeNumber = episodeMatch.groupValues[1].toIntOrNull()
                        val episodeLinks = mutableListOf<String>()
                        var nextSibling = pTag.nextElementSibling()
                        while (nextSibling != null && nextSibling.tagName() != "hr") {
                            if (nextSibling.tagName() == "p") {
                                nextSibling.select("a[href]").forEach { aTag ->
                                    episodeLinks.add(aTag.attr("href").replace("/file/","/embed/"))
                                }
                            }
                            nextSibling = nextSibling.nextElementSibling()
                        }
                        episodes+=newEpisode(episodeLinks.toJson())
                        {
                            this.name="Episode $episodeNumber"
                        }
                    }
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundposter
                this.plot = description
            }
        }
        else {
            newMovieLoadResponse(title, url, TvType.Movie, hrefs) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundposter
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val jsonArray = JSONArray(data)
        val links = List(jsonArray.length()) { jsonArray.getString(it) }
        coroutineScope {
            links.map { link ->
                launch {
                    try {
                        loadExtractor(link, subtitleCallback, callback)
                    } catch (e: Exception) {
                        Log.e("ToonHub", "Error loading $link: ${e.message}")
                    }
                }
            }.joinAll()
        }

        return true
    }
}



================================================
FILE: ToonHub/src/main/kotlin/com/toonhub4u/Toonhub4uPlugin.kt
================================================
package com.toonhub4u

import com.lagradost.cloudstream3.extractors.GDMirrorbot
import com.lagradost.cloudstream3.extractors.MixDrop
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class Toonhub4uPlugin: BasePlugin() {
    override fun load() {
        registerMainAPI(Toonhub4u())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(MultimoviesAIO())
        registerExtractorAPI(Multimovies())
        registerExtractorAPI(Animezia())
        registerExtractorAPI(server2())
        registerExtractorAPI(Asnwish())
        registerExtractorAPI(CdnwishCom())
        registerExtractorAPI(Multimovies())
        registerExtractorAPI(MixDrop())
        registerExtractorAPI(Dhtpre())
        registerExtractorAPI(Multimoviesshg())
    }
}


================================================
FILE: Toonstream/build.gradle.kts
================================================
// use an integer for version numbers
version = 2

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "ToonStream Multi Language"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("AnimeMovie","Anime","Cartoon")
    iconUrl="https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/toonstream.png"

    isCrossPlatform = true
}



================================================
FILE: Toonstream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Toonstream/src/main/kotlin/com/Toonstream/Extractors.kt
================================================
package com.Toonstream


import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.DoodLaExtractor
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.extractors.VidStack
import com.lagradost.cloudstream3.extractors.VidhideExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink

class StreamSB8 : StreamSB() {
    override var mainUrl = "https://streamsb.net"
}

class Cloudy : VidStack() {
    override var mainUrl = "https://cloudy.upns.one"
}

open class Streamruby : ExtractorApi() {
    override var name = "Streamruby"
    override var mainUrl = "streamruby.com"
    override val requiresReferer = false

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val newUrl = if (url.contains("/e/")) url.replace("/e", "") else url
        val txt = app.get(newUrl).text
        val m3u8 = Regex("file:\\s*\"(.*?m3u8.*?)\"").find(txt)?.groupValues?.getOrNull(1)

        return m3u8?.takeIf { it.isNotEmpty() }?.let {
            listOf(
                newExtractorLink(
                    name = this.name,
                    source = this.name,
                    url = it,
                    type = INFER_TYPE
                ) {
                    this.referer = mainUrl
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }
}


class Cdnwish : StreamWishExtractor() {
    override var mainUrl = "https://cdnwish.com"
}

class vidhidevip : VidhideExtractor() {
    override var mainUrl = "https://vidhidevip.com"
}

class D000d : DoodLaExtractor() {
    override var mainUrl = "https://d000d.com"
}


class FileMoonnl : Filesim() {
    override val mainUrl = "https://filemoon.nl"
    override val name = "FileMoon"
}



================================================
FILE: Toonstream/src/main/kotlin/com/Toonstream/Toonstream.kt
================================================
package com.Toonstream

import com.lagradost.api.Log
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

class Toonstream : MainAPI() {
    override var mainUrl              = "https://toonstream.one"
    override var name                 = "Toonstream"
    override val hasMainPage          = true
    override var lang                 = "hi"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Anime,TvType.Cartoon)

    override val mainPage = mainPageOf(
        "series" to "Series",
        "movies" to "Movies",
        "category/cartoon" to "Cartoon",
        "category/anime" to "Animes"
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/page/$page/").documentLarge
        val home     = document.select("#movies-a > ul > li").mapNotNull { it.toSearchResult() }
        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("article  > header > h2").text().trim().replace("Watch Online","")
        val href      = fixUrl(this.select("article  > a").attr("href"))
        val posterUrlRaw = this.select("article  > div.post-thumbnail > figure > img").attr("src")
        val poster:String = if (posterUrlRaw.startsWith("http")) { posterUrlRaw } else "https:$posterUrlRaw"
        return newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = poster
            }
    }

    private fun Element.toSearch(): SearchResponse {
        val title     = this.select("article  > header > h2").text().trim().replace("Watch Online","")
        val href      = fixUrl(this.select("article  > a").attr("href"))
        val posterUrlRaw = this.select("article figure img").attr("src")
        val poster:String = if (posterUrlRaw.startsWith("http")) { posterUrlRaw } else "https:$posterUrlRaw"

        return newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = poster
            }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/page/$i/?s=$query").documentLarge

            val results = document.select("#movies-a > ul > li").mapNotNull { it.toSearch() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title       = document.selectFirst("header.entry-header > h1")?.text()?.trim().toString().replace("Watch Online","")
        val posterraw = document.select("div.bghd > img").attr("src")
        val poster:String = if (posterraw.startsWith("http")) { posterraw } else "https:$posterraw"
        val description = document.selectFirst("div.description > p")?.text()?.trim()
        val tvtag=if (url.contains("series")) TvType.TvSeries else TvType.Movie
        return if (tvtag == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            document.select("div.aa-drp.choose-season > ul > li > a").forEach { info->
                val data_post=info.attr("data-post")
                val data_season=info.attr("data-season")
                val season=app.post("$mainUrl/wp-admin/admin-ajax.php", data = mapOf(
                    "action" to "action_select_season",
                    "season" to data_season,
                    "post" to data_post
                ), headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                ).documentLarge
                    season.select("article").forEach {
                        val href = it.selectFirst("article >a")?.attr("href") ?:""
                        val posterRaw=it.selectFirst("article > div.post-thumbnail > figure > img")?.attr("src")
                        val poster1="https:$posterRaw"
                        val episode = it.select("article > header.entry-header > h2").text()
                        val seasonnumber=season.toString().substringAfter("<span class=\"num-epi\">").substringBefore("x").toIntOrNull()
                        episodes.add(
                            newEpisode(href)
                            {
                                this.name=episode
                                this.posterUrl=poster1
                                this.season=seasonnumber
                            })
                    }
            }
            newTvSeriesLoadResponse(title, url, TvType.Anime, episodes) {
                this.posterUrl = poster
                this.plot = description
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
            }
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select("#aa-options > div > iframe").forEach {
            val serverlink=it.attr("data-src")
            val truelink= app.get(serverlink).documentLarge.selectFirst("iframe")?.attr("src") ?:""
            Log.d("Phisher",truelink)
            loadExtractor(truelink,subtitleCallback, callback)
        }
        return true
    }
}

class Zephyrflick : AWSStream() {
    override val name = "Zephyrflick"
    override val mainUrl = "https://play.zephyrflick.top"
    override val requiresReferer = true
}

open class AWSStream : ExtractorApi() {
    override val name = "AWSStream"
    override val mainUrl = "https://z.awstream.net"
    override val requiresReferer = true

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val extractedHash = url.substringAfterLast("/")
        val doc = app.get(url).documentLarge
        val m3u8Url = "$mainUrl/player/index.php?data=$extractedHash&do=getVideo"
        val header = mapOf("x-requested-with" to "XMLHttpRequest")
        val formdata = mapOf("hash" to extractedHash, "r" to mainUrl)
        val response = app.post(m3u8Url, headers = header, data = formdata).parsedSafe<Response>()
        response?.videoSource?.let { m3u8 ->
            callback(
                newExtractorLink(
                    name,
                    name,
                    url = m3u8,
                    type = ExtractorLinkType.M3U8
                ) {
                    this.referer = ""
                    this.quality = Qualities.P1080.value
                }
            )
            val extractedPack = doc.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().orEmpty()

            JsUnpacker(extractedPack).unpack()?.let { unpacked ->
                Regex(""""kind":\s*"captions"\s*,\s*"file":\s*"(https.*?\.srt)""")
                    .find(unpacked)
                    ?.groupValues
                    ?.get(1)
                    ?.let { subtitleUrl ->
                        subtitleCallback.invoke(
                            newSubtitleFile(
                                "English",
                                subtitleUrl
                            )
                        )
                    }
            }
        }
    }

    data class Response(
        val hls: Boolean,
        val videoImage: String,
        val videoSource: String,
        val securedLink: String,
        val downloadLinks: List<Any?>,
        val attachmentLinks: List<Any?>,
        val ck: String,
    )
}



================================================
FILE: Toonstream/src/main/kotlin/com/Toonstream/ToonstreamProvider.kt
================================================
package com.Toonstream

import com.lagradost.cloudstream3.extractors.EmturbovidExtractor
import com.lagradost.cloudstream3.extractors.GDMirrorbot
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.Vidmolyme

@CloudstreamPlugin
class ToonstreamProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Toonstream())
        registerExtractorAPI(StreamSB8())
        registerExtractorAPI(Vidmolyme())
        registerExtractorAPI(Streamruby())
        registerExtractorAPI(D000d())
        registerExtractorAPI(vidhidevip())
        registerExtractorAPI(Cdnwish())
        registerExtractorAPI(FileMoonnl())
        registerExtractorAPI(Cloudy())
        registerExtractorAPI(GDMirrorbot())
        registerExtractorAPI(EmturbovidExtractor())
        registerExtractorAPI(Zephyrflick())
    }
}


================================================
FILE: ToonTales/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "ToonTales"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Cartoon")
    iconUrl="https://www.toontales.net/wp-content/themes/toontales/images/logo.png"

    isCrossPlatform = true
}



================================================
FILE: ToonTales/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: ToonTales/src/main/kotlin/com/ToonTales/ToonTales.kt
================================================
package com.ToonTales

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

class ToonTales : MainAPI() {
    override var mainUrl              = "https://www.toontales.net"
    override var name                 = "ToonTales"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Cartoon)

    override val mainPage = mainPageOf(
        "series/popeye-the-sailor/" to " Popeye the Sailor",
        "series/the-pink-panther-show" to "The Pink Panther Show",
        "series/tom-and-jerry" to "Tom and Jerry",
        "series/disney" to "Disney",
        "series/looney-tunes" to "Looney Tunes",
        "series/merrie-melodies" to "Merrie Melodies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/?page=$page").documentLarge
        val home     = document.select("section > div.item").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("a > img").attr("alt")
        val href      = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("a > img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/?s=$query&paged=$i").documentLarge

            val results = document.select("#movies-a > ul > li").mapNotNull { it.toSearchResult() }

            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    @Suppress("SuspiciousIndentation")
    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url, referer = url).documentLarge
        val title       = document.selectFirst("meta[property=og:title]")?.attr("content")?.trim().toString()
        val poster = document.selectFirst("meta[property=og:image]")?.attr("content")?.trim().toString()
        val description = document.selectFirst("meta[property=og:description]")?.attr("content")?.trim().toString()
            return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        val file=document.selectFirst("script:containsData(file)")?.data().toString().substringAfter("file: \"").substringBefore("\"")

        callback.invoke(
            newExtractorLink(
                name = name,
                source = name,
                url = file,
                type = INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName("")
            }
        )
        return true
    }
}



================================================
FILE: ToonTales/src/main/kotlin/com/ToonTales/ToonTalesProvider.kt
================================================
package com.ToonTales

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class ToonTalesProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(ToonTales())
    }
}


================================================
FILE: Topcartoons/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Top Cartoon"
    language    = "hi"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Cartoon")
    iconUrl="https://www.topcartoons.tv/wp-content/uploads/logo.png"

    isCrossPlatform = true
}



================================================
FILE: Topcartoons/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Topcartoons/src/main/kotlin/com/Topcartoons/Topcartoons.kt
================================================
package com.Topcartoons

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

class Topcartoons : MainAPI() {
    override var mainUrl              = "https://www.topcartoons.tv"
    override var name                 = "Topcartoons"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Cartoon)

    override val mainPage = mainPageOf(
        "serie" to " Shows",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}").documentLarge
        val home     = document.select("article").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("a > img").attr("alt")
        val href      = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("a img").attr("data-src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
            val document = app.get("${mainUrl}/?s=$query").documentLarge
            val results = document.select("article").mapNotNull { it.toSearchResult() }
            return results
    }

    @Suppress("SuspiciousIndentation")
    override suspend fun load(url: String): LoadResponse {
        val request = app.get(url)
        val document = request.documentLarge
        val title =document.selectFirst("div.header-content h1")?.text()?.trim().toString()
        val poster = document.select("a.blog-img img").attr("data-src")
        val description = document.selectFirst("div.entry-content")?.text()

         val episodes = mutableListOf<Episode>()
            document.select("article article").map {
                    val href = it.select("a").attr("href")
                    val name = fixTitle(it.select("h3 a").text().trim())
                    val ps = it.selectFirst("a img")?.attr("data-src").toString().trim()
                episodes.add(newEpisode(href){
                    this.name=name
                    this.posterUrl=ps
                })
                }
        return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.plot=description
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        val file=document.selectFirst("meta[property=og:video:url]")?.attr("content").toString()
        callback.invoke(
            newExtractorLink(
                name = name,
                source = name,
                url = file,
                type = INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName("")
            }
        )

        return true
    }
}



================================================
FILE: Topcartoons/src/main/kotlin/com/Topcartoons/TopcartoonsProvider.kt
================================================
package com.Topcartoons

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class TopcartoonsProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(Topcartoons())
    }
}


================================================
FILE: Topstreamfilm/build.gradle.kts
================================================
// use an integer for version numbers
version = 6

cloudstream {
    description ="Filme  and Serien (German)"
    authors = listOf("Phisher")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries"
    )
    language = "de"

    iconUrl = "https://www.topstreamfilm.live/templates/topstreamfilm/images/logo-1.png"

    isCrossPlatform = true
}



================================================
FILE: Topstreamfilm/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />



================================================
FILE: Topstreamfilm/src/main/kotlin/com/Topstreamfilm/Extractor.kt
================================================
package com.Topstreamfilm

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.getAndUnpack


open class SuperVideo : ExtractorApi() {
    override val name = "SuperVideo"
    override val mainUrl = "https://supervideo.tv"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val res = app.get(url.replace("tv","cc"),referer=referer)
        val script =
            res.documentLarge.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data()
        val unpacked = getAndUnpack(script ?: return)
        val m3u8 =Regex("file:\"(.*?m3u8.*?)").find(unpacked)?.groupValues?.getOrNull(1) ?:""
        M3u8Helper.generateM3u8(
            this.name,
            m3u8,
            referer = "$mainUrl/",
        ).forEach(callback)
    }
}

//still in Development

open class Dropload : ExtractorApi() {
    override val name = "Dropload"
    override val mainUrl = "https://dropload.io"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val res = app.get(url)
        val script =res.documentLarge.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data()
        val unpacked = JsUnpacker(script).unpack().toString()
        val m3u8 =Regex("file:\"(.*?m3u8.*?)\"").find(unpacked)?.groupValues?.getOrNull(1) ?:""
        val headers= mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36")
        M3u8Helper.generateM3u8(
            this.name,
            m3u8,
            referer = "$mainUrl/",
            headers = headers
        ).forEach(callback)
    }
}


================================================
FILE: Topstreamfilm/src/main/kotlin/com/Topstreamfilm/Topstreamfilm.kt
================================================
package com.Topstreamfilm

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.httpsify
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.utils.loadExtractor

class TopStreamFilm : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl = "https://www.topstreamfilm.live"
    override var name = "TopStreamFilm"
    override val hasMainPage = true
    override var lang = "de"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override val mainPage = mainPageOf(
        "" to "Home",
        "serien" to "Series",
        "filme-online-sehen" to "Movies/Series",
        )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url ="$mainUrl/${request.data}/page/$page"
        val document = app.get(url).documentLarge
        val home = document.select("article").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    @Suppress("SuspiciousIndentation")
    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3")?.text()?.trim() ?: return null
        val href = this.selectFirst("a")?.attr("href") ?: return null
        val posterUrl = fixUrlNull(this.selectFirst("a img")?.attr("data-src"))
        val quality =getQualityFromString(this.select("span.Qlty").text())

            return newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?story=$query&do=search&subaction=search").documentLarge
        return document.select("article").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("h1.Title")?.text() ?:return null
        val plot = document.select("div.Description p:nth-child(2)").text()
        val poster = fixUrlNull(document.select("article div.TPostBg img.TPostBg").attr("data-src"))
        val year=document.selectFirst("span.Date.AAIco-date_range")?.text()?.toIntOrNull()
        val tags=document.select("ul li.AAIco-adjust:contains(Genre) a").map { it.text() }
        val rating=document.select("ul li.AAIco-adjust:contains(Rating) span").text()
        val checkSeason=document.selectFirst("div.tt_season")?.text()
        val type=if (checkSeason!=null) TvType.TvSeries else TvType.Movie
        return if (type==TvType.TvSeries)
        {
            val episodes = mutableListOf<Episode>()
            document.select("div.su-accordion div.cu-ss").amap { it ->
                    val name = it.text().substringAfter(" ").substringBefore(" – ").trim()
                    val href = it.select("a").map {
                        it.attr("href")
                    }.toString()
                    val ep =name.substringAfter("Episode").trim().toIntOrNull()
                    val season = it.text().substringBefore("x").trim().toIntOrNull()
                    episodes.add(
                        newEpisode(href)
                        {
                            this.episode=ep
                            this.name=name
                            this.season=season
                        }
                    ).toJson()
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.tags = tags
                this.score = Score.from10(rating)
            }
        }
        else
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.tags=tags
            this.year = year
            this.score = Score.from10(rating)
            this.posterUrl = poster
            this.plot=plot

        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data.startsWith("["))
        {
            val urls = extractUrlsWithMapNotNull(data)
            urls.map {
                loadExtractor(it, subtitleCallback, callback)
            }

        }
        else {
            val iframe = app.get(data).documentLarge.select("div.TPlayer iframe").attr("src")
            app.get(iframe).documentLarge.select("ul li").map {
                val href = httpsify(it.attr("data-link"))
                loadExtractor(href, subtitleCallback, callback)
            }
        }
        return true
    }


    fun extractUrlsWithMapNotNull(text: String): List<String> {
        return text
            .removeSurrounding("[", "]")
            .split(",")
            .mapNotNull { part ->
                val url = part.trim()
                if (url.startsWith("http://") || url.startsWith("https://")) url else null
            }
    }

}


================================================
FILE: Topstreamfilm/src/main/kotlin/com/Topstreamfilm/TopstreamfilmPlugin.kt
================================================
package com.Topstreamfilm

import com.lagradost.cloudstream3.extractors.MixDrop
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class TopstreamfilmPlugin : BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TopStreamFilm())
        registerExtractorAPI(SuperVideo())
        registerExtractorAPI(Dropload())
        registerExtractorAPI(MixDrop())
    }
}



================================================
FILE: TorraStream/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 64

android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
    }
}

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "#1 Best Extension – MultiAPI-Based with 4K Torrent Support (Debian) Use Extension Settings"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","Torrent","AsianDrama","TvSeries","Anime")

    iconUrl = "https://torrentio.strem.fun/images/logo_v1.png"
    requiresResources = true
    isCrossPlatform = false
}

dependencies {
    implementation("androidx.appcompat:appcompat:1.7.1")
    implementation("com.google.android.material:material:1.13.0")
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: TorraStream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStream.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import org.json.JSONObject
import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import java.text.SimpleDateFormat
import java.util.Locale

class TorraStream(private val sharedPref: SharedPreferences) : TmdbProvider() {
    override var name = "TorraStream"
    override var mainUrl = "https://torrentio.strem.fun"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama, TvType.Torrent)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Trakt)
    override val hasMainPage = true
    override val hasQuickSearch = false

    companion object {
        const val OnethreethreesevenxAPI = "https://proxy.phisher2.workers.dev/?url=https://1337x.to"
        const val MediafusionApi = "https://mediafusion.elfhosted.com/D-_ru4-xVDOkpYNgdQZ-gA6whxWtMNeLLsnAyhb82mkks4eJf4QTlrAksSeBnwFAbIGWQLaokCGFxxsHupxSVxZO8xhhB2UYnyc5nnLeDnIqiLajtkmaGJMB_ZHqMqSYIU2wcGhrw0s4hlXeRAfnnbDywHCW8DLF_ZZfOXYUGPzWS-91cvu7kA2xPs0lJtcqZO"
        const val ThePirateBayApi = "https://thepiratebay-plus.strem.fun"
        const val AIOStreams = "https://aiostreams.elfhosted.com/E2-xLzptGhmwLnA9L%2FOUHyZJg%3D%3D-Io2cJBStOrbqlmGwGz2ZwBbMGBj5enyJFgN5XcslkuiUS5KSjJrv90yd4HHLj1fyq6hJm7QpnCxDiPqbeOwdGA2yySllUQh2T%2B5qPqgtPt2sWBN5zdeetbiFFLHvVqq0PZOhKGM7pv2LzCoMLAk%2BSo86mcrzWIeszmvHuRMoKX3zBO6hUDvH6oqK2hFfbUF7ZONMdm9jE7lHp0LuXKPzHSwKUvDZroJ9iRgBkvHIGjJL65oBv2PxfQK%2Fu4gYEuLVhH3dQ7Xu6i1AshdxycCPRQOO2LcDDZkBC84zLXoy3DDPkvDkWBv2icVZIs2dnQlwvtfu7fFiXaGxWJxtYvbBALIhey8SaaeCKts8xMEyuJvSZiKBbkiTblb0NbqfRyGoJz5rJkiCPzlnX6S%2BpNHKNXVYRj2QZmmvN47fdteAZfhvCuNRW1XBP%2FhTr5ufzCQ9tC8ao%2F4ZhoVXPje45mgPpeJy%2FqYGkX36%2BDgjUMGM1SIvm416pHFL1fVG9MQlIdTn2T4VaUHA0dZHXxznaSQDB%2F1GIkDCHOp2iWUl8zceINOE08AI%2BUwmWCnVXsvsXYaTbFnsE%2F0n1zQwN19ULRCnO4AN2KKLfWKHCz9q5YwQG6y9r%2BXTkjtAXoju764x1f2UlFZT8aavjX1oAcPiTC5vA%3D%3D"
        const val PeerflixApi = "https://peerflix.mov"
        const val CometAPI = "https://comet.elfhosted.com"
        const val SubtitlesAPI = "https://opensubtitles-v3.strem.io"
        const val AnimetoshoAPI = "https://feed.animetosho.org"
        const val TorrentioAnimeAPI = "https://torrentio.strem.fun/providers=nyaasi,tokyotosho,anidex%7Csort=seeders"
        const val TorboxAPI= "https://stremio.torbox.app"
        val TRACKER_LIST_URL = listOf(
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best.txt",
            "https://raw.githubusercontent.com/ngosang/trackerslist/refs/heads/master/trackers_best_ip.txt",
        )
        private const val Uindex = "https://uindex.org"
        private const val Knaben = "https://knaben.org"
        private const val tmdbAPI = "https://api.themoviedb.org/3"
        private const val apiKey = "1865f43a0549ca50d341dd9ab8b29f49"

        fun getType(t: String?): TvType {
            return when (t) {
                "movie" -> TvType.Movie
                else -> TvType.TvSeries
            }
        }

        fun getStatus(t: String?): ShowStatus {
            return when (t) {
                "Returning Series" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage = mainPageOf(
        "$tmdbAPI/trending/all/day?api_key=$apiKey&region=US" to "Trending",
        "$tmdbAPI/trending/movie/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular Movies",
        "$tmdbAPI/trending/tv/week?api_key=$apiKey&region=US&with_original_language=en" to "Popular TV Shows",
        "$tmdbAPI/tv/airing_today?api_key=$apiKey&region=US&with_original_language=en" to "Airing Today TV Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=213" to "Netflix",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=1024" to "Amazon",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2739" to "Disney+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=453" to "Hulu",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=2552" to "Apple TV+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=49" to "HBO",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=4330" to "Paramount+",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_networks=3353" to "Peacock",
        "$tmdbAPI/discover/movie?api_key=$apiKey&language=en-US&page=1&sort_by=popularity.desc&with_origin_country=IN&release_date.gte=${getDate().lastWeekStart}&release_date.lte=${getDate().today}" to "Trending Indian Movies",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().today}&air_date.gte=${getDate().today}" to "Airing Today Anime",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_keywords=210024|222243&sort_by=popularity.desc&air_date.lte=${getDate().nextWeek}&air_date.gte=${getDate().today}" to "On The Air Anime",
        "$tmdbAPI/discover/movie?api_key=$apiKey&with_keywords=210024|222243" to "Anime Movies",
        "$tmdbAPI/movie/top_rated?api_key=$apiKey&region=US" to "Top Rated Movies",
        "$tmdbAPI/tv/top_rated?api_key=$apiKey&region=US" to "Top Rated TV Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_original_language=ko" to "Korean Shows",
        "$tmdbAPI/discover/tv?api_key=$apiKey&with_genres=99" to "Documentary",
    )

    private fun getImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    private fun getOriImageUrl(link: String?): String? {
        if (link == null) return null
        return if (link.startsWith("/")) "https://image.tmdb.org/t/p/original/$link" else link
    }

    override suspend fun getMainPage(
        page: Int, request: MainPageRequest
    ): HomePageResponse {
        val adultQuery =
            if (settingsForProvider.enableAdult) "" else "&without_keywords=190370|13059|226161|195669|190370"
        val type = if (request.data.contains("/movie")) "movie" else "tv"
        val home = app.get("${request.data}$adultQuery&page=$page")
            .parsedSafe<Results>()?.results?.mapNotNull { media ->
                media.toSearchResponse(type)
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(type: String? = null): SearchResponse? {
        return newMovieSearchResponse(
            title ?: name ?: originalTitle ?: return null,
            Data(id = id, type = mediaType ?: type).toJson(),
            TvType.Movie,
        ) {
            this.posterUrl = getImageUrl(posterPath)
            this.score= Score.from10(voteAverage)
        }
    }

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        return app.get(
            "$tmdbAPI/search/multi?api_key=$apiKey&language=en-US&query=$query&page=$page&include_adult=${settingsForProvider.enableAdult}"
        ).parsedSafe<Results>()?.results?.mapNotNull { media ->
            media.toSearchResponse()
        }?.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse? {
        val data = parseJson<Data>(url)
        val type = getType(data.type)
        val resUrl = if (type == TvType.Movie) {
            "$tmdbAPI/movie/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        } else {
            "$tmdbAPI/tv/${data.id}?api_key=$apiKey&append_to_response=keywords,credits,external_ids,videos,recommendations"
        }
        val res = app.get(resUrl).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json Response")

        val title = res.title ?: res.name ?: return null
        val poster = getOriImageUrl(res.posterPath)
        val bgPoster = getOriImageUrl(res.backdropPath)
        val releaseDate = res.releaseDate ?: res.firstAirDate
        val year = releaseDate?.split("-")?.first()?.toIntOrNull()
        val genres = res.genres?.mapNotNull { it.name }
        val isAnime =
            genres?.contains("Animation") == true && (res.original_language == "zh" || res.original_language == "ja")
        val keywords = res.keywords?.results?.mapNotNull { it.name }.orEmpty()
            .ifEmpty { res.keywords?.keywords?.mapNotNull { it.name } }

        val actors = res.credits?.cast?.mapNotNull { cast ->
            ActorData(
                Actor(
                    cast.name ?: cast.originalName ?: return@mapNotNull null,
                    getImageUrl(cast.profilePath)
                ), roleString = cast.character
            )
        } ?: return null
        val recommendations =
            res.recommendations?.results?.mapNotNull { media -> media.toSearchResponse() }

        val trailer =
            res.videos?.results?.map { "https://www.youtube.com/watch?v=${it.key}" }?.randomOrNull()

        return if (type == TvType.TvSeries) {
            val episodes = res.seasons?.mapNotNull { season ->
                app.get("$tmdbAPI/${data.type}/${data.id}/season/${season.seasonNumber}?api_key=$apiKey")
                    .parsedSafe<MediaDetailEpisodes>()?.episodes?.map { eps ->
                        newEpisode(LoadData(
                            res.title,
                            year,
                            isAnime,
                            res.external_ids?.imdb_id,
                            eps.seasonNumber,
                            eps.episodeNumber
                        ).toJson())
                        {
                            this.name = eps.name + if (isUpcoming(eps.airDate)) " • [UPCOMING]" else ""
                            this.season = eps.seasonNumber
                            this.episode = eps.episodeNumber
                            this.posterUrl = getImageUrl(eps.stillPath)
                            this.score = Score.from10(eps.voteAverage)
                            this.description = eps.overview
                            this.addDate(eps.airDate)
                        }
                    }
            }?.flatten() ?: listOf()

            newTvSeriesLoadResponse(
                title, url, if (isAnime) TvType.Anime else TvType.TvSeries, episodes
            ) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.tags =  keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.showStatus = getStatus(res.status)
                this.recommendations = recommendations
                this.actors = actors
                this.episodes = episodes
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addImdbId(res.external_ids?.imdb_id)
            }
        } else {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                LoadData(res.title,year,isAnime,res.external_ids?.imdb_id).toJson()
            ) {
                this.posterUrl = poster
                this.comingSoon = isUpcoming(releaseDate)
                this.backgroundPosterUrl = bgPoster
                this.year = year
                this.plot = res.overview
                this.duration = res.runtime
                this.tags = keywords.takeIf { !it.isNullOrEmpty() } ?: genres
                this.score = Score.from10(res.vote_average.toString())
                this.recommendations = recommendations
                this.actors = actors
                //this.contentRating = fetchContentRating(data.id, "US")
                addTrailer(trailer)
                addImdbId(res.external_ids?.imdb_id)
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val provider = sharedPref.getString("debrid_provider", null)
        val key = sharedPref.getString("debrid_key", null)
        val dataObj = parseJson<LoadData>(data)
        val isAnime = dataObj.isAnime
        val title = dataObj.title
        val season = dataObj.season
        var episode = dataObj.episode
        val id = dataObj.imdbId
        val year = dataObj.year
        val anijson = app.get("https://api.ani.zip/mappings?imdb_id=$id").toString()
        val mappings = runCatching {
            val response = app.get("https://api.ani.zip/mappings?imdb_id=$id")
            JSONObject(response.text).optJSONObject("mappings")
        }.getOrNull()

        val isMovie = mappings
            ?.optString("type", "")
            ?.contains("MOVIE", ignoreCase = true) == true

        episode = if (isMovie) 1 else episode
        val anidbEid = getAnidbEid(anijson, episode) ?: 0

        suspend fun runAllAsync(vararg tasks: suspend () -> Unit) {
            coroutineScope {
                tasks.map { async { it() } }.awaitAll()
            }
        }

        val apiUrl = buildApiUrl(sharedPref, mainUrl)

        if (provider == "AIO Streams" && !key.isNullOrEmpty()) {
            runAllAsync(
                { invokeAIOStreamsDebian(key, id, season, episode, callback) }
            )
        }

        if (provider == "TorBox" && !key.isNullOrEmpty()) {
            runAllAsync(
                { invokeDebianTorbox(TorboxAPI, key, id, season, episode, callback) }
            )
        }

        if (!key.isNullOrEmpty()) {
            runAllAsync(
                { invokeTorrentioDebian(apiUrl, id, season, episode, callback) }
            )
        } else {
            runAllAsync(
                { invokeTorrentio(apiUrl, id, season, episode, callback) },
                { invokeThepiratebay(ThePirateBayApi, id, season, episode, callback) },
                { if (dataObj.isAnime) invokeAnimetosho(anidbEid, callback) },
                { if (dataObj.isAnime) invokeTorrentioAnime(TorrentioAnimeAPI, id, season, episode, callback) },
                { invokeUindex(Uindex, title, year, season, episode, callback) },
                { invokeKnaben(Knaben, isAnime, title, year, season, episode, callback) },
                { invokeSubtitleAPI(id, season, episode, subtitleCallback) }
            )
        }



        // Subtitles
        val subApiUrl = "https://opensubtitles-v3.strem.io"
        val url = if (season == null) "$subApiUrl/subtitles/movie/$id.json"
        else "$subApiUrl/subtitles/series/$id:$season:$episode.json"

        val headers = mapOf(
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )

        app.get(url, headers = headers, timeout = 100L)
            .parsedSafe<Subtitles>()?.subtitles?.amap {
                val lan = getLanguage(it.lang) ?: it.lang
                subtitleCallback(
                    newSubtitleFile(
                        lan,
                        it.url
                    )
                )
            }

        return true
    }


    private fun getStatus(t: String?): ShowStatus {
        return when (t) {
            "returning series" -> ShowStatus.Ongoing
            "continuing" -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }


    private fun isUpcoming(dateString: String?): Boolean {
        return try {
            val format = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
            val dateTime = dateString?.let { format.parse(it)?.time } ?: return false
            unixTimeMS < dateTime
        } catch (t: Throwable) {
            logError(t)
            false
        }
    }

    private fun fixPath(url: String?): String? {
        url ?: return null
        return "https://$url"
    }
    private fun buildApiUrl(sharedPref: SharedPreferences, mainUrl: String): String {
        val sort = sharedPref.getString("sort", "qualitysize")
        val languageOption = sharedPref.getString("language", "")
        val qualityFilter = sharedPref.getString("qualityfilter", "")
        val limit = sharedPref.getString("limit", "")
        val sizeFilter = sharedPref.getString("sizefilter", "")
        val debridProvider = sharedPref.getString("debrid_provider", "") // e.g., "easydebrid"
        val debridKey = sharedPref.getString("debrid_key", "") // e.g., "12345abc"

        val params = mutableListOf<String>()
        if (!sort.isNullOrEmpty()) params += "sort=$sort"
        if (!languageOption.isNullOrEmpty()) params += "language=${languageOption.lowercase()}"
        if (!qualityFilter.isNullOrEmpty()) params += "qualityfilter=$qualityFilter"
        if (!limit.isNullOrEmpty()) params += "limit=$limit"
        if (!sizeFilter.isNullOrEmpty()) params += "sizefilter=$sizeFilter"

        if (!debridProvider.isNullOrEmpty() && !debridKey.isNullOrEmpty()) {
            params += "$debridProvider=$debridKey"
        }

        val query = params.joinToString("%7C")
        return "$mainUrl/$query"
    }
}

suspend fun generateMagnetLink(
    trackerUrls: List<String>,
    hash: String?,
): String {
    require(hash?.isNotBlank() == true)

    val trackers = mutableSetOf<String>()

    trackerUrls.forEach { url ->
        try {
            val response = app.get(url)
            response.text
                .lineSequence()
                .map { it.trim() }
                .filter { it.isNotEmpty() && !it.startsWith("#") }
                .forEach { trackers.add(it) }
        } catch (_: Exception) {
            // ignore bad sources
        }
    }

    return buildString {
        append("magnet:?xt=urn:btih:").append(hash)

        if (hash.isNotBlank()) {
            append("&dn=")
            append(URLEncoder.encode(hash, StandardCharsets.UTF_8.name()))
        }

        trackers
            .take(10) // practical limit
            .forEach { tracker ->
                append("&tr=")
                append(URLEncoder.encode(tracker, StandardCharsets.UTF_8.name()))
            }
    }
}




================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStreamAnime.kt
================================================
package com.phisher98

import android.content.SharedPreferences
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.CommonActivity.activity
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.ShowStatus
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.runAllAsync
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import com.phisher98.TorraStream.Companion.TorboxAPI
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import java.util.Calendar

open class TorraStreamAnime(private val sharedPref: SharedPreferences) : MainAPI() {
    override var name = "TorraStream-Anime"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.aniListApi)
    private val apiUrl = "https://graphql.anilist.co"
    private val anilistAPI = "https://graphql.anilist.co"
    private val mediaLimit = 20
    private val isAdult = false
    private val headerJSON =
        mapOf("Accept" to "application/json", "Content-Type" to "application/json")
    private val torrentioDebian= "https://torrentio.strem.fun"

    private fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun anilistAPICall(query: String): AnilistAPIResponse {
        val data = mapOf("query" to query)
        val test = app.post(apiUrl, headers = headerJSON, data = data)
        val res =
            test.parsedSafe<AnilistAPIResponse>()
                ?: throw Exception("Unable to fetch or parse Anilist api response")
        return res
    }

    private fun Media.toSearchResponse(): SearchResponse {
        val title = this.title.english ?: this.title.romaji ?: ""
        val url = "$mainUrl/anime/${this.id}"
        val posterUrl = this.coverImage.large
        val rating = this.averageScore
        return newAnimeSearchResponse(title, url, TvType.Anime) {
            this.posterUrl = posterUrl
            this.score= Score.from100(rating)
        }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
        page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val res = anilistAPICall(this.data.replace("###", "$page"))
        val data =
            res.data.page?.media?.map { it.toSearchResponse() }
                ?: throw Exception("Unable to read media data")
        val hasNextPage = res.data.page.pageInfo.hasNextPage ?: false
        return data to hasNextPage
    }
    private val currentYear = Calendar.getInstance().get(Calendar.YEAR)

    override val mainPage =
        mainPageOf(
            "query (\$page: Int = ###, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Trending Now",
            "query (\$page: Int = ###, \$seasonYear: Int = $currentYear, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, seasonYear: \$seasonYear, season: SPRING, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Popular This Season",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "All Time Popular",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [SCORE_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters averageScore title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Top 100 Anime",
            "Personal" to "Personal"
        )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res =
            anilistAPICall(
                "query (\$search: String = \"$query\") { Page(page: 1, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(search: \$search, isAdult: $isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }"
            )
        return res.data.page?.media?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                ?: return newHomePageResponse(
                    "Login required for personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            val homePageList =
                repo.library().getOrThrow()!!.allLibraryLists.mapNotNull {
                    if (it.items.isEmpty()) return@mapNotNull null
                    val libraryName =
                        it.name.asString(activity ?: return@mapNotNull null)
                    HomePageList("${request.name}: $libraryName", it.items)
                }
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is
            // overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data = anilistAPICall(
            "query (\$id: Int = $id) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore status bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val anititle = data.getTitle()
        val aniyear = data.startDate.year
        val anitype = if (data.format!!.contains("MOVIE", ignoreCase = true)) TvType.AnimeMovie else TvType.TvSeries
        val ids = tmdbToAnimeId(anititle, aniyear, anitype)
        val posterurl = data.coverImage.extraLarge
        val backgroundUrl = data.bannerImage

        val jpTitle = data.title.romaji
        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=${ids.id}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)
        val logoposter = animeMetaData?.images?.find { it.coverType == "Clearlogo" }?.url

        val href = LinkData(
            malId = ids.idMal,
            aniId = ids.id,
            title = data.getTitle(),
            jpTitle = jpTitle,
            year = data.startDate.year,
            isAnime = true
        ).toStringData()

        // --- Helper to get best episode title ---
        fun resolveTitle(epData: MetaEpisode?): String {
            val jsonTitle = epData?.title?.get("en")
                ?: epData?.title?.get("ja")
                ?: epData?.title?.get("x-jat")
                ?: animeMetaData?.titles?.get("en")
                ?: animeMetaData?.titles?.get("ja")
                ?: animeMetaData?.titles?.get("x-jat")
                ?: ""
            return jsonTitle.ifBlank { "Episode ${epData?.episode ?: ""}" }
        }

        fun createEpisode(i: Int): Episode {
            val epData = animeMetaData?.episodes?.get(i.toString())
            val linkData = LinkData(
                malId = ids.idMal,
                aniId = ids.id,
                title = data.getTitle(),
                jpTitle = jpTitle,
                year = data.startDate.year,
                season = 1,
                episode = i,
                isAnime = true,
            ).toStringData()

            return newEpisode(linkData) {
                this.season = 1
                this.episode = i
                this.name = resolveTitle(epData)
                this.posterUrl = epData?.image ?: animeMetaData?.images?.firstOrNull()?.url ?: ""
                this.description = epData?.overview ?: "No summary available"
                this.score = Score.from10(epData?.rating)
                this.runTime = epData?.runtime
                this.addDate(epData?.airDateUtc)
            }
        }

        val episodes = (1..data.totalEpisodes()).map { createEpisode(it) }

        return if (data.format.contains("Movie",ignoreCase = true)) {
            newMovieLoadResponse(data.getTitle(), url, TvType.AnimeMovie, href) {
                addAniListId(id.toInt())
                addMalId(ids.idMal)
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = backgroundUrl ?: animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl = posterurl ?: animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                    ?: data.getCoverImage()
                try { this.logoUrl = logoposter } catch(_:Throwable){}
                this.tags = data.genres
            }
        } else {
            newAnimeLoadResponse(data.getTitle(), url, TvType.Anime) {
                addAniListId(id.toInt())
                addMalId(ids.idMal)
                addEpisodes(DubStatus.Subbed, episodes)
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl =
                    animeMetaData?.images?.firstOrNull { it.coverType == "Fanart" }?.url
                        ?: data.bannerImage
                this.posterUrl = animeMetaData?.images
                    ?.firstOrNull { it.coverType.equals("Poster", ignoreCase = true) }
                    ?.url
                    ?: data.getCoverImage()
                try { this.logoUrl = logoposter } catch(_:Throwable){}
                this.tags = data.genres
                this.showStatus = getStatus(data.status)
                this.recommendations = data.recommendations?.edges
                    ?.mapNotNull { edge ->
                        val recommendation = edge.node.mediaRecommendation ?:return@mapNotNull null
                        val title = recommendation.title?.english
                            ?: recommendation.title?.romaji
                            ?:  "Unknown"
                        val recommendationUrl = "$mainUrl/anime/${recommendation.id}"
                        newAnimeSearchResponse(title, recommendationUrl, TvType.Anime).apply {
                            this.posterUrl = recommendation.coverImage?.large
                        }
                    }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val provider = sharedPref.getString("debrid_provider", null)
        val key = sharedPref.getString("debrid_key", null)
        val mediaData = AppUtils.parseJson<LinkData>(data)
        var episode = mediaData.episode
        val aniid = mediaData.aniId
        var kitsuId = -1
        var type = TvType.TvSeries
        var anidbEid: Int? = null

        try {
            val anijson = app.get("https://api.ani.zip/mappings?anilist_id=$aniid").toString()
            val mappings = JSONObject(anijson).optJSONObject("mappings")
            if (mappings != null) {
                kitsuId = mappings.optInt("kitsu_id", -1)
                val rawtype = mappings.optString("type", "")
                if (rawtype.contains("MOVIE", ignoreCase = true)) {
                    type = TvType.Movie
                    episode = 1
                }
            }
            anidbEid = try { getAnidbEid(anijson, episode) } catch (_: Exception) { null }

        } catch (_: Exception) {
        }

        val debianapiUrl = buildApiUrl(sharedPref, torrentioDebian)
        if (!provider.isNullOrEmpty() && !key.isNullOrEmpty()) {
            if (kitsuId != -1) {
                runAllAsync(
                    { invokeTorrentioAnimeDebian(debianapiUrl, type, kitsuId, episode, callback) },
                    { invokeTorboxAnimeDebian(TorboxAPI, key,type, kitsuId, episode, callback) }
                )
            }
        } else {
            runAllAsync(
                { invokeAnimetosho(anidbEid, callback) },
                { if (kitsuId != -1) invokeTorrentioAnime(torrentioDebian, type, kitsuId, episode, callback) }
            )
        }


        return true
    }

    data class AnilistAPIResponse(
        @JsonProperty("data") val data: AnilistData,
    ) {
        data class AnilistData(
            @JsonProperty("Page") val page: AnilistPage?,
            @JsonProperty("Media") val media: anilistMedia?,
        ) {
            data class AnilistPage(
                @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
                @JsonProperty("media") val media: List<Media>,
            )
        }

        data class anilistMedia(
            @JsonProperty("id") val id: Int,
            @JsonProperty("startDate") val startDate: StartDate,
            @JsonProperty("episodes") val episodes: Int?,
            @JsonProperty("title") val title: Title,
            @JsonProperty("season") val season: String?,
            @JsonProperty("genres") val genres: List<String>,
            @JsonProperty("averageScore") val averageScore: Int,
            @JsonProperty("status") val status: String,
            @JsonProperty("description") val description: String?,
            @JsonProperty("coverImage") val coverImage: CoverImage,
            @JsonProperty("bannerImage") val bannerImage: String?,
            @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
            @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
            @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
            @JsonProperty("format") val format: String?,
            ) {
            data class StartDate(@JsonProperty("year") val year: Int)

            data class AiringScheduleNodes(
                @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
            )

            fun totalEpisodes(): Int {
                return nextAiringEpisode?.episode?.minus(1)
                    ?: episodes ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                    ?: 0
            }

            fun getTitle(): String {
                return title.english
                    ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
            }

            fun getCoverImage(): String? {
                return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
            }
        }
    }

    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: Int? = null,
        @JsonProperty("malId") val malId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
        @JsonProperty("isDub") val isDub: Boolean = false,
    )


    data class Media(
        @JsonProperty("id") val id: Int,
        @JsonProperty("idMal") val idMal: Int?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("seasonYear") val seasonYear: Int,
        @JsonProperty("format") val format: String?,
        @JsonProperty("averageScore") val averageScore: Int,
        @JsonProperty("episodes") val episodes: Int,
        @JsonProperty("title") val title: Title,
        @JsonProperty("description") val description: String?,
        @JsonProperty("coverImage") val coverImage: CoverImage,
        @JsonProperty("synonyms") val synonyms: List<String>,
        @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
    )

    private suspend fun tmdbToAnimeId(title: String?, year: Int?, type: TvType): AniIds {
        if (title.isNullOrBlank()) return AniIds(null, null)

        val query = """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}seasonYear: Int
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              seasonYear: ${'$'}seasonYear
              format_in: ${'$'}format
            ) {
              id
              idMal
            }
          }
        }
    """.trimIndent()

        val variables = mutableMapOf(
            "search" to title,
            "sort" to listOf("SEARCH_MATCH"),
            "type" to "ANIME",
            "format" to listOf(
                if (type == TvType.AnimeMovie) "MOVIE" else "TV",
                "ONA",
                "OVA"
            )
        )

        val data = mapOf(
            "query" to query,
            "variables" to variables
        ).toJson().toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val res = app.post(anilistAPI, requestBody = data)
            .parsedSafe<AniSearch>()
            ?.data
            ?.let { it.Page?.media ?: it.media }
            ?.firstOrNull()

        return AniIds(res?.id, res?.idMal)
    }

    data class AniIds(var id: Int? = null, var idMal: Int? = null)

    data class AniMedia(
        @JsonProperty("id") var id: Int? = null,
        @JsonProperty("idMal") var idMal: Int? = null
    )

    data class AniPage(
        @JsonProperty("media") var media: ArrayList<AniMedia> = arrayListOf()
    )

    data class AniData(
        @JsonProperty("Page") var Page: AniPage? = null,
        @JsonProperty("media") var media: ArrayList<AniMedia>? = null
    )

    data class AniSearch(
        @JsonProperty("data") var data: AniData? = null
    )

    private fun buildApiUrl(sharedPref: SharedPreferences, mainUrl: String): String {
        val sort = sharedPref.getString("sort", "qualitysize")
        val languageOption = sharedPref.getString("language", "")
        val qualityFilter = sharedPref.getString("qualityfilter", "")
        val limit = sharedPref.getString("limit", "")
        val sizeFilter = sharedPref.getString("sizefilter", "")
        val debridProvider = sharedPref.getString("debrid_provider", "") // e.g., "easydebrid"
        val debridKey = sharedPref.getString("debrid_key", "") // e.g., "12345abc"

        val params = mutableListOf<String>()
        if (!sort.isNullOrEmpty()) params += "sort=$sort"
        if (!languageOption.isNullOrEmpty()) params += "language=${languageOption.lowercase()}"
        if (!qualityFilter.isNullOrEmpty()) params += "qualityfilter=$qualityFilter"
        if (!limit.isNullOrEmpty()) params += "limit=$limit"
        if (!sizeFilter.isNullOrEmpty()) params += "sizefilter=$sizeFilter"

        if (!debridProvider.isNullOrEmpty() && !debridKey.isNullOrEmpty()) {
            params += "$debridProvider=$debridKey"
        }

        val query = params.joinToString("%7C")
        return "$mainUrl/$query"
    }

    fun getStatus(t: String?): ShowStatus {
        return when {
            t?.contains("Returning", ignoreCase = true) == true -> ShowStatus.Ongoing
            t?.contains("RELEASING", ignoreCase = true) == true -> ShowStatus.Ongoing
            else -> ShowStatus.Completed
        }
    }
}


================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStreamExtractor.kt
================================================
package com.phisher98

import android.util.Log
import com.phisher98.TorraStream.Companion.AnimetoshoAPI
import com.phisher98.TorraStream.Companion.SubtitlesAPI
import com.phisher98.TorraStream.Companion.TRACKER_LIST_URL
import com.google.gson.Gson
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import java.util.Locale

suspend fun invokeTorrentio(
    mainUrl:String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
        val torrentioAPI:String = mainUrl
        val url = if(season == null) {
            "$torrentioAPI/stream/movie/$id.json"
        }
        else {
            "$torrentioAPI/stream/series/$id:$season:$episode.json"
        }
        val headers = mapOf(
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )
        val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val formattedTitleName = stream.title
            ?.let { title ->
                val qualityTermsRegex = "(2160p|1080p|720p|WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)".toRegex(RegexOption.IGNORE_CASE)
                val tagsList = qualityTermsRegex.findAll(title).map { it.value.uppercase() }.toList()
                val tags = tagsList.distinct().joinToString(" | ")

                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\n]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"

                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        val qualityMatch = "(2160p|1080p|720p)".toRegex(RegexOption.IGNORE_CASE)
            .find(stream.title ?: "")
            ?.value
            ?.lowercase()

        val magnet = generateMagnetLink(TRACKER_LIST_URL, stream.infoHash)

        callback.invoke(
            newExtractorLink(
                "Torrentio",
                formattedTitleName ?: stream.name ?: "",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}


suspend fun invokeTorrentioDebian(
    mainUrl: String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (season == null) {
        "$mainUrl/stream/movie/$id.json"
    } else {
        "$mainUrl/stream/series/$id:$season:$episode.json"
    }
    val res = app.get(url).parsedSafe<DebianRoot>()
    res?.streams?.forEach { stream ->
        val fileUrl = stream.url

        val size = Regex("""(\d+(?:[.,]\d+)?)\s*(GB|MB)""", RegexOption.IGNORE_CASE)
            .find(stream.title)
            ?.let { m -> "${m.groupValues[1].replace(',', '.')} ${m.groupValues[2].uppercase()}" }

        val seedersNum = Regex("""(\d+)$""").find(stream.title)?.groupValues?.get(1)

        val name = stream.behaviorHints.filename ?: stream.title.substringBefore("\n")
        val cache = Regex("""\[(.*?)]""").find(stream.name)?.groupValues?.get(1)
        val formattedName = name
            .substringBeforeLast('.')
            .replace('.', ' ')
            .trim()

        val parts = listOfNotNull(
            size?.let { "📦 $it" },
            seedersNum?.let { "🌱 $it" }
        )

        val suffix = if (parts.isNotEmpty()) " | ${parts.joinToString(" | ")}" else ""

        val finalTitle = "Torrentio+ | [$cache] | $formattedName$suffix"

        callback.invoke(
            newExtractorLink(
                "Torrentio+ [$cache]",
                finalTitle,
                url = fileUrl,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(stream.name)
            }
        )
    }
}


suspend fun invokeTorrentioAnimeDebian(
    mainUrl: String,
    type: TvType,
    id: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (type == TvType.Movie) {
        "$mainUrl/stream/movie/kitsu:$id.json"
    } else {
        "$mainUrl/stream/series/kitsu:$id:$episode.json"
    }
    val res = app.get(url).parsedSafe<DebianRoot>()
    res?.streams?.forEach { stream ->
        val fileUrl = stream.url

        val size = Regex("""(\d+(?:[.,]\d+)?)\s*(GB|MB)""", RegexOption.IGNORE_CASE)
            .find(stream.title)
            ?.let { m -> "${m.groupValues[1].replace(',', '.')} ${m.groupValues[2].uppercase()}" }

        val seedersNum = Regex("""(\d+)$""").find(stream.title)?.groupValues?.get(1)

        val name = stream.behaviorHints.filename ?: stream.title.substringBefore("\n")
        val cache = Regex("""\[(.*?)]""").find(stream.name)?.groupValues?.get(1)
        val formattedName = name
            .substringBeforeLast('.')
            .replace('.', ' ')
            .trim()

        val parts = listOfNotNull(
            size?.let { "📦 $it" },
            seedersNum?.let { "🌱 $it" }
        )

        val suffix = if (parts.isNotEmpty()) " | ${parts.joinToString(" | ")}" else ""

        val finalTitle = "Torrentio+ Anime | [$cache] | $formattedName$suffix"

        callback.invoke(
            newExtractorLink(
                "Torrentio+ [$cache]",
                finalTitle,
                url = fileUrl,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(stream.name)
            }
        )
    }
}


suspend fun invokeTorrentioAnime(
    mainUrl: String,
    type: TvType,
    id: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (type == TvType.Movie) {
        "$mainUrl/stream/movie/kitsu:$id.json"
    } else {
        "$mainUrl/stream/series/kitsu:$id:$episode.json"
    }
    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val formattedTitleName = stream.title
            ?.let { title ->
                val qualityTermsRegex = "(2160p|1080p|720p|WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)".toRegex(RegexOption.IGNORE_CASE)
                val tagsList = qualityTermsRegex.findAll(title).map { it.value.uppercase() }.toList()
                val tags = tagsList.distinct().joinToString(" | ")

                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\n]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"

                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        val qualityMatch = "(2160p|1080p|720p)".toRegex(RegexOption.IGNORE_CASE)
            .find(stream.title ?: "")
            ?.value
            ?.lowercase()

        val magnet = generateMagnetLink(TRACKER_LIST_URL, stream.infoHash)
        callback.invoke(
            newExtractorLink(
                "Torrentio",
                formattedTitleName ?: stream.name ?: "",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getQualityFromName(qualityMatch)
            }
        )

    }
}


suspend fun invoke1337x(
    OnethreethreesevenxAPI: String? = null,
    title: String? = null,
    year: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    app.get("$OnethreethreesevenxAPI/category-search/${title?.replace(" ", "+")}+$year/Movies/1/")
        .documentLarge.select("tbody > tr > td a:nth-child(2)").amap {
            val iframe = OnethreethreesevenxAPI + it.attr("href")
            val doc = app.get(iframe).documentLarge

            val magnet = doc.select("#openPopup").attr("href").trim()
            val qualityRaw = doc.select("div.box-info ul.list li:contains(Type) span").text()
            val quality = getQuality(qualityRaw)

            val size = doc.select("div.box-info ul.list li:contains(Total size) span").text()
            val language = doc.select("div.box-info ul.list li:contains(Language) span").text()
            val seeders = doc.select("div.box-info ul.list li:contains(Seeders) span.seeds").text()

            val displayName = buildString {
                append("Torrent1337x $qualityRaw")
                if (size.isNotBlank()) append(" | Size: $size")
                if (language.isNotBlank()) append(" | Lang: $language")
                if (seeders.isNotBlank()) append(" | 🟢$seeders")
            }

            callback.invoke(
                newExtractorLink(
                    "Torrent1337x",
                    displayName,
                    url = magnet,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = quality
                }
            )
        }
}


suspend fun invokeMediaFusion(
    mediaFusionApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$mediaFusionApi/stream/movie/$imdbId.json"
        }
        else {
            "$mediaFusionApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<MediafusionResponse>()
        for(stream in res?.streams!!)
        {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            val qualityFromName = getIndexQuality(stream.name)

            callback.invoke(
                newExtractorLink(
                    "MediaFusion",
                    stream.description,
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = qualityFromName
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokeThepiratebay(
    thepiratebayApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$thepiratebayApi/stream/movie/$imdbId.json"
        }
        else {
            "$thepiratebayApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<TBPResponse>()
        for(stream in res?.streams!!)
        {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            callback.invoke(
                newExtractorLink(
                    "ThePirateBay",
                    "ThePirateBay [${stream.title}]",
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.title)
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokePeerFlix(
    peerflixApi: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if (season == null) {
            "$peerflixApi/stream/movie/$imdbId.json"
        } else {
            "$peerflixApi/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<PeerflixResponse>()
        for (stream in res?.streams!!) {
            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash).trim()
            callback.invoke(
                newExtractorLink(
                    "Peerflix",
                    stream.name,
                    url = magnetLink,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.description)
                }
            )
        }
    } catch (_: Exception) {
    }
}


suspend fun invokeComet(
    CometAPI: String? = null,
    imdbId: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    try {
        val url = if(season == null) {
            "$CometAPI/stream/movie/$imdbId.json"
        }
        else {
            "$CometAPI/stream/series/$imdbId:$season:$episode.json"
        }
        val res = app.get(url, timeout = 10).parsedSafe<MediafusionResponse>()
        for(stream in res?.streams!!)
        {
            val formattedTitleName = stream.description.let { title ->
                val tags = "\\[(.*?)]".toRegex()
                    .findAll(title)
                    .map { it.groupValues[1] }
                    .joinToString(" | ")
                    .takeIf { it.isNotBlank() }

                val quality = "💿\\s*([^\n]+)".toRegex()
                    .find(title)
                    ?.groupValues?.getOrNull(1)
                    ?.trim()
                    ?.takeIf { it.isNotEmpty() && it != "Unknown" }

                val provider = "🔎\\s*([^\n]+)".toRegex()
                    .find(title)
                    ?.groupValues?.getOrNull(1)
                    ?.trim()
                    ?.takeIf { it.isNotEmpty() && it != "Unknown" }

                buildString {
                    append("Comet")
                    if (!tags.isNullOrEmpty()) append(" | $tags")
                    if (!quality.isNullOrEmpty()) append(" | Quality: $quality")
                    if (!provider.isNullOrEmpty()) append(" | Provider: $provider")
                }
            }

            val magnetLink = generateMagnetLink(TRACKER_LIST_URL,stream.infoHash)
            callback.invoke(
                newExtractorLink(
                    "Comet",
                    formattedTitleName,
                    url = magnetLink,
                    ExtractorLinkType.MAGNET
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(stream.description)
                }
            )
        }
    } catch (_: Exception) { }
}

suspend fun invokeSubtitleAPI(
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    subtitleCallback: (SubtitleFile) -> Unit,
) {
    val url = if (season == null) {
        "$SubtitlesAPI/subtitles/movie/$id.json"
    } else {
        "$SubtitlesAPI/subtitles/series/$id:$season:$episode.json"
    }
    val headers = mapOf(
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    app.get(url, headers = headers, timeout = 100L)
        .parsedSafe<SubtitlesAPI>()?.subtitles?.amap { it ->
            val lan = getLanguage(it.lang) ?:"Unknown"
            val suburl = it.url
            subtitleCallback.invoke(
                newSubtitleFile(
                    lan.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },  // Use label for the name
                    suburl     // Use extracted URL
                )
            )
        }
}

suspend fun invokeAnimetosho(
    id: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = "$AnimetoshoAPI/json?eid=$id&qx=1&q=!(%22DTS%22%7C%22TrueHD%22)((e*%7Ca*%7Cr*%7Ci*%7Co*%7C%221080%22)%20!%22540%22%20!%22480%22)%22%0D%0A"
    val jsonResponse = app.get(url).toString()
    val parsedList = Gson().fromJson(jsonResponse, Array<AnimetoshoItem>::class.java)?.toList() ?: emptyList()
    parsedList.sortedByDescending { it.seeders }.forEach { item ->
        item.magnetUri.let { magnet ->
            val formattedTitleName = item.torrentName
                .let { title ->
                    val tags = "\\[(.*?)]".toRegex().findAll(title)
                        .map { match -> "[${match.groupValues[1]}]" }
                        .joinToString(" | ")
                    val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: ""
                    "Animetosho | $tags | Seeder: $seeder".trim()
                }
            callback.invoke(
                newExtractorLink(
                    "Animetosho",
                    formattedTitleName,
                    url = magnet,
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = getIndexQuality(item.torrentName)
                }
            )
        }
    }
}

suspend fun invokeTorrentioAnime(
    mainUrl:String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val torrentioAPI:String = mainUrl
    val url = if(season == null) {
        "$torrentioAPI/stream/movie/$id.json"
    }
    else {
        "$torrentioAPI/stream/series/$id:$season:$episode.json"
    }
    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )
    val res = app.get(url, headers = headers, timeout = 100L).parsedSafe<TorrentioResponse>()
    res?.streams?.forEach { stream ->
        val magnet = generateMagnetLink(TRACKER_LIST_URL, stream.infoHash)
        val formattedTitleName = stream.title
            ?.let { title ->
                val tags = "\\[(.*?)]".toRegex().findAll(title)
                    .map { match -> "[${match.groupValues[1]}]" }
                    .joinToString(" | ")
                val seeder = "👤\\s*(\\d+)".toRegex().find(title)?.groupValues?.get(1) ?: "0"
                val provider = "⚙️\\s*([^\\\\]+)".toRegex().find(title)?.groupValues?.get(1)?.trim() ?: "Unknown"
                "Torrentio | $tags | Seeder: $seeder | Provider: $provider".trim()
            }

        callback.invoke(
            newExtractorLink(
                "Torrentio ",
                formattedTitleName ?: "Torrentio",
                url = magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(stream.name)
            }
        )
    }
}

suspend fun invokeAIOStreamsDebian(
    mainUrl:String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val mainurl = if (season == null) {
        "${mainUrl.substringBeforeLast("/manifest.json")}/stream/movie/$id.json"
    } else {
        "${mainUrl.substringBeforeLast("/manifest.json")}/stream/series/$id:$season:$episode.json"
    }
    app.get(mainurl).parsedSafe<AIODebian>()?.streams?.map {
        val qualityRegex = Regex("""\b(4K|2160p|1080p|720p|WEB[-\s]?DL|BluRay|HDRip|DVDRip)\b""", RegexOption.IGNORE_CASE)
        val qualityMatch = qualityRegex.find(it.name)?.value ?: "Unknown"
        callback.invoke(
            newExtractorLink(
                "Torrentio AIO Debian ${getIndexQuality(qualityMatch)}",
                it.behaviorHints.filename,
                it.url,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(qualityMatch)
            }
        )
    }
}

suspend fun invokeAIOStreams(
    mainUrl:String,
    id: String? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val mainurl = if (season == null) {
        "$mainUrl/stream/movie/$id.json"
    } else {
        "$mainUrl/stream/series/$id:$season:$episode.json"
    }
    val json= app.get(mainurl).toString()
    val magnetLink = parseStreamsToMagnetLinks(json)
    magnetLink.forEach {
        callback.invoke(
            newExtractorLink(
                "Torrentio AIO ${it.title}",
                it.title,
                it.magnet,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(it.quality)
            }
        )
    }
}

suspend fun invokeDebianTorbox(
    torBoxAPI: String,
    key: String,
    id: String? =null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (season == null) {
        "$torBoxAPI/$key/stream/movie/$id.json"
    } else {
        "$torBoxAPI/$key/stream/series/$id:$season:$episode.json"
    }

    val response = app.get(url, timeout = 10_000).parsedSafe<TorBoxDebian>() ?: return

    response.streams.forEach { stream ->

        val resolution = extractResolutionFromDescription(stream.description)

        val sourceName = stream.name
            .substringBeforeLast("(")
            .trim()
            .ifBlank { "TorBox" }

        val cache = Regex("""\((.*?)\)""").find(stream.name)
            ?.groupValues?.get(1)
            ?.takeIf { it == "Instant" }
            ?: "TorBox Download"

        val displayName = buildString {
            append("TorBox+ | [$cache] | ")
            val rawName = stream.behaviorHints.filename
            val baseName = rawName
                .substringBeforeLast(".")
                .replace(".", " ")
                .trim()

            if (baseName.isNotBlank())
                append(baseName)

            // --- filesize ---
            val fileSize = Regex("Size:\\s*([^|\\n]+)")
                .find(stream.description)
                ?.groupValues?.get(1)
                ?.trim()
            if (!fileSize.isNullOrBlank())
                append(" | 📦 $fileSize")

            // --- seeders ---
            val seeders = Regex("Seeders:\\s*(\\d+)")
                .find(stream.description)
                ?.groupValues?.get(1)
                ?.trim()
            if (!seeders.isNullOrBlank())
                append(" | 🌱 $seeders")

        }.trim()


        callback(
            newExtractorLink(
                "$sourceName [$cache]",
                displayName,
                url = stream.url,
                INFER_TYPE
            ).apply {
                referer = ""
                this.quality = getQualityFromName(resolution)
            }
        )
    }

}


suspend fun invokeUindex(
    uindex: String,
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val isTv = season != null

    val searchQuery = buildString {
        if (!title.isNullOrBlank()) append(title)
        if (year != null) {
            if (isNotEmpty()) append(' ')
            append(year)
        }
    }.replace(' ', '+')

    val url = "$uindex/search.php?search=$searchQuery&c=${if (isTv) 2 else 1}"

    val headers = mapOf(
        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
        "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
    )

    val rows = app.get(url, headers = headers).documentLarge.select("tr")

    val episodePatterns: List<Regex> = if (isTv && episode != null) {
        val rawPatterns = listOf(
            String.format(Locale.US, "S%02dE%02d", season, episode),
            "S${season}E$episode",
            String.format(Locale.US, "S%02dE%d", season, episode),
            String.format(Locale.US, "S%dE%02d", season, episode),
        )

        rawPatterns.distinct().map {
            Regex("\\b$it\\b", RegexOption.IGNORE_CASE)
        }
    } else {
        emptyList()
    }

    rows.amap { row ->
        val rowTitle = row.select("td:nth-child(2) > a:nth-child(2)").text()
        val magnet = row.select("td:nth-child(2) > a:nth-child(1)").attr("href")

        if (rowTitle.isBlank() || magnet.isBlank()) return@amap

        if (isTv && episodePatterns.isNotEmpty()) {
            if (episodePatterns.none { it.containsMatchIn(rowTitle) }) return@amap
        }

        val qualityMatch = "(2160p|1080p|720p)"
            .toRegex(RegexOption.IGNORE_CASE)
            .find(rowTitle)
            ?.value

        val seeder = row
            .select("td:nth-child(4) > span")
            .text()
            .replace(",", "")
            .ifBlank { "0" }

        val fileSize = row.select("td:nth-child(3)").text()

        val formattedTitleName = run {
            val qualityTermsRegex =
                "(WEBRip|WEB-DL|x265|x264|10bit|HEVC|H264)"
                    .toRegex(RegexOption.IGNORE_CASE)

            val tags = qualityTermsRegex.findAll(rowTitle)
                .map { it.value.uppercase() }
                .distinct()
                .joinToString(" | ")

            "UIndex | $tags | Seeder: $seeder | FileSize: $fileSize".trim()
        }

        callback.invoke(
            newExtractorLink(
                "UIndex",
                formattedTitleName.ifBlank { rowTitle },
                url = magnet,
                type = INFER_TYPE
            ) {
                this.quality = getQualityFromName(qualityMatch)
            }
        )
    }
}

suspend fun invokeKnaben(
    knaben: String,
    isAnime: Boolean,
    title: String? = null,
    year: Int? = null,
    season: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val isTv = season != null
    val host = knaben.trimEnd('/')

    val baseQuery = buildString {
        val queryText = title?.takeIf { it.isNotBlank() } ?: return@buildString

        append(
            queryText
                .trim()
                .replace("\\s+".toRegex(), "+")
        )

        if (isTv && episode != null) {
            append("+S${season.toString().padStart(2, '0')}")
            append("E${episode.toString().padStart(2, '0')}")
        } else if (!isTv && year != null) {
            append("+$year")
        }
    }

    if (baseQuery.isBlank()) return

    val category = when {
        isAnime -> "6000000"
        isTv -> "2000000"
        else -> "3000000"
    }

    for (page in 1..2) {
        val url = "$host/search/$baseQuery/$category/$page/seeders"

        val doc = app.get(url).document

        doc.select("tr.text-nowrap.border-start").forEach { row ->
            val infoTd = row.selectFirst("td:nth-child(2)") ?: return@forEach

            val titleElement = infoTd.selectFirst("a[title]") ?: return@forEach
            val rawTitle = titleElement.attr("title").ifBlank { titleElement.text() }

            val magnet = infoTd.selectFirst("a[href^=magnet:?]")?.attr("href") ?: return@forEach

            val source = row
                .selectFirst("td.d-sm-none.d-xl-table-cell a")
                ?.text()
                ?.trim()
                .orEmpty()

            val tds = row.select("td")
            val sizeText = tds.getOrNull(2)?.text().orEmpty()
            val seedsText = tds.getOrNull(4)?.text().orEmpty()
            val seeds = seedsText.toIntOrNull() ?: 0
            val qualityMatch = "(2160p|1080p|720p)"
                .toRegex(RegexOption.IGNORE_CASE)
                .find(rawTitle)
                ?.value
            val formattedTitleName = buildString {
                append("Knaben | ")
                append(rawTitle)

                if (seeds > 0) {
                    append(" | Seeds: ")
                    append(seeds)
                }

                if (sizeText.isNotBlank()) {
                    append(" | ")
                    append(sizeText)
                }

                if (source.isNotBlank()) {
                    append(" | ")
                    append(source)
                }
            }

            callback(
                newExtractorLink(
                    "Knaben",
                    formattedTitleName.ifBlank { rawTitle },
                    url = magnet,
                    type = INFER_TYPE
                ) {
                    this.quality = getQualityFromName(qualityMatch)
                }
            )
        }
    }
}



suspend fun invokeTorboxAnimeDebian(
    mainUrl: String,
    key: String,
    type: TvType,
    id: Int? = null,
    episode: Int? = null,
    callback: (ExtractorLink) -> Unit
) {
    val url = if (type == TvType.Movie) {
        "$mainUrl/$key/stream/movie/kitsu:$id.json"
    } else {
        "$mainUrl/$key/stream/series/kitsu:$id:$episode.json"
    }
    val res = app.get(url, timeout = 10_000).parsedSafe<DebianRoot>()
    res?.streams?.forEach { stream ->
        val fileUrl = stream.url

        val size = Regex("""(\d+(?:[.,]\d+)?)\s*(GB|MB)""", RegexOption.IGNORE_CASE)
            .find(stream.title)
            ?.let { m -> "${m.groupValues[1].replace(',', '.')} ${m.groupValues[2].uppercase()}" }

        val seedersNum = Regex("""(\d+)$""").find(stream.title)?.groupValues?.get(1)

        val name = stream.behaviorHints.filename ?: stream.title.substringBefore("\n")

        val formattedName = name
            .substringBeforeLast('.')
            .replace('.', ' ')
            .trim()
        val cache = Regex("""\((.*?)\)""").find(stream.name)
            ?.groupValues?.get(1)
            ?.takeIf { it == "Instant" }
            ?: "TorBox Download"

        val parts = listOfNotNull(
            size?.let { "📦 $it" },
            seedersNum?.let { "🌱 $it" }
        )

        val suffix = if (parts.isNotEmpty()) " | ${parts.joinToString(" | ")}" else ""

        val finalTitle = "TorBox+ Anime | [$cache] | $formattedName$suffix"

        callback.invoke(
            newExtractorLink(
                "TorBox+ [$cache]",
                finalTitle,
                url = fileUrl,
                INFER_TYPE
            ) {
                this.referer = ""
                this.quality = getIndexQuality(stream.name)
            }
        )
    }
}



================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStreamParser.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.annotations.SerializedName


//TorBox

data class TorBoxDebian(
    val streams: List<TorBoxDebianStream>,
)

data class TorBoxDebianStream(
    val name: String,
    val description: String,
    val behaviorHints: TorBoxDebianBehaviorHints,
    val url: String,
)

data class TorBoxDebianBehaviorHints(
    val notWebReady: Boolean,
    val videoSize: Long,
    val filename: String,
    val bingeGroup: String,
    val videoHash: String?,
)


data class MediafusionResponse(
    val streams: List<MediafusionStream>,
)

data class MediafusionStream(
    val name: String,
    val description: String,
    val infoHash: String,
    val fileIdx: Long?,
    val behaviorHints: MediafusionBehaviorHints,
    val sources: List<String>,
)

data class MediafusionBehaviorHints(
    val bingeGroup: String,
    val filename: String,
    val videoSize: Long,
)

data class TBPResponse(
    val streams: List<TBPStream>,
    val cacheMaxAge: Long,
    val staleRevalidate: Long,
    val staleError: Long,
)

data class TBPStream(
    val name: String,
    val title: String,
    val infoHash: String,
    val tag: String,
)

data class PeerflixResponse(
    val streams: List<PeerflixStream>,
)

data class PeerflixStream(
    val name: String,
    val description: String,
    val infoHash: String,
    val sources: List<String>,
    val fileIdx: Long?,
    val language: String,
    val quality: String,
    val seed: Long,
    val sizebytes: Long?,
)

data class SubtitlesAPI(
    val subtitles: List<Subtitle1>,
    val cacheMaxAge: Long,
)

data class Subtitle1(
    val id: String,
    val url: String,
    @JsonProperty("SubEncoding")
    val subEncoding: String,
    val lang: String,
    val m: String,
    val g: String,
)

data class AnimetoshoItem(
    val id: Long,
    val title: String,
    val link: String,
    val timestamp: Long,
    val status: String,
    @SerializedName("tosho_id")
    val toshoId: Long?,
    @SerializedName("nyaa_id")
    val nyaaId: Long,
    @SerializedName("nyaa_subdom")
    val nyaaSubdom: Any?,
    @SerializedName("anidex_id")
    val anidexId: Any?,
    @SerializedName("torrent_url")
    val torrentUrl: String,
    @SerializedName("torrent_name")
    val torrentName: String,
    @SerializedName("info_hash")
    val infoHash: String,
    @SerializedName("info_hash_v2")
    val infoHashV2: Any?,
    @SerializedName("magnet_uri")
    val magnetUri: String,
    val seeders: Long,
    val leechers: Long,
    @SerializedName("torrent_downloaded_count")
    val torrentDownloadedCount: Long,
    @SerializedName("tracker_updated")
    val trackerUpdated: Long?,
    @SerializedName("nzb_url")
    val nzbUrl: String,
    @SerializedName("total_size")
    val totalSize: Long,
    @SerializedName("num_files")
    val numFiles: Long,
    @SerializedName("anidb_aid")
    val anidbAid: Long,
    @SerializedName("anidb_eid")
    val anidbEid: Long,
    @SerializedName("anidb_fid")
    val anidbFid: Long?,
    @SerializedName("article_url")
    val articleUrl: Any?,
    @SerializedName("article_title")
    val articleTitle: Any?,
    @SerializedName("website_url")
    val websiteUrl: String?
)
data class AIO(
    val streams: List<AIOStream>,
)

data class AIOStream(
    val url: String,
    val name: String,
    val description: String,
    val behaviorHints: AIOBehaviorHints,
)

data class AIOBehaviorHints(
    val videoSize: Long,
    val filename: String,
    val bingeGroup: String,
)

data class MagnetStream(
    val title: String,
    val quality: String,
    val magnet: String
)



data class AIODebian(
    val streams: List<AIODebianStream>,
)

data class AIODebianStream(
    val name: String,
    val description: String,
    val url: String,
    val behaviorHints: AIODebianBehaviorHints,
    val streamData: AIODebianStreamData,
)

data class AIODebianBehaviorHints(
    val videoSize: Long,
    val filename: String,
)

data class AIODebianStreamData(
    val type: String,
    val proxied: Boolean,
    val indexer: String,
    val duration: Long,
    val library: Boolean,
    val size: Long,
    val torrent: AIODebianTorrent,
    val addon: String,
    val filename: String,
    val service: Service,
    val parsedFile: ParsedFile,
    val id: String,
    val folderName: String?,
)

data class AIODebianTorrent(
    val infoHash: String,
    val seeders: Long,
)

data class Service(
    val id: String,
    val cached: Boolean,
)

data class ParsedFile(
    val title: String,
    val year: String,
    val resolution: String,
    val quality: String,
    val encode: String?,
    val releaseGroup: String?,
    val seasonEpisode: List<Any?>,
    val visualTags: List<String>,
    val audioTags: List<String>,
    val audioChannels: List<String>,
    val languages: List<String>,
)


data class LoadData(
    val title: String? = null,
    val year: Int? =null,
    val isAnime: Boolean = false,
    val imdbId: String? = null,
    val season: Int? = null,
    val episode: Int? = null,
)

data class Data(
    val id: Int? = null,
    val type: String? = null,
    val aniId: String? = null,
    val malId: Int? = null,
)

data class Results(
    @param:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
)

data class Media(
    @param:JsonProperty("id") val id: Int? = null,
    @param:JsonProperty("name") val name: String? = null,
    @param:JsonProperty("title") val title: String? = null,
    @param:JsonProperty("original_title") val originalTitle: String? = null,
    @param:JsonProperty("media_type") val mediaType: String? = null,
    @param:JsonProperty("poster_path") val posterPath: String? = null,
    @param:JsonProperty("vote_average") val voteAverage: Double? = null,
)

data class Genres(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
)

data class Keywords(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
)

data class KeywordResults(
    @get:JsonProperty("results") val results: ArrayList<Keywords>? = arrayListOf(),
    @get:JsonProperty("keywords") val keywords: ArrayList<Keywords>? = arrayListOf(),
)

data class Seasons(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("season_number") val seasonNumber: Int? = null,
    @get:JsonProperty("air_date") val airDate: String? = null,
)

data class Cast(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("original_name") val originalName: String? = null,
    @get:JsonProperty("character") val character: String? = null,
    @get:JsonProperty("known_for_department") val knownForDepartment: String? = null,
    @get:JsonProperty("profile_path") val profilePath: String? = null,
)

data class Episodes(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("overview") val overview: String? = null,
    @get:JsonProperty("air_date") val airDate: String? = null,
    @get:JsonProperty("still_path") val stillPath: String? = null,
    @get:JsonProperty("vote_average") val voteAverage: Double? = null,
    @get:JsonProperty("episode_number") val episodeNumber: Int? = null,
    @get:JsonProperty("season_number") val seasonNumber: Int? = null,
    @get:JsonProperty("runtime") val runTime: Int? = null
)

data class MediaDetailEpisodes(
    @get:JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
)

data class Trailers(
    @get:JsonProperty("key") val key: String? = null,
    @get:JsonProperty("type") val type: String? = null,
)

data class ResultsTrailer(
    @get:JsonProperty("results") val results: ArrayList<Trailers>? = arrayListOf(),
)

data class AltTitles(
    @get:JsonProperty("iso_3166_1") val iso_3166_1: String? = null,
    @get:JsonProperty("title") val title: String? = null,
    @get:JsonProperty("type") val type: String? = null,
)

data class ResultsAltTitles(
    @get:JsonProperty("results") val results: ArrayList<AltTitles>? = arrayListOf(),
)

data class ExternalIds(
    @get:JsonProperty("imdb_id") val imdb_id: String? = null,
    @get:JsonProperty("tvdb_id") val tvdb_id: Int? = null,
)

data class Credits(
    @get:JsonProperty("cast") val cast: ArrayList<Cast>? = arrayListOf(),
)

data class ResultsRecommendations(
    @get:JsonProperty("results") val results: ArrayList<Media>? = arrayListOf(),
)

data class LastEpisodeToAir(
    @get:JsonProperty("episode_number") val episode_number: Int? = null,
    @get:JsonProperty("season_number") val season_number: Int? = null,
)

data class ProductionCountries(
    @get:JsonProperty("name") val name: String? = null,
)

data class MediaDetail(
    @get:JsonProperty("id") val id: Int? = null,
    @get:JsonProperty("imdb_id") val imdbId: String? = null,
    @get:JsonProperty("title") val title: String? = null,
    @get:JsonProperty("name") val name: String? = null,
    @get:JsonProperty("original_title") val originalTitle: String? = null,
    @get:JsonProperty("original_name") val originalName: String? = null,
    @get:JsonProperty("poster_path") val posterPath: String? = null,
    @get:JsonProperty("backdrop_path") val backdropPath: String? = null,
    @get:JsonProperty("release_date") val releaseDate: String? = null,
    @get:JsonProperty("first_air_date") val firstAirDate: String? = null,
    @get:JsonProperty("overview") val overview: String? = null,
    @get:JsonProperty("runtime") val runtime: Int? = null,
    @get:JsonProperty("vote_average") val vote_average: Any? = null,
    @get:JsonProperty("original_language") val original_language: String? = null,
    @get:JsonProperty("status") val status: String? = null,
    @get:JsonProperty("genres") val genres: ArrayList<Genres>? = arrayListOf(),
    @get:JsonProperty("keywords") val keywords: KeywordResults? = null,
    @get:JsonProperty("last_episode_to_air") val last_episode_to_air: LastEpisodeToAir? = null,
    @get:JsonProperty("seasons") val seasons: ArrayList<Seasons>? = arrayListOf(),
    @get:JsonProperty("videos") val videos: ResultsTrailer? = null,
    @get:JsonProperty("external_ids") val external_ids: ExternalIds? = null,
    @get:JsonProperty("credits") val credits: Credits? = null,
    @get:JsonProperty("recommendations") val recommendations: ResultsRecommendations? = null,
    @get:JsonProperty("alternative_titles") val alternative_titles: ResultsAltTitles? = null,
    @get:JsonProperty("production_countries") val production_countries: ArrayList<ProductionCountries>? = arrayListOf(),
)

data class TmdbDate(
    val today: String,
    val nextWeek: String,
    val lastWeekStart: String,
    val monthStart: String
)


================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStreamProvider.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import com.phisher98.settings.SettingsFragment

@CloudstreamPlugin
class TorraStreamProvider: Plugin() {
    override fun load(context: Context) {
        val sharedPref = context.getSharedPreferences("TorraStream", Context.MODE_PRIVATE)
        registerMainAPI(TorraStream(sharedPref))
        registerMainAPI(TorraStreamAnime(sharedPref))

        openSettings = { ctx ->
            val activity = ctx as AppCompatActivity
            val frag = SettingsFragment(this, sharedPref)
            frag.show(activity.supportFragmentManager, "Frag")
        }
    }
}



================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/TorraStreamUtils.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.json.JSONObject
import java.net.URLEncoder
import java.text.SimpleDateFormat
import java.util.Calendar
import java.util.Date
import java.util.Locale

fun getIndexQuality(str: String?): Int {
    return Regex("(\\d{3,4})[pP]").find(str ?: "") ?. groupValues ?. getOrNull(1) ?. toIntOrNull()
        ?: Qualities.Unknown.value
}


fun getQuality(str: String): Int {
    return when (str) {
        "360p" -> Qualities.P240.value
        "480p" -> Qualities.P360.value
        "HD" -> Qualities.P720.value
        "HEVC" -> Qualities.P1440.value
        "UHD" -> Qualities.P2160.value
        else -> getQualityFromName(str)
    }
}

fun getLanguage(language: String?): String? {
    return SubtitleHelper.fromTagToEnglishLanguageName(language ?: return null)
        ?: SubtitleHelper.fromTagToEnglishLanguageName(language.substringBefore("-"))
}


data class TorrentioResponse(
    @SerializedName("streams") val streams: List<TorrentioStream> = emptyList()
)

data class TorrentioStream(
    @SerializedName("name") val name: String? = null,
    @SerializedName("title") val title: String? = null,
    @SerializedName("infoHash") val infoHash: String? = null,
    @SerializedName("fileIdx") val fileIdx: Int? = null
)

data class DebianRoot(
    @SerializedName("streams") val streams: List<Stream> = emptyList(),
    @SerializedName("cacheMaxAge") val cacheMaxAge: Long = 0,
    @SerializedName("staleRevalidate") val staleRevalidate: Long = 0,
    @SerializedName("staleError") val staleError: Long = 0
)

data class Stream(
    @SerializedName("name") val name: String = "",
    @SerializedName("title") val title: String = "",
    @SerializedName("url") val url: String = "",
    @SerializedName("behaviorHints") val behaviorHints: BehaviorHints = BehaviorHints()
)

data class BehaviorHints(
    @SerializedName("bingeGroup") val bingeGroup: String? = null,
    @SerializedName("filename") val filename: String? = null
)

//Subtitles

data class Subtitles(
    val subtitles: List<Subtitle>,
    val cacheMaxAge: Long,
)

data class Subtitle(
    val id: String,
    val url: String,
    @JsonProperty("SubEncoding")
    val subEncoding: String,
    val lang: String,
    val m: String,
    val g: String,
)


fun getAnidbEid(jsonString: String, episodeNumber: Int?): Int? {
    if (episodeNumber == null) return null

    return try {
        val jsonObject = JSONObject(jsonString)
        val episodes = jsonObject.optJSONObject("episodes") ?: return null

        episodes.optJSONObject(episodeNumber.toString())
            ?.optInt("anidbEid", -1)
            ?.takeIf { it != -1 }
    } catch (e: Exception) {
        e.printStackTrace() // Logs the error but prevents breaking the app
        null
    }
}


fun parseAnimeData(jsonString: String): MetaAnimeData? {
    return try {
        val objectMapper = ObjectMapper()
        objectMapper.readValue(jsonString, MetaAnimeData::class.java)
    } catch (_: Exception) {
        null // Return null for invalid JSON instead of crashing
    }
}


@JsonIgnoreProperties(ignoreUnknown = true)
data class ImageData(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaEpisode(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airdate") val airdate: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,
    @JsonProperty("length") val length: Int?,
    @JsonProperty("runtime") val runtime: Int?,
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)


@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>? = null,
    @JsonProperty("images") val images: List<ImageData>? = null,
    @JsonProperty("episodes") val episodes: Map<String, MetaEpisode>? = null,
)

fun parseStreamsToMagnetLinks(jsonString: String): List<MagnetStream> {
    val json = JSONObject(jsonString)
    val streams = json.getJSONArray("streams")

    return (0 until streams.length()).mapNotNull { i ->
        val item = streams.getJSONObject(i)

        val infoHash = item.optString("infoHash")
        if (infoHash.isBlank()) return@mapNotNull null

        val originalName = item.optString("name", "Unnamed")
        val sources = item.optJSONArray("sources") ?: return@mapNotNull null

        val behaviorHints = item.optJSONObject("behaviorHints")
        val bingeGroup = behaviorHints?.optString("bingeGroup").orEmpty()
        bingeGroup.split("|").filter { it.isNotBlank() && it != "Unknown" }

        // Extract quality (simple regex to match "720p", "1080p", "WEB-DL", etc.)
        val qualityRegex = Regex("""\b(4K|2160p|1080p|720p|WEB[-\s]?DL|BluRay|HDRip|DVDRip)\b""", RegexOption.IGNORE_CASE)
        val qualityMatch = qualityRegex.find(originalName)?.value ?: "Unknown"

        // Build magnet link
        val encodedName = URLEncoder.encode(originalName, "UTF-8")
        val trackers = (0 until sources.length()).joinToString("&") {
            val tracker = sources.optString(it)
            "tr=${URLEncoder.encode(tracker, "UTF-8")}"
        }

        val magnet = "magnet:?xt=urn:btih:$infoHash&dn=$encodedName&$trackers"

        MagnetStream(
            title = originalName,
            quality = qualityMatch,
            magnet = magnet
        )
    }
}

fun extractResolutionFromDescription(description: String?): String? {
    if (description.isNullOrBlank()) return null
    val regex = Regex("""\b(2160p|1440p|1080p|720p|480p|360p)\b""", RegexOption.IGNORE_CASE)
    return regex.find(description)?.value
}

fun getDate(): TmdbDate {
    val formatter = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
    val calendar = Calendar.getInstance()

    // Today
    val today = formatter.format(calendar.time)

    // Next week
    calendar.add(Calendar.WEEK_OF_YEAR, 1)
    val nextWeek = formatter.format(calendar.time)

    // Last week's Monday
    calendar.time = Date()
    calendar.set(Calendar.DAY_OF_WEEK, Calendar.MONDAY)
    calendar.add(Calendar.WEEK_OF_YEAR, -1)
    val lastWeekStart = formatter.format(calendar.time)

    // Start of current month
    calendar.time = Date()
    calendar.set(Calendar.DAY_OF_MONTH, 1)
    val monthStart = formatter.format(calendar.time)

    return TmdbDate(today, nextWeek, lastWeekStart, monthStart)
}


================================================
FILE: TorraStream/src/main/kotlin/com/phisher98/settings/SettingsFragment.kt
================================================
package com.phisher98.settings

import android.annotation.SuppressLint
import android.content.Intent
import android.content.SharedPreferences
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.*
import android.widget.*
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import androidx.core.content.edit
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import com.phisher98.TorraStreamProvider

class SettingsFragment(
    private val plugin: TorraStreamProvider,
    private val sharedPref: SharedPreferences
) : BottomSheetDialogFragment() {

    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        return inflater.inflate(res.getLayout(id), container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View?.makeTvCompatible() {
        if (this == null) return
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        if (outlineId != 0) {
            val drawable = res.getDrawable(outlineId, null)
            if (drawable != null) background = drawable
        }
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val root = getLayout("settings", inflater, container)

        // ===== PROVIDERS =====
        val providerTextView = root.findView<TextView>("providers_spinner")
        val providers = listOf(
            "YTS", "EZTV", "RARBG", "1337x", "ThePirateBay", "KickassTorrents",
            "TorrentGalaxy", "MagnetDL", "HorribleSubs", "NyaaSi", "TokyoTosho",
            "AniDex", "Rutor", "RuTracker", "Comando", "BluDV", "Torrent9",
            "ilCorSaRoNeRo", "MejorTorrent", "Wolfmax4k", "Cinecalidad", "BestTorrents"
        )
        val selectedProviders = BooleanArray(providers.size)
        sharedPref.getString("provider", "")?.split(",")?.forEach { saved ->
            val index = providers.indexOf(saved)
            if (index >= 0) selectedProviders[index] = true
        }

        val updateProviderText = {
            val selected = providers.filterIndexed { index, _ -> selectedProviders[index] }
            providerTextView.text =
                if (selected.isEmpty()) "Select Providers" else selected.joinToString(", ")
        }
        updateProviderText()

        providerTextView.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Select Providers")
                .setMultiChoiceItems(providers.toTypedArray(), selectedProviders) { _, which, isChecked ->
                    selectedProviders[which] = isChecked
                }
                .setPositiveButton("OK") { _, _ ->
                    updateProviderText()
                    sharedPref.edit {
                        putString(
                            "provider",
                            providers.filterIndexed { i, _ -> selectedProviders[i] }.joinToString(",")
                        )
                    }
                }
                .setNegativeButton("Cancel", null)
                .show()
        }
        providerTextView.makeTvCompatible()

        // ===== SORT SPINNER =====
        val sortSpinner = root.findView<Spinner>("sort_spinner")
        val sortOptions = listOf("Seeders", "Qualitysize", "Quality", "Size")
        sortSpinner.adapter =
            ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, sortOptions).also {
                it.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            }
        val savedSort = sharedPref.getString("sort", null)
        if (savedSort != null) {
            val pos = sortOptions.indexOf(savedSort)
            if (pos >= 0) sortSpinner.setSelection(pos)
        }
        sortSpinner.makeTvCompatible()

        // ===== LANGUAGES =====
        val languageTextView = root.findView<TextView>("language_spinner")
        val languages = listOf(
            "Japanese", "Russian", "Italian", "Portuguese", "Spanish", "Latino",
            "Korean", "Chinese", "Taiwanese", "French", "German", "Dutch", "Hindi",
            "Telugu", "Tamil", "Polish", "Lithuanian", "Latvian", "Estonian", "Czech",
            "Slovakian", "Slovenian", "Hungarian", "Romanian", "Bulgarian", "Serbian",
            "Croatian", "Ukrainian", "Greek", "Danish", "Finnish", "Swedish",
            "Norwegian", "Turkish", "Arabic", "Persian", "Hebrew", "Vietnamese",
            "Indonesian", "Malay", "Thai"
        )
        val selectedLanguages = BooleanArray(languages.size)
        sharedPref.getString("language", "")?.split(",")?.forEach { saved ->
            val index = languages.indexOf(saved)
            if (index >= 0) selectedLanguages[index] = true
        }

        val updateLanguageText = {
            val selected = languages.filterIndexed { index, _ -> selectedLanguages[index] }
            languageTextView.text =
                if (selected.isEmpty()) "Select Languages"
                else selected.joinToString(", ") { it.replaceFirstChar { c -> c.uppercase() } }
        }
        updateLanguageText()

        languageTextView.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Select Languages")
                .setMultiChoiceItems(languages.toTypedArray(), selectedLanguages) { _, which, isChecked ->
                    selectedLanguages[which] = isChecked
                }
                .setPositiveButton("OK") { _, _ ->
                    updateLanguageText()
                    sharedPref.edit {
                        putString(
                            "language",
                            languages.filterIndexed { index, _ -> selectedLanguages[index] }
                                .joinToString(",")
                        )
                    }
                }
                .setNegativeButton("Cancel", null)
                .show()
        }
        languageTextView.makeTvCompatible()

        // ===== QUALITY FILTER =====
        val qualityTextView = root.findView<TextView>("quality_spinner")
        val qualities = listOf(
            "Brremux", "Hdrall", "Dolbyvision", "Dolbyvisionwithhdr",
            "Threed", "Nonthreed", "4k", "1080p", "720p", "480p",
            "Other", "Scr", "Cam", "Unknown"
        )
        val selectedQualities = BooleanArray(qualities.size)
        sharedPref.getString("qualityfilter", "")?.split(",")?.forEach { saved ->
            val index = qualities.indexOf(saved)
            if (index >= 0) selectedQualities[index] = true
        }

        val updateQualityText = {
            val selected = qualities.filterIndexed { i, _ -> selectedQualities[i] }
            qualityTextView.text =
                if (selected.isEmpty()) "Select Qualities" else selected.joinToString(", ")
        }
        updateQualityText()

        qualityTextView.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Select Qualities")
                .setMultiChoiceItems(qualities.toTypedArray(), selectedQualities) { _, which, isChecked ->
                    selectedQualities[which] = isChecked
                }
                .setPositiveButton("OK") { _, _ ->
                    updateQualityText()
                    sharedPref.edit {
                        putString(
                            "qualityfilter",
                            qualities.filterIndexed { i, _ -> selectedQualities[i] }.joinToString(",")
                        )
                    }
                }
                .setNegativeButton("Cancel", null)
                .show()
        }
        qualityTextView.makeTvCompatible()

        // ===== LIMIT =====
        val limitInput = root.findView<EditText>("limit_input")
        limitInput.setText(sharedPref.getString("limit", ""))
        limitInput.makeTvCompatible()

        // ===== SIZE =====
        val sizeInput = root.findView<EditText>("size_filter_input")
        sizeInput.setText(sharedPref.getString("sizefilter", ""))
        sizeInput.makeTvCompatible()

        // ===== DEBRID PROVIDERS =====
        val debridSpinner = root.findView<Spinner>("debrid_provider_spinner")
        val debridProviders = listOf(
            "None", "RealDebrid", "Premiumize", "AllDebrid", "DebridLink",
            "EasyDebrid", "Offcloud", "TorBox", "Put.io", "AIO Streams"
        )
        debridSpinner.adapter =
            ArrayAdapter(requireContext(), android.R.layout.simple_spinner_item, debridProviders).also {
                it.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
            }
        val savedDebrid = sharedPref.getString("debrid_provider", null)
        if (savedDebrid != null) {
            val pos = debridProviders.indexOf(savedDebrid)
            if (pos >= 0) debridSpinner.setSelection(pos)
        }
        debridSpinner.makeTvCompatible()

        val debridKeyInput = root.findView<EditText>("debrid_key_input")
        debridKeyInput.setText(sharedPref.getString("debrid_key", ""))
        debridKeyInput.makeTvCompatible()

        // ===== SAVE =====
        val saveBtn = root.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            sharedPref.edit {
                putString("provider", providers.filterIndexed { i, _ -> selectedProviders[i] }.joinToString(","))
                putString("language", languages.filterIndexed { i, _ -> selectedLanguages[i] }.joinToString(","))
                putString("qualityfilter", qualities.filterIndexed { i, _ -> selectedQualities[i] }.joinToString(","))
                putString("sort", sortSpinner.selectedItem?.toString() ?: "")
                putString("limit", limitInput.text.toString())
                putString("sizefilter", sizeInput.text.toString())
                putString("debrid_provider", debridSpinner.selectedItem?.toString() ?: "")
                putString("debrid_key", debridKeyInput.text.toString())
            }

            AlertDialog.Builder(requireContext())
                .setTitle("Restart Required")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them?")
                .setPositiveButton("Yes") { _, _ ->
                    showToast("Saved and Restarting...")
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No") { dialog, _ ->
                    showToast("Saved. Restart later to apply changes.")
                    dialog.dismiss()
                    dismiss()
                }
                .show()
        }

        // ===== RESET =====
        val resetBtn = root.findView<View>("delete_img")
        resetBtn.makeTvCompatible()
        resetBtn.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Reset")
                .setMessage("This will delete all saved settings.")
                .setPositiveButton("Reset") { _, _ ->
                    sharedPref.edit().clear().commit()
                    selectedProviders.fill(false)
                    updateProviderText()
                    selectedLanguages.fill(false)
                    updateLanguageText()
                    selectedQualities.fill(false)
                    updateQualityText()
                    sortSpinner.setSelection(0, false)
                    debridSpinner.setSelection(0, false)
                    limitInput.text.clear()
                    sizeInput.text.clear()
                    debridKeyInput.text.clear()
                    restartApp()
                }
                .setNegativeButton("Cancel", null)
                .show()
        }

        return root
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component
        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: TorraStream/src/main/res/drawable/add_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M13,7h-2v4L7,11v2h4v4h2v-4h4v-2h-4L13,7zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z"/>
    
</vector>



================================================
FILE: TorraStream/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android" android:height="24dp" android:tint="#FFFFFF" android:viewportHeight="24" android:viewportWidth="24" android:width="24dp">
      
    <path android:fillColor="@android:color/white" android:pathData="M6,19c0,1.1 0.9,2 2,2h8c1.1,0 2,-0.9 2,-2L18,7L6,7v12zM8,9h8v10L8,19L8,9zM15.5,4l-1,-1h-5l-1,1L5,4v2h14L19,4z"/>
    
</vector>



================================================
FILE: TorraStream/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="6dp"
                android:bottomRightRadius="6dp"
                android:topLeftRadius="6dp"
                android:topRightRadius="6dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: TorraStream/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: TorraStream/src/main/res/drawable/settings_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: TorraStream/src/main/res/layout/settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    android:fillViewport="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical">

        <!-- Title Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="TorraStream Settings"
                android:textSize="20sp"
                android:textStyle="bold"
                android:layout_marginBottom="10dp" />

            <ImageView
                android:id="@+id/save"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:contentDescription="Save Settings"
                android:padding="5dp" />
        </LinearLayout>

        <!-- Providers -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Select Providers"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <TextView
            android:id="@+id/providers_spinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:padding="8dp"
            android:focusable="true"
            android:nextFocusDown="@id/sort_spinner"
            android:text="Select Providers"
            android:ellipsize="end"
            android:scrollHorizontally="true"
            android:singleLine="true" />

        <!-- Sorting -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Sorting"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <Spinner
            android:id="@+id/sort_spinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:focusable="true"
            android:nextFocusUp="@id/providers_spinner"
            android:nextFocusDown="@id/language_spinner" />

        <!-- Priority Languages -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Priority Languages"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <TextView
            android:id="@+id/language_spinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:padding="8dp"
            android:text="Select Languages"
            android:focusable="true" />

        <!-- Exclude Qualities -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Exclude Qualities"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <TextView
            android:id="@+id/quality_spinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:padding="8dp"
            android:focusable="true"
            android:nextFocusUp="@id/language_spinner"
            android:nextFocusDown="@id/limit_input"
            android:text="Select Qualities"
            android:ellipsize="end"
            android:scrollHorizontally="true"
            android:singleLine="true" />

        <!-- Max Results per Quality -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Max Results per Quality"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <EditText
            android:id="@+id/limit_input"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="e.g., 10"
            android:inputType="number"
            android:padding="8dp"
            android:focusable="true"
            android:nextFocusUp="@id/quality_spinner"
            android:nextFocusDown="@id/size_filter_input" />

        <!-- Video Size Limit -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Video Size Limit (Movie,TV)"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <EditText
            android:id="@+id/size_filter_input"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="e.g., 6GB,2GB"
            android:inputType="text"
            android:padding="8dp"
            android:focusable="true"
            android:nextFocusUp="@id/limit_input"
            android:nextFocusDown="@id/debrid_provider_spinner" />

        <!-- Debrid Providers -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Debrid Providers"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginTop="10dp" />

        <Spinner
            android:id="@+id/debrid_provider_spinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:focusable="true"
            android:nextFocusUp="@id/size_filter_input"
            android:nextFocusDown="@id/debrid_key_input" />

        <EditText
            android:id="@+id/debrid_key_input"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Enter API Key / URL"
            android:inputType="text"
            android:padding="8dp"
            android:layout_marginTop="5dp"
            android:focusable="true"
            android:nextFocusUp="@id/debrid_provider_spinner"
            android:nextFocusDown="@id/delete_img" />

        <!-- Reset Button -->
        <Button
            android:id="@+id/delete_img"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Reset"
            android:layout_marginTop="20dp"
            android:focusable="true"
            android:nextFocusUp="@id/debrid_key_input" />

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: UHDmoviesProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 32

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Indian Multi-language 4K Provider"
    language = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "Movie",
        "TvSeries",
    )
    iconUrl = "https://raw.githubusercontent.com/LikDev-256/likdev256-tamil-providers/master/UHDmoviesProvider/icon.png"

    isCrossPlatform = false
}

dependencies {
    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}



================================================
FILE: UHDmoviesProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: UHDmoviesProvider/src/main/kotlin/com/phisher98/Extractors.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import org.json.JSONObject
import okhttp3.FormBody
import com.lagradost.api.Log

class Driveleech : Driveseed() {
    override val name: String = "Driveleech"
    override val mainUrl: String = "https://driveleech.org"
}

class DriveleechPro : Driveseed() {
    override val name: String = "Driveleech"
    override val mainUrl: String = "https://driveleech.pro"
}

class DriveleechNet : Driveseed() {
    override val name: String = "Driveleech"
    override val mainUrl: String = "https://driveleech.net"
}

open class Driveseed : ExtractorApi() {
    override val name: String = "Driveseed"
    override val mainUrl: String = "https://driveseed.org"
    override val requiresReferer = false

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]").find(str ?: "")?.groupValues?.getOrNull(1)?.toIntOrNull()
            ?: Qualities.Unknown.value
    }

    private suspend fun CFType1(url: String): List<String> {
        return runCatching {
            app.get("$url?type=1").documentLarge
                .select("a.btn-success")
                .mapNotNull { it.attr("href").takeIf { href -> href.startsWith("http") } }
        }.getOrElse {
            Log.e("Driveseed", "CFType1 error: ${it.message}")
            emptyList()
        }
    }

    private suspend fun resumeCloudLink(baseUrl: String, path: String): String? {
        return runCatching {
            app.get(baseUrl + path).documentLarge
                .selectFirst("a.btn-success")?.attr("href")
                ?.takeIf { it.startsWith("http") }
        }.getOrElse {
            Log.e("Driveseed", "ResumeCloud error: ${it.message}")
            null
        }
    }

    private suspend fun resumeBot(url: String): String? {
        return runCatching {
            val response = app.get(url)
            val docString = response.documentLarge.toString()
            val ssid = response.cookies["PHPSESSID"].orEmpty()
            val token = Regex("formData\\.append\\('token', '([a-f0-9]+)'\\)").find(docString)?.groupValues?.getOrNull(1).orEmpty()
            val path = Regex("fetch\\('/download\\?id=([a-zA-Z0-9/+]+)'").find(docString)?.groupValues?.getOrNull(1).orEmpty()
            val baseUrl = url.substringBefore("/download")

            if (token.isEmpty() || path.isEmpty()) return@runCatching null

            val json = app.post(
                "$baseUrl/download?id=$path",
                requestBody = FormBody.Builder().addEncoded("token", token).build(),
                headers = mapOf("Accept" to "*/*", "Origin" to baseUrl, "Sec-Fetch-Site" to "same-origin"),
                cookies = mapOf("PHPSESSID" to ssid),
                referer = url
            ).text

            JSONObject(json).getString("url").takeIf { it.startsWith("http") }
        }.getOrElse {
            Log.e("Driveseed", "ResumeBot error: ${it.message}")
            null
        }
    }

    private suspend fun instantLink(finalLink: String): String? {
        return runCatching {
            val response = app.get(finalLink)
            val resolvedUrl = response.url
            val extracted = resolvedUrl
                .substringAfter("url=", missingDelimiterValue = "")
                .takeIf { it.isNotBlank() }
            extracted
        }.getOrElse {
            Log.e("Driveseed", "InstantLink error: ${it.message}")
            null
        }
    }



    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val Basedomain = getBaseUrl(url)

        val document = try {
            if (url.contains("r?key=")) {
                val temp = app.get(url).documentLarge.selectFirst("script")
                    ?.data()
                    ?.substringAfter("replace(\"")
                    ?.substringBefore("\")")
                    .orEmpty()
                app.get(mainUrl + temp).documentLarge
            } else {
                app.get(url).documentLarge
            }
        } catch (e: Exception) {
            Log.e("Driveseed", "getUrl page load error: ${e.message}")
            return
        }

        val qualityText = document.selectFirst("li.list-group-item")?.text().orEmpty()
        val rawFileName = qualityText.replace("Name : ", "").trim()
        val cleaned = removeLeadingIndex(rawFileName)
        val fileName = cleanTitle(cleaned)
        val size = document.selectFirst("li:nth-child(3)")?.text().orEmpty().replace("Size : ", "").trim()

        val labelExtras = buildString {
            if (fileName.isNotEmpty()) append("[$fileName]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("div.text-center > a").forEach { element ->
            val text = element.text()
            val href = element.attr("href")
            Log.d("Driveseed", "Link: $href")

            if (href.isNotBlank()) {
                when {
                    text.contains("Instant Download", ignoreCase = true) -> {
                        instantLink(href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name Instant(Download) (Use VLC)",
                                    "$name Instant(Download) (Use VLC) $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Resume Worker Bot", ignoreCase = true) -> {
                        resumeBot(href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name ResumeBot(VLC)",
                                    "$name ResumeBot(VLC) $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Direct Links", ignoreCase = true) -> {
                        CFType1(Basedomain + href).forEach { link ->
                            callback(
                                newExtractorLink(
                                    "$name CF Type1",
                                    "$name CF Type1 $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Resume Cloud", ignoreCase = true) -> {
                        resumeCloudLink(Basedomain, href)?.let { link ->
                            callback(
                                newExtractorLink(
                                    "$name ResumeCloud",
                                    "$name ResumeCloud $labelExtras",
                                    url = link
                                ) {
                                    this.quality = getIndexQuality(qualityText)
                                }
                            )
                        }
                    }

                    text.contains("Cloud Download", ignoreCase = true) -> {
                        callback(
                            newExtractorLink(
                                "$name Cloud Download",
                                "$name Cloud Download $labelExtras",
                                url = href
                            ) {
                                this.quality = getIndexQuality(qualityText)
                            }
                        )
                    }
                }
            }
        }
    }
}

private fun removeLeadingIndex(title: String): String {
    return title.replace(
        Regex("^[\\[(]?\\s*\\d+\\s*[])\\-_.]*\\s*"),
        ""
    )
}

private fun cleanTitle(title: String): String {

    val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

    val normalized = name
        .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
        .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
        .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
        .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
        .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

    val parts = normalized.split(" ", "_", ".")

    val sourceTags = setOf(
        "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
        "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
    )

    val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")
    val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")
    val audioExtras = setOf("ATMOS")
    val hdrTags = setOf("SDR", "HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

    val tags = mutableListOf<String>()
    val titleParts = mutableListOf<String>()

    for (part in parts) {
        val p = part.uppercase()

        when {
            sourceTags.contains(p) -> tags += p
            codecTags.contains(p) -> tags += p
            audioTags.any { p.startsWith(it) } -> tags += p
            audioExtras.contains(p) -> tags += p
            hdrTags.contains(p) -> tags += if (p == "DV" || p == "DOLBYVISION") "DOLBYVISION" else p
            p == "NF" || p == "CR" -> tags += p
            else -> titleParts += part
        }
    }

    val cleanTitle = titleParts
        .joinToString(" ")
        .replace(Regex("\\s+"), " ")
        .trim()

    val cleanTags = tags.distinct().joinToString(" ")

    return listOf(cleanTitle, cleanTags)
        .filter { it.isNotBlank() }
        .joinToString(" ")
}




================================================
FILE: UHDmoviesProvider/src/main/kotlin/com/phisher98/UHDmoviesProvider.kt
================================================
package com.phisher98


import android.util.Log
import java.net.URLEncoder
import java.nio.charset.StandardCharsets
import org.json.JSONObject
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.JsonNode
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addSimklId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTMDbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import org.jsoup.nodes.Element
import com.lagradost.nicehttp.NiceResponse
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking

class UHDmoviesProvider : MainAPI() { // all providers must be an instance of MainAPI
    override var mainUrl: String = runBlocking {
        UHDmoviesProviderPlugin.getDomains()?.UHDMovies ?: "https://uhdmovies.rip"
    }
    override var name = "UHDmovies"
    override val hasMainPage = true
    override var lang = "en"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override val mainPage = mainPageOf(
        "" to "Home",
        "movies/" to "Movies",
        "tv-series/" to "TV Series",
        "tv-shows/" to "TV Shows",
        "movies/dual-audio-movies/" to "Dual Audio Movies",
        "movies/collection-movies/" to "Hollywood",
        "tv-shows/netflix/" to "Netflix",
        "web-series/" to "Web Series",
        "amazon-prime/" to "Amazon Prime",
    )

    private suspend fun cfKiller(url: String): NiceResponse {
        var doc = app.get(url)
        if (doc.documentLarge.select("title").text() == "Just a moment...") {
            doc = app.get(url, interceptor = CloudflareKiller())
        }
        return doc
    }

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = if (page == 1) {
            cfKiller("$mainUrl/${request.data}").documentLarge
        } else {
            cfKiller("$mainUrl/${request.data}" + "/page/$page/").documentLarge
        }

        val home = document.select("article.gridlove-post").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(arrayListOf(HomePageList(request.name, home)), hasNext = true)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val titleRaw = this.select("h1.sanket").text().trim().removePrefix("Download ")
        val titleRegex = Regex("(^.*\\)\\d*)")
        val title = titleRegex.find(titleRaw)?.groups?.get(1)?.value ?: titleRaw
        val href = fixUrl(this.select("div.entry-image > a").attr("href"))
        val posterUrl = fixUrlNull(this.select("div.entry-image > a > img").attr("src"))
        val quality = getSearchQuality(titleRaw)
        return if (titleRaw.contains("season|S0", true) || titleRaw.contains("episode", true) || titleRaw.contains("S0", true)) {
            newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        } else {
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = cfKiller("$mainUrl?s=$query ").documentLarge

        return document.select("article.gridlove-post").mapNotNull {
            it.toSearchResult()
        }
    }

    data class UHDLinks(
        @JsonProperty("sourceName") val sourceName: String,
        @JsonProperty("sourceLink") val sourceLink: String
    )

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).documentLarge
        val titleRaw = doc.select("div.gridlove-content div.entry-header h1.entry-title").text().trim().removePrefix("Download ")
        val titleRegex = Regex("(^.*\\)\\d*)")
        val title = titleRegex.find(titleRaw)?.groupValues?.get(1)?.trim()?.substringBefore("(")?.substringBefore("Season")?.substringBefore("S0") ?: titleRaw.substringBefore("(").substringBefore("Season").substringBefore("S0")
        val img = doc.selectFirst("div.entry-content p img")

        val poster = img?.attr("srcset")
            ?.split(",")
            ?.map { it.trim() }
            ?.maxByOrNull {
                it.substringAfterLast(" ")
                    .removeSuffix("w")
                    .toIntOrNull() ?: 0
            }
            ?.substringBefore(" ")
            ?: img?.attr("src")
        val collectionposter = doc.select("meta[property=og:image]").attr("content")
        val yearRegex = Regex("(?<=\\()[\\d(\\]]+(?!=\\))")
        val year = yearRegex.find(titleRaw)?.value?.toIntOrNull()
        val tags = doc.select("div.entry-category > a.gridlove-cat").map { it.text() }
        val tvTags = doc.selectFirst("h1.entry-title")?.text() ?:""
        val type = if (tvTags.contains("Season") || tvTags.contains("S0")) TvType.TvSeries else TvType.Movie
        val ids = fetchIds(
            title,
            year,
            type == TvType.TvSeries
        )
        val meta = if (!ids.imdbId.isNullOrBlank()) fetchMetaData(ids.imdbId, type) else null
        val metaVideos = meta?.get("videos")?.toList() ?: emptyList()

        val Background = meta?.get("background")?.asText() ?: poster
        val Description = meta?.get("description")?.asText() ?: ""
        val IMDBRating = meta?.get("imdbRating")?.asText()
        val trailer = doc.select("p iframe").attr("src")


        val simklId = ids.imdbId?.let {
            fetchSimklId(it, isSeries = type == TvType.TvSeries)
        }

        return if (type == TvType.TvSeries) {
            val episodes = mutableListOf<Episode>()
            var pTags = doc.select("p:has(a:contains(Episode))")
            if (pTags.isEmpty())
            {
                pTags = doc.select("div:has(a:contains(Episode))")
            }

            val tvSeriesEpisodes = mutableListOf<Episode>()
            val episodesMap: MutableMap<Pair<Int, Int>, List<String>> = mutableMapOf()

            pTags.mapNotNull { pTag ->
                val prevPtag = pTag.previousElementSibling()
                val details = prevPtag ?. text() ?: ""
                val realSeason = Regex("""(?:Season |S0)(\d+)""").find(details) ?. groupValues
                    ?. get(1) ?.toIntOrNull() ?: 0
                val aTags = pTag.select("a:contains(Episode)")

                aTags.mapNotNull { aTag ->
                    val realEp = Regex("""Episode\s+(\d+)""").find(aTag.toString()) ?. groupValues ?. get(1) ?.toIntOrNull() ?: 0
                    val epUrl = aTag.attr("href")
                    val key = Pair(realSeason, realEp)

                    if(!epUrl.isEmpty()) {
                        if (episodesMap.containsKey(key)) {
                            val currentList = episodesMap[key] ?: emptyList()
                            val newList = currentList.toMutableList()
                            newList.add(epUrl)
                            episodesMap[key] = newList
                        } else {
                            episodesMap[key] = mutableListOf(epUrl)
                        }
                    }

                }
            }

            for ((key, value) in episodesMap) {
                if(key.first == 0 || key.second == 0) continue

                val epMeta = metaVideos.firstOrNull {
                    it["season"]?.asInt() == key.first &&
                        it["episode"]?.asInt() == key.second
                }

                val data = value.map { source->
                    UHDLinks(
                        "UHD",
                        source
                    )
                }

                val epName =
                    epMeta?.get("name")?.asText()?.takeIf { it.isNotBlank() }
                        ?: "Episode ${key.second}"

                val epDesc =
                    epMeta?.get("overview")?.asText()
                        ?: epMeta?.get("description")?.asText()
                        ?: ""

                val epThumb =
                    epMeta?.get("thumbnail")?.asText()?.takeIf { it.isNotBlank() }
                        ?: ""

                val aired =
                    epMeta?.get("firstAired")?.asText()?.takeIf { it.isNotBlank() }
                        ?: ""
                tvSeriesEpisodes.add(
                    newEpisode(data) {
                        this.name = epName
                        this.season = key.first
                        this.episode = key.second
                        this.posterUrl = epThumb
                        this.description = epDesc
                        addDate(aired)
                    }
                )
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, tvSeriesEpisodes) {
                this.posterUrl = poster?.trim() ?: collectionposter
                this.year = year
                this.tags = tags
                addTrailer(trailer)
                addImdbId(ids.imdbId)
                addTMDbId(ids.tmdbId.toString())
                addSimklId(simklId)
                this.backgroundPosterUrl = Background ?: collectionposter
                this.plot = Description
                this.year = year
                this.tags = tags
                this.score = Score.from10(IMDBRating)
            }
        } else {
            val iframeRegex = Regex("""\[.*]""")
            val iframe = doc.select("""div.entry-content > p""").amap { it }.filter {
                iframeRegex.find(it.toString()) != null
            }
            val data = iframe.amap {
                UHDLinks(
                    it.text().substringBefore("Download"),
                    it.nextElementSibling()?.select("a.maxbutton-1")?.attr("href") ?: ""
                )
            }
            Log.d("Phisher","$poster $collectionposter $Background")
            newMovieLoadResponse(title, url, TvType.Movie, data) {
                this.posterUrl = poster?.trim() ?: collectionposter
                this.year = year
                this.tags = tags
                addTrailer(trailer)
                addImdbId(ids.imdbId)
                addTMDbId(ids.tmdbId.toString())
                addSimklId(simklId)
                this.backgroundPosterUrl = Background ?: collectionposter
                this.plot = Description
                this.year = year
                this.tags = tags
                this.score = Score.from10(IMDBRating)
            }
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean = coroutineScope {
        if (data.startsWith("https://")) {
            val finalLink = if (data.contains("unblockedgames")) {
                bypassHrefli(data) ?: return@coroutineScope true
            } else {
                data
            }
            loadExtractor(finalLink, subtitleCallback, callback)
        } else {
            val sources = parseJson<ArrayList<UHDLinks>>(data)

            sources.forEach { me ->
                launch {
                    runCatching {
                        val link = me.sourceLink
                        val finalLink = if (link.contains("unblockedgames")) {
                            bypassHrefli(link) ?: return@runCatching
                        } else {
                            link
                        }
                        loadExtractor(finalLink, subtitleCallback, callback)
                    }.onFailure {
                    }
                }
            }
        }
        return@coroutineScope true
    }
}

suspend fun fetchIds(
    title: String,
    year: Int?,
    isSeries: Boolean
): IdResult {
    val TMDB_API = "https://api.themoviedb.org/3"
    val TMDB_API_KEY = "1865f43a0549ca50d341dd9ab8b29f49"

    val type = if (isSeries) "tv" else "movie"

    val searchUrl = buildString {
        append("$TMDB_API/search/$type")
        append("?api_key=$TMDB_API_KEY")
        append("&query=${title.urlEncode()}")
        if (year != null) {
            append(if (isSeries) "&first_air_date_year=$year" else "&year=$year")
        }
    }

    val searchJson = JSONObject(app.get(searchUrl).textLarge)
    val results = searchJson.optJSONArray("results")
    val tmdbId = results?.optJSONObject(0)?.optInt("id")

    val imdbId = tmdbId?.let { id ->
        val extUrl = "$TMDB_API/$type/$id/external_ids?api_key=$TMDB_API_KEY"
        val extJson = JSONObject(app.get(extUrl).textLarge)
        extJson.optString("imdb_id").takeIf { it.isNotBlank() }
    }

    return IdResult(
        tmdbId = tmdbId,
        imdbId = imdbId
    )
}

data class IdResult(
    val tmdbId: Int?,
    val imdbId: String?
)

fun String.urlEncode(): String = URLEncoder.encode(this, StandardCharsets.UTF_8.toString())

private suspend fun fetchMetaData(imdbId: String?, type: TvType): JsonNode? {
    if (imdbId.isNullOrBlank()) return null

    val metaType = if (type == TvType.TvSeries) "series" else "movie"
    val url = "https://aiometadata.elfhosted.com/stremio/b7cb164b-074b-41d5-b458-b3a834e197bb/meta/$metaType/$imdbId.json"

    return try {
        val resp = app.get(url).text
        mapper.readTree(resp)["meta"]
    } catch (_: Exception) {
        null
    }
}

private suspend fun fetchSimklId(
    imdbId: String,
    isSeries: Boolean
): Int? = runCatching {
    val type = if (isSeries) "tv" else "movies"
    val url = "https://api.simkl.com/$type/$imdbId?client_id=${BuildConfig.SIMKL_CLIENT_ID}"

    JSONObject(app.get(url).text)
        .optJSONObject("ids")
        ?.optInt("simkl")
        ?.takeIf { it != 0 }
}.getOrNull()



================================================
FILE: UHDmoviesProvider/src/main/kotlin/com/phisher98/UHDmoviesProviderPlugin.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.app


@CloudstreamPlugin
class UHDmoviesProviderPlugin: BasePlugin() {
    override fun load() {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(UHDmoviesProvider())
        registerExtractorAPI(Driveleech())
        registerExtractorAPI(Driveseed())
        registerExtractorAPI(UHDMovies())
        registerExtractorAPI(DriveleechPro())
        registerExtractorAPI(DriveleechNet())
    }
    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("UHDMovies")
            val UHDMovies: String,
        )
    }
}



================================================
FILE: UHDmoviesProvider/src/main/kotlin/com/phisher98/Utils.kt
================================================
package com.phisher98


import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import java.net.*
import org.jsoup.nodes.Document

fun getBaseUrl(url: String): String {
    return URI(url).let {
        "${it.scheme}://${it.host}"
    }
}

fun fixUrl(url: String, domain: String): String {
    if (url.startsWith("http")) {
        return url
    }
    if (url.isEmpty()) {
        return ""
    }

    val startsWithNoHttp = url.startsWith("//")
    if (startsWithNoHttp) {
        return "https:$url"
    } else {
        if (url.startsWith('/')) {
            return domain + url
        }
        return "$domain/$url"
    }
}

suspend fun bypassHrefli(url: String): String? {
    fun Document.getFormUrl(): String {
        return this.select("form#landing").attr("action")
    }

    fun Document.getFormData(): Map<String, String> {
        return this.select("form#landing input").associate { it.attr("name") to it.attr("value") }
    }

    val host = getBaseUrl(url)
    var res = app.get(url).documentLarge
    var formUrl = res.getFormUrl()
    var formData = res.getFormData()

    res = app.post(formUrl, data = formData).documentLarge
    formUrl = res.getFormUrl()
    formData = res.getFormData()

    res = app.post(formUrl, data = formData).documentLarge
    val skToken = res.selectFirst("script:containsData(?go=)")?.data()?.substringAfter("?go=")
        ?.substringBefore("\"") ?: return null
    val driveUrl = app.get(
        "$host?go=$skToken", cookies = mapOf(
            skToken to "${formData["_wp_http2"]}"
        )
    ).documentLarge.selectFirst("meta[http-equiv=refresh]")?.attr("content")?.substringAfter("url=")
    val path = app.get(driveUrl ?: return null).text.substringAfter("replace(\"")
        .substringBefore("\")")
    if (path == "/404") return null
    return fixUrl(path, getBaseUrl(driveUrl))
}

open class UHDMovies : ExtractorApi() {
    override val name: String = "UHDMovies"
    override val mainUrl: String = "https://video-seed.xyz"
    override val requiresReferer = true

    @Suppress("PARAMETER_NAME_CHANGED_ON_OVERRIDE")
    override suspend fun getUrl(
        finallink: String,
        quality: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val token = finallink.substringAfter("https://video-seed.xyz/?url=")
        val downloadlink = app.post(
            url = "https://video-seed.xyz/api",
            data = mapOf(
                "keys" to token
            ),
            referer = finallink,
            headers = mapOf(
                "x-token" to "video-seed.xyz",
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:125.0) Gecko/20100101 Firefox/125.0"
            )
        )
        val finaldownloadlink =
            downloadlink.toString().substringAfter("url\":\"")
                .substringBefore("\",\"name")
                .replace("\\/", "/")
        val link = finaldownloadlink
        callback.invoke(
            newExtractorLink(
                name,
                name,
                url = link
            ) {
                this.referer = ""
                this.quality = getQualityFromName(quality)
            }
        )
    }
}

fun getSearchQuality(check: String?): SearchQuality? {
    val lowercaseCheck = check?.lowercase()
    if (lowercaseCheck != null) {
        return when {
            lowercaseCheck.contains("4k") || lowercaseCheck.contains("uhd") || lowercaseCheck.contains("2160p") -> SearchQuality.FourK
            lowercaseCheck.contains("1440p") || lowercaseCheck.contains("qhd") -> SearchQuality.BlueRay
            lowercaseCheck.contains("1080p") || lowercaseCheck.contains("fullhd") -> SearchQuality.HD
            lowercaseCheck.contains("720p") -> SearchQuality.SD
            lowercaseCheck.contains("webrip") || lowercaseCheck.contains("web-dl") -> SearchQuality.WebRip
            lowercaseCheck.contains("bluray") -> SearchQuality.BlueRay
            lowercaseCheck.contains("hdts") || lowercaseCheck.contains("hdcam") || lowercaseCheck.contains("hdtc") -> SearchQuality.HdCam
            lowercaseCheck.contains("dvd") -> SearchQuality.DVD
            lowercaseCheck.contains("camrip") || lowercaseCheck.contains("rip") -> SearchQuality.CamRip
            lowercaseCheck.contains("cam") -> SearchQuality.Cam
            lowercaseCheck.contains("hdrip") || lowercaseCheck.contains("hdtv") -> SearchQuality.HD
            lowercaseCheck.contains("hq") -> SearchQuality.HQ
            else -> null
        }
    }
    return null
}


================================================
FILE: Ultima/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties

dependencies {
    implementation("com.google.android.material:material:1.13.0")

    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}
// use an integer for version numbers
version = 32

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "The ultimate All-in-One home screen to access all of your extensions at one place (You need to select/deselect sections in Ultima's settings to load other extensions on home screen)"
    authors = listOf("RowdyRushya,Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 2

    tvTypes = listOf("All")

    requiresResources = true
    language = "en"

    // random cc logo i found
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/Ultima.jpg"

    isCrossPlatform = false
}

android {
    buildFeatures {
        buildConfig = true
    }

    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        buildConfigField("String", "KAISVA", "\"${properties.getProperty("KAISVA")}\"")
        buildConfigField("String", "SIMKL_API", "\"${properties.getProperty("SIMKL_API")}\"")
        buildConfigField("String", "MAL_API", "\"${properties.getProperty("MAL_API")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_ALT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_ALT")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_DEFAULT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_DEFAULT")}\"")

    }
}


================================================
FILE: Ultima/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Ultima.kt
================================================
package com.phisher98

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.allProviders
import com.lagradost.cloudstream3.AnimeSearchResponse
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageData
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.MovieSearchResponse
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.TvSeriesSearchResponse
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.utils.AppUtils
import com.phisher98.UltimaUtils.SectionInfo

class Ultima(val plugin: UltimaPlugin) : MainAPI() {
    override var name = "Ultima"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Anime)
    override var lang = "en"
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val sm = UltimaStorageManager
    private val deviceSyncData = sm.deviceSyncCreds

    private val mapper = jacksonObjectMapper()
    private var sectionNamesList: List<String> = emptyList()

    private fun loadSections(): List<MainPageData> {
        val tempSectionNames = mutableListOf<String>()

        val result = mutableListOf<MainPageData>()
        val savedPlugins = sm.currentExtensions

        result += mainPageOf("" to "watch_sync")

        val enabledSections = savedPlugins
            .flatMap { it.sections?.asList() ?: emptyList() }
            .filter { it.enabled }
            .sortedByDescending { it.priority }

        enabledSections.forEach { section ->
            try {
                val sectionKey = mapper.writeValueAsString(section)
                val sectionName = buildSectionName(section, tempSectionNames)
                result += mainPageOf(sectionKey to sectionName)
            } catch (e: Exception) {
                Log.e("loadSections", "Failed to load section ${section.name}: ${e.message}")
            }
        }

        sectionNamesList = tempSectionNames

        return if (result.size <= 1) mainPageOf("" to "") else result
    }


    private fun buildSectionName(section: SectionInfo, names: MutableList<String>): String {
        val name = if (sm.extNameOnHome) {
            "${section.pluginName}: ${section.name}"
        } else if (names.contains(section.name)) {
            "${section.name} ${names.count { it.startsWith(section.name) } + 1}"
        } else {
            section.name
        }
        names += name
        return name
    }


    override val mainPage = loadSections()

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        val creds = sm.deviceSyncCreds
        creds?.syncThisDevice()

        if (request.name.isEmpty()) {
            throw ErrorLoadingException("Select sections from the extension's settings page to show here.")
        }

        return try {
            if (request.name == "watch_sync") {
                val syncedDevices = creds?.fetchDevices()
                val filteredDevices = syncedDevices?.filter {
                    deviceSyncData?.enabledDevices?.contains(it.deviceId) == true
                } ?: emptyList()

                if (filteredDevices.isEmpty()) {
                    Log.w("getMainPage", "No enabled devices found in the synced list.")
                    return null
                }

                val homeSections = ArrayList<HomePageList>(filteredDevices.size)

                for (device in filteredDevices) {
                    val syncedContent = device.syncedData ?: continue
                    homeSections += HomePageList("Continue from: ${device.name}", syncedContent)
                }

                newHomePageResponse(homeSections, false)
            } else {
                val section = AppUtils.parseJson<SectionInfo>(request.data)
                val provider = allProviders.find { it.name == section.pluginName }
                    ?: throw ErrorLoadingException("Provider '${section.pluginName}' is not available.")

                provider.getMainPage(
                    page,
                    MainPageRequest(
                        name = request.name,
                        data = section.url,
                        horizontalImages = request.horizontalImages
                    )
                )
            }
        } catch (e: Throwable) {
            Log.e("getMainPage", "Error loading main page: ${e.message}")
            e.printStackTrace()
            null
        }
    }


    override suspend fun search(query: String): List<SearchResponse>? {
        val enabledSections = mainPage
            .filter { !it.name.equals("watch_sync", ignoreCase = true) }
            .mapNotNull {
                try {
                    val section = AppUtils.parseJson<SectionInfo>(it.data)
                    section.pluginName to section
                } catch (_: Exception) {
                    null
                }
            }

        val tasks = mutableListOf<suspend () -> List<SearchResponse>>()

        for ((pluginName, _) in enabledSections) {
            val provider = allProviders.find { it.name == pluginName } ?: continue

            tasks += suspend {
                try {
                    when (val result = provider.search(query)) {
                        is List<*> -> {
                            result.map { item ->
                                when (item) {
                                    is MovieSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    is AnimeSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    is TvSeriesSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    else -> item
                                }
                            }
                        }
                        else -> emptyList()
                    }
                } catch (e: Exception) {
                    Log.e("search", "Search failed for provider $pluginName: ${e.message}")
                    emptyList()
                }
            }
        }


        return runLimitedParallel(limit = 4, tasks).flatten()
    }

    override suspend fun load(url: String): LoadResponse {
        val enabledPlugins = mainPage
            .filter { !it.name.equals("watch_sync", ignoreCase = true) }
            .mapNotNull {
                try {
                    AppUtils.parseJson<SectionInfo>(it.data).pluginName
                } catch (_: Exception) {
                    null
                }
            }

        val providersToTry = allProviders.filter { it.name in enabledPlugins }

        for (provider in providersToTry) {
            try {
                val response = provider.load(url)

                if (response != null &&
                    response.name.isNotBlank() &&
                    !response.posterUrl.isNullOrBlank()
                ) {
                    return response
                }
            } catch (_: Throwable) {
                // Optional: Log specific provider failure if debugging
                Log.e("Ultima load", "Failed loading from ${provider.name}")
            }
        }

        return newMovieLoadResponse("Welcome to Ultima", "", TvType.Others, "")
    }


}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/UltimaPlugin.kt
================================================
package com.phisher98

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.api.Log
import com.lagradost.cloudstream3.MainActivity.Companion.afterPluginsLoadedEvent
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import com.lagradost.cloudstream3.plugins.PluginManager

@CloudstreamPlugin
class UltimaPlugin : Plugin() {
    var activity: AppCompatActivity? = null
    override fun load(context: Context) {
        activity = context as AppCompatActivity
        // All providers should be added in this manner
        registerMainAPI(Ultima(this))

        UltimaStorageManager.currentMetaProviders.forEach { metaProvider ->
            when (metaProvider.first) {
                "Simkl" -> if (metaProvider.second) registerMainAPI(Simkl(this))
                "AniList" -> if (metaProvider.second) registerMainAPI(AniList(this))
                "MyAnimeList" -> if (metaProvider.second) registerMainAPI(MyAnimeList(this))
                "TMDB" -> if (metaProvider.second) registerMainAPI(Tmdb(this))
                "Trakt" -> if (metaProvider.second) registerMainAPI(Trakt(this))
                else -> {}
            }
        }

        openSettings = { ctx ->
            val act = ctx as? AppCompatActivity
            if (act != null && !act.isFinishing && !act.isDestroyed) {
                val frag = UltimaSettings(this)
                frag.show(act.supportFragmentManager, "UltimaSettingsDialog")
            } else {
                Log.e("Plugin", "Activity is not valid anymore, cannot show settings dialog")
            }
        }
    }

    fun reload() {
        val pluginData = PluginManager.getPluginsOnline().find { it.internalName.contains("Ultima") }
        if (pluginData == null) {
            afterPluginsLoadedEvent.invoke(true)
        }
    }
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/AllMovieland.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.phisher98.UltimaMediaProvidersUtils.fixUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

class AllMovielandMediaProvider : MediaProvider() {
    override val name = "AllMovieland"
    override val domain = "https://allmovieland.fun"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val playerScript = app.get("https://allmovieland.link/player.js?v=60%20128").toString()
        val domainRegex = Regex("const AwsIndStreamDomain.*'(.*)';")
        val host = domainRegex.find(playerScript)?.groupValues?.getOrNull(1) ?: return

        val resData = app.get(
            "$host/play/${data.imdbId}",
            referer = "$url/"
        ).documentLarge.selectFirst("script:containsData(playlist)")?.data()
            ?.substringAfter("{")?.substringBefore(";")?.substringBefore(")") ?: return

        val json = tryParseJson<AllMovielandPlaylist>("{$resData}") ?: return
        val headers = mapOf(("X-CSRF-TOKEN" to "${json.key}"))

        val serverJson = app.get(
            fixUrl(json.file ?: return, host),
            headers = headers,
            referer = "$url/"
        ).text.replace(Regex(""",\\s*\\/"""), "")

        val serverRes =
                app.get(fixUrl(json.file, host), headers = headers, referer = url)
                        .text
                        .replace(Regex(""",\s*\[]"""), "")
        val servers =
                tryParseJson<ArrayList<AllMovielandServer>>(serverRes).let { server ->
                    if (data.season == null) {
                        server?.map { it.file to it.title }
                    } else {
                        server
                                ?.find { it.id.equals("${data.season}") }
                                ?.folder
                                ?.find { it.episode.equals("${data.episode}") }
                                ?.folder
                                ?.map { it.file to it.title }
                    }
                }

        servers?.amap { (server, lang) ->
            val path =
                app.post(
                    "${host}/playlist/${server ?: return@amap}.txt",
                    headers = headers,
                    referer = url
                )
                    .text
            M3u8Helper.generateM3u8("Allmovieland [$lang]", path, url).forEach(callback)
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    data class AllMovielandPlaylist(
            @JsonProperty("file") val file: String? = null,
            @JsonProperty("key") val key: String? = null,
            @JsonProperty("href") val href: String? = null,
    )

    data class AllMovielandServer(
            @JsonProperty("title") val title: String? = null,
            @JsonProperty("id") val id: String? = null,
            @JsonProperty("file") val file: String? = null,
            @JsonProperty("folder")
            val folder: ArrayList<AllMovielandSeasonFolder>? = arrayListOf(),
    ) {
        data class AllMovielandSeasonFolder(
                @JsonProperty("episode") val episode: String? = null,
                @JsonProperty("id") val id: String? = null,
                @JsonProperty("folder")
                val folder: ArrayList<AllMovielandEpisodeFolder>? = arrayListOf(),
        ) {
            data class AllMovielandEpisodeFolder(
                    @JsonProperty("title") val title: String? = null,
                    @JsonProperty("id") val id: String? = null,
                    @JsonProperty("file") val file: String? = null,
            )
        }
    }
    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/AnimeKai.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import kotlin.math.max

class AnimeKaiMediaProvider : MediaProvider() {
    override val name = "AnimeKai"
    override val domain = "https://animekai.bz"
    override val categories = listOf(Category.ANIME)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val jptitle = data.jpTitle
        val title = data.title
        if (jptitle.isNullOrBlank() || title.isNullOrBlank()) return

        try {
            // Perform the search requests sequentially but avoid redundant requests
            val searchEnglish = app.get("$domain/ajax/anime/search?keyword=$title").body.string()
            val searchRomaji = app.get("$domain/ajax/anime/search?keyword=$jptitle").body.string()

            val resultsEng = parseAnimeKaiResults(searchEnglish)
            val resultsRom = parseAnimeKaiResults(searchRomaji)

            val combined = (resultsEng + resultsRom).distinctBy { it.id }

            // Find the best match based on title similarity
            var bestMatch: AnimeKaiSearchResult? = null
            var highestScore = 0.0

            for (result in combined) {
                val engScore = similarity(title, result.title)
                val romScore = similarity(jptitle, result.japaneseTitle ?: "")
                val score = max(engScore, romScore)

                if (score > highestScore) {
                    highestScore = score
                    bestMatch = result
                }
            }

            bestMatch?.let { match ->
                val matchedId = match.id
                val href = "$domain/watch/$matchedId"

                // Fetch anime details and episode list
                val animeId = app.get(href).documentLarge.selectFirst("div.rate-box")?.attr("data-id")
                val decoded = app.get("${BuildConfig.KAISVA}/?f=e&d=$animeId")
                val epRes = app.get("$domain/ajax/episodes/list?ani_id=$animeId&_=$decoded")
                    .parsedSafe<AnimeKaiResponse>()?.getDocument()

                epRes?.select("div.eplist a")?.forEach { ep ->
                    val epNum = ep.attr("num").toIntOrNull()
                    if (epNum == data.episode) {
                        val token = ep.attr("token")

                        // Fetch episode links for this episode
                        val decodedtoken = app.get("${BuildConfig.KAISVA}/?f=e&d=$token")
                        val document =
                            app.get("$domain/ajax/links/list?token=$token&_=$decodedtoken")
                                .parsed<AnimeKaiResponse>()
                                .getDocument()

                        val types = listOf("sub", "softsub", "dub")
                        val servers = types.flatMap { type ->
                            document.select("div.server-items[data-id=$type] span.server[data-lid]")
                                .map { server ->
                                    val lid = server.attr("data-lid")
                                    val serverName = server.text()
                                    Triple(type, lid, serverName)
                                }
                        }

                        // Process each server sequentially
                        for ((type, lid, serverName) in servers) {
                            val decodelid = app.get("${BuildConfig.KAISVA}/?f=e&d=$lid")
                            val result = app.get("$domain/ajax/links/view?id=$lid&_=$decodelid")
                                .parsed<AnimeKaiResponse>().result
                            val decodeiframe = app.get("${BuildConfig.KAISVA}/?f=d&d=$result").text
                            val iframe = extractVideoUrlFromJsonAnimekai(decodeiframe)

                            val nameSuffix = when {
                                type.contains("soft", ignoreCase = true) -> " [Soft Sub]"
                                type.contains("sub", ignoreCase = true) -> " [Sub]"
                                type.contains("dub", ignoreCase = true) -> " [Dub]"
                                else -> ""
                            }

                            val name = "⌜ AnimeKai ⌟  |  $serverName  | $nameSuffix"
                            commonLinkLoader(
                                name,
                                ServerName.Megacc,
                                iframe,
                                null,
                                null,
                                subtitleCallback,
                                callback
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

fun extractVideoUrlFromJsonAnimekai(jsonData: String): String {
    val jsonObject = JSONObject(jsonData)
    return jsonObject.getString("url")
}

data class AnimeKaiM3U8(
    val sources: List<AnimekaiSource>,
    val tracks: List<AnimekaiTrack>,
    val download: String,
)
data class AnimekaiSource(
    val file: String,
)

data class AnimekaiTrack(
    val file: String,
    val label: String?,
    val kind: String,
    val default: Boolean?,
)

data class AnimeKaiResponse(
    @JsonProperty("status") val status: Boolean,
    @JsonProperty("result") val result: String
) {
    fun getDocument(): Document {
        return Jsoup.parse(result)
    }
}

data class VideoData(
    val url: String,
    val skip: Skip,
)

data class Skip(
    val intro: List<Long>,
    val outro: List<Long>,
)

fun similarity(a: String?, b: String?): Double {
    if (a.isNullOrBlank() || b.isNullOrBlank()) return 0.0
    val tokensA = a.lowercase().split(Regex("\\W+")).toSet()
    val tokensB = b.lowercase().split(Regex("\\W+")).toSet()
    if (tokensA.isEmpty() || tokensB.isEmpty()) return 0.0
    val intersection = tokensA.intersect(tokensB).size
    return intersection.toDouble() / max(tokensA.size, tokensB.size)
}

data class AnimeKaiSearchResult(
    val id: String,
    val title: String,
    val japaneseTitle: String? = null
)


private fun parseAnimeKaiResults(jsonResponse: String): List<AnimeKaiSearchResult> {
    val results = mutableListOf<AnimeKaiSearchResult>()
    val html =
        JSONObject(jsonResponse).optJSONObject("result")?.optString("html")
            ?: return results
    val doc = Jsoup.parse(html)

    for (element in doc.select("a.aitem")) {
        val href = element.attr("href").substringAfterLast("/")
        val titleElem = element.selectFirst("h6.title") ?: continue
        val title = titleElem.text().trim()
        val jpTitle = titleElem.attr("data-jp").trim().takeIf { it.isNotBlank() }

        results.add(AnimeKaiSearchResult(href, title, jpTitle))
    }

    return results
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/DahmerMovies.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.encodeUrl
import com.phisher98.UltimaMediaProvidersUtils.getEpisodeSlug
import com.phisher98.UltimaMediaProvidersUtils.getIndexQuality
import com.phisher98.UltimaMediaProvidersUtils.getIndexQualityTags
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink

class DahmerMoviesMediaProvider : MediaProvider() {
    override val name = "DahmerMovies"
    override val domain = "https://a.111477.xyz"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val year= app.get("https://cinemeta-live.strem.io/meta/movie/${data.imdbId}.json").parsedSafe<MetaData>()?.meta?.releaseInfo
        val mediaUrl =
                if (data.season == null) {
                    "$url/movies/${data.title?.replace(":", "")} (${year})/"
                } else {
                    "$url/tvs/${data.title?.replace(":", " -")}/Season ${data.season}/"
                }
        Log.d("Phisher",data.toJson())
        val request = app.get(mediaUrl, timeout = 60L)
        if (!request.isSuccessful) return
        val paths =
                request.documentLarge
                        .select("a")
                        .map { it.text() to it.attr("href") }
                        .filter {
                            if (data.season == null) {
                                it.first.contains(Regex("(?i)(1080p|2160p)"))
                            } else {
                                val (seasonSlug, episodeSlug) =
                                        getEpisodeSlug(data.season, data.episode)
                                it.first.contains(Regex("(?i)S${seasonSlug}E${episodeSlug}"))
                            }
                        }
                        .ifEmpty {
                            return
                        }

        paths.map {
            val quality = getIndexQuality(it.first)
            val tag = getIndexQualityTags(it.first)
            val href=if (it.second.contains(mediaUrl)) it.second else (mediaUrl + it.second)
            UltimaMediaProvidersUtils.commonLinkLoader(
                name,
                ServerName.Custom,
                href.encodeUrl(),
                null,
                null,
                subtitleCallback,
                callback,
                quality,
                tag = tag
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/Elevenmovies.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import kotlin.experimental.xor


class ElevenmoviesProvider : MediaProvider() {
    override val name = "Elevenmovies"
    override val domain = "https://111movies.com"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val Elevenmovies =domain
        val apiurl = if (data.season == null) {
            "$domain/movie/${data.tmdbId}"
        } else {
            "$domain/tv/${data.tmdbId}/${data.season}/${data.episode}"
        }

        val encodedToken = app.get(apiurl).documentLarge.selectFirst("script[type=application/json]")
            ?.data()
            ?.substringAfter("{\"data\":\"")
            ?.substringBefore("\",")
        if (encodedToken == null) return
        val jsonString = app.get("https://raw.githubusercontent.com/phisher98/TVVVV/main/output.json").text
        val gson = Gson()

        val json: Elevenmoviesjson? = try {
            gson.fromJson(jsonString, Elevenmoviesjson::class.java)
        } catch (e: JsonSyntaxException) {
            e.printStackTrace()
            null
        }
        requireNotNull(json) { "Failed to parse Elevenmovies JSON" }
        val token = elevenMoviesTokenV2(encodedToken)

        val staticPath = json.staticPath
        val apiServerUrl = "$Elevenmovies/$staticPath/$token/sr"
        val headers = mapOf(
            "Referer" to Elevenmovies,
            "User-Agent" to USER_AGENT,
            "Content-Type" to json.contentTypes,
            "X-Requested-With" to "XMLHttpRequest"
        )

        val responseString = try {
            if (json.httpMethod.contains("GET")) {
                val res = app.get(apiServerUrl, headers = headers).body.string()
                res
            } else {
                val postHeaders = headers.toMutableMap()
                postHeaders["X-Requested-With"] = "XMLHttpRequest"
                postHeaders["User-Agent"] = USER_AGENT
                val res = app.post(apiServerUrl, headers = postHeaders).body.string()
                res
            }
        } catch (e: Exception) {
            throw RuntimeException("Failed to fetch server list: ${e.message}")
        }

        val listType = object : TypeToken<List<ElevenmoviesServerEntry>>() {}.type
        val serverList: List<ElevenmoviesServerEntry> = Gson().fromJson(responseString, listType)

        for (entry in serverList) {
            val serverToken = entry.data
            val serverName = entry.name

            val streamApiUrl = "$Elevenmovies/$staticPath/$serverToken"
            val streamResponseString = if (json.httpMethod == "GET") {
                app.get(streamApiUrl, headers = headers).body.string()
            } else {
                val postHeaders = mapOf(
                    "Referer" to Elevenmovies,
                    "Content-Type" to "application/vnd.api+json",
                    "X-CSRF-Token" to json.csrfToken,
                    "X-Requested-With" to "XMLHttpRequest"
                )
                val mediaType = "application/vnd.api+json".toMediaType()
                val requestBody = "".toRequestBody(mediaType)
                app.post(
                    streamApiUrl,
                    headers = postHeaders,
                    requestBody = requestBody
                ).body.string()
            }
            val streamRes =
                Gson().fromJson(streamResponseString, ElevenmoviesStreamResponse::class.java)
                    ?: continue
            val videoUrl = streamRes.url ?: continue

            M3u8Helper.generateM3u8(
                "Eleven Movies $serverName",
                videoUrl,
                ""
            ).forEach(callback)

            streamRes.tracks?.forEach { sub ->
                subtitleCallback.invoke(
                    newSubtitleFile(
                        sub.label ?: return@forEach,
                        sub.file ?: return@forEach
                    )
                )
            }
        }
    }

    // #region - Encryption and Decryption handlers
    @RequiresApi(Build.VERSION_CODES.O)
    suspend fun elevenMoviesTokenV2(rawData: String): String {
        val jsonUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/main/output.json"
        val jsonString = app.get(jsonUrl).text
        val gson = Gson()
        val json: Elevenmoviesjson = gson.fromJson(jsonString, Elevenmoviesjson::class.java)
        val keyHex = json.keyHex
        val ivHex = json.ivHex
        val aesKey = SecretKeySpec(keyHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray(), "AES")
        val aesIv = IvParameterSpec(ivHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray())

        // AES encrypt
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        cipher.init(Cipher.ENCRYPT_MODE, aesKey, aesIv)
        val aesEncrypted = cipher.doFinal(rawData.toByteArray())
        val aesHex = aesEncrypted.joinToString("") { "%02x".format(it) }

        // XOR operation
        val xorKeyHex = json.xorKey
        val xorKey = xorKeyHex.chunked(2)
            .map { it.toInt(16).toByte() }
            .toByteArray()

        val xorResult = aesHex.mapIndexed { index, char ->
            ((char.code.toByte() xor xorKey[index % xorKey.size]).toInt()).toChar()
        }.joinToString("")


        val src = json.src
        val dst = json.dst

        val b64 = base64Encode(xorResult.toByteArray())
            .replace("+", "-")
            .replace("/", "_")
            .replace("=", "")

        return b64.map { char ->
            val index = src.indexOf(char)
            if (index != -1) dst[index] else char
        }.joinToString("")
    }

    // #endregion - Encryption and Decryption handlers

    // #region - Data classes

    data class ElevenmoviesServerEntry(
        val name: String,
        val description: String,
        val image: String,
        val data: String,
    )

    data class ElevenmoviesStreamResponse(
        val url: String?,
        val tracks: List<ElevenmoviesSubtitle>?
    )

    data class ElevenmoviesSubtitle(
        val label: String?,
        val file: String?
    )

    data class Elevenmoviesjson(
        val src: String,
        val dst: String,

        @SerializedName("static_path")
        val staticPath: String,

        @SerializedName("http_method")
        val httpMethod: String,

        @SerializedName("key_hex")
        val keyHex: String,

        @SerializedName("iv_hex")
        val ivHex: String,

        @SerializedName("xor_key")
        val xorKey: String,

        @SerializedName("csrf_token")
        val csrfToken: String,

        @SerializedName("content_types")
        val contentTypes: String
    )
    // #endregion - Data classes

}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/HiAnime.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

class HiAnimeMediaProvider : MediaProvider() {
    override val name = "HiAnime"
    override val domain = "https://hianimez.is"
    override val categories = listOf(Category.ANIME)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        data.year ?: return
        val filterUrl = "$url/search?keyword=${fixName(data.title)}&sy=${data.year}"
        val filterRes = app.get(filterUrl).documentLarge
        val result = filterRes.selectFirst("div.film-poster > a")?.attr("href") ?: return
        val seasonId = result.substringAfterLast("-")
        val epListResUrl = "$url/ajax/v2/episode/list/$seasonId"
        val epListRes = app.get(epListResUrl).parsed<ApiResponseHTML>()
        if (!epListRes.status) return
        val epId =
                epListRes
                        .html()
                        .selectFirst("div.ss-list > a[data-number=\"${data.episode}\"]")
                        ?.attr("data-id")
                        ?: return
        val serversListResUrl = "$url/ajax/v2/episode/servers?episodeId=$epId"
        val serversListRes = app.get(serversListResUrl).parsed<ApiResponseHTML>()
        if (!serversListRes.status) return
        val servers =
                serversListRes.html().select("div.server-item").map {
                    it.attr("data-type").replaceFirstChar(Char::titlecase) to it.attr("data-id")
                }
        servers.amap { server ->
            val serverResUrl = "$url/ajax/v2/episode/sources?id=${server.second}"
            val serverRes = app.get(serverResUrl).parsed<ServerData>()
            if (serverRes.type == "error") return@amap
            val serverName =
                    when (serverRes.server) {
                        1 -> ServerName.Megacloud
                        4 -> ServerName.Megacloud
                        else -> return@amap
                    }
            commonLinkLoader(
                name,
                serverName,
                serverRes.link,
                null,
                server.first,
                subtitleCallback,
                callback
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    data class ApiResponseHTML(
            @JsonProperty("status") val status: Boolean,
            @JsonProperty("html") val result: String
    ) {
        fun html(): Document {
            return Jsoup.parse(result)
        }
    }

    data class ServerData(
            @JsonProperty("type") val type: String,
            @JsonProperty("link") val link: String,
            @JsonProperty("server") val server: Int
    )
    // #endregion - Data classes

    private fun fixName(name: String?):String? {
        return when(name) {
            "DAN DA DAN" -> "Dandadan"
            else -> name
        }
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/MovieBox.kt
================================================
package com.phisher98

import androidx.core.net.toUri
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import java.security.MessageDigest
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

class MovieBoxMediaProvider : MediaProvider() {
    override val name = "MovieBox"
    override val domain = "https://api.inmoviebox.com"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val title=data.title
        try {
            if (title.isNullOrBlank()) return

            val url = "$domain/wefeed-mobile-bff/subject-api/search/v2"
            val jsonBody = """{"page":1,"perPage":10,"keyword":"$title"}"""
            val xClientToken = generateXClientToken()
            val xTrSignature = generateXTrSignature(
                "POST", "application/json", "application/json; charset=utf-8", url, jsonBody
            )
            val headers = mapOf(
                "user-agent" to "com.community.mbox.in/50020042 (Linux; Android 16)",
                "accept" to "application/json",
                "content-type" to "application/json",
                "x-client-token" to xClientToken,
                "x-tr-signature" to xTrSignature,
                "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03"}""",
                "x-client-status" to "0"
            )

            val requestBody = jsonBody.toRequestBody("application/json".toMediaType())
            val response = app.post(url, headers = headers, requestBody = requestBody)
            if (response.code != 200) return

            val mapper = jacksonObjectMapper()
            val root = mapper.readTree(response.body.string())
            val results = root["data"]?.get("results") ?: return

            val matchingIds = mutableListOf<String>()
            for (result in results) {
                val subjects = result["subjects"] ?: continue
                for (subject in subjects) {
                    val name = subject["title"]?.asText() ?: continue
                    val id = subject["subjectId"]?.asText() ?: continue
                    val type = subject["subjectType"]?.asInt() ?: 0
                    if (name.contains(title, ignoreCase = true) && (type == 1 || type == 2)) {
                        matchingIds.add(id)
                    }
                }
            }
            if (matchingIds.isEmpty()) return

            for (id in matchingIds) {
                try {
                    val subjectUrl = "$domain/wefeed-mobile-bff/subject-api/get?subjectId=$id"
                    val subjectXToken = generateXClientToken()
                    val subjectXSign = generateXTrSignature("GET", "application/json", "application/json", subjectUrl)
                    val subjectHeaders = headers + mapOf(
                        "x-client-token" to subjectXToken,
                        "x-tr-signature" to subjectXSign
                    )
                    val subjectRes = app.get(subjectUrl, headers = subjectHeaders)
                    if (subjectRes.code != 200) continue

                    val subjectJson = mapper.readTree(subjectRes.body.string())
                    val subjectData = subjectJson["data"]
                    val subjectIds = mutableListOf<Pair<String, String>>()
                    var originalLanguageName = "Original"

                    // handle dubs
                    val dubs = subjectData?.get("dubs")
                    if (dubs != null && dubs.isArray) {
                        for (dub in dubs) {
                            val dubId = dub["subjectId"]?.asText()
                            val lanName = dub["lanName"]?.asText()
                            if (dubId != null && lanName != null) {
                                if (dubId == id) {
                                    originalLanguageName = lanName
                                } else {
                                    subjectIds.add(Pair(dubId, lanName))
                                }
                            }
                        }
                    }
                    subjectIds.add(0, Pair(id, originalLanguageName))

                    for ((subjectId, language) in subjectIds) {
                        val playUrl =
                            "$domain/wefeed-mobile-bff/subject-api/play-info?subjectId=$subjectId&se=${data.season ?: 0}&ep=${data.episode ?: 0}"
                        val token = generateXClientToken()
                        val sign = generateXTrSignature("GET", "application/json", "application/json", playUrl)
                        val playHeaders = headers + mapOf("x-client-token" to token, "x-tr-signature" to sign)

                        val playRes = app.get(playUrl, headers = playHeaders)
                        if (playRes.code != 200) continue

                        val playRoot = mapper.readTree(playRes.body.string())
                        val streams = playRoot["data"]?.get("streams") ?: continue
                        if (!streams.isArray) continue

                        for (stream in streams) {
                            val streamId = stream["id"]?.asText() ?: "$subjectId|${data.season}|${data.episode}"
                            val subjectTitle = subjectData?.get("title")?.asText() ?: "Unknown Title"
                            val format = stream["format"]?.asText() ?: ""
                            val signCookie = stream["signCookie"]?.asText()?.takeIf { it.isNotEmpty() }

                            val resolutionNodes = stream["resolutionList"] ?: stream["resolutions"]

                            if (resolutionNodes != null && resolutionNodes.isArray) {
                                for (resNode in resolutionNodes) {
                                    val resUrl = resNode["resourceLink"]?.asText() ?: continue
                                    val quality = resNode["resolution"]?.asInt() ?: 0

                                    callback.invoke(
                                        newExtractorLink(
                                            source = "MovieBox",
                                            name = "MovieBox (${language.capitalize()}) [$subjectTitle]",
                                            url = resUrl,
                                            type = when {
                                                resUrl.startsWith("magnet:", true) -> ExtractorLinkType.MAGNET
                                                resUrl.endsWith(".mpd", true) -> ExtractorLinkType.DASH
                                                resUrl.endsWith(".torrent", true) -> ExtractorLinkType.TORRENT
                                                format.equals("HLS", true) || resUrl.endsWith(".m3u8", true) -> ExtractorLinkType.M3U8
                                                else -> INFER_TYPE
                                            }
                                        ) {
                                            this.headers = mapOf("Referer" to domain) +
                                                    (if (signCookie != null) mapOf("Cookie" to signCookie) else emptyMap())
                                            this.quality = getQualityFromName("$quality")
                                        }
                                    )
                                }
                            } else {
                                // fallback single url
                                val singleUrl = stream["url"]?.asText() ?: continue
                                val resText = stream["resolutions"]?.asText() ?: ""

                                callback.invoke(
                                    newExtractorLink(
                                        source = "MovieBox",
                                        name = "MovieBox (${language.capitalize()}) [$subjectTitle]",
                                        url = singleUrl,
                                        type = when {
                                            singleUrl.startsWith("magnet:", true) -> ExtractorLinkType.MAGNET
                                            singleUrl.endsWith(".mpd", true) -> ExtractorLinkType.DASH
                                            singleUrl.endsWith(".torrent", true) -> ExtractorLinkType.TORRENT
                                            format.equals("HLS", true) || singleUrl.endsWith(".m3u8", true) -> ExtractorLinkType.M3U8
                                            else -> INFER_TYPE
                                        }
                                    ) {
                                        this.headers = mapOf("Referer" to domain) +
                                                (if (signCookie != null) mapOf("Cookie" to signCookie) else emptyMap())
                                        this.quality = getQualityFromName(resText)
                                    }
                                )
                            }

                            // subtitles
                            val subLinks = listOf(
                                "$domain/wefeed-mobile-bff/subject-api/get-stream-captions?subjectId=$subjectId&streamId=$streamId",
                                "$domain/wefeed-mobile-bff/subject-api/get-ext-captions?subjectId=$subjectId&resourceId=$streamId&episode=${data.episode ?: 0}"
                            )

                            for (subLink in subLinks) {
                                val subToken = generateXClientToken()
                                val subSign = generateXTrSignature("GET", "", "", subLink)

                                val subHeaders = mapOf(
                                    "User-Agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                                    "Accept" to "",
                                    "Content-Type" to "",
                                    "X-Client-Info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                                    "X-Client-Status" to "0",
                                    "x-client-token" to subToken,
                                    "x-tr-signature" to subSign
                                )

                                val subRes = app.get(subLink, headers = subHeaders)
                                if (subRes.code != 200) continue

                                val subRoot = mapper.readTree(subRes.body.string())
                                val captions = subRoot["data"]?.get("extCaptions")
                                if (captions != null && captions.isArray) {
                                    for (caption in captions) {
                                        val captionUrl = caption["url"]?.asText() ?: continue
                                        val lang = caption["language"]?.asText()
                                            ?: caption["lanName"]?.asText()
                                            ?: caption["lan"]?.asText()
                                            ?: "Unknown"
                                        subtitleCallback.invoke(
                                            newSubtitleFile(
                                                url = captionUrl,
                                                lang = "$lang (${language.capitalize()})"
                                            )
                                        )
                                    }
                                }
                            }
                        }
                    }
                } catch (_: Exception) {
                    continue
                }
            }
            return
        } catch (_: Exception) {
            return
        }
    }
}


private fun md5(input: ByteArray): String {
    return MessageDigest.getInstance("MD5").digest(input)
        .joinToString("") { "%02x".format(it) }
}

private fun reverseString(input: String): String = input.reversed()

fun generateXClientToken(hardcodedTimestamp: Long? = null): String {
    val timestamp = (hardcodedTimestamp ?: System.currentTimeMillis()).toString()
    val reversed = reverseString(timestamp)
    val hash = md5(reversed.toByteArray())
    return "$timestamp,$hash"
}

fun generateXTrSignature(
    method: String,
    accept: String? = "application/json",
    contentType: String? = "application/json",
    url: String,
    body: String? = null,
    useAltKey: Boolean = false,
    hardcodedTimestamp: Long? = null
): String {
    val timestamp = hardcodedTimestamp ?: System.currentTimeMillis()

    val canonical = buildCanonicalString(
        method = method,
        accept = accept,
        contentType = contentType,
        url = url,
        body = body,
        timestamp = timestamp
    )
    val secretKey = if (useAltKey) {
        BuildConfig.MOVIEBOX_SECRET_KEY_ALT
    } else {
        BuildConfig.MOVIEBOX_SECRET_KEY_DEFAULT
    }
    val secretBytes = android.util.Base64.decode(secretKey, android.util.Base64.DEFAULT)
    val mac = Mac.getInstance("HmacMD5").apply {
        init(SecretKeySpec(secretBytes, "HmacMD5"))
    }
    val rawSignature = mac.doFinal(canonical.toByteArray(Charsets.UTF_8))
    val signatureBase64 = android.util.Base64.encodeToString(rawSignature, android.util.Base64.NO_WRAP)
    return "$timestamp|2|$signatureBase64"
}


private fun buildCanonicalString(
    method: String,
    accept: String?,
    contentType: String?,
    url: String,
    body: String?,
    timestamp: Long
): String {
    val parsed = url.toUri()
    val path = parsed.path ?: ""

    // Build query string with sorted parameters (if any)
    val query = if (parsed.queryParameterNames.isNotEmpty()) {
        parsed.queryParameterNames.sorted().joinToString("&") { key ->
            parsed.getQueryParameters(key).joinToString("&") { value ->
                "$key=$value"  // Don't URL encode here - Python doesn't do it
            }
        }
    } else ""

    val canonicalUrl = if (query.isNotEmpty()) "$path?$query" else path

    val bodyBytes = body?.toByteArray(Charsets.UTF_8)
    val bodyHash = if (bodyBytes != null) {
        val trimmed = if (bodyBytes.size > 102400) bodyBytes.copyOfRange(0, 102400) else bodyBytes
        md5(trimmed)
    } else ""

    val bodyLength = bodyBytes?.size?.toString() ?: ""
    return "${method.uppercase()}\n" +
            "${accept ?: ""}\n" +
            "${contentType ?: ""}\n" +
            "$bodyLength\n" +
            "$timestamp\n" +
            "$bodyHash\n" +
            canonicalUrl
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/MoviesDrive.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.api.Log
import com.phisher98.UltimaMediaProvidersUtils.ServerName.*
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader

class MoviesDriveProvider : MediaProvider() {
    override val name = "MoviesDrive"
    override val domain = "https://moviesdrive.channel"
    override val categories = listOf(Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val movieDriveAPI = getDomains()?.moviesdrive ?: return
        val cleanTitle = data.title.orEmpty()
        val season =data.season
        val episode=data.episode
        val year= data.year
        val searchUrl = buildString {
            append("$movieDriveAPI/?s=$cleanTitle")
            if (season != null && !cleanTitle.contains(season.toString(), ignoreCase = true)) {
                append(" $season")
            } else if (season == null && year != null) {
                append(" $year")
            }
        }

        val figures = retry {
            val allFigures =
                app.get(searchUrl, interceptor = CloudflareKiller()).documentLarge.select("figure")
            if (season == null) {
                allFigures
            } else {
                val seasonPattern = Regex("""season\s*${season}\b""", RegexOption.IGNORE_CASE)
                allFigures.filter { figure ->
                    val img = figure.selectFirst("img")
                    val alt = img?.attr("alt").orEmpty()
                    val titleAttr = img?.attr("title").orEmpty()
                    seasonPattern.containsMatchIn(alt) || seasonPattern.containsMatchIn(titleAttr)
                }
            }
        } ?: return

        for (figure in figures) {
            val detailUrl = figure.selectFirst("a[href]")?.attr("href").orEmpty()
            if (detailUrl.isBlank()) continue

            val detailDoc = retry {
                app.get(detailUrl, interceptor = CloudflareKiller()).documentLarge
            } ?: continue

            val imdbId = detailDoc
                .select("a[href*=\"imdb.com/title/\"]")
                .firstOrNull()
                ?.attr("href")
                ?.substringAfter("title/")
                ?.substringBefore("/")
                ?.takeIf { it.isNotBlank() } ?: continue

            val titleMatch = imdbId == data.imdbId.orEmpty() || detailDoc
                .select("main > p:nth-child(10)")
                .firstOrNull()
                ?.text()
                ?.contains(cleanTitle, ignoreCase = true) == true

            if (!titleMatch) continue

            if (season == null) {
                val links = detailDoc.select("h5 a")
                for (element in links) {
                    val urls = retry { extractMdrive(element.attr("href")) } ?: continue
                    for (serverUrl in urls) {
                        processMoviesdriveUrl(serverUrl, subtitleCallback, callback)
                    }
                }
            } else {
                val seasonPattern = "(?i)Season\\s*0?$season\\b|S0?$season\\b"
                val episodePattern =
                    "(?i)Ep\\s?0?$episode\\b|Episode\\s+0?$episode\\b|V-Cloud|G-Direct|OXXFile"

                val seasonElements = detailDoc.select("h5:matches($seasonPattern)")
                if (seasonElements.isEmpty()) continue

                val allLinks = mutableListOf<String>()

                for (seasonElement in seasonElements) {
                    val seasonHref = seasonElement.nextElementSibling()
                        ?.selectFirst("a")
                        ?.attr("href")
                        ?.takeIf { it.isNotBlank() } ?: continue

                    val episodeDoc = retry { app.get(seasonHref).documentLarge } ?: continue
                    val episodeHeaders = episodeDoc.select("h5:matches($episodePattern)")

                    for (header in episodeHeaders) {

                        val siblingLinks =
                            generateSequence(header.nextElementSibling()) { it.nextElementSibling() }
                                .takeWhile { it.tagName() != "hr" }
                                .filter { it.tagName() == "h5" }
                                .mapNotNull { h5 ->
                                    h5.selectFirst("a")?.takeIf { a ->
                                        !a.text()
                                            .contains("Zip", ignoreCase = true) && a.hasAttr("href")
                                    }?.attr("href")
                                }.toList()

                        allLinks.addAll(siblingLinks)
                    }
                }
                if (allLinks.isNotEmpty()) {
                    for (serverUrl in allLinks) {
                        processMoviesdriveUrl(serverUrl, subtitleCallback, callback)
                    }
                } else {
                    detailDoc.select("h5 a:contains(HubCloud)")
                        .mapNotNull { it.attr("href").takeIf { href -> href.isNotBlank() } }
                        .forEach { fallbackUrl ->
                            processMoviesdriveUrl(fallbackUrl, subtitleCallback, callback)
                        }
                }
            }
        }
    }


    @RequiresApi(Build.VERSION_CODES.O)
    private suspend fun processMoviesdriveUrl(
        serverUrl: String,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        when {
            serverUrl.contains("hubcloud", ignoreCase = true) -> {
                commonLinkLoader(
                    name,
                    Hubcloud,
                    serverUrl,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }

            serverUrl.contains("gdlink", ignoreCase = true) -> {
                commonLinkLoader(
                    name,
                    GDFlix,
                    serverUrl,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }
            else -> {
                loadExtractor(serverUrl, referer = "MoviesDrive", subtitleCallback, callback)
            }
        }
    }
    // Extractor



    private suspend fun extractMdrive(url: String): List<String> {
        val regex = Regex("hubcloud|gdflix|gdlink", RegexOption.IGNORE_CASE)

        return try {
            app.get(url).documentLarge
                .select("a[href]")
                .mapNotNull { element ->
                    val href = element.attr("href")
                    if (regex.containsMatchIn(href)) {
                        href
                    } else {
                        null
                    }
                }
        } catch (e: Exception) {
            Log.e("Error Mdrive", "Error extracting links: ${e.localizedMessage}")
            emptyList()
        }
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/MultiEmbededAPI.kt
================================================
package com.phisher98

import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.mozilla.javascript.Scriptable

class MultiEmbededAPIProvider : MediaProvider() {
    override val name = "MultiEmbeded API"
    override val domain = "https://multiembed.mov"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val mediaUrl =
                if (data.season == null) {
                    "$url/directstream.php?video_id=${data.imdbId}"
                } else {
                    "$url/directstream.php?video_id=${data.imdbId}&s=${data.season}&e=${data.episode}"
                }
        val res = app.get(mediaUrl, referer = mediaUrl).documentLarge
        val script =
                res.selectFirst("script:containsData(function(h,u,n,t,e,r))")?.data().toString()
        if (script.isNotEmpty()) {
            val firstJS =
                    """
        var globalArgument = null;
        function Playerjs(arg) {
        globalArgument = arg;
        };
        """.trimIndent()
            val rhino = org.mozilla.javascript.Context.enter()
            rhino.setInterpretedMode(true)
            val scope: Scriptable = rhino.initSafeStandardObjects()
            rhino.evaluateString(scope, firstJS + script, "JavaScript", 1, null)
            val file =
                    (scope.get("globalArgument", scope).toJson())
                            .substringAfter("file\":\"")
                            .substringBefore("\",")
            callback.invoke(
                newExtractorLink(
                    "MultiEmbeded API",
                    "MultiEmbeded API",
                    file,
                    INFER_TYPE
                )
                {
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/MultiMovies.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaMediaProvidersUtils.createSlug
import com.phisher98.UltimaMediaProvidersUtils.getBaseUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class MultiMoviesProvider : MediaProvider() {
    override val name = "MultiMovies"
    override val domain = "https://multimovies.coupons"
    override val categories = listOf(Category.MEDIA)
    private val xmlHeader = mapOf("X-Requested-With" to "XMLHttpRequest")

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val multimoviesAPI = getDomains()?.multiMovies ?: return

        val fixTitle = data.title.createSlug()
        val mediaurl =
                if (data.season == null) {
                    "$multimoviesAPI/movies/$fixTitle"
                } else {
                    "$multimoviesAPI/episodes/$fixTitle-${data.season}x${data.episode}"
                }
        val req = app.get(mediaurl).documentLarge
        req.select("ul#playeroptionsul li").amap {
            val id = it.attr("data-post")
            val nume = it.attr("data-nume")
            val type = it.attr("data-type")
            if (nume.contains("trailer")) return@amap
            val apiUrl = "$url/wp-admin/admin-ajax.php"
            val postData =
                mapOf(
                    "action" to "doo_player_ajax",
                    "post" to id,
                    "nume" to nume,
                    "type" to type
                )
            val source =
                app.post(url = apiUrl, data = postData, referer = url, headers = xmlHeader)
                    .parsed<ResponseHash>()
                    .embed_url
            val link = source.substringAfter("\"").substringBefore("\"")
            val domain = getBaseUrl(link)
            val serverName =
                when (domain) {
                    "https://aa.clonimeziud" -> ServerName.Vidhide
                    "https://server2.shop" -> ServerName.Vidhide
                    "https://multimovies.cloud" -> ServerName.StreamWish
                    "https://allinonedownloader.fun" -> ServerName.StreamWish
                    else -> ServerName.NONE
                }
            commonLinkLoader(name, serverName, link, null, null, subtitleCallback, callback)
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes

    data class ResponseHash(
            @JsonProperty("embed_url") val embed_url: String,
            @JsonProperty("key") val key: String? = null,
            @JsonProperty("type") val type: String? = null,
    )
    // #endregion - Data classes
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/Noverse.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.createSlug
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import kotlinx.coroutines.delay

class NoverseMediaProvider : MediaProvider() {
    override val name = "Noverse"
    override val domain = "https://www.thenollyverse.com"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val fixTitle = data.title.createSlug()
        val mediaUrl =
                if (data.season == null) {
                    "$url/movie/$fixTitle/download/"
                } else {
                    "$url/serie/$fixTitle/season-${data.season}"
                }

        val doc = app.get(mediaUrl).documentLarge
        val links =
                if (data.season == null) {
                    doc.select("div.section-row table.table-striped tbody tr").map {
                        it.select("a").attr("href") to it.selectFirst("td")?.text()
                    }
                } else {
                    doc.select("div.section-row table.table-striped tbody tr")
                            .find { it.text().contains("Episode ${data.episode}") }
                            ?.select("td")
                            ?.map { it.select("a").attr("href") to it.select("a").text() }
                }
                        ?: return

        delay(4000)
        links.map { (link, quality) ->
            // if (quality.equals("Subtitles")) return@mapNotNull
            val tag = quality?.split(".")?.getOrNull(1)
            UltimaMediaProvidersUtils.commonLinkLoader(
                name,
                ServerName.Custom,
                link,
                null,
                null,
                subtitleCallback,
                callback,
                getQualityFromName("${quality?.substringBefore("p")?.trim()}p"),
                tag = tag,
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/NowTv.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.getEpisodeSlug
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class NowTvMediaProvider : MediaProvider() {
    override val name = "NowTv"
    override val domain = "https://myfilestorage.xyz"
    override val categories = listOf(Category.MEDIA)
    private val referer = "https://w1.nites.is/"

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        suspend fun String.isSuccess(): Boolean {
            return app.get(this, referer = referer).isSuccessful
        }

        val slug = getEpisodeSlug(data.season, data.episode)
        var mediaUrl =
                if (data.season == null) "$url/${data.tmdbId}.mp4"
                else "$url/tv/${data.tmdbId}/s${data.season}e${slug.second}.mp4"
        if (!mediaUrl.isSuccess()) {
            mediaUrl =
                    if (data.season == null) {
                        val temp = "$url/${data.imdbId}.mp4"
                        if (temp.isSuccess()) temp else "$url/${data.tmdbId}-1.mp4"
                    } else {
                        "$url/tv/${data.imdbId}/s${data.season}e${slug.second}.mp4"
                    }
            if (!app.get(mediaUrl, referer = referer).isSuccessful) return
        }
        UltimaMediaProvidersUtils.commonLinkLoader(
            name,
            ServerName.Custom,
            mediaUrl,
            url,
            null,
            subtitleCallback,
            callback
        )
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/PrimeWireProvider.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec

class PrimeWireProvider : MediaProvider() {
    override val name = "PrimeWireProvider"
    override val domain = "https://www.primewire.tf"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val apiurl = if (data.season == null) {
            "$domain/embed/movie?imdb=${data.imdbId}"
        } else {
            "$domain/embed/tv?imdb=${data.imdbId}&season=${data.season}&episode=${data.episode}"
        }

        val doc = app.get(apiurl, timeout = 10).documentLarge
        val userData = doc.select("#user-data")
        val decryptedLinks = decryptLinks(userData.attr("v"))
        for (link in decryptedLinks) {
            val href = "$domain/links/gos/$link"
            val token= app.get("https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Primetoken.txt").text
            val oUrl = app.get(href, timeout = 10)
            val iframeurl= app.get("${oUrl.url.replace("/gos/","/go/")}?token=$token").parsedSafe<Root>()?.link
            if (iframeurl != null) {
                loadSourceNameExtractor(
                    "Primewire ",
                    iframeurl,
                    "",
                    subtitleCallback,
                    callback,
                    quality = getQualityFromName("")
                )
            }
        }
    }

    private fun decryptLinks(data: String): List<String> {
        val key = data.substring(data.length - 10)
        val ct = data.substring(0, data.length - 10)
        val pt = decryptBase64BlowfishEbc(ct, key)
        return pt.chunked(5)
    }

    @SuppressLint("GetInstance")
    private fun decryptBase64BlowfishEbc(base64Encrypted: String, key: String): String {
        try {
            val encryptedBytes = base64DecodeArray(base64Encrypted)
            val secretKeySpec = SecretKeySpec(key.toByteArray(), "Blowfish")
            val cipher = Cipher.getInstance("Blowfish/ECB/NoPadding")
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec)
            val decryptedBytes = cipher.doFinal(encryptedBytes)
            return String(decryptedBytes)
        } catch (e: Exception) {
            e.printStackTrace()
            return "Decryption failed: ${e.message}"
        }
    }

    private suspend fun loadSourceNameExtractor(
        source: String,
        url: String,
        referer: String? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        quality: Int? = null,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        "$source[${link.source}]",
                        "$source[${link.source}]",
                        link.url,
                    ) {
                        this.quality = link.quality
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }
    
    data class Root(
        val link: String,
        @JsonProperty("host_id")
        val hostId: Long,
        val host: String,
    )
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/TwoEmbed.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.getBaseUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class TwoEmbedMediaProvider : MediaProvider() {
    override val name = "2Embed"
    override val domain = "https://www.2embed.cc"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val mediaUrl =
                if (data.season == null) {
                    "$url/embed/${data.imdbId}"
                } else {
                    "$url/embedtv/${data.imdbId}&s=${data.season}&e=${data.episode}"
                }
        val framesrc =
                app.get(mediaUrl).documentLarge.selectFirst("iframe#iframesrc")?.attr("data-src")
                        ?: return
        val referer = getBaseUrl(framesrc) + "/"
        val id = framesrc.substringAfter("id=").substringBefore("&")
        val finalUrl = "https://uqloads.xyz/e/$id"
        UltimaMediaProvidersUtils.commonLinkLoader(
            name,
            ServerName.Uqload,
            finalUrl,
            referer,
            null,
            subtitleCallback,
            callback
        )
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/VegaMovies.kt
================================================
package com.phisher98.MediaProviders

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.MediaProvider
import com.phisher98.UltimaMediaProvidersUtils.ServerName.Vcloud
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.phisher98.getDomains
import kotlinx.coroutines.delay


class VegaMoviesProvider : MediaProvider() {
    override val name = "VegaMovies"
    override val domain = "https://vegamovies.moi"
    override val categories = listOf(Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
            "cookie" to "xla=s4t",
            "Accept-Language" to "en-US,en;q=0.9",
            "sec-ch-ua" to "\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Microsoft Edge\";v=\"120\"",
            "sec-ch-ua-mobile" to "?0",
            "sec-ch-ua-platform" to "\"Linux\"",
            "Sec-Fetch-Dest" to "document",
            "Sec-Fetch-Mode" to "navigate",
            "Sec-Fetch-Site" to "none",
            "Sec-Fetch-User" to "?1",
            "Upgrade-Insecure-Requests" to "1",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36"
        )
        val vegaMoviesAPI = getDomains()?.vegamovies ?: return
        val title=data.title
        val season=data.season
        val year=data.year
        val imdbId=data.imdbId
        val cfInterceptor = CloudflareKiller()
        val fixtitle =
            title?.substringBefore("-")?.substringBefore(":")?.replace("&", " ")?.trim().orEmpty()
        val query = if (season == null) "$fixtitle $year" else "$fixtitle season $season $year"
        val primaryUrl = "$vegaMoviesAPI/?s=$query"
        val secondaryUrl = "$vegaMoviesAPI/?search=$query"
        val excludedButtonTexts = setOf("Filepress", "GDToT", "DropGalaxy")

        val searchDoc = retry { app.get(primaryUrl, interceptor = cfInterceptor, headers = headers).documentLarge }
            ?: retry { app.get(secondaryUrl, interceptor = cfInterceptor, headers = headers).documentLarge }
            ?: return
        val articles = searchDoc.select("article h2")
        if (articles.isEmpty()) return

        var foundLinks = false

        for (article in articles) {
            val hrefpattern = article.selectFirst("a")?.attr("href").orEmpty()
            if (hrefpattern.isBlank()) continue

            val doc = retry { app.get(hrefpattern).documentLarge } ?: continue

            val imdbAnchor =
                doc.selectFirst("div.entry-inner p strong a[href*=\"imdb.com/title/tt\"]")
            val imdbHref = imdbAnchor?.attr("href")?.lowercase()

            if (imdbId != null && (imdbHref == null || !imdbHref.contains(imdbId.lowercase()))) {
                Log.i("Skip", "IMDb ID mismatch: $imdbHref != $imdbId")
                continue
            }

            if (season == null) {
                // Movie Mode
                val btnLinks = doc.select("button.dwd-button")
                    .filterNot { btn ->
                        excludedButtonTexts.any {
                            btn.text().contains(it, ignoreCase = true)
                        }
                    }
                    .mapNotNull {
                        it.closest("a")?.attr("href")?.takeIf { link -> link.isNotBlank() }
                    }

                if (btnLinks.isEmpty()) continue

                for (detailUrl in btnLinks) {
                    val detailDoc = retry { app.get(detailUrl).documentLarge } ?: continue

                    val streamingLinks = detailDoc.select("button.btn.btn-sm.btn-outline")
                        .filterNot { btn ->
                            excludedButtonTexts.any {
                                btn.text().contains(it, ignoreCase = true)
                            }
                        }
                        .mapNotNull {
                            it.closest("a")?.attr("href")?.takeIf { link -> link.isNotBlank() }
                        }

                    if (streamingLinks.isEmpty()) continue

                    for (streamingUrl in streamingLinks) {
                        commonLinkLoader(
                            name,
                            Vcloud,
                            streamingUrl,
                            null,
                            null,
                            subtitleCallback,
                            callback
                        )
                        foundLinks = true
                    }
                }

            } else {
                // TV Show Mode
                val seasonPattern = "(?i)(Season $season)"
                val episodePattern = "(?i)(V-Cloud|Single|Episode|G-Direct)"

                val seasonElements =
                    doc.select("h4:matches($seasonPattern), h3:matches($seasonPattern)")

                if (seasonElements.isEmpty()) continue

                for (seasonElement in seasonElements) {
                    val episodeLinks = seasonElement.nextElementSibling()
                        ?.select("a:matches($episodePattern)")
                        ?.mapNotNull { it.attr("href").takeIf { link -> link.isNotBlank() } }
                        ?: continue

                    if (episodeLinks.isEmpty()) continue

                    for (episodeUrl in episodeLinks) {
                        val episodeDoc = retry { app.get(episodeUrl).documentLarge } ?: continue

                        val matchBlock =
                            episodeDoc.selectFirst("h4:contains(Episodes):contains(${data.episode})")
                                ?.nextElementSibling()
                                ?.select("a:matches((?i)(V-Cloud|G-Direct|OxxFile))")
                                ?.mapNotNull {
                                    it.attr("href").takeIf { link -> link.isNotBlank() }
                                }

                        if (matchBlock.isNullOrEmpty()) continue

                        for (streamingUrl in matchBlock) {
                            commonLinkLoader(
                                name,
                                Vcloud,
                                streamingUrl,
                                null,
                                null,
                                subtitleCallback,
                                callback
                            )
                            foundLinks = true
                        }
                    }
                }
            }
        }

        if (!foundLinks) {
            Log.d("VegaMovies", "No valid streaming links found for: $title")
            return
        }
    }
}

private suspend fun <T> retry(
    times: Int = 3,
    delayMillis: Long = 1000,
    block: suspend () -> T
): T? {
    repeat(times - 1) {
        runCatching { return block() }.onFailure { delay(delayMillis) }
    }
    return runCatching { block() }.getOrNull()
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/Vidflast.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class VidFlastProvider : MediaProvider() {
    override val name = "VidFast"
    override val domain = "https://www.vidfast.pro"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val apiurl = if (data.season == null) {
            "$domain/movie/${data.imdbId}"
        } else {
            "$domain/tv/${data.imdbId}/${data.season}/${data.episode}"
        }

        val regexData = app.get(apiurl).text
        val regex = Regex("""\\"en\\":\\"(.*?)\\""")

        val rawData = regex.find(regexData)?.groupValues?.getOrNull(1)
            ?: return println("❌ No match found.")

        val keyHex = "13346e2c05211f72e46a465e953fd5410826715e28d927f92ea5f4daee985c8b"
        val ivHex = "b83bcd42b90f5364e9b95c398264bca4"
        val aesKey = keyHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        val aesIv = ivHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()

        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        val keySpec = SecretKeySpec(aesKey, "AES")
        val ivSpec = IvParameterSpec(aesIv)
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec)

        val blockSize = 16
        val padLength = blockSize - rawData.toByteArray().size % blockSize
        val paddedData = rawData.toByteArray() + ByteArray(padLength) { padLength.toByte() }
        val encrypted = cipher.doFinal(paddedData)

        val xorKey = "3fc3e051ddc9dd8a74".chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        val xorResult = ByteArray(encrypted.size) { i ->
            (encrypted[i].toInt() xor xorKey[i % xorKey.size].toInt()).toByte()
        }
        val headers = mapOf(
            "Accept" to "*/*",
            "Referer" to domain,
            "x-session" to "",
            "X-Requested-With" to "XMLHttpRequest",
            "X-Csrf-Token" to "lVx7BVtk9c3SMNbF49PNvUc7GV5zzdem"
        )

        val encodedFinal = customBase64EncodeVidfast(xorResult)
        val staticPath = "rebivol/ad/w/2c7998b18129848378021254f87db35df8f562b2/2cf30a7c/APA91nNHHa3xbnvasl8ciswLATkt2fIiVFciF5RLarK4oR7nrTpEDSBjO_kRoBJD730BWfo6bQZIpxCr-PAlSGc8GAAxueegNH5gNzrcqhPDliciuUDv0GTqb_2t1ik9pIAXpVaZ8inm6ey56Qf44wrOOPUfZYlkKuKs18mNKqBluBYTB5lBXWF/775d49bf3b9b4d082f5156cd9f36e21d42014547cd9282b1fe62ccbe3d09f66b/1000094661747536"
        val apiServersUrl = "https://vidfast.pro/$staticPath/k33a7dwPZst1/$encodedFinal"
        val gson = Gson()
        val jsonMedia = "{}".toRequestBody("application/json".toMediaTypeOrNull())
        val responseBody = app.post(apiServersUrl, headers = headers, requestBody = jsonMedia).body.string()
        val type = object : TypeToken<List<VidfastServerData>>() {}.type
        val apiResponse: List<VidfastServerData>? = gson.fromJson(responseBody, type)

        if (apiResponse != null) {
            for (item in apiResponse) {
                val serverName = item.name
                val serverData = item.data ?: continue
                val apiStream = "https://vidfast.pro/$staticPath/p6PWA5s/$serverData"

                try {
                    val streamResponse = app.post(apiStream, headers = headers, requestBody = jsonMedia)
                    val streamBody = streamResponse.body.string()
                    val resultJson = JSONObject(streamBody)

                    val streamUrl = if (resultJson.has("url")) resultJson.getString("url") else null
                    val m3u8headers = mapOf(
                        "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
                        "Referer" to "https://vidfast.pro/",
                        "Origin" to "https://vidfast.pro",
                    )

                    if (streamUrl != null) {
                        if (streamUrl.contains(".m3u8")) {
                            M3u8Helper.generateM3u8("Vidfast [$serverName]", streamUrl, domain, headers = m3u8headers)
                                .forEach(callback)
                        } else {
                            callback.invoke(
                                newExtractorLink(
                                    "Vidfast",
                                    "Vidfast D [$serverName]",
                                    streamUrl,
                                    INFER_TYPE
                                ) {
                                    referer = domain
                                    quality = Qualities.Unknown.value
                                    this.headers = m3u8headers
                                }
                            )
                        }
                    }
                } catch (e: Exception) {
                    Log.e("Vidfast Error:", "❌ [$serverName] Failed for $apiStream: ${e.message}")
                }
            }
        }
    }


    private fun customBase64EncodeVidfast(input: ByteArray): String {
        val sourceChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"
        val targetChars = "Ju9Egn27FZNe-kaMUtOBAmf0qp3xDYlTX6PhiL5SRjzQIsHvoVw_WC4dGc1Ky8rb"

        // Standard Base64 URL-safe encode, no padding or wrap
        val base64 = android.util.Base64.encodeToString(
            input,
            android.util.Base64.URL_SAFE or android.util.Base64.NO_PADDING or android.util.Base64.NO_WRAP
        )

        // Translate characters to custom charset
        val translationMap = sourceChars.zip(targetChars).toMap()
        return base64.map { translationMap[it] ?: it }.joinToString("")
    }


    // #region - Data classes

    data class VidfastServerData(
        val name: String,
        val description: String,
        val image: String,
        val data: String?
    )

    // #endregion - Data classes

}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/Vidsrccc.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import java.security.MessageDigest
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


class VidsrcccProvider : MediaProvider() {
    override val name = "VidSrc CC"
    override val domain = "https://vidsrc.cc"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val url = if (data.season == null) {
            "$domain/v2/embed/movie/${data.tmdbId}?autoPlay=false"
        } else {
            "$domain/v2/embed/tv/${data.tmdbId}/${data.season}/${data.episode}?autoPlay=false"
        }
        val doc = app.get(url).documentLarge.toString()
        val regex = Regex("""var\s+(\w+)\s*=\s*(?:"([^"]*)"|(\w+));""")
        val variables = mutableMapOf<String, String>()

        regex.findAll(doc).forEach { match ->
            val key = match.groupValues[1]
            val value = match.groupValues[2].ifEmpty { match.groupValues[3] }
            variables[key] = value
        }
        val vvalue = variables["v"] ?: ""
        val userId = variables["userId"] ?: ""
        val imdbId = variables["imdbId"] ?: ""
        val movieId = variables["movieId"] ?: ""
        val movieType = variables["movieType"] ?: ""

        val vrf = generateVidsrcVrf(movieId,userId)
        val apiurl = if (data.season == null) {
            "${domain}/api/${data.tmdbId}/servers?id=${data.tmdbId}&type=$movieType&v=$vvalue=&vrf=$vrf&imdbId=$imdbId"
        } else {
            "${domain}/api/${data.tmdbId}/servers?id=${data.tmdbId}&type=$movieType&season=${data.season}&episode=${data.episode}&v=$vvalue&vrf=${vrf}&imdbId=$imdbId"
        }
        app.get(apiurl).parsedSafe<Vidsrcccservers>()?.data?.forEach {
            val servername = it.name
            val iframe = app.get("$domain/api/source/${it.hash}")
                .parsedSafe<Vidsrcccm3u8>()?.data?.source
            val sourceUrl = iframe?.let { iframeUrl ->
                val response = app.get(iframeUrl, referer = domain).text
                val urlregex = Regex("""var\s+source\s*=\s*"([^"]+)"""")
                val match = urlregex.find(response)
                match?.groups?.get(1)?.value?.replace("""\\/""".toRegex(), "/")
            }

            sourceUrl?.let { url->
                commonLinkLoader(
                    "⌜ Vidsrc ⌟ | [$servername]",
                    ServerName.Videostr,
                    url,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }
        }
    }

    private fun generateVidsrcVrf(movieId: String, userId: String): String {
        val keyBytes = MessageDigest.getInstance("SHA-256").digest(userId.toByteArray())
        val key = SecretKeySpec(keyBytes, "AES")
        val iv = IvParameterSpec(ByteArray(16))
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        cipher.init(Cipher.ENCRYPT_MODE, key, iv)
        val plaintext = movieId.toByteArray()
        val ciphertext = cipher.doFinal(plaintext)
        val encoded = base64Encode(ciphertext)
        val urlSafe = encoded.replace('+', '-').replace('/', '_').replace("=", "")
        return urlSafe
    }

    data class Vidsrcccservers(
        val data: List<VidsrcccDaum>,
        val success: Boolean,
    )

    data class VidsrcccDaum(
        val name: String,
        val hash: String,
    )

    data class Vidsrcccm3u8(
        val data: VidsrcccData,
        val success: Boolean,
    )

    data class VidsrcccData(
        val type: String,
        val source: String,
    )
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/Watch32.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

class Watch32Provider : MediaProvider() {
    override val name = "Watch32"
    override val domain = "https://watch32.sx"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        if (data.title.isNullOrBlank()) return

        val type = if (data.season == null) "Movie" else "TV"
        val searchUrl = "$domain/search/${data.title.trim().replace(" ", "-")}"

        val matchedElement = runCatching {
            val doc = app.get(searchUrl, timeout = 120L).documentLarge
            val results = doc.select("div.flw-item")

            results.firstOrNull { item ->
                val titleElement = item.selectFirst("h2.film-name a")
                val typeElement = item.selectFirst("span.fdi-type")
                val name = titleElement?.text()?.trim() ?: return@firstOrNull false
                val mediaType = typeElement?.text()?.trim() ?: return@firstOrNull false

                name.contains(data.title, ignoreCase = true) && mediaType.equals(type, ignoreCase = true)
            }?.selectFirst("h2.film-name a")
        }.getOrNull() ?: return
        val detailUrl = domain+matchedElement.attr("href")
        val typee=if (type=="Movie") TvType.Movie else TvType.TvSeries
        val infoId=detailUrl.substringAfterLast("-")

        if (typee == TvType.TvSeries) {
            val seasonLinks = runCatching {
                app.get("$domain/ajax/season/list/$infoId").documentLarge.select("div.dropdown-menu a")
            }.getOrNull() ?: return

            val matchedSeason = seasonLinks.firstOrNull {
                it.text().contains("Season ${data.season}", ignoreCase = true)
            } ?: return

            val seasonId = matchedSeason.attr("data-id")

            val episodeLinks = runCatching {
                app.get("$domain/ajax/season/episodes/$seasonId").documentLarge.select("li.nav-item a")
            }.getOrNull() ?: return

            val matchedEpisode = episodeLinks.firstOrNull {
                it.text().contains("Eps ${data.episode}:", ignoreCase = true)
            } ?: return

            val dataId = matchedEpisode.attr("data-id")

            val serverDoc = runCatching {
                app.get("$domain/ajax/episode/servers/$dataId").documentLarge
            }.getOrNull() ?: return

            val sourceButtons = serverDoc.select("li.nav-item a")
            for (source in sourceButtons) {
                val sourceId = source.attr("data-id") ?: continue

                val iframeUrl = runCatching {
                    app.get("$domain/ajax/episode/sources/$sourceId")
                        .parsedSafe<Watch32>()?.link
                }.getOrNull() ?: continue
                commonLinkLoader(name, ServerName.Videostr, iframeUrl, null, null, subtitleCallback, callback)
            }
        }
        else
        {
            val episodeLinks = runCatching {
                app.get("$domain/ajax/episode/list/$infoId").documentLarge.select("li.nav-item a")
            }.getOrNull() ?: return

            episodeLinks.forEach { ep ->
                val dataId = ep.attr("data-id")
                val iframeUrl = runCatching {
                    app.get("$domain/ajax/episode/sources/$dataId")
                        .parsedSafe<Watch32>()?.link
                }.getOrNull() ?: return@forEach
                commonLinkLoader(name, ServerName.Videostr, iframeUrl, null, null, subtitleCallback, callback)
            }
        }
    }

    data class Watch32(
        val type: String,
        val link: String,
    )
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MediaProviders/XPrimeProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.KotlinModule
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.api.Log
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink

class XPrimeProvider : MediaProvider() {
    override val name = "XPrimeProvider"
    override val domain = "https://xprime.tv"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val backendAPI = getDomains()?.xprime ?: return
        val servers = app.get("$backendAPI/servers").parsedSafe<XprimeServers>() ?: return

        val objectMapper = ObjectMapper()
            .registerModule(KotlinModule.Builder().build())
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)

        servers.servers.forEach { server ->
            if (server.status != "ok") return@forEach

            val baseUrl = "$backendAPI/${server.name}"
            val queryParams = buildString {
                append("?name=${data.title.orEmpty()}")
                when (server.name) {
                    "primebox" -> {
                        if (data.year != null) append("&fallback_year=${data.year}")
                        if (data.season != null && data.episode != null) append("&season=${data.season}&episode=${data.episode}")
                    }
                    else -> {
                        if (data.year != null) append("&year=${data.year}")
                        if (!data.imdbId.isNullOrBlank()) append("&id=${data.tmdbId}&imdb=${data.imdbId}")
                        if (data.season != null && data.episode != null) append("&season=${data.season}&episode=${data.episode}")
                    }
                }
            }

            val finalUrl = baseUrl + queryParams

            try {
                val response = app.get(finalUrl)
                val json = response.text
                val serverLabel = "Xprime ${server.name.replaceFirstChar { it.uppercaseChar() }}"

                if (server.name == "primebox") {
                    val stream = objectMapper.readValue<XprimeStream>(json)
                    val streamsJson = objectMapper.readTree(json).get("streams")

                    stream.qualities.forEach { quality ->
                        val href = streamsJson?.get(quality)?.textValue()
                        if (!href.isNullOrBlank()) {
                            callback(
                                newExtractorLink(
                                    source = serverLabel,
                                    name = serverLabel,
                                    url = href,
                                    type = ExtractorLinkType.VIDEO
                                ) {
                                    this.quality = getQualityFromName(quality)
                                    this.headers = mapOf("Origin" to domain)
                                    this.referer = domain
                                }
                            )
                        }
                    }

                    if (stream.hasSubtitles) {
                        stream.subtitles.forEach { subtitle ->
                            val subUrl = subtitle.file.orEmpty()
                            if (subUrl.isNotBlank()) {
                                subtitleCallback(
                                    newSubtitleFile(
                                        lang = subtitle.label ?: "Unknown",
                                        url = subUrl
                                    )
                                )
                            }
                        }
                    }
                } else {
                    val href = objectMapper.readTree(json).get("url")?.textValue().orEmpty()
                    if (href.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                source = serverLabel,
                                name = serverLabel,
                                url = href,
                                type = ExtractorLinkType.M3U8
                            ) {
                                this.headers = mapOf("Origin" to domain)
                                this.referer = domain
                                this.quality = Qualities.Unknown.value
                            }
                        )
                    }
                }
            } catch (e: Exception) {
                Log.e("XPrimeAPI", "Error on server ${server.name} $e")
            }
        }
    }
    data class XprimeServers(
        val servers: List<XprimeServer1>,
    )

    data class XprimeServer1(
        val name: String,
        val status: String,
        val language: String,
    )


    data class XprimeStream(
        @JsonProperty("available_qualities") val qualities: List<String>,
        @JsonProperty("status") val status: String,
        @JsonProperty("has_subtitles") val hasSubtitles: Boolean,
        @JsonProperty("subtitles") val subtitles: List<XprimePrimeSubs>
    )

    data class XprimePrimeSubs(
        @JsonProperty("file") val file: String? = null,
        @JsonProperty("label") val label: String? = null,
    )
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/AniList.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.lagradost.api.Log
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Media
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody

class AniList(val plugin: UltimaPlugin) : MainAPI() {
    override var name = "AniList"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.aniListApi)
    private val apiUrl = "https://graphql.anilist.co"
    private final val mediaLimit = 20
    private final val isAdult = false
    private val headerJSON =
        mapOf("Accept" to "application/json", "Content-Type" to "application/json")

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun anilistAPICall(query: String): AnilistAPIResponse {
        val data = mapOf("query" to query)
        val test = app.post(apiUrl, headers = headerJSON, data = data)
        val res =
            test.parsedSafe<AnilistAPIResponse>()
                ?: throw Exception("Unable to fetch or parse Anilist api response")
        return res
    }

    private fun AniListApi.Media.toSearchResponse(): SearchResponse {
        val title = this.title.english ?: this.title.romaji ?: ""
        val url = "$mainUrl/anime/${this.id}"
        val posterUrl = this.coverImage.large
        return newAnimeSearchResponse(title, url, TvType.Anime) { this.posterUrl = posterUrl }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
        page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val res = anilistAPICall(this.data.replace("###", "$page"))
        val data =
            res.data.page?.media?.map { it.toSearchResponse() }
                ?: throw Exception("Unable to read media data")
        val hasNextPage = res.data.page.pageInfo.hasNextPage ?: false
        return data to hasNextPage
    }

    override val mainPage =
        mainPageOf(
            "query (\$page: Int = ###, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Trending Now",
            "query (\$page: Int = ###, \$seasonYear: Int = 2024, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, seasonYear: \$seasonYear, season: SPRING, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Popular This Season",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "All Time Popular",
            "query (\$page: Int = ###, \$sort: [MediaSort] = [SCORE_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                    "Top 100 Anime",
            "Personal" to "Personal"
        )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res =
            anilistAPICall(
                "query (\$search: String = \"$query\") { Page(page: 1, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(search: \$search, isAdult: $isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }"
            )
        return res.data.page?.media?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                ?: return newHomePageResponse(
                    "Login required for personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            var homePageList =
                repo.library()?.getOrThrow()!!.allLibraryLists.mapNotNull {
                    if (it.items.isEmpty()) return@mapNotNull null
                    val libraryName =
                        it.name.asString(plugin.activity ?: return@mapNotNull null)
                    HomePageList("${request.name}: $libraryName", it.items)
                }
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is
            // overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data = anilistAPICall(
            "query (\$id: Int = $id) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val anititle = data.getTitle()
        val aniyear = data.startDate.year
        val anitype = if (data.format!!.contains("MOVIE", ignoreCase = true)) TvType.AnimeMovie else TvType.TvSeries
        val ids = tmdbToAnimeId(anititle, aniyear, anitype)

        val jpTitle = data.title.romaji


        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=${ids.id}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)

        val href = LinkData(
            malId = ids.idMal,
            aniId = ids.id,
            title = data.getTitle(),
            jpTitle = jpTitle,
            year = data.startDate.year,
            isAnime = true
        ).toStringData()

        // --- Helper to get best episode title ---
        fun resolveTitle(epData: MetaEpisode?): String {
            val jsonTitle = epData?.title?.get("en")
                ?: epData?.title?.get("ja")
                ?: epData?.title?.get("x-jat")
                ?: animeMetaData.titles?.get("en")
                ?: animeMetaData.titles?.get("ja")
                ?: animeMetaData.titles?.get("x-jat")
                ?: ""
            return jsonTitle.ifBlank { "Episode ${epData?.episode ?: ""}" }
        }

        fun createEpisode(i: Int, isDub: Boolean): Episode {
            val epData = animeMetaData.episodes?.get(i.toString())
            val linkData = LinkData(
                malId = ids.idMal,
                aniId = ids.id,
                title = data.getTitle(),
                jpTitle = jpTitle,
                year = data.startDate.year,
                season = 1,
                episode = i,
                isAnime = true,
                isDub = isDub
            ).toStringData()

            return newEpisode(linkData) {
                this.season = 1
                this.episode = i
                this.name = resolveTitle(epData)
                this.posterUrl = epData?.image ?: animeMetaData.images?.firstOrNull()?.url ?: ""
                this.description = epData?.overview ?: "No summary available"
                this.score = Score.from10(epData?.rating)
                this.runTime = epData?.runtime
                this.addDate(epData?.airDateUtc)
            }
        }

        val episodes = (1..data.totalEpisodes()).map { createEpisode(it, false) }


        return if (data.format.contains("Movie",ignoreCase = true)) {
            newMovieLoadResponse(data.getTitle(), url, TvType.AnimeMovie, href) {
                addAniListId(id.toInt())
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.getCoverImage()
                this.tags = data.genres
            }
        } else {
            newAnimeLoadResponse(data.getTitle(), url, TvType.Anime) {
                addAniListId(id.toInt())
                addEpisodes(DubStatus.Subbed, episodes)
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl =
                    animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url
                        ?: data.bannerImage
                this.posterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url
                    ?: data.getCoverImage()
                this.tags = data.genres
                this.recommendations = data.recommendations?.edges
                    ?.mapNotNull { edge ->
                        val recommendation = edge.node.mediaRecommendation ?: return@mapNotNull null
                        val title = recommendation.title?.english
                            ?: recommendation.title?.romaji
                            ?: "Unknown"
                        val recommendationUrl = "$mainUrl/anime/${recommendation.id}"
                        newAnimeSearchResponse(title, recommendationUrl, TvType.Anime).apply {
                            this.posterUrl = recommendation.coverImage?.large
                        }
                    }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        Log.d("Phisher ANilist",mediaData.toJson())
        invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        return true
    }

    data class AnilistAPIResponse(
        @JsonProperty("data") val data: AnilistData,
    ) {
        data class AnilistData(
            @JsonProperty("Page") val page: AnilistPage?,
            @JsonProperty("Media") val media: anilistMedia?,
        ) {
            data class AnilistPage(
                @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
                @JsonProperty("media") val media: List<Media>,
            )
        }

        data class anilistMedia(
            @JsonProperty("id") val id: Int,
            @JsonProperty("startDate") val startDate: StartDate,
            @JsonProperty("episodes") val episodes: Int?,
            @JsonProperty("title") val title: Title,
            @JsonProperty("genres") val genres: List<String>,
            @JsonProperty("description") val description: String?,
            @JsonProperty("coverImage") val coverImage: CoverImage,
            @JsonProperty("bannerImage") val bannerImage: String?,
            @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
            @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
            @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
            @JsonProperty("format") val format: String?,
        ) {
            data class StartDate(@JsonProperty("year") val year: Int)

            data class AiringScheduleNodes(
                @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
            )

            fun totalEpisodes(): Int {
                return nextAiringEpisode?.episode?.minus(1)
                    ?: episodes ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                    ?: throw Exception("Unable to calculate total episodes")
            }

            fun getTitle(): String {
                return title.english
                    ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
            }

            fun getCoverImage(): String? {
                return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
            }
        }
    }

    private suspend fun tmdbToAnimeId(title: String?, year: Int?, type: TvType): AniIds {
        if (title.isNullOrBlank()) return AniIds(null, null)

        val query = """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}seasonYear: Int
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              seasonYear: ${'$'}seasonYear
              format_in: ${'$'}format
            ) {
              id
              idMal
            }
          }
        }
    """.trimIndent()

        val variables = mutableMapOf(
            "search" to title,
            "sort" to listOf("SEARCH_MATCH"),
            "type" to "ANIME",
            "format" to listOf(
                if (type == TvType.AnimeMovie) "MOVIE" else "TV",
                "ONA",
                "OVA"
            )
        )

        val data = mapOf(
            "query" to query,
            "variables" to variables
        ).toJson().toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val res = app.post(apiUrl, requestBody = data)
            .parsedSafe<AniSearch>()
            ?.data
            ?.let { it.Page?.media ?: it.media }
            ?.firstOrNull()
        return AniIds(res?.id, res?.idMal)
    }
}

fun parseAnimeData(jsonString: String): MetaAnimeData {
    val objectMapper = ObjectMapper()
    return objectMapper.readValue(jsonString, MetaAnimeData::class.java)
}


@JsonIgnoreProperties(ignoreUnknown = true)
data class ImageData(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaEpisode(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airdate") val airdate: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,
    @JsonProperty("length") val length: Int?,
    @JsonProperty("runtime") val runtime: Int?,
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)


@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>? = null,
    @JsonProperty("images") val images: List<ImageData>? = null,
    @JsonProperty("episodes") val episodes: Map<String, MetaEpisode>? = null,
)

data class AniMedia(
    @JsonProperty("id") var id: Int? = null,
    @JsonProperty("idMal") var idMal: Int? = null
)

data class AniPage(
    @JsonProperty("media") var media: ArrayList<AniMedia> = arrayListOf()
)

data class AniData(
    @JsonProperty("Page") var Page: AniPage? = null,
    @JsonProperty("media") var media: ArrayList<AniMedia>? = null
)

data class AniSearch(
    @JsonProperty("data") var data: AniData? = null
)

data class AniIds(var id: Int? = null, var idMal: Int? = null)


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/MetaProviders.kt
================================================
package com.phisher98

object UltimaMetaProviderUtils {
    val metaProviders =
            arrayOf(
                    "Simkl" to false,
                    "AniList" to false,
                    "MyAnimeList" to false,
                    "TMDB" to false,
                    "Trakt" to false
            )
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/MyAnimeList.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager.Companion.malApi
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.MALApi.MalAnime
import com.lagradost.cloudstream3.syncproviders.providers.MALApi.Recommendations
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

open class MyAnimeList(val plugin: UltimaPlugin) : MainAPI() {
    override var name = "MyAnimeList"
    override var mainUrl = "https://myanimelist.net"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.MyAnimeList)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(malApi)
    private val apiUrl = "https://api.myanimelist.net/v2"
    private val mediaLimit = 20


    private fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun malAPICall(query: String): MalApiResponse {
        //val accountId = "${malApi.idPrefix}_account_${malApi.accountIndex}"
        //val authToken = AcraApplication.getKey<String>(accountId, MALApi.MAL_TOKEN_KEY)
        val res =
                app.get(query, headers = mapOf("Authorization" to "Bearer $"))
                        .parsedSafe<MalApiResponse>()
                        ?: throw Exception("Unable to fetch content from API")
        return res
    }

    private fun MalApiResponse.MalApiData.toSearchResponse(): SearchResponse {
        val url = "$mainUrl/${this.node.id}"
        val posterUrl = this.node.picture.large
        val res = newAnimeSearchResponse(this.node.title, url) { this.posterUrl = posterUrl }
        return res
    }

    private fun Recommendations.toSearchResponse(): SearchResponse {
        val node = this.node ?: throw Exception("Unable to parse Recommendation")
        val url = "$mainUrl/${node.id}"
        val posterUrl = node.mainPicture?.large
        val res = newAnimeSearchResponse(node.title, url) { this.posterUrl = posterUrl }
        return res
    }

    override val mainPage =
            mainPageOf(
                    "$apiUrl/anime/ranking?ranking_type=all&limit=$mediaLimit&offset=" to
                            "Top Anime Series",
                    "$apiUrl/anime/ranking?ranking_type=airing&limit=$mediaLimit&offset=" to
                            "Top Airing Anime",
                    "$apiUrl/anime/ranking?ranking_type=bypopularity&limit=$mediaLimit&offset=" to
                            "Popular Anime",
                    "$apiUrl/anime/ranking?ranking_type=favorite&limit=$mediaLimit&offset=" to
                            "Top Favorited Anime",
                    "$apiUrl/anime/suggestions?limit=$mediaLimit&offset=" to "Suggestions",
                    "Personal" to "Personal"
            )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res = malAPICall("$apiUrl/anime?q=$query&limit=$mediaLimit")
        return res.data?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                    ?: return newHomePageResponse(
                            "Login required for personal content.",
                            emptyList<SearchResponse>(),
                            false
                    )
            val homePageList =
                    repo.library()?.getOrThrow()!!.allLibraryLists.mapNotNull {
                        if (it.items.isEmpty()) return@mapNotNull null
                        val libraryName =
                                it.name.asString(plugin.activity ?: return@mapNotNull null)
                        HomePageList("${request.name}: $libraryName", it.items)
                    }
            return newHomePageResponse(homePageList, false)
        } else {
            val res = malAPICall("${request.data}${(page - 1) * mediaLimit}")
            val media =
                    res.data?.map { it.toSearchResponse() }
                            ?: return newHomePageResponse(request.name, emptyList(), false)
            return newHomePageResponse(request.name, media, true)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data =
                app.get(
                                "$apiUrl/anime/$id?fields=id,title,synopsis,main_picture,start_season,num_episodes,recommendations,genres",
                                headers = mapOf("Authorization" to "Bearer ")
                        )
                        .parsedSafe<MalAnime>()
                        ?: throw ErrorLoadingException("Unable to fetch show details")
        val year = data.startSeason?.year
        val epCount = data.numEpisodes ?: 0
        val episodes =
                (1..epCount).map { i ->
                    val linkData =
                            LinkData(
                                            title = data.title,
                                            year = year,
                                            season = 1,
                                            episode = i,
                                            isAnime = true
                                    )
                                    .toStringData()
                    newEpisode(linkData)
                    {
                        this.season= 1
                        this.episode = i
                    }
                }
        return newAnimeLoadResponse(
                data.title ?: throw NotImplementedError("Unable to parse title"),
                url,
                TvType.Anime
        ) {
            this.year = data.startSeason?.year
            this.posterUrl = data.mainPicture?.large
            this.plot = data.synopsis
            this.tags = data.genres?.map { it.name }
            addMalId(id.toInt())
            addEpisodes(DubStatus.Subbed, episodes)
            this.recommendations = data.recommendations?.map { it.toSearchResponse() }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        return true
    }

    data class MalApiResponse(
            @JsonProperty("data") val data: Array<MalApiData>? = null,
    ) {
        data class MalApiData(
                @JsonProperty("node") val node: MalApiNode,
        ) {
            data class MalApiNode(
                    @JsonProperty("id") val id: Int,
                    @JsonProperty("title") val title: String,
                    @JsonProperty("main_picture") val picture: MalApiNodePicture
            ) {
                data class MalApiNodePicture(
                        @JsonProperty("medium") val medium: String,
                        @JsonProperty("large") val large: String,
                )
            }
        }
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/Simkl.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addSimklId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.SimklApi.Companion.MediaObject
import com.lagradost.cloudstream3.syncproviders.providers.SimklApi.Companion.getPosterUrl
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

class Simkl(val plugin: UltimaPlugin) : MainAPI() {
    override var name = "Simkl"
    override var mainUrl = "https://simkl.com"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Simkl)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.simklApi)
    private val apiUrl = "https://api.simkl.com"
    private final val mediaLimit = 20

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private fun SimklMediaObject.toSearchResponse(): SearchResponse {
        val poster = getPosterUrl(poster ?: "")
        return newMovieSearchResponse(title, "$mainUrl/shows/${ids?.simkl}") {
            this.posterUrl = poster
        }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
        page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val emptyData = emptyList<SearchResponse>() to false
        val res =
            app.get(this.data + page).parsedSafe<Array<SimklMediaObject>>() ?: return emptyData
        return res.map {
            newMovieSearchResponse("${it.title}", "$mainUrl/shows/${it.ids?.simkl2}") {
                this.posterUrl = getPosterUrl(it.poster.toString())
            }
        } to res.size.equals(mediaLimit)
    }

    private fun SimklMediaObject.toLinkData(): LinkData {
        return LinkData(
            simklId = ids?.simkl,
            imdbId = ids?.imdb,
            tmdbId = ids?.tmdb,
            aniId = ids?.anilist?.toIntOrNull(),
            malId = ids?.mal?.toIntOrNull(),
            title = title,
            year = year,
            type = type,
            isAnime = type.equals("anime")
        )
    }

    private fun SimklEpisodeObject.toLinkData(
        showName: String,
        ids: SimklIds?,
        year: Int?,
        isAnime: Boolean
    ): LinkData {
        return LinkData(
            simklId = ids?.simkl,
            imdbId = ids?.imdb,
            tmdbId = ids?.tmdb,
            aniId = ids?.anilist?.toIntOrNull(),
            malId = ids?.mal?.toIntOrNull(),
            title = showName,
            year = year,
            season = season,
            episode = episode,
            type = type,
            isAnime = isAnime
        )
    }

    private fun SimklEpisodeObject.toEpisode(
        showName: String,
        ids: SimklIds?,
        year: Int?,
        isAnime: Boolean
    ): Episode {
        val poster = "https://simkl.in/episodes/${img}_c.webp"
        val linkData = this.toLinkData(showName, ids, year, isAnime).toStringData()
        return newEpisode(linkData)
        {
            this.name = title
            this.description = desc
            this.posterUrl = poster
        }
    }

    // this method is added to tackle current API limitation of 100 req per day
    private fun MediaObject.toSimklMediaObject(): SimklMediaObject? {
        return parseJson<SimklMediaObject>(this.toStringData())
    }

    // this method is added to tackle current API limitation of 100 req per day
    private fun buildSimklEpisodes(total: Int?): Array<SimklEpisodeObject>? {
        if (total == null) return null
        var data = emptyArray<SimklEpisodeObject>()
        (1..total).forEach {
            data += SimklEpisodeObject(season = 1, episode = it, ids = null, type = "episode")
        }
        return data
    }

    override val mainPage =
        mainPageOf(
            "$apiUrl/tv/trending/month?type=series&client_id=&extended=overview&limit=$mediaLimit&page=" to
                    "Trending TV Shows",
            "$apiUrl/movies/trending/month?client_id=&extended=overview&limit=$mediaLimit&page=" to
                    "Trending Movies",
            "$apiUrl/tv/best/all?type=series&client_id=&extended=overview&limit=$mediaLimit&page=" to
                    "Best TV Shows",
            //"$apiUrl/movies/best/all?client_id=&extended=overview&limit=$mediaLimit&page=" to
            //       "Best Movies",
            "Personal" to "Personal"
        )

    override suspend fun search(query: String): List<SearchResponse>? {
        //return api.search(query)
        return null
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                ?: return newHomePageResponse(
                    "Login required for personal content.",
                    emptyList<SearchResponse>(),
                    false
                )
            val homePageList =
                repo.library()?.getOrThrow()?.allLibraryLists?.mapNotNull {
                    if (it.items.isEmpty()) return@mapNotNull null
                    val libraryName =
                        it.name.asString(plugin.activity ?: return@mapNotNull null)
                    HomePageList("${request.name}: $libraryName", it.items)
                }
                    ?: return null
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data =
            app.get("$apiUrl/tv/$id?client_id=&extended=full")
                .parsedSafe<SimklMediaObject>()
                ?: throw ErrorLoadingException("Unable to load data")
        val year = data.year
        val posterUrl = getPosterUrl(data.poster ?: "")
        return if (data.type.equals("movie")) {
            val linkData = data.toLinkData().toStringData()
            newMovieLoadResponse(data.title, url, TvType.Movie, linkData) {
                this.addSimklId(id.toInt())
                this.year = year
                this.posterUrl = posterUrl
                this.plot = data.overview
                this.recommendations = data.recommendations?.map { it.toSearchResponse() }
            }
        } else {
            val eps =
                app.get("$apiUrl/tv/episodes/$id?client_id=&extended=full")
                    .parsedSafe<Array<SimklEpisodeObject>>()
                    ?: buildSimklEpisodes(data.total_episodes)
                    ?: throw Exception("Unable to fetch episodes")
            val episodes =
                eps.filter { it.type.equals("episode") }.map {
                    it.toEpisode(data.title, data.ids, year, data.type.equals("anime"))
                }
            newTvSeriesLoadResponse(data.title, url, TvType.TvSeries, episodes) {
                this.addSimklId(id.toInt())
                this.year = year
                this.posterUrl = posterUrl
                this.plot = data.overview
                this.recommendations = data.recommendations?.map { it.toSearchResponse() }
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = parseJson<LinkData>(data)
        if (mediaData.isAnime)
            invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }

    open class SimklMediaObject(
        @JsonProperty("title") val title: String,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("ids") val ids: SimklIds?,
        @JsonProperty("total_episodes") val total_episodes: Int? = null,
        @JsonProperty("status") val status: String? = null,
        @JsonProperty("poster") val poster: String? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("genres") val genres: List<String>? = null,
        @JsonProperty("users_recommendations")
        val recommendations: List<SimklMediaObject>? = null,
    )

    open class SimklEpisodeObject(
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("description") val desc: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("aired") val aired: Boolean? = null,
        @JsonProperty("img") val img: String? = null,
        @JsonProperty("ids") val ids: SimklIds?,
    )

    data class SimklIds(
        @JsonProperty("simkl") val simkl: Int? = null,
        @JsonProperty("simkl_id") val simkl2: Int? = null,
        @JsonProperty("imdb") val imdb: String? = null,
        @JsonProperty("tmdb") val tmdb: Int? = null,
        @JsonProperty("mal") val mal: String? = null,
        @JsonProperty("anilist") val anilist: String? = null,
    )
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/Tmdb.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import java.util.Locale


class Tmdb(val plugin: UltimaPlugin) : TmdbProvider() {
    override var name = "TMDB"
    override var mainUrl = "https://www.themoviedb.org"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama)
    override var lang = "en"
    override val hasMainPage = true
    override val hasQuickSearch = false
    override val useMetaLoadResponse = true
    private val apiUrl = "https://api.themoviedb.org"

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private fun TmdbLink.toLinkData(): LinkData {
        return LinkData(
                imdbId = imdbID,
                tmdbId = tmdbID,
                title = movieName,
                season = season,
                episode = episode,
        )
    }

    @RequiresApi(Build.VERSION_CODES.N)
    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<TmdbLink>(data).toLinkData()
        invokeSubtitleAPI(mediaData.imdbId, mediaData.season, mediaData.episode, subtitleCallback)
        //invokeWyZIESUBAPI(mediaData.imdbId, mediaData.season, mediaData.episode, subtitleCallback)
        if (mediaData.isAnime)
                invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }

    private suspend fun invokeSubtitleAPI(
        id: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val url = if (season == null) {
            "https://opensubtitles-v3.strem.io/subtitles/movie/$id.json"
        } else {
            "https://opensubtitles-v3.strem.io/subtitles/series/$id:$season:$episode.json"
        }
        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )
        app.get(url, headers = headers, timeout = 100L)
            .parsedSafe<SubtitlesAPI>()?.subtitles?.amap { it ->
                val lan = getLanguage(it.lang) ?: "Unknown"
                val suburl = it.url
                subtitleCallback.invoke(
                    newSubtitleFile(
                        lan.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },  // Use label for the name
                        suburl     // Use extracted URL
                    )
                )
        }
    }
    data class SubtitlesAPI(
        val subtitles: List<Subtitle>,
        val cacheMaxAge: Long,
    )

    data class Subtitle(
        val id: String,
        val url: String,
        @JsonProperty("SubEncoding")
        val subEncoding: String,
        val lang: String,
        val m: String,
        val g: String,
    )
}

val languageMap = mapOf(
    "Afrikaans" to Pair("af", "afr"),
    "Albanian" to Pair("sq", "sqi"),
    "Amharic" to Pair("am", "amh"),
    "Arabic" to Pair("ar", "ara"),
    "Armenian" to Pair("hy", "hye"),
    "Azerbaijani" to Pair("az", "aze"),
    "Basque" to Pair("eu", "eus"),
    "Belarusian" to Pair("be", "bel"),
    "Bengali" to Pair("bn", "ben"),
    "Bosnian" to Pair("bs", "bos"),
    "Bulgarian" to Pair("bg", "bul"),
    "Catalan" to Pair("ca", "cat"),
    "Chinese" to Pair("zh", "zho"),
    "Croatian" to Pair("hr", "hrv"),
    "Czech" to Pair("cs", "ces"),
    "Danish" to Pair("da", "dan"),
    "Dutch" to Pair("nl", "nld"),
    "English" to Pair("en", "eng"),
    "Estonian" to Pair("et", "est"),
    "Filipino" to Pair("tl", "tgl"),
    "Finnish" to Pair("fi", "fin"),
    "French" to Pair("fr", "fra"),
    "Galician" to Pair("gl", "glg"),
    "Georgian" to Pair("ka", "kat"),
    "German" to Pair("de", "deu"),
    "Greek" to Pair("el", "ell"),
    "Gujarati" to Pair("gu", "guj"),
    "Hebrew" to Pair("he", "heb"),
    "Hindi" to Pair("hi", "hin"),
    "Hungarian" to Pair("hu", "hun"),
    "Icelandic" to Pair("is", "isl"),
    "Indonesian" to Pair("id", "ind"),
    "Italian" to Pair("it", "ita"),
    "Japanese" to Pair("ja", "jpn"),
    "Kannada" to Pair("kn", "kan"),
    "Kazakh" to Pair("kk", "kaz"),
    "Korean" to Pair("ko", "kor"),
    "Latvian" to Pair("lv", "lav"),
    "Lithuanian" to Pair("lt", "lit"),
    "Macedonian" to Pair("mk", "mkd"),
    "Malay" to Pair("ms", "msa"),
    "Malayalam" to Pair("ml", "mal"),
    "Maltese" to Pair("mt", "mlt"),
    "Marathi" to Pair("mr", "mar"),
    "Mongolian" to Pair("mn", "mon"),
    "Nepali" to Pair("ne", "nep"),
    "Norwegian" to Pair("no", "nor"),
    "Persian" to Pair("fa", "fas"),
    "Polish" to Pair("pl", "pol"),
    "Portuguese" to Pair("pt", "por"),
    "Punjabi" to Pair("pa", "pan"),
    "Romanian" to Pair("ro", "ron"),
    "Russian" to Pair("ru", "rus"),
    "Serbian" to Pair("sr", "srp"),
    "Sinhala" to Pair("si", "sin"),
    "Slovak" to Pair("sk", "slk"),
    "Slovenian" to Pair("sl", "slv"),
    "Spanish" to Pair("es", "spa"),
    "Swahili" to Pair("sw", "swa"),
    "Swedish" to Pair("sv", "swe"),
    "Tamil" to Pair("ta", "tam"),
    "Telugu" to Pair("te", "tel"),
    "Thai" to Pair("th", "tha"),
    "Turkish" to Pair("tr", "tur"),
    "Ukrainian" to Pair("uk", "ukr"),
    "Urdu" to Pair("ur", "urd"),
    "Uzbek" to Pair("uz", "uzb"),
    "Vietnamese" to Pair("vi", "vie"),
    "Welsh" to Pair("cy", "cym"),
    "Yiddish" to Pair("yi", "yid")
)

fun getLanguage(language: String?): String? {
    language ?: return null
    val normalizedLang = language.substringBefore("-")
    return languageMap.entries.find { it.value.first == normalizedLang || it.value.second == normalizedLang }?.key
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/Trakt.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData as UltimaLinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.metaproviders.TraktProvider
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink

class Trakt(val plugin: UltimaPlugin) : TraktProvider() {
    override var name = "Trakt"
    override var mainUrl = "https://trakt.tv"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Trakt)
    override val hasMainPage = true
    override val hasQuickSearch = false

    private val traktClientId =
            base64Decode(
                    "N2YzODYwYWQzNGI4ZTZmOTdmN2I5MTA0ZWQzMzEwOGI0MmQ3MTdlMTM0MmM2NGMxMTg5NGE1MjUyYTQ3NjE3Zg=="
            )
    private val traktApiUrl = base64Decode("aHR0cHM6Ly9hcGl6LnRyYWt0LnR2")

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    override val mainPage =
            mainPageOf(
                    "$traktApiUrl/movies/trending?extended=cloud9,full&limit=25" to
                            "Trending Movies",
                    "$traktApiUrl/movies/popular?extended=cloud9,full&limit=25" to "Popular Movies",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25" to "Trending Shows",
                    "$traktApiUrl/shows/popular?extended=cloud9,full&limit=25" to "Popular Shows",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=53,1465" to
                            "Netflix",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=47,2385" to
                            "Amazon Prime Video",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=256" to
                            "Apple TV+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=41,2018,2566,2567,2597" to
                            "Disney+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=87" to
                            "Hulu",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=1623" to
                            "Paramount+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=550,3027" to
                            "Peacock",
            )

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<UltimaLinkData>(data)
        if (mediaData.isAnime)
                invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/MetaProviders/WatchSync.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.syncproviders.SyncIdName

open class WatchSync(val plugin: UltimaPlugin) : MainAPI() {
    override var name = "WatchSync"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    private val apiUrl = "https://graphql.anilist.co"

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    override val mainPage = mainPageOf("" to "")

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        return null
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Settings/ConfigureExtensions.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.core.view.isVisible
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.api.Log

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaConfigureExtensions(val plugin: UltimaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")
    private val extensions = sm.fetchExtensions().also {
        Log.d("UltimaDebug", "Fetched ${it.size} extensions.")
        it.forEach { ext ->
            Log.d("UltimaDebug", "→ Extension: ${ext.name}")
            ext.sections?.forEach { sec ->
                Log.d("UltimaDebug", " - Section: ${sec.name}, enabled=${sec.enabled}")
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - Utility functions
    @SuppressLint("DiscouragedApi")
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion

    @SuppressLint("UseSwitchCompatOrMaterialCode")
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val settings = getLayout("configure_extensions", inflater, container)

        // Save button
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            // Debug log all selected sections
            extensions.forEach { ext ->
                Log.d("UltimaDebug", "Saving Extension: ${ext.name}")
                ext.sections?.forEach { sec ->
                    Log.d("UltimaDebug", "-- Section: ${sec.name} enabled=${sec.enabled}")
                }
            }

            sm.currentExtensions = extensions
            plugin.reload()
            showToast("Saved")
            dismiss()
        }

        // Toggle switch: Show extension name on home
        val extNameOnHomeBtn = settings.findView<Switch>("ext_name_on_home_toggle")
        extNameOnHomeBtn.makeTvCompatible()
        extNameOnHomeBtn.isChecked = sm.extNameOnHome
        extNameOnHomeBtn.setOnClickListener {
            sm.extNameOnHome = extNameOnHomeBtn.isChecked
        }

        // Extensions list
        val extensionsListLayout = settings.findView<LinearLayout>("extensions_list")
        extensions.forEach { extension ->
            val extensionLayoutView = buildExtensionView(extension, inflater, container)
            extensionsListLayout.addView(extensionLayoutView)
        }

        return settings
    }

    // Create one full view for each extension
    private fun buildExtensionView(
        extension: UltimaUtils.ExtensionInfo,
        inflater: LayoutInflater,
        container: ViewGroup?
    ): View {

        fun buildSectionView(
            section: UltimaUtils.SectionInfo,
            inflater: LayoutInflater,
            container: ViewGroup?
        ): View {
            val sectionView = getLayout("list_section_item", inflater, container)
            val checkBox = sectionView.findView<CheckBox>("section_checkbox")

            checkBox.text = section.name
            checkBox.makeTvCompatible()

            // Auto-enable sections by default if not already toggled
            if (section.enabled == null) section.enabled = true

            checkBox.isChecked = section.enabled == true
            checkBox.setOnCheckedChangeListener { _, isChecked ->
                section.enabled = isChecked
                Log.d("UltimaDebug", "Section '${section.name}' in '${extension.name}' set to $isChecked")
            }

            return sectionView
        }

        val extView = getLayout("list_extension_item", inflater, container)
        val extensionDataBtn = extView.findView<LinearLayout>("extension_data")
        val expandImage = extView.findView<ImageView>("expand_icon")
        val extensionNameBtn = extensionDataBtn.findView<TextView>("extension_name")
        val childList = extView.findView<LinearLayout>("sections_list")

        expandImage.setImageDrawable(getDrawable("triangle"))
        expandImage.rotation = 90f

        extensionNameBtn.text = extension.name
        extensionDataBtn.makeTvCompatible()
        extensionDataBtn.setOnClickListener {
            val isVisible = childList.isVisible
            childList.visibility = if (isVisible) View.GONE else View.VISIBLE
            expandImage.rotation = if (isVisible) 90f else 180f
        }

        // Add sections
        extension.sections?.forEach { section ->
            val sectionView = buildSectionView(section, inflater, container)
            childList.addView(sectionView)
        }

        return extView
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
            activity?.supportFragmentManager ?: throw Exception("Unable to open configure settings"),
            ""
        )
        super.onDetach()
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Settings/ConfigureWatchSync.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.coroutineScope
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.cloudstream3.utils.AppContextUtils.setDefaultFocus
import com.phisher98.WatchSyncUtils.WatchSyncCreds
import kotlinx.coroutines.launch

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaConfigureWatchSync(private val plugin: UltimaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val deviceData = sm.deviceSyncCreds
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")
    private val packageName = BuildConfig.LIBRARY_PACKAGE_NAME

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    @SuppressLint("DiscouragedApi")
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", packageName)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", packageName)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", packageName)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", packageName)
        return this.findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", packageName)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion

    @SuppressLint("UseSwitchCompatOrMaterialCode", "SetTextI18n")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("configure_watch_sync", inflater, container)

        // #region - save button
        settings.findView<ImageView>("save").apply {
            setImageDrawable(getDrawable("save_icon"))
            makeTvCompatible()
            setOnClickListener {
                sm.deviceSyncCreds = deviceData
                plugin.reload()
                showToast("Saved")
                dismiss()
            }
        }
        // #endregion

        // #region - watch sync creds
        settings.findView<ImageView>("watch_sync_creds_btn").apply {
            setImageDrawable(getDrawable("edit_icon"))
            makeTvCompatible()
            setOnClickListener {
                val credsView = getLayout("watch_sync_creds", inflater, container)
                val tokenInput = credsView.findView<EditText>("token")
                val prNumInput = credsView.findView<EditText>("project_num")
                val deviceNameInput = credsView.findView<EditText>("device_name")

                tokenInput.setText(sm.deviceSyncCreds?.token)
                prNumInput.setText(sm.deviceSyncCreds?.projectNum?.toString())
                deviceNameInput.setText(sm.deviceSyncCreds?.deviceName)

                AlertDialog.Builder(requireContext())
                    .setTitle("Set your creds")
                    .setView(credsView)
                    .setPositiveButton("Save") { _, _ ->
                        val token = tokenInput.text.trim().toString()
                        val prNum = prNumInput.text.toString().toIntOrNull()
                        val deviceName = deviceNameInput.text.trim().toString()

                        if (token.isEmpty() || prNum == null || deviceName.isEmpty()) {
                            showToast("Invalid details")
                        } else {
                            activity?.lifecycle?.coroutineScope?.launch {
                                sm.deviceSyncCreds = WatchSyncCreds(token, prNum, deviceName)
                                showToast(
                                    sm.deviceSyncCreds
                                        ?.syncProjectDetails()
                                        ?.second
                                )
                            }
                        }
                        dismiss()
                    }
                    .setNegativeButton("Reset") { _, _ ->
                        sm.deviceSyncCreds = WatchSyncCreds()
                        showToast("Credentials removed")
                        dismiss()
                    }
                    .show()
                    .setDefaultFocus()
            }
        }
        // #endregion

        // #region - toggle for sync this device
        settings.findView<Switch>("sync_this_device").apply {
            makeTvCompatible()
            isChecked = sm.deviceSyncCreds?.isThisDeviceSync ?: false
            setOnClickListener {
                activity?.lifecycle?.coroutineScope?.launch {
                    sm.deviceSyncCreds?.let {
                        val res = if (isChecked) it.registerThisDevice()
                        else it.deregisterThisDevice()
                        showToast(res.second)
                        if (res.first) dismiss()
                    }
                }
            }
        }
        // #endregion

        // #region - list of devices
        val devicesListLayout = settings.findView<LinearLayout>("devices_list")
        val activeDevices = deviceData?.enabledDevices?.toMutableList() ?: mutableListOf()
        activity?.lifecycle?.coroutineScope?.launch {
            val devices = deviceData?.fetchDevices()
            devices?.forEach { device ->
                val currentDevice = sm.deviceSyncCreds?.deviceId.equals(device.deviceId)
                val syncDeviceView = getLayout("watch_sync_device", inflater, container)
                val deviceName = syncDeviceView.findView<Switch>("watch_sync_device_name")
                deviceName.text = device.name + if (currentDevice) " (current device)" else ""
                deviceName.isChecked =
                    sm.deviceSyncCreds?.enabledDevices?.contains(device.deviceId) ?: false
                deviceName.setOnClickListener {
                    if (deviceName.isChecked) {
                        if (currentDevice) deviceName.isChecked = false
                        else activeDevices.add(device.deviceId)
                    } else activeDevices.remove(device.deviceId)
                    deviceData?.enabledDevices = activeDevices
                }
                devicesListLayout.addView(syncDeviceView)
            }
        }
        // #endregion

        return settings
    }

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
            activity?.supportFragmentManager
                ?: throw Exception("Unable to open configure settings"),
            ""
        )
        super.onDetach()
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Settings/MetaProviders.kt
================================================
package com.phisher98

import android.app.AlertDialog
import android.content.DialogInterface
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.text.InputType
import android.view.LayoutInflater
import android.view.View
import android.view.View.OnClickListener
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.CompoundButton
import android.widget.CompoundButton.OnCheckedChangeListener
import android.widget.EditText
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import android.widget.TextView
import androidx.annotation.RequiresApi
import com.phisher98.UltimaUtils.MediaProviderState
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import kotlin.collections.toList

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaMetaProviders(val plugin: UltimaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private var sm = UltimaStorageManager
    private var metaProviders = sm.currentMetaProviders.toList()
    private var mediaProviders = sm.currentMediaProviders.toList()
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion - necessary functions

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("meta_providers", inflater, container)

        // #region - building save button and its click listener
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        sm.currentMetaProviders = metaProviders.toTypedArray()
                        sm.currentMediaProviders = mediaProviders.toTypedArray()
                        plugin.reload()
                        showToast("Saved")
                        dismiss()
                    }
                }
        )
        // #endregion - building save button and its click listener

        // #region - building list of meta providers and its sections with its click listener
        val metaProvidersListLayout = settings.findView<LinearLayout>("meta_providers_list")
        metaProviders.forEach { metaProvider ->
            val extensionLayoutView = buildMetaProviderView(metaProvider, inflater, container)
            metaProvidersListLayout.addView(extensionLayoutView)
        }
        // #endregion - building list of meta providers and its sections with its click listener

        // #region - building list of media providers and its sections with its click listener
        val mediaProvidersListLayout = settings.findView<LinearLayout>("media_providers_list")
        mediaProviders.forEach { mediaProvider ->
            val extensionLayoutView = buildMediaProviderView(mediaProvider, inflater, container)
            mediaProvidersListLayout.addView(extensionLayoutView)
        }
        // #endregion - building list of media providers and its sections with its click listener

        return settings
    }

    fun buildMetaProviderView(
            metaProvider: Pair<String, Boolean>,
            inflater: LayoutInflater,
            container: ViewGroup?
    ): View {

        // collecting required resources
        val metaProviderLayoutView = getLayout("list_meta_provider_item", inflater, container)
        val metaProviderNameBtn = metaProviderLayoutView.findView<Switch>("meta_provider_name")

        // building extension textview and its click listener
        metaProviderNameBtn.text = metaProvider.first
        metaProviderNameBtn.isChecked = metaProvider.second
        metaProviderNameBtn.makeTvCompatible()
        metaProviderNameBtn.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        metaProviders =
                                metaProviders.map {
                                    if (it.first.equals(metaProvider.first))
                                            it.first to metaProviderNameBtn.isChecked
                                    else it
                                }
                    }
                }
        )

        return metaProviderLayoutView
    }

    fun buildMediaProviderView(
            mediaProvider: MediaProviderState,
            inflater: LayoutInflater,
            container: ViewGroup?
    ): View {
        val mediaProviderLayoutView = getLayout("list_media_provider_item", inflater, container)
        val providerCheckBox = mediaProviderLayoutView.findView<CheckBox>("provider")
        providerCheckBox.makeTvCompatible()

        val domainEdit = mediaProviderLayoutView.findView<ImageView>("domain_edit")
        domainEdit.setImageDrawable(getDrawable("edit_icon"))
        domainEdit.makeTvCompatible()

        providerCheckBox.text =
                mediaProvider.name + if (mediaProvider.customDomain.isNullOrBlank()) "" else "*"
        providerCheckBox.isChecked = mediaProvider.enabled
        providerCheckBox.setOnCheckedChangeListener(
                object : OnCheckedChangeListener {
                    override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
                        mediaProvider.enabled = isChecked
                    }
                }
        )

        // #region - Set domain and its edit + reset buttons with listeners
        val domain = mediaProviderLayoutView.findView<TextView>("domain")
        domain.text = mediaProvider.customDomain ?: mediaProvider.getDomain()
        domainEdit.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        val editText = EditText(context)
                        editText.setText(mediaProvider.getDomain())
                        editText.setInputType(InputType.TYPE_CLASS_TEXT)

                        AlertDialog.Builder(
                                        context ?: throw Exception("Unable to build alert dialog")
                                )
                                .setTitle("Update Domain")
                                .setView(editText)
                                .setPositiveButton(
                                        "Save",
                                        object : DialogInterface.OnClickListener {
                                            override fun onClick(p0: DialogInterface, p1: Int) {
                                                mediaProvider.customDomain =
                                                        editText.text.toString()
                                                domain.text = mediaProvider.getDomain()
                                                providerCheckBox.text = mediaProvider.name + "*"
                                            }
                                        }
                                )
                                .setNegativeButton(
                                        "Reset",
                                        object : DialogInterface.OnClickListener {
                                            override fun onClick(p0: DialogInterface, p1: Int) {
                                                mediaProvider.customDomain = null
                                                domain.text = mediaProvider.getDomain()
                                                providerCheckBox.text = mediaProvider.name
                                            }
                                        }
                                )
                                .show()
                    }
                }
        )
        // #endregion - Set domain and its edit + reset buttons with listeners

        return mediaProviderLayoutView
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
                activity?.supportFragmentManager
                        ?: throw Exception("Unable to open configure settings"),
                ""
        )
        super.onDetach()
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Settings/Reorder.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import android.graphics.drawable.LayerDrawable
import android.os.Build
import android.os.Bundle
import android.view.*
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.lifecycle.lifecycleScope
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"
private var selectedSection: UltimaUtils.SectionInfo? = null

class UltimaReorder(val plugin: UltimaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val extensions = sm.fetchExtensions()
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // region - resource helpers
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        return inflater.inflate(res.getLayout(id), container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
            ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        background = res.getDrawable(outlineId, null)
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val root = getLayout("reorder", inflater, container)

        val saveBtn = root.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            lifecycleScope.launch {
                withContext(Dispatchers.IO) {
                    sm.currentExtensions = extensions
                    plugin.reload()
                }

                showToast("Saved. Please restart the app to apply changes.")
                dismiss()
            }
        }

        val noSectionWarning = root.findView<TextView>("no_section_warning")
        val sectionsListView = root.findView<LinearLayout>("section_list")
        updateSectionList(sectionsListView, inflater, container, noSectionWarning)

        return root
    }

    private fun updateSectionList(
        sectionsListView: LinearLayout,
        inflater: LayoutInflater,
        container: ViewGroup?,
        noSectionWarning: TextView? = null,
        currentSections: List<UltimaUtils.SectionInfo>? = null,
        focusingSection: Int? = null,
        focusOn: String? = null,
    ) {
        sectionsListView.removeAllViews()

        val sections = currentSections ?: run {
            var freshSections = emptyList<UltimaUtils.SectionInfo>()
            extensions.forEach { ext ->
                ext.sections?.filter { it.enabled }?.let { freshSections += it }
            }
            freshSections
        }

        if (sections.isEmpty()) {
            noSectionWarning?.visibility = View.VISIBLE
            return
        }

        val sortedSections = sections.sortedByDescending { it.priority }
        var counter = sortedSections.size

        val displaySections = (currentSections ?: run {
            val freshSections = emptyList<UltimaUtils.SectionInfo>().toMutableList()
            extensions.forEach { ext ->
                ext.sections?.filter { it.enabled }?.let { freshSections += it }
            }
            freshSections
        }).sortedByDescending { it.priority }

        if (displaySections.isEmpty()) {
            noSectionWarning?.visibility = View.VISIBLE
            return
        }

        displaySections.forEach { section ->
            val sectionView = getLayout("list_section_reorder_item", inflater, container)
            val sectionName = sectionView.findView<TextView>("section_name")

            if (section.priority == 0) section.priority = counter
            sectionName.text = "${section.pluginName}: ${section.name}"

            sectionView.background = LayerDrawable(
                arrayOf(
                    ColorDrawable(if (section == selectedSection) 0x2200FF00.toInt() else Color.TRANSPARENT),
                    getDrawable("outline")
                )
            )

            sectionView.setOnClickListener {
                when (selectedSection) {
                    null -> {
                        selectedSection = section
                        showToast("Picked! Now tap a target.")
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            displaySections
                        )
                    }
                    section -> {
                        selectedSection = null
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            displaySections
                        )
                    }
                    else -> {
                        val selected = selectedSection!!
                        val sectionsMutable = displaySections.toMutableList()

                        val selectedIndex = sectionsMutable.indexOf(selected)
                        val targetIndex = sectionsMutable.indexOf(section)

                        if (selectedIndex == targetIndex) {
                            showToast("Already in this position")
                            return@setOnClickListener
                        }

                        sectionsMutable.removeAt(selectedIndex)
                        sectionsMutable.add(targetIndex, selected)

                        sectionsMutable.forEachIndexed { index, sec ->
                            sec.priority = sectionsMutable.size - index
                        }

                        selectedSection = null
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            sectionsMutable
                        )
                        showToast("Section moved to position ${targetIndex + 1}")
                    }
                }

                sectionsListView.post {
                    for (i in 0 until sectionsListView.childCount) {
                        val child = sectionsListView.getChildAt(i)
                        val nameView = child.findView<TextView>("section_name")
                        if (nameView.text.contains(section.name, ignoreCase = true)) {
                            child.requestFocus()
                            break
                        }
                    }
                }
            }

            val increaseBtn = sectionView.findView<ImageView>("increase")
            val decreaseBtn = sectionView.findView<ImageView>("decrease")
            increaseBtn.setImageDrawable(getDrawable("triangle"))
            decreaseBtn.setImageDrawable(getDrawable("triangle"))
            decreaseBtn.rotation = 180f

            increaseBtn.makeTvCompatible()
            decreaseBtn.makeTvCompatible()

            increaseBtn.setOnClickListener {
                val idx = displaySections.indexOf(section)
                if (idx > 0) {
                    val newList = displaySections.toMutableList()
                    newList.removeAt(idx)
                    newList.add(idx - 1, section)
                    newList.forEachIndexed { index, sec -> sec.priority = newList.size - index }
                    increaseBtn.contentDescription = "Move ${section.name} up"
                    updateSectionList(sectionsListView, inflater, container, noSectionWarning, newList)

                    sectionsListView.post {
                        for (i in 0 until sectionsListView.childCount) {
                            val child = sectionsListView.getChildAt(i)
                            val nameView = child.findView<TextView>("section_name")
                            if (nameView.text.contains(section.name, ignoreCase = true)) {
                                child.findView<ImageView>("increase").requestFocus()
                                break
                            }
                        }
                    }
                } else {
                    showToast("Already at the top")
                }
            }

            decreaseBtn.setOnClickListener {
                val idx = displaySections.indexOf(section)
                if (idx < displaySections.lastIndex) {
                    val newList = displaySections.toMutableList()
                    newList.removeAt(idx)
                    newList.add(idx + 1, section)
                    newList.forEachIndexed { index, sec -> sec.priority = newList.size - index }
                    decreaseBtn.contentDescription = "Move ${section.name} down"
                    updateSectionList(sectionsListView, inflater, container, noSectionWarning, newList)

                    sectionsListView.post {
                        for (i in 0 until sectionsListView.childCount) {
                            val child = sectionsListView.getChildAt(i)
                            val nameView = child.findView<TextView>("section_name")
                            if (nameView.text.contains(section.name, ignoreCase = true)) {
                                // Focus back to decrease button inside this row
                                child.findView<ImageView>("decrease").requestFocus()
                                break
                            }
                        }
                    }
                } else {
                    showToast("Already at the bottom")
                }
            }

            counter -= 1
            sectionsListView.addView(sectionView)
        }
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        super.onDetach()
        UltimaSettings(plugin).show(
            activity?.supportFragmentManager
                ?: throw Exception("Unable to open configure settings"),
            ""
        )
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Settings/Settings.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.Intent
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.cloudstream3.utils.AppContextUtils.setDefaultFocus
import com.phisher98.BuildConfig
import androidx.core.net.toUri

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaSettings(val plugin: UltimaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion - necessary functions

    @SuppressLint("SetTextI18n")
    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("settings", inflater, container)

        // #region - building save button and its click listener
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Restart Required")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them ?")
                .setPositiveButton("Yes") { _, _ ->
                    plugin.reload()
                    showToast("Saved and Restarting...")
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No") { dialog, _ ->
                    showToast("Saved. Restart later to apply changes.")
                    dialog.dismiss()
                    dismiss()
                }.show()
        }
        // #endregion - building save button and its click listener

        // #region - building meta providers button and its click listener
        val metaProvidersBtn = settings.findView<ImageView>("meta_providers_img")
        metaProvidersBtn.setImageDrawable(getDrawable("edit_icon"))
        metaProvidersBtn.makeTvCompatible()
        metaProvidersBtn.setOnClickListener {
            val configure = UltimaMetaProviders(plugin)
            configure.show(
                activity?.supportFragmentManager
                    ?: throw Exception(
                        "Unable to open meta providers settings"
                    ),
                ""
            )
            dismiss()
        }
        // #endregion - building meta providers button and its click listener

        // #region - building config extensions button and its click listener
        val configBtn = settings.findView<ImageView>("config_img")
        configBtn.setImageDrawable(getDrawable("edit_icon"))
        configBtn.makeTvCompatible()
        configBtn.setOnClickListener {
            val configure = UltimaConfigureExtensions(plugin)
            configure.show(
                activity?.supportFragmentManager
                    ?: throw Exception(
                        "Unable to open configure extensions settings"
                    ),
                ""
            )
            dismiss()
        }
        // #endregion - building config extensions button and its click listener

        // #region - building reorder button and its click listener
        val reorderBtn = settings.findView<ImageView>("reorder_img")
        reorderBtn.setImageDrawable(getDrawable("edit_icon"))
        reorderBtn.makeTvCompatible()
        reorderBtn.setOnClickListener {
            val reorder = UltimaReorder(plugin)
            reorder.show(
                activity?.supportFragmentManager
                    ?: throw Exception("Unable to open reorder settings"),
                ""
            )
            dismiss()
        }
        // #endregion - building reorder button and its click listener

        // #region - building reorder button and its click listener
        val watchSyncBtn = settings.findView<ImageView>("watch_sync_img")
        watchSyncBtn.setImageDrawable(getDrawable("edit_icon"))
        watchSyncBtn.makeTvCompatible()
        watchSyncBtn.setOnClickListener {
            val reorder = UltimaConfigureWatchSync(plugin)
            reorder.show(
                activity?.supportFragmentManager
                    ?: throw Exception("Unable to open reorder settings"),
                ""
            )
            dismiss()
        }
        // #endregion - building reorder button and its click listener

        val guideIcon = settings.findView<ImageView>("guide_icon")
        guideIcon.setImageDrawable(getDrawable("ic_eye"))
        guideIcon.makeTvCompatible()
        guideIcon.setOnClickListener {
            val url = "https://github.com/phisher98/cloudstream-extensions-phisher/blob/master/docs/ULTIMA_SYNC_SETUP.md"
            val intent = Intent(Intent.ACTION_VIEW, url.toUri())
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            activity?.startActivity(intent)
        }

        // #region - building delete button with its click listener
        val deleteBtn = settings.findView<TextView>("delete_img")

        deleteBtn.text = "Reset"
        deleteBtn.makeTvCompatible()

        deleteBtn.setOnClickListener {
            AlertDialog.Builder(
                context ?: throw Exception("Unable to build alert dialog")
            )
                .setTitle("Reset Ultima")
                .setMessage("This will delete all selected sections.")
                .setPositiveButton("Reset") { _, _ ->
                    sm.deleteAllData()
                    plugin.reload()
                    showToast("Sections cleared")
                    dismiss()
                }
                .setNegativeButton("Cancel", null)
                .show()
                .setDefaultFocus()
        }
        // #endregion - building delete button with its click listener

        return settings
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}


    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Utils/StorageManager.kt
================================================
package com.phisher98

// import com.phisher98.UltimaUtils.Provider

import com.lagradost.api.Log
import com.phisher98.UltimaUtils.ExtensionInfo
import com.phisher98.UltimaUtils.MediaProviderState
import com.phisher98.UltimaUtils.SectionInfo
import com.phisher98.WatchSyncUtils.WatchSyncCreds
import com.lagradost.cloudstream3.APIHolder.allProviders
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.AcraApplication.Companion.setKey

object UltimaStorageManager {

    // #region - custom data variables

    var extNameOnHome: Boolean
        get() = getKey("ULTIMA_EXT_NAME_ON_HOME") ?: true
        set(value) {
            setKey("ULTIMA_EXT_NAME_ON_HOME", value)
        }

    var currentExtensions: Array<ExtensionInfo>
        get() = getKey("ULTIMA_EXTENSIONS_LIST") ?: emptyArray<ExtensionInfo>()
        set(value) {
            setKey("ULTIMA_EXTENSIONS_LIST", value)
        }

    var currentMetaProviders: Array<Pair<String, Boolean>>
        get() = listMetaProviders()
        set(value) {
            setKey("ULTIMA_CURRENT_META_PROVIDERS", value)
        }

    var currentMediaProviders: Array<MediaProviderState>
        get() = listMediaProviders()
        set(value) {
            setKey("ULTIMA_CURRENT_MEDIA_PROVIDERS", value)
        }

    var deviceSyncCreds: WatchSyncCreds?
        get() = getKey("ULTIMA_WATCH_SYNC_CREDS")
        set(value) {
            setKey("ULTIMA_WATCH_SYNC_CREDS", value)
        }

    // #endregion - custom data variables

    fun deleteAllData() {
        listOf(
                        "ULTIMA_PROVIDER_LIST", // old key
                        "ULTIMA_EXT_NAME_ON_HOME",
                        "ULTIMA_EXTENSIONS_LIST",
                        "ULTIMA_CURRENT_META_PROVIDERS",
                        "ULTIMA_CURRENT_MEDIA_PROVIDERS",
                        "ULTIMA_WATCH_SYNC_CREDS"
                )
                .forEach { setKey(it, null) }
    }


    fun fetchExtensions(): Array<ExtensionInfo> = synchronized(allProviders) {
        val cachedExtensions = getKey<Array<ExtensionInfo>>("ULTIMA_EXTENSIONS_LIST")
        val providers = allProviders.filter { it.name != "Ultima" }

        providers.map { provider ->
            val existing = cachedExtensions?.find { it.name == provider.name }
            existing ?: ExtensionInfo(
                name = provider.name,
                provider.mainPage.map { section ->
                    SectionInfo(
                        name = section.name,
                        section.data,
                        provider.name,
                        false
                    )
                }.toTypedArray()
            )
        }.toTypedArray()
    }


    private fun listMetaProviders(): Array<Pair<String, Boolean>> {
        val currentProviders = UltimaMetaProviderUtils.metaProviders
        val storedProviders = getKey<Array<Pair<String, Boolean>>>("ULTIMA_CURRENT_META_PROVIDERS")
            ?: return currentProviders

        val currentNames = currentProviders.map { it.first }.sorted()
        val storedNames = storedProviders.map { it.first }.sorted()

        // If the names match (ignoring order), use the stored version
        if (currentNames == storedNames) return storedProviders

        // Merge stored flags if available, otherwise use default
        return currentProviders.map { provider ->
            storedProviders.find { it.first == provider.first } ?: provider
        }.toTypedArray()
    }


    private fun listMediaProviders(): Array<MediaProviderState> {
        val currentProviderNames = UltimaMediaProvidersUtils.mediaProviders.map { it.name }
        val stored = getKey<Array<MediaProviderState>>("ULTIMA_CURRENT_MEDIA_PROVIDERS")
            ?: return currentProviderNames.map { MediaProviderState(it, enabled = true, null) }.toTypedArray()

        val storedNames = stored.map { it.name }.sorted()
        if (currentProviderNames.sorted() == storedNames) return stored

        return currentProviderNames.map { name ->
            stored.find { it.name == name } ?: MediaProviderState(name, enabled = true,  null)
        }.toTypedArray()
    }

}



================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Utils/UltimaUtils.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import kotlinx.coroutines.delay
import com.lagradost.cloudstream3.app
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit

object UltimaUtils {
    data class SectionInfo(
            @JsonProperty("name") var name: String,
            @JsonProperty("url") var url: String,
            @JsonProperty("pluginName") var pluginName: String,
            @JsonProperty("enabled") var enabled: Boolean = false,
            @JsonProperty("priority") var priority: Int = 0
    )

    data class ExtensionInfo(
            @JsonProperty("name") var name: String? = null,
            @JsonProperty("sections") var sections: Array<SectionInfo>? = null
    )

    enum class Category {
        ANIME,
        MEDIA,
        NONE
    }

    data class MediaProviderState(
            @JsonProperty("name") var name: String,
            @JsonProperty("enabled") var enabled: Boolean = true,
            @JsonProperty("customDomain") var customDomain: String? = null
    ) {
        fun getProvider(): MediaProvider {
            return UltimaMediaProvidersUtils.mediaProviders.find { it.name.equals(name) }
                    ?: throw Exception("Unable to find media provider for $name")
        }

        fun getDomain(): String {
            return customDomain ?: getProvider().domain
        }
    }

    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: Int? = null,
        @JsonProperty("malId") val malId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
        @JsonProperty("isDub") val isDub: Boolean = false,
    )
}

suspend fun <T> retry(
    times: Int = 3,
    delayMillis: Long = 1000,
    block: suspend () -> T
): T? {
    repeat(times - 1) {
        runCatching { return block() }.onFailure { delay(delayMillis) }
    }
    return runCatching { block() }.getOrNull()
}

data class DomainsParser(
    val moviesdrive: String,
    @JsonProperty("HDHUB4u")
    val hdhub4u: String,
    @JsonProperty("4khdhub")
    val n4khdhub: String,
    @JsonProperty("MultiMovies")
    val multiMovies: String,
    val bollyflix: String,
    @JsonProperty("UHDMovies")
    val uhdmovies: String,
    val moviesmod: String,
    val topMovies: String,
    val hdmovie2: String,
    val vegamovies: String,
    val rogmovies: String,
    val luxmovies: String,
    val xprime: String,
    val extramovies:String,
    val dramadrip:String
)

// ----------- Constants and Cache -----------
private var cachedDomains: DomainsParser? = null
private const val DOMAINS_URL =
    "https://raw.githubusercontent.com/phisher98/TVVVV/main/domains.json"

// ----------- Domain Fetch Function -----------
suspend fun getDomains(forceRefresh: Boolean = false): DomainsParser? {
    if (cachedDomains == null || forceRefresh) {
        try {
            val response = app.get(DOMAINS_URL)
            cachedDomains = response.parsedSafe<DomainsParser>()
            if (cachedDomains == null) {
                Log.e("getDomains", "Parsed domains are null. Possibly malformed JSON.")
            }
        } catch (e: Exception) {
            Log.e("getDomains", "Error fetching/parsing domains: ${e.message}")
            return null
        }
    }
    return cachedDomains
}

suspend fun <T> runLimitedParallel(
    limit: Int = 4,
    blockList: List<suspend () -> T>
): List<T> {
    val semaphore = Semaphore(limit)
    return coroutineScope {
        blockList.map { block ->
            async(Dispatchers.IO) {
                semaphore.withPermit { block() }
            }
        }.awaitAll()
    }
}

fun cleanTitle(title: String): String {
    val parts = title.split(".", "-", "_")

    val qualityTags = listOf(
        "WEBRip", "WEB-DL", "WEB", "BluRay", "HDRip", "DVDRip", "HDTV",
        "CAM", "TS", "R5", "DVDScr", "BRRip", "BDRip", "DVD", "PDTV",
        "HD"
    )

    val audioTags = listOf(
        "AAC", "AC3", "DTS", "MP3", "FLAC", "DD5", "EAC3", "Atmos"
    )

    val subTags = listOf(
        "ESub", "ESubs", "Subs", "MultiSub", "NoSub", "EnglishSub", "HindiSub"
    )

    val codecTags = listOf(
        "x264", "x265", "H264", "HEVC", "AVC"
    )

    val startIndex = parts.indexOfFirst { part ->
        qualityTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    val endIndex = parts.indexOfLast { part ->
        subTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                audioTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                codecTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    return if (startIndex != -1 && endIndex != -1 && endIndex >= startIndex) {
        parts.subList(startIndex, endIndex + 1).joinToString(".")
    } else if (startIndex != -1) {
        parts.subList(startIndex, parts.size).joinToString(".")
    } else {
        parts.takeLast(3).joinToString(".")
    }
}


================================================
FILE: Ultima/src/main/kotlin/com/phisher98/Utils/WatchSyncUtils.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.ui.home.HomeViewModel.Companion.getResumeWatching
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.DataStoreHelper.ResumeWatchingResult
import com.phisher98.UltimaStorageManager as sm

object WatchSyncUtils {
    data class WatchSyncCreds(
            @JsonProperty("token") var token: String? = null,
            @JsonProperty("projectNum") var projectNum: Int? = null,
            @JsonProperty("deviceName") var deviceName: String? = null,
            @JsonProperty("deviceId") var deviceId: String? = null, // draftIssueID
            @JsonProperty("itemId") var itemId: String? = null, // projectItemID
            @JsonProperty("projectId") var projectId: String? = null,
            @JsonProperty("isThisDeviceSync") var isThisDeviceSync: Boolean = false,
            @JsonProperty("enabledDevices") var enabledDevices: MutableList<String>? = null
    ) {
        data class APIRes(@JsonProperty("data") var data: Data) {
            data class Data(
                    @JsonProperty("viewer") var viewer: Viewer?,
                    @JsonProperty("addProjectV2DraftIssue") var issue: Issue?,
                    @JsonProperty("deleteProjectV2Item") var delItem: DelItem?
            ) {
                data class Viewer(@JsonProperty("projectV2") var projectV2: ProjectV2) {
                    data class ProjectV2(
                            @JsonProperty("id") var id: String,
                            @JsonProperty("items") var items: Items?
                    ) {
                        data class Items(
                                @JsonProperty("nodes") var nodes: Array<Node>?,
                        ) {
                            data class Node(
                                    @JsonProperty("id") var id: String,
                                    @JsonProperty("content") var content: Content
                            ) {
                                data class Content(
                                        @JsonProperty("id") var id: String,
                                        @JsonProperty("title") var title: String,
                                        @JsonProperty("bodyText") var bodyText: String,
                                )
                            }
                        }
                    }
                }
                data class Issue(@JsonProperty("projectItem") var projectItem: ProjectItem) {
                    data class ProjectItem(
                            @JsonProperty("id") var id: String,
                            @JsonProperty("content") var content: Content
                    ) {
                        data class Content(@JsonProperty("id") var id: String)
                    }
                }
                data class DelItem(@JsonProperty("deletedItemId") var deletedItemId: String)
            }
        }

        data class SyncDevice(
                @JsonProperty("name") var name: String,
                @JsonProperty("deviceId") var deviceId: String, // draftIssueID // for add update
                @JsonProperty("itemId") var itemId: String, // projectItemID // for delete
                @JsonProperty("syncedData") var syncedData: List<ResumeWatchingResult>? = null
        )

        private val apiUrl = "https://api.github.com/graphql"

        private fun Any.toStringData(): String {
            return mapper.writeValueAsString(this)
        }

        fun isLoggedIn(): Boolean {
            return !(token.isNullOrEmpty() ||
                    projectNum == null ||
                    deviceName.isNullOrEmpty() ||
                    projectId.isNullOrEmpty())
        }

        private suspend fun apiCall(query: String): APIRes? {
            val apiUrl = "https://api.github.com/graphql"
            val header =
                    mapOf(
                            "Content-Type" to "application/json",
                            "Authorization" to "Bearer " + (token ?: return null)
                    )
            val data = """ { "query": ${query} } """
            val test = app.post(apiUrl, headers = header, json = data)
            val res = test.parsedSafe<APIRes>()
            return res
        }

        suspend fun syncProjectDetails(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            val query =
                    """ query Viewer { viewer { projectV2(number: ${projectNum ?: return failure}) { id } } } """
            val res = apiCall(query.toStringData()) ?: return failure
            projectId = res.data.viewer?.projectV2?.id ?: return failure
            sm.deviceSyncCreds = this
            return true to "Project details saved"
        }

        suspend fun registerThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn()) return failure
            val syncData = getResumeWatching()?.toStringData() ?: "[]"
            val data = base64Encode(syncData.toByteArray())
            val query =
                    """ mutation AddProjectV2DraftIssue { addProjectV2DraftIssue( input: { projectId: "$projectId", title: "$deviceName", body: "$data" } ) { projectItem { id content { ... on DraftIssue { id } } } } } """
            val res = apiCall(query.toStringData()) ?: return failure
            itemId = res.data.issue?.projectItem?.id ?: return failure
            deviceId = res.data.issue?.projectItem?.content?.id ?: return failure
            isThisDeviceSync = true
            sm.deviceSyncCreds = this
            return true to "Device is registered"
        }

        suspend fun deregisterThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn()) return failure
            val query =
                    """ mutation DeleteIssue { deleteProjectV2Item( input: { projectId: "$projectId" itemId: "$itemId" } ) { deletedItemId } } """
            val res = apiCall(query.toStringData()) ?: return failure
            if (res.data.delItem?.deletedItemId.equals(itemId)) {
                itemId = null
                deviceId = null
                isThisDeviceSync = false
                sm.deviceSyncCreds = this
                return true to "Device de-registered"
            } else return failure
        }

        suspend fun syncThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn()) return failure
            if (!isThisDeviceSync) return failure
            val syncData = getResumeWatching()?.toStringData() ?: "[]"
            val data = base64Encode(syncData.toByteArray())
            val query =
                    """ mutation UpdateProjectV2DraftIssue { updateProjectV2DraftIssue( input: { draftIssueId: "$deviceId", title: "$deviceName", body: "$data" } ) { draftIssue { id } } } """
            apiCall(query.toStringData()) ?: return failure
            return true to "sync complete"
        }

        suspend fun fetchDevices(): List<SyncDevice>? {
            if (!isLoggedIn()) return null
            val query =
                    """ query User { viewer { projectV2(number: ${projectNum ?: return null}) { id items(first: 50) { nodes { id content { ... on DraftIssue { id title bodyText } } } totalCount } } } } """
            val res = apiCall(query.toStringData()) ?: return null
            val data =
                    res.data.viewer?.projectV2?.items?.nodes?.map {
                        val data = base64Decode(it.content.bodyText)
                        val syncData =
                                parseJson<Array<ResumeWatchingResult>?>(data)?.toList()
                                        ?: return null
                        SyncDevice(it.content.title, it.content.id, it.id, syncData)
                    }
            return data
        }
    }
}



================================================
FILE: Ultima/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#FFFFFFFF"
        android:pathData="M12.95,42.8 C11.5,42.8 10.4,41.7 10.4,39.15 V10.4 H8.75 C8,10.4 7.475,9.85 7.475,8.55 C7.475,7.8 8,6.75 8.75,6.75 H17.35 C17.35,6 17.875,5.525 19.15,5.05 H28.9 C29.65,5.05 30.175,6 30.7,6.75 H39.3 C40.05,6.75 40.6,7.8 40.6,8.55 C40.6,9.3 40.05,10.4 39.3,10.4 H38.75 V39.15 C38.75,40.6 37.65,41.7 35.1,42.8 Z M12.95,10.4 V39.15 H35.1 V10.4 Z M17.85,33 C17.85,33.75 18.375,34.275 19.65,34.8 C20.4,34.8 20.95,33.75 21.5,33 V16.5 C21.5,15.75 20.95,15.2 19.65,14.65 C18.9,14.65 17.85,15.75 17.85,16.5 Z M26.6,33 C26.6,33.75 27.125,34.275 28.4,34.8 C29.15,34.8 30.25,33.75 30.25,33 V16.5 C30.25,15.75 29.7,15.2 28.4,14.65 C27.65,14.65 26.6,15.75 26.6,16.5 Z" />
</vector>



================================================
FILE: Ultima/src/main/res/drawable/edit_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: Ultima/src/main/res/drawable/ic_eye.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M24,4C12.95,4 4,12.95 4,24s8.95,20 20,20 20,-8.95 20,-20S35.05,4 24,4zM26,34h-4V20h4v14zM26,16h-4v-4h4v4z"/>
</vector>



================================================
FILE: Ultima/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="2dp"
                android:bottomRightRadius="2dp"
                android:topLeftRadius="2dp"
                android:topRightRadius="2dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: Ultima/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
  android:width="24dp"
  android:height="24dp"
  android:viewportWidth="24"
  android:viewportHeight="24"
  android:tint="@android:color/white">
  <path
    android:fillColor="@android:color/white"
    android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: Ultima/src/main/res/drawable/triangle.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="15dp"
    android:height="15dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M24 22h-24l12-20z" />
</vector>


================================================
FILE: Ultima/src/main/res/layout/configure_extensions.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Configure Extension Sections"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp" />

            </LinearLayout>

        </LinearLayout>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:text="set priority next to section (higher number to stay on top)" />

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <Switch
            android:id="@+id/ext_name_on_home_toggle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="17sp"
            android:padding="5dp"
            android:text="Include extension name on home screen"
            android:focusable="true" />

        <LinearLayout
            android:id="@+id/extensions_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: Ultima/src/main/res/layout/configure_watch_sync.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <!-- Header Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="5dp">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Sync Watch History"
                android:textSize="20sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/save"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="5dp"
                android:contentDescription="Save"
                android:focusable="true" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Credentials Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp"
            android:gravity="center_vertical">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Login data"
                android:textSize="18sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/watch_sync_creds_btn"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="5dp"
                android:contentDescription="Edit"
                android:focusable="true" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Sync Toggle -->
        <Switch
            android:id="@+id/sync_this_device"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Sync this device"
            android:textSize="17sp"
            android:padding="5dp"
            android:layout_marginVertical="5dp" />

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Device List Header -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Devices"
            android:textSize="18sp"
            android:layout_marginBottom="5dp" />

        <!-- Devices List -->
        <LinearLayout
            android:id="@+id/devices_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp" />

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: Ultima/src/main/res/layout/list_extension_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <LinearLayout
        android:id="@+id/extension_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:focusable="true">

        <ImageView
            android:id="@+id/expand_icon"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/extension_name"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="parent_name"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginLeft="10dp" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/sections_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginStart="10dp"
        android:visibility="gone"
        android:paddingBottom="10dp">
    </LinearLayout>

</LinearLayout>


================================================
FILE: Ultima/src/main/res/layout/list_media_provider_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="horizontal">

    <CheckBox
        android:id="@+id/provider"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:text="provider"
        android:textSize="15sp"
        android:textStyle="bold"
        android:focusable="true" />


    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="right"
        android:orientation="horizontal"
        android:visibility="visible">

        <TextView
            android:id="@+id/domain"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:gravity="center"
            android:textSize="15sp"
            android:text="domain.com"
            android:paddingEnd="10dp" />

        <ImageView
            android:id="@+id/domain_edit"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:padding="5dp"
            android:layout_rowWeight="1"
            android:focusable="true" />
    </LinearLayout>

</LinearLayout>


================================================
FILE: Ultima/src/main/res/layout/list_meta_provider_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <Switch
        android:id="@+id/meta_provider_name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:text="test"
        android:focusable="true"
        tools:ignore="UseSwitchCompatOrMaterialXml" />

</LinearLayout>


================================================
FILE: Ultima/src/main/res/layout/list_section_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="horizontal">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="12dp"
        android:gravity="center_vertical"
        android:clickable="true"
        android:focusable="true">

        <CheckBox
            android:id="@+id/section_checkbox"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Provider Name"
            android:textSize="15sp"/>
    </LinearLayout>

</LinearLayout>




================================================
FILE: Ultima/src/main/res/layout/list_section_reorder_item.xml
================================================
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/section_container"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:paddingTop="12dp"
    android:paddingBottom="12dp"
    android:background="?android:attr/selectableItemBackground"
    android:nextFocusRight="@+id/increase">

    <TextView
        android:id="@+id/section_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp"
        android:textStyle="bold"
        android:textColor="#DDDDDD"
        android:maxLines="1"
        android:ellipsize="end"
        android:gravity="center_vertical"
        android:focusable="false"
        android:clickable="false" />

    <ImageView
        android:id="@+id/increase"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="8dp"
        android:nextFocusLeft="@id/section_container"
        android:nextFocusRight="@id/decrease" />

    <ImageView
        android:id="@+id/decrease"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="8dp"
        android:nextFocusLeft="@id/section_container"
        android:nextFocusRight="@id/increase" />
</LinearLayout>



================================================
FILE: Ultima/src/main/res/layout/meta_providers.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Meta Providers"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_rowWeight="1"
            android:layout_marginTop="5dp"
            android:layout_marginBottom="5dp"
            android:text="Meta Services"
            android:textSize="18sp" />

        <LinearLayout
            android:id="@+id/meta_providers_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_rowWeight="1"
            android:layout_marginTop="5dp"
            android:layout_marginBottom="5dp"
            android:text="Media Sources"
            android:textSize="18sp" />

        <LinearLayout
            android:id="@+id/media_providers_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: Ultima/src/main/res/layout/reorder.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr"
    android:focusable="true"
    android:focusableInTouchMode="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <!-- Header Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Reorder Sections"
                android:textSize="20sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/save"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:padding="5dp" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:layout_marginVertical="10dp"
            android:paddingHorizontal="2dp" />

        <!-- Section List -->
        <LinearLayout
            android:id="@+id/section_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp" />

        <!-- No Section Warning -->
        <TextView
            android:id="@+id/no_section_warning"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:layout_marginBottom="20dp"
            android:text="You have not enabled any section"
            android:textSize="15sp"
            android:gravity="center"
            android:visibility="gone" />

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: Ultima/src/main/res/layout/settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Ultima Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/meta_providers_img"
                    android:nextFocusUp="@id/save" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Configure Meta Providers"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/meta_providers_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/config_img"
                    android:nextFocusUp="@id/save" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Configure Extension Sections"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/config_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/reorder_img"
                    android:nextFocusUp="@id/meta_providers_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Reorder Sections"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/reorder_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/watch_sync_img"
                    android:nextFocusUp="@id/config_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Cross Device Watch Sync"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/watch_sync_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/guide_icon"
                    android:nextFocusUp="@id/reorder_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Ultima Setup Guide"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/guide_icon"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/delete_img"
                    android:nextFocusUp="@id/watch_sync_img" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Reset Ultima"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <TextView
                    android:id="@+id/delete_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="10dp"
                    android:focusable="true"
                    android:text="Reset"
                    android:textSize="18sp"
                    android:textStyle="bold"
                    android:nextFocusDown="@id/save"
                    android:nextFocusUp="@id/guide_icon" />

            </LinearLayout>

        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: Ultima/src/main/res/layout/watch_sync_creds.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="25dp"
        android:layout_marginLeft="25dp"
        android:layout_marginRight="25dp"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="GitHub token"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/token"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:layout_marginBottom="10dp"
            android:inputType="text" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Project number"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/project_num"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:layout_marginBottom="10dp"
            android:inputType="text" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Device name"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/device_name"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:inputType="text" />

    </LinearLayout>

</LinearLayout>


================================================
FILE: Ultima/src/main/res/layout/watch_sync_device.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <Switch
        android:id="@+id/watch_sync_device_name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:text="test"
        android:focusable="true" />

</LinearLayout>


================================================
FILE: UltimaBeta/build.gradle.kts
================================================
@file:Suppress("UnstableApiUsage")

import org.jetbrains.kotlin.konan.properties.Properties

dependencies {
    implementation("com.google.android.material:material:1.13.0")

    // FIXME remove this when crossplatform is fully supported
    val cloudstream by configurations
    cloudstream("com.lagradost:cloudstream3:pre-release")
}
// use an integer for version numbers
version = 14

cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "(Beta)The ultimate All-in-One home screen to access all of your extensions at one place (You need to select/deselect sections in Ultima's settings to load other extensions on home screen)"
    authors = listOf("RowdyRushya,Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 2

    tvTypes = listOf("All")

    requiresResources = true
    language = "en"

    // random cc logo i found
    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/UltimaBeta.png"

    isCrossPlatform = false
}

android {
    buildFeatures {
        buildConfig = true
    }

    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        buildConfigField("String", "KAISVA", "\"${properties.getProperty("KAISVA")}\"")
        buildConfigField("String", "SIMKL_API", "\"${properties.getProperty("SIMKL_API")}\"")
        buildConfigField("String", "MAL_API", "\"${properties.getProperty("MAL_API")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_ALT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_ALT")}\"")
        buildConfigField("String", "MOVIEBOX_SECRET_KEY_DEFAULT", "\"${properties.getProperty("MOVIEBOX_SECRET_KEY_DEFAULT")}\"")

    }
}



================================================
FILE: UltimaBeta/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Ultima.kt
================================================
package com.phisher98

import androidx.core.content.edit
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.api.Log
import com.lagradost.cloudstream3.APIHolder.allProviders
import com.lagradost.cloudstream3.AcraApplication.Companion.context
import com.lagradost.cloudstream3.AnimeSearchResponse
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageData
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.MovieSearchResponse
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.TvSeriesSearchResponse
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.DataStore.getSharedPrefs
import com.phisher98.UltimaUtils.SectionInfo

class UltimaBeta(val plugin: UltimaBetaPlugin) : MainAPI() {
    override var name = "Ultima Beta"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Anime)
    override var lang = "en"
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val sm = UltimaStorageManager
    private val deviceSyncData = sm.deviceSyncCreds

    private val mapper = jacksonObjectMapper()
    private var sectionNamesList: List<String> = emptyList()

    private fun loadSections(): List<MainPageData> {
        val tempSectionNames = mutableListOf<String>()

        val result = mutableListOf<MainPageData>()
        val savedPlugins = sm.currentExtensions

        result += mainPageOf("" to "watch_sync")

        val enabledSections = savedPlugins
            .flatMap { it.sections?.asList() ?: emptyList() }
            .filter { it.enabled }
            .sortedByDescending { it.priority }

        enabledSections.forEach { section ->
            try {
                val sectionKey = mapper.writeValueAsString(section)
                val sectionName = buildSectionName(section, tempSectionNames)
                result += mainPageOf(sectionKey to sectionName)
            } catch (e: Exception) {
                Log.e("loadSections", "Failed to load section ${section.name}: ${e.message}")
            }
        }

        sectionNamesList = tempSectionNames

        return if (result.size <= 1) mainPageOf("" to "watch_sync") else result
    }


    private fun buildSectionName(section: SectionInfo, names: MutableList<String>): String {
        val lrm = "\u200E"
        val name = if (sm.extNameOnHome) {
            "${section.pluginName}$lrm: $lrm${section.name}"
        } else if (names.contains(section.name)) {
            "${section.name} ${names.count { it.startsWith(section.name) } + 1}"
        } else {
            section.name
        }
        names += name
        return name
    }



    override val mainPage = loadSections()

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        val creds = sm.deviceSyncCreds
        creds?.syncThisDevice()

        if (request.name.isEmpty()) {
            throw ErrorLoadingException("Select sections from the extension's settings page to show here.")
        }

        return try {
            if (request.name == "watch_sync") {
                val syncedDevices = creds?.fetchDevices()
                val filteredDevices = syncedDevices?.filter {
                    deviceSyncData?.enabledDevices?.contains(it.deviceId) == true
                } ?: emptyList()

                if (filteredDevices.isEmpty()) {
                    Log.w("getMainPage", "No enabled devices found in the synced list.")
                    return null
                }

                val homeSections = ArrayList<HomePageList>(filteredDevices.size)

                for (device in filteredDevices) {
                    val currentDevice = sm.deviceSyncCreds?.deviceId == device.deviceId
                    val payload = device.payload
                    if (payload == null) {
                        Log.w("restoreResumeWatching", "No payload found for ${device.name}")
                        continue
                    }

                    if (!currentDevice) {
                        runCatching {
                            payload.extensions?.let { sm.currentExtensions = it }
                            payload.metaProviders?.let { sm.currentMetaProviders = it }
                            payload.mediaProviders?.let { sm.currentMediaProviders = it }
                            payload.extNameOnHome?.let { sm.extNameOnHome = it }
                        }.onSuccess {
                            Log.i("getMainPage", "Restored providers from ${device.name}")
                        }.onFailure {
                            Log.e("getMainPage", "Restore failed from ${device.name}: ${it.message}")
                        }

                        // Restore resumeWatching items
                        val allResumeItems = filteredDevices
                            .filter { it.deviceId != sm.deviceSyncCreds?.deviceId }
                            .flatMap { it.payload?.resumeWatching.orEmpty() }
                            .distinctBy { it.id }

                        context?.let { ctx ->
                            val sharedPrefs = ctx.getSharedPrefs()
                            sharedPrefs.edit {
                                payload.data?.forEach { (key, value) ->
                                    val idPart = key.split("/").lastOrNull()
                                    val id = idPart?.toLongOrNull() ?: idPart?.toIntOrNull()?.toLong()

                                    val shouldRestore = when {
                                        key.contains("download_header_cache") -> id != null && allResumeItems.any { it.parentId?.toLong() == id }
                                        key.contains("result_resume_watching") -> id != null && allResumeItems.any { it.id?.toLong() == id }
                                        key.contains("video_pos") -> id != null && allResumeItems.any { it.id?.toLong() == id }
                                        else -> false
                                    }
                                    if (shouldRestore) {
                                        Log.d("RestoreAlldata", "Restoring key=$key, value=$value")
                                    } else {
                                        Log.d("RestoreAlldata", "Skipping key=$key")
                                    }
                                    sharedPrefs.edit {
                                        putString(key, value).apply()
                                    }
                                }
                            }
                        }
                    }
                }
                newHomePageResponse(homeSections, false)
            } else {
                val section = AppUtils.parseJson<SectionInfo>(request.data)
                val provider = allProviders.find { it.name == section.pluginName }
                    ?: throw ErrorLoadingException("Provider '${section.pluginName}' is not available.")

                provider.getMainPage(
                    page,
                    MainPageRequest(
                        name = request.name,
                        data = section.url,
                        horizontalImages = request.horizontalImages
                    )
                )
            }
        } catch (e: Throwable) {
            Log.e("getMainPage", "Error loading main page: ${e.message}")
            e.printStackTrace()
            null
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
        val enabledSections = mainPage
            .filter { !it.name.equals("watch_sync", ignoreCase = true) }
            .mapNotNull {
                try {
                    val section = AppUtils.parseJson<SectionInfo>(it.data)
                    section.pluginName to section
                } catch (_: Exception) {
                    null
                }
            }

        val tasks = mutableListOf<suspend () -> List<SearchResponse>>()

        for ((pluginName, _) in enabledSections) {
            val provider = allProviders.find { it.name == pluginName } ?: continue

            tasks += suspend {
                try {
                    when (val result = provider.search(query)) {
                        is List<*> -> {
                            result.map { item ->
                                when (item) {
                                    is MovieSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    is AnimeSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    is TvSeriesSearchResponse -> item.copy(name = "[$pluginName] ${item.name}")
                                    else -> item
                                }
                            }
                        }
                        else -> emptyList()
                    }
                } catch (e: Exception) {
                    Log.e("search", "Search failed for provider $pluginName: ${e.message}")
                    emptyList()
                }
            }
        }


        return runLimitedParallel(limit = 4, tasks).flatten()
    }

    override suspend fun load(url: String): LoadResponse? {
        val enabledPlugins = mainPage
            .filter { !it.name.equals("watch_sync", ignoreCase = true) }
            .mapNotNull {
                try {
                    AppUtils.parseJson<SectionInfo>(it.data).pluginName
                } catch (_: Exception) {
                    null
                }
            }

        val providersToTry = allProviders.filter { it.name in enabledPlugins }

        for (provider in providersToTry) {
            try {
                val response = provider.load(url)
                if (response != null &&
                    response.name.isNotBlank() &&
                    !response.posterUrl.isNullOrBlank() && response.posterUrl!!.startsWith("http")
                ) {
                    return response
                }
            } catch (e: Throwable) {
                Log.e("Ultima load", "Failed loading from ${provider.name}: ${e.message}")
            }
        }

        // No valid content found, just return null
        Log.w("Ultima load", "No valid content found for $url")
        return null
    }

}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/UltimaPlugin.kt
================================================
package com.phisher98

import android.content.Context
import android.os.Handler
import android.os.Looper
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.api.Log
import com.lagradost.cloudstream3.MainActivity.Companion.afterPluginsLoadedEvent
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import com.lagradost.cloudstream3.plugins.PluginManager
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

@CloudstreamPlugin
class UltimaBetaPlugin : Plugin() {
    var activity: AppCompatActivity? = null

    override fun load(context: Context) {
        activity = context as AppCompatActivity
        handler.post(syncRunnable)
        // All providers should be added in this manner
        registerMainAPI(UltimaBeta(this))
        UltimaStorageManager.currentMetaProviders.forEach { metaProvider ->
            when (metaProvider.first) {
                "Simkl" -> if (metaProvider.second) registerMainAPI(Simkl(this))
                "AniList" -> if (metaProvider.second) registerMainAPI(AniList(this))
                "MyAnimeList" -> if (metaProvider.second) registerMainAPI(MyAnimeList(this))
                "TMDB" -> if (metaProvider.second) registerMainAPI(Tmdb(this))
                "Trakt" -> if (metaProvider.second) registerMainAPI(Trakt(this))
                else -> {}
            }
        }


        openSettings = { ctx ->
            val act = ctx as? AppCompatActivity
            if (act != null && !act.isFinishing && !act.isDestroyed) {
                val frag = UltimaSettings(this)
                frag.show(act.supportFragmentManager, "UltimaSettingsDialog")
            } else {
                Log.e("UltimaPlugin", "Activity is not valid anymore, cannot show settings dialog")
            }
        }
    }

    fun reload() {
        val pluginData = PluginManager.getPluginsOnline().find { it.internalName.contains("Ultima Beta") }
        if (pluginData == null) {
            afterPluginsLoadedEvent.invoke(true)
        }
    }

    private val handler = Handler(Looper.getMainLooper())

    private val syncRunnable = object : Runnable {
        override fun run() {
            triggerSync()
            handler.postDelayed(this, 5000)
        }
    }
    private fun triggerSync() {
        UltimaStorageManager.deviceSyncCreds?.let { creds ->
            CoroutineScope(Dispatchers.IO).launch {
                runCatching {
                    creds.syncThisDevice()
                    Log.i("Sync", "Local backup synced")
                    val devices = creds.fetchDevices()
                    devices?.forEach { device ->
                        Log.i("Sync", "Device: ${device.name}, payload: ${device.payload}")
                    }
                }.onFailure {
                    Log.e("Sync", "Sync/Backup/Fetch failed: ${it.message}")
                }
            }
        }
    }




}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/AllMovieland.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.phisher98.UltimaMediaProvidersUtils.fixUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

class AllMovielandMediaProvider : MediaProvider() {
    override val name = "AllMovieland"
    override val domain = "https://allmovieland.fun"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val playerScript = app.get("https://allmovieland.link/player.js?v=60%20128").toString()
        val domainRegex = Regex("const AwsIndStreamDomain.*'(.*)';")
        val host = domainRegex.find(playerScript)?.groupValues?.getOrNull(1) ?: return

        val resData = app.get(
            "$host/play/${data.imdbId}",
            referer = "$url/"
        ).documentLarge.selectFirst("script:containsData(playlist)")?.data()
            ?.substringAfter("{")?.substringBefore(";")?.substringBefore(")") ?: return

        val json = tryParseJson<AllMovielandPlaylist>("{$resData}") ?: return
        val headers = mapOf(("X-CSRF-TOKEN" to "${json.key}"))

        val serverJson = app.get(
            fixUrl(json.file ?: return, host),
            headers = headers,
            referer = "$url/"
        ).text.replace(Regex(""",\\s*\\/"""), "")

        val serverRes =
                app.get(fixUrl(json.file, host), headers = headers, referer = url)
                        .text
                        .replace(Regex(""",\s*\[]"""), "")
        val servers =
                tryParseJson<ArrayList<AllMovielandServer>>(serverRes).let { server ->
                    if (data.season == null) {
                        server?.map { it.file to it.title }
                    } else {
                        server
                                ?.find { it.id.equals("${data.season}") }
                                ?.folder
                                ?.find { it.episode.equals("${data.episode}") }
                                ?.folder
                                ?.map { it.file to it.title }
                    }
                }

        servers?.amap { (server, lang) ->
            val path =
                app.post(
                    "${host}/playlist/${server ?: return@amap}.txt",
                    headers = headers,
                    referer = url
                )
                    .text
            M3u8Helper.generateM3u8("Allmovieland [$lang]", path, url).forEach(callback)
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    data class AllMovielandPlaylist(
            @JsonProperty("file") val file: String? = null,
            @JsonProperty("key") val key: String? = null,
            @JsonProperty("href") val href: String? = null,
    )

    data class AllMovielandServer(
            @JsonProperty("title") val title: String? = null,
            @JsonProperty("id") val id: String? = null,
            @JsonProperty("file") val file: String? = null,
            @JsonProperty("folder")
            val folder: ArrayList<AllMovielandSeasonFolder>? = arrayListOf(),
    ) {
        data class AllMovielandSeasonFolder(
                @JsonProperty("episode") val episode: String? = null,
                @JsonProperty("id") val id: String? = null,
                @JsonProperty("folder")
                val folder: ArrayList<AllMovielandEpisodeFolder>? = arrayListOf(),
        ) {
            data class AllMovielandEpisodeFolder(
                    @JsonProperty("title") val title: String? = null,
                    @JsonProperty("id") val id: String? = null,
                    @JsonProperty("file") val file: String? = null,
            )
        }
    }
    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/AnimeKai.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import kotlin.math.max

class AnimeKaiMediaProvider : MediaProvider() {
    override val name = "AnimeKai"
    override val domain = "https://animekai.bz"
    override val categories = listOf(Category.ANIME)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val jptitle = data.jpTitle
        val title = data.title
        if (jptitle.isNullOrBlank() || title.isNullOrBlank()) return

        try {
            // Perform the search requests sequentially but avoid redundant requests
            val searchEnglish = app.get("$domain/ajax/anime/search?keyword=$title").body.string()
            val searchRomaji = app.get("$domain/ajax/anime/search?keyword=$jptitle").body.string()

            val resultsEng = parseAnimeKaiResults(searchEnglish)
            val resultsRom = parseAnimeKaiResults(searchRomaji)

            val combined = (resultsEng + resultsRom).distinctBy { it.id }

            // Find the best match based on title similarity
            var bestMatch: AnimeKaiSearchResult? = null
            var highestScore = 0.0

            for (result in combined) {
                val engScore = similarity(title, result.title)
                val romScore = similarity(jptitle, result.japaneseTitle ?: "")
                val score = max(engScore, romScore)

                if (score > highestScore) {
                    highestScore = score
                    bestMatch = result
                }
            }

            bestMatch?.let { match ->
                val matchedId = match.id
                val href = "$domain/watch/$matchedId"

                // Fetch anime details and episode list
                val animeId = app.get(href).documentLarge.selectFirst("div.rate-box")?.attr("data-id")
                val decoded = app.get("${BuildConfig.KAISVA}/?f=e&d=$animeId")
                val epRes = app.get("$domain/ajax/episodes/list?ani_id=$animeId&_=$decoded")
                    .parsedSafe<AnimeKaiResponse>()?.getDocument()

                epRes?.select("div.eplist a")?.forEach { ep ->
                    val epNum = ep.attr("num").toIntOrNull()
                    if (epNum == data.episode) {
                        val token = ep.attr("token")

                        // Fetch episode links for this episode
                        val decodedtoken = app.get("${BuildConfig.KAISVA}/?f=e&d=$token")
                        val document =
                            app.get("$domain/ajax/links/list?token=$token&_=$decodedtoken")
                                .parsed<AnimeKaiResponse>()
                                .getDocument()

                        val types = listOf("sub", "softsub", "dub")
                        val servers = types.flatMap { type ->
                            document.select("div.server-items[data-id=$type] span.server[data-lid]")
                                .map { server ->
                                    val lid = server.attr("data-lid")
                                    val serverName = server.text()
                                    Triple(type, lid, serverName)
                                }
                        }

                        // Process each server sequentially
                        for ((type, lid, serverName) in servers) {
                            val decodelid = app.get("${BuildConfig.KAISVA}/?f=e&d=$lid")
                            val result = app.get("$domain/ajax/links/view?id=$lid&_=$decodelid")
                                .parsed<AnimeKaiResponse>().result
                            val decodeiframe = app.get("${BuildConfig.KAISVA}/?f=d&d=$result").text
                            val iframe = extractVideoUrlFromJsonAnimekai(decodeiframe)

                            val nameSuffix = when {
                                type.contains("soft", ignoreCase = true) -> " [Soft Sub]"
                                type.contains("sub", ignoreCase = true) -> " [Sub]"
                                type.contains("dub", ignoreCase = true) -> " [Dub]"
                                else -> ""
                            }

                            val name = "⌜ AnimeKai ⌟  |  $serverName  | $nameSuffix"
                            commonLinkLoader(
                                name,
                                ServerName.Megacc,
                                iframe,
                                null,
                                null,
                                subtitleCallback,
                                callback
                            )
                        }
                    }
                }
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}

fun extractVideoUrlFromJsonAnimekai(jsonData: String): String {
    val jsonObject = JSONObject(jsonData)
    return jsonObject.getString("url")
}

data class AnimeKaiM3U8(
    val sources: List<AnimekaiSource>,
    val tracks: List<AnimekaiTrack>,
    val download: String,
)
data class AnimekaiSource(
    val file: String,
)

data class AnimekaiTrack(
    val file: String,
    val label: String?,
    val kind: String,
    val default: Boolean?,
)

data class AnimeKaiResponse(
    @JsonProperty("status") val status: Boolean,
    @JsonProperty("result") val result: String
) {
    fun getDocument(): Document {
        return Jsoup.parse(result)
    }
}

data class VideoData(
    val url: String,
    val skip: Skip,
)

data class Skip(
    val intro: List<Long>,
    val outro: List<Long>,
)

fun similarity(a: String?, b: String?): Double {
    if (a.isNullOrBlank() || b.isNullOrBlank()) return 0.0
    val tokensA = a.lowercase().split(Regex("\\W+")).toSet()
    val tokensB = b.lowercase().split(Regex("\\W+")).toSet()
    if (tokensA.isEmpty() || tokensB.isEmpty()) return 0.0
    val intersection = tokensA.intersect(tokensB).size
    return intersection.toDouble() / max(tokensA.size, tokensB.size)
}

data class AnimeKaiSearchResult(
    val id: String,
    val title: String,
    val japaneseTitle: String? = null
)


private fun parseAnimeKaiResults(jsonResponse: String): List<AnimeKaiSearchResult> {
    val results = mutableListOf<AnimeKaiSearchResult>()
    val html =
        JSONObject(jsonResponse).optJSONObject("result")?.optString("html")
            ?: return results
    val doc = Jsoup.parse(html)

    for (element in doc.select("a.aitem")) {
        val href = element.attr("href").substringAfterLast("/")
        val titleElem = element.selectFirst("h6.title") ?: continue
        val title = titleElem.text().trim()
        val jpTitle = titleElem.attr("data-jp").trim().takeIf { it.isNotBlank() }

        results.add(AnimeKaiSearchResult(href, title, jpTitle))
    }

    return results
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/DahmerMovies.kt
================================================
package com.phisher98

import com.lagradost.api.Log
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.encodeUrl
import com.phisher98.UltimaMediaProvidersUtils.getEpisodeSlug
import com.phisher98.UltimaMediaProvidersUtils.getIndexQuality
import com.phisher98.UltimaMediaProvidersUtils.getIndexQualityTags
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink

class DahmerMoviesMediaProvider : MediaProvider() {
    override val name = "DahmerMovies"
    override val domain = "https://a.111477.xyz"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val year= app.get("https://cinemeta-live.strem.io/meta/movie/${data.imdbId}.json").parsedSafe<MetaData>()?.meta?.releaseInfo
        val mediaUrl =
                if (data.season == null) {
                    "$url/movies/${data.title?.replace(":", "")} (${year})/"
                } else {
                    "$url/tvs/${data.title?.replace(":", " -")}/Season ${data.season}/"
                }
        Log.d("Phisher",data.toJson())
        val request = app.get(mediaUrl, timeout = 60L)
        if (!request.isSuccessful) return
        val paths =
                request.documentLarge
                        .select("a")
                        .map { it.text() to it.attr("href") }
                        .filter {
                            if (data.season == null) {
                                it.first.contains(Regex("(?i)(1080p|2160p)"))
                            } else {
                                val (seasonSlug, episodeSlug) =
                                        getEpisodeSlug(data.season, data.episode)
                                it.first.contains(Regex("(?i)S${seasonSlug}E${episodeSlug}"))
                            }
                        }
                        .ifEmpty {
                            return
                        }

        paths.map {
            val quality = getIndexQuality(it.first)
            val tag = getIndexQualityTags(it.first)
            val href=if (it.second.contains(mediaUrl)) it.second else (mediaUrl + it.second)
            UltimaMediaProvidersUtils.commonLinkLoader(
                name,
                ServerName.Custom,
                href.encodeUrl(),
                null,
                null,
                subtitleCallback,
                callback,
                quality,
                tag = tag
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/Elevenmovies.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import java.util.Base64
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


class ElevenmoviesProvider : MediaProvider() {
    override val name = "Elevenmovies"
    override val domain = "https://111movies.com"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val Elevenmovies =domain
        val apiurl = if (data.season == null) {
            "$domain/movie/${data.tmdbId}"
        } else {
            "$domain/tv/${data.tmdbId}/${data.season}/${data.episode}"
        }

        val encodedToken = app.get(apiurl).documentLarge.selectFirst("script[type=application/json]")
            ?.data()
            ?.substringAfter("{\"data\":\"")
            ?.substringBefore("\",")
        if (encodedToken == null) return
        val jsonString = app.get("https://raw.githubusercontent.com/phisher98/TVVVV/main/output.json").text
        val gson = Gson()

        val json: Elevenmoviesjson? = try {
            gson.fromJson(jsonString, Elevenmoviesjson::class.java)
        } catch (e: JsonSyntaxException) {
            e.printStackTrace()
            null
        }
        requireNotNull(json) { "Failed to parse Elevenmovies JSON" }
        val token = elevenMoviesTokenV2(encodedToken)

        val staticPath = json.staticPath
        val apiServerUrl = "$Elevenmovies/$staticPath/$token/sr"
        val headers = mapOf(
            "Referer" to Elevenmovies,
            "User-Agent" to USER_AGENT,
            "Content-Type" to json.contentTypes,
            "X-Requested-With" to "XMLHttpRequest"
        )


        val responseString = try {
            if (json.httpMethod.contains("GET")) {
                val res = app.get(apiServerUrl, headers = headers).body.string()
                res
            } else {
                val postHeaders = headers.toMutableMap()
                postHeaders["X-Requested-With"] = "XMLHttpRequest"
                postHeaders["User-Agent"] = USER_AGENT
                val res = app.post(apiServerUrl, headers = postHeaders).body.string()
                res
            }
        } catch (e: Exception) {
            throw RuntimeException("Failed to fetch server list: ${e.message}")
        }

        val listType = object : TypeToken<List<ElevenmoviesServerEntry>>() {}.type
        val serverList: List<ElevenmoviesServerEntry> = Gson().fromJson(responseString, listType)

        for (entry in serverList) {
            val serverToken = entry.data
            val serverName = entry.name

            val streamApiUrl = "$Elevenmovies/$staticPath/$serverToken"
            val streamResponseString = if (json.httpMethod == "GET") {
                app.get(streamApiUrl, headers = headers).body.string()
            } else {
                val postHeaders = mapOf(
                    "Referer" to Elevenmovies,
                    "Content-Type" to "application/vnd.api+json",
                    "X-CSRF-Token" to json.csrfToken,
                    "X-Requested-With" to "XMLHttpRequest"
                )
                val mediaType = "application/vnd.api+json".toMediaType()
                val requestBody = "".toRequestBody(mediaType)
                app.post(
                    streamApiUrl,
                    headers = postHeaders,
                    requestBody = requestBody
                ).body.string()
            }
            val streamRes =
                Gson().fromJson(streamResponseString, ElevenmoviesStreamResponse::class.java)
                    ?: continue
            val videoUrl = streamRes.url ?: continue

            M3u8Helper.generateM3u8(
                "Eleven Movies $serverName",
                videoUrl,
                ""
            ).forEach(callback)

            streamRes.tracks?.forEach { sub ->
                subtitleCallback.invoke(
                    newSubtitleFile(
                        sub.label ?: return@forEach,
                        sub.file ?: return@forEach
                    )
                )
            }
        }
    }

    // #region - Encryption and Decryption handlers
    @RequiresApi(Build.VERSION_CODES.O)
    suspend fun elevenMoviesTokenV2(rawData: String): String {
        val jsonString = app.get("https://raw.githubusercontent.com/phisher98/TVVVV/main/output.json").text

        val json: Elevenmoviesjson? = try {
            Gson().fromJson(jsonString, Elevenmoviesjson::class.java)
        } catch (e: JsonSyntaxException) {
            e.printStackTrace()
            return ""
        }

        val keyHex = json?.keyHex ?: return ""
        val ivHex = json.ivHex

        val aesKey = keyHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        val aesIv = ivHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()

        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        val secretKey = SecretKeySpec(aesKey, "AES")
        val ivSpec = IvParameterSpec(aesIv)
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivSpec)

        val paddedInput = rawData.toByteArray(Charsets.UTF_8)
        val encrypted = cipher.doFinal(paddedInput)
        val hexString = encrypted.joinToString("") { "%02x".format(it) }

        // XOR key from hex string
        val xorKeyHex = json.xorKey
        val xorKey = xorKeyHex.chunked(2)
            .map { it.toInt(16).toByte() }
            .toByteArray()

        val xorResult = buildString {
            for (i in hexString.indices) {
                val c = hexString[i].code
                val k = xorKey[i % xorKey.size].toInt() and 0xFF
                append((c xor k).toChar())
            }
        }

        val src = json.src
        val dst = json.dst
        val translationMap = src.zip(dst).toMap()

        val base64Encoded = Base64.getEncoder()
            .encodeToString(xorResult.toByteArray(Charsets.UTF_8))
            .replace("+", "-")
            .replace("/", "_")
            .replace("=", "")

        val finalEncoded = base64Encoded.map { translationMap[it] ?: it }.joinToString("")

        return finalEncoded
    }
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes

    data class ElevenmoviesServerEntry(
        val name: String,
        val description: String,
        val image: String,
        val data: String,
    )

    data class ElevenmoviesStreamResponse(
        val url: String?,
        val tracks: List<ElevenmoviesSubtitle>?
    )

    data class ElevenmoviesSubtitle(
        val label: String?,
        val file: String?
    )

    data class Elevenmoviesjson(
        val src: String,
        val dst: String,

        @SerializedName("static_path")
        val staticPath: String,

        @SerializedName("http_method")
        val httpMethod: String,

        @SerializedName("key_hex")
        val keyHex: String,

        @SerializedName("iv_hex")
        val ivHex: String,

        @SerializedName("xor_key")
        val xorKey: String,

        @SerializedName("csrf_token")
        val csrfToken: String,

        @SerializedName("content_types")
        val contentTypes: String
    )
    // #endregion - Data classes

}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/HiAnime.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.Jsoup
import org.jsoup.nodes.Document

class HiAnimeMediaProvider : MediaProvider() {
    override val name = "HiAnime"
    override val domain = "https://hianimez.is"
    override val categories = listOf(Category.ANIME)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        data.year ?: return
        val filterUrl = "$url/search?keyword=${fixName(data.title)}&sy=${data.year}"
        val filterRes = app.get(filterUrl).documentLarge
        val result = filterRes.selectFirst("div.film-poster > a")?.attr("href") ?: return
        val seasonId = result.substringAfterLast("-")
        val epListResUrl = "$url/ajax/v2/episode/list/$seasonId"
        val epListRes = app.get(epListResUrl).parsed<ApiResponseHTML>()
        if (!epListRes.status) return
        val epId =
                epListRes
                        .html()
                        .selectFirst("div.ss-list > a[data-number=\"${data.episode}\"]")
                        ?.attr("data-id")
                        ?: return
        val serversListResUrl = "$url/ajax/v2/episode/servers?episodeId=$epId"
        val serversListRes = app.get(serversListResUrl).parsed<ApiResponseHTML>()
        if (!serversListRes.status) return
        val servers =
                serversListRes.html().select("div.server-item").map {
                    it.attr("data-type").replaceFirstChar(Char::titlecase) to it.attr("data-id")
                }
        servers.amap { server ->
            val serverResUrl = "$url/ajax/v2/episode/sources?id=${server.second}"
            val serverRes = app.get(serverResUrl).parsed<ServerData>()
            if (serverRes.type == "error") return@amap
            val serverName =
                    when (serverRes.server) {
                        1 -> ServerName.Megacloud
                        4 -> ServerName.Megacloud
                        else -> return@amap
                    }
            commonLinkLoader(
                name,
                serverName,
                serverRes.link,
                null,
                server.first,
                subtitleCallback,
                callback
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    data class ApiResponseHTML(
            @JsonProperty("status") val status: Boolean,
            @JsonProperty("html") val result: String
    ) {
        fun html(): Document {
            return Jsoup.parse(result)
        }
    }

    data class ServerData(
            @JsonProperty("type") val type: String,
            @JsonProperty("link") val link: String,
            @JsonProperty("server") val server: Int
    )
    // #endregion - Data classes

    private fun fixName(name: String?):String? {
        return when(name) {
            "DAN DA DAN" -> "Dandadan"
            else -> name
        }
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/MovieBox.kt
================================================
package com.phisher98

import androidx.core.net.toUri
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import java.security.MessageDigest
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

class MovieBoxMediaProvider : MediaProvider() {
    override val name = "MovieBox"
    override val domain = "https://api.inmoviebox.com"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val title=data.title
        try {
            if (title.isNullOrBlank()) return

            val url = "$domain/wefeed-mobile-bff/subject-api/search/v2"
            val jsonBody = """{"page":1,"perPage":10,"keyword":"$title"}"""
            val xClientToken = generateXClientToken()
            val xTrSignature = generateXTrSignature(
                "POST", "application/json", "application/json; charset=utf-8", url, jsonBody
            )
            val headers = mapOf(
                "user-agent" to "com.community.mbox.in/50020042 (Linux; Android 16)",
                "accept" to "application/json",
                "content-type" to "application/json",
                "x-client-token" to xClientToken,
                "x-tr-signature" to xTrSignature,
                "x-client-info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03"}""",
                "x-client-status" to "0"
            )

            val requestBody = jsonBody.toRequestBody("application/json".toMediaType())
            val response = app.post(url, headers = headers, requestBody = requestBody)
            if (response.code != 200) return

            val mapper = jacksonObjectMapper()
            val root = mapper.readTree(response.body.string())
            val results = root["data"]?.get("results") ?: return

            val matchingIds = mutableListOf<String>()
            for (result in results) {
                val subjects = result["subjects"] ?: continue
                for (subject in subjects) {
                    val name = subject["title"]?.asText() ?: continue
                    val id = subject["subjectId"]?.asText() ?: continue
                    val type = subject["subjectType"]?.asInt() ?: 0
                    if (name.contains(title, ignoreCase = true) && (type == 1 || type == 2)) {
                        matchingIds.add(id)
                    }
                }
            }
            if (matchingIds.isEmpty()) return

            for (id in matchingIds) {
                try {
                    val subjectUrl = "$domain/wefeed-mobile-bff/subject-api/get?subjectId=$id"
                    val subjectXToken = generateXClientToken()
                    val subjectXSign = generateXTrSignature("GET", "application/json", "application/json", subjectUrl)
                    val subjectHeaders = headers + mapOf(
                        "x-client-token" to subjectXToken,
                        "x-tr-signature" to subjectXSign
                    )
                    val subjectRes = app.get(subjectUrl, headers = subjectHeaders)
                    if (subjectRes.code != 200) continue

                    val subjectJson = mapper.readTree(subjectRes.body.string())
                    val subjectData = subjectJson["data"]
                    val subjectIds = mutableListOf<Pair<String, String>>()
                    var originalLanguageName = "Original"

                    // handle dubs
                    val dubs = subjectData?.get("dubs")
                    if (dubs != null && dubs.isArray) {
                        for (dub in dubs) {
                            val dubId = dub["subjectId"]?.asText()
                            val lanName = dub["lanName"]?.asText()
                            if (dubId != null && lanName != null) {
                                if (dubId == id) {
                                    originalLanguageName = lanName
                                } else {
                                    subjectIds.add(Pair(dubId, lanName))
                                }
                            }
                        }
                    }
                    subjectIds.add(0, Pair(id, originalLanguageName))

                    for ((subjectId, language) in subjectIds) {
                        val playUrl =
                            "$domain/wefeed-mobile-bff/subject-api/play-info?subjectId=$subjectId&se=${data.season ?: 0}&ep=${data.episode ?: 0}"
                        val token = generateXClientToken()
                        val sign = generateXTrSignature("GET", "application/json", "application/json", playUrl)
                        val playHeaders = headers + mapOf("x-client-token" to token, "x-tr-signature" to sign)

                        val playRes = app.get(playUrl, headers = playHeaders)
                        if (playRes.code != 200) continue

                        val playRoot = mapper.readTree(playRes.body.string())
                        val streams = playRoot["data"]?.get("streams") ?: continue
                        if (!streams.isArray) continue

                        for (stream in streams) {
                            val streamId = stream["id"]?.asText() ?: "$subjectId|${data.season}|${data.episode}"
                            val subjectTitle = subjectData?.get("title")?.asText() ?: "Unknown Title"
                            val format = stream["format"]?.asText() ?: ""
                            val signCookie = stream["signCookie"]?.asText()?.takeIf { it.isNotEmpty() }

                            val resolutionNodes = stream["resolutionList"] ?: stream["resolutions"]

                            if (resolutionNodes != null && resolutionNodes.isArray) {
                                for (resNode in resolutionNodes) {
                                    val resUrl = resNode["resourceLink"]?.asText() ?: continue
                                    val quality = resNode["resolution"]?.asInt() ?: 0

                                    callback.invoke(
                                        newExtractorLink(
                                            source = "MovieBox",
                                            name = "MovieBox (${language.capitalize()}) [$subjectTitle]",
                                            url = resUrl,
                                            type = when {
                                                resUrl.startsWith("magnet:", true) -> ExtractorLinkType.MAGNET
                                                resUrl.endsWith(".mpd", true) -> ExtractorLinkType.DASH
                                                resUrl.endsWith(".torrent", true) -> ExtractorLinkType.TORRENT
                                                format.equals("HLS", true) || resUrl.endsWith(".m3u8", true) -> ExtractorLinkType.M3U8
                                                else -> INFER_TYPE
                                            }
                                        ) {
                                            this.headers = mapOf("Referer" to domain) +
                                                    (if (signCookie != null) mapOf("Cookie" to signCookie) else emptyMap())
                                            this.quality = getQualityFromName("$quality")
                                        }
                                    )
                                }
                            } else {
                                // fallback single url
                                val singleUrl = stream["url"]?.asText() ?: continue
                                val resText = stream["resolutions"]?.asText() ?: ""

                                callback.invoke(
                                    newExtractorLink(
                                        source = "MovieBox",
                                        name = "MovieBox (${language.capitalize()}) [$subjectTitle]",
                                        url = singleUrl,
                                        type = when {
                                            singleUrl.startsWith("magnet:", true) -> ExtractorLinkType.MAGNET
                                            singleUrl.endsWith(".mpd", true) -> ExtractorLinkType.DASH
                                            singleUrl.endsWith(".torrent", true) -> ExtractorLinkType.TORRENT
                                            format.equals("HLS", true) || singleUrl.endsWith(".m3u8", true) -> ExtractorLinkType.M3U8
                                            else -> INFER_TYPE
                                        }
                                    ) {
                                        this.headers = mapOf("Referer" to domain) +
                                                (if (signCookie != null) mapOf("Cookie" to signCookie) else emptyMap())
                                        this.quality = getQualityFromName(resText)
                                    }
                                )
                            }

                            // subtitles
                            val subLinks = listOf(
                                "$domain/wefeed-mobile-bff/subject-api/get-stream-captions?subjectId=$subjectId&streamId=$streamId",
                                "$domain/wefeed-mobile-bff/subject-api/get-ext-captions?subjectId=$subjectId&resourceId=$streamId&episode=${data.episode ?: 0}"
                            )

                            for (subLink in subLinks) {
                                val subToken = generateXClientToken()
                                val subSign = generateXTrSignature("GET", "", "", subLink)

                                val subHeaders = mapOf(
                                    "User-Agent" to "com.community.mbox.in/50020042 (Linux; U; Android 16; en_IN; sdk_gphone64_x86_64; Build/BP22.250325.006; Cronet/133.0.6876.3)",
                                    "Accept" to "",
                                    "Content-Type" to "",
                                    "X-Client-Info" to """{"package_name":"com.community.mbox.in","version_name":"3.0.03.0529.03","version_code":50020042,"os":"android","os_version":"16","device_id":"da2b99c821e6ea023e4be55b54d5f7d8","install_store":"ps","gaid":"d7578036d13336cc","brand":"google","model":"sdk_gphone64_x86_64","system_language":"en","net":"NETWORK_WIFI","region":"IN","timezone":"Asia/Calcutta","sp_code":""}""",
                                    "X-Client-Status" to "0",
                                    "x-client-token" to subToken,
                                    "x-tr-signature" to subSign
                                )

                                val subRes = app.get(subLink, headers = subHeaders)
                                if (subRes.code != 200) continue

                                val subRoot = mapper.readTree(subRes.body.string())
                                val captions = subRoot["data"]?.get("extCaptions")
                                if (captions != null && captions.isArray) {
                                    for (caption in captions) {
                                        val captionUrl = caption["url"]?.asText() ?: continue
                                        val lang = caption["language"]?.asText()
                                            ?: caption["lanName"]?.asText()
                                            ?: caption["lan"]?.asText()
                                            ?: "Unknown"
                                        subtitleCallback.invoke(
                                            newSubtitleFile(
                                                url = captionUrl,
                                                lang = "$lang (${language.capitalize()})"
                                            )
                                        )
                                    }
                                }
                            }
                        }
                    }
                } catch (_: Exception) {
                    continue
                }
            }
            return
        } catch (_: Exception) {
            return
        }
    }
}


private fun md5(input: ByteArray): String {
    return MessageDigest.getInstance("MD5").digest(input)
        .joinToString("") { "%02x".format(it) }
}

private fun reverseString(input: String): String = input.reversed()

fun generateXClientToken(hardcodedTimestamp: Long? = null): String {
    val timestamp = (hardcodedTimestamp ?: System.currentTimeMillis()).toString()
    val reversed = reverseString(timestamp)
    val hash = md5(reversed.toByteArray())
    return "$timestamp,$hash"
}

fun generateXTrSignature(
    method: String,
    accept: String? = "application/json",
    contentType: String? = "application/json",
    url: String,
    body: String? = null,
    useAltKey: Boolean = false,
    hardcodedTimestamp: Long? = null
): String {
    val timestamp = hardcodedTimestamp ?: System.currentTimeMillis()

    val canonical = buildCanonicalString(
        method = method,
        accept = accept,
        contentType = contentType,
        url = url,
        body = body,
        timestamp = timestamp
    )
    val secretKey = if (useAltKey) {
        BuildConfig.MOVIEBOX_SECRET_KEY_ALT
    } else {
        BuildConfig.MOVIEBOX_SECRET_KEY_DEFAULT
    }
    val secretBytes = android.util.Base64.decode(secretKey, android.util.Base64.DEFAULT)
    val mac = Mac.getInstance("HmacMD5").apply {
        init(SecretKeySpec(secretBytes, "HmacMD5"))
    }
    val rawSignature = mac.doFinal(canonical.toByteArray(Charsets.UTF_8))
    val signatureBase64 = android.util.Base64.encodeToString(rawSignature, android.util.Base64.NO_WRAP)
    return "$timestamp|2|$signatureBase64"
}


private fun buildCanonicalString(
    method: String,
    accept: String?,
    contentType: String?,
    url: String,
    body: String?,
    timestamp: Long
): String {
    val parsed = url.toUri()
    val path = parsed.path ?: ""

    // Build query string with sorted parameters (if any)
    val query = if (parsed.queryParameterNames.isNotEmpty()) {
        parsed.queryParameterNames.sorted().joinToString("&") { key ->
            parsed.getQueryParameters(key).joinToString("&") { value ->
                "$key=$value"  // Don't URL encode here - Python doesn't do it
            }
        }
    } else ""

    val canonicalUrl = if (query.isNotEmpty()) "$path?$query" else path

    val bodyBytes = body?.toByteArray(Charsets.UTF_8)
    val bodyHash = if (bodyBytes != null) {
        val trimmed = if (bodyBytes.size > 102400) bodyBytes.copyOfRange(0, 102400) else bodyBytes
        md5(trimmed)
    } else ""

    val bodyLength = bodyBytes?.size?.toString() ?: ""
    return "${method.uppercase()}\n" +
            "${accept ?: ""}\n" +
            "${contentType ?: ""}\n" +
            "$bodyLength\n" +
            "$timestamp\n" +
            "$bodyHash\n" +
            canonicalUrl
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/MoviesDrive.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.api.Log
import com.phisher98.UltimaMediaProvidersUtils.ServerName.*
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader

class MoviesDriveProvider : MediaProvider() {
    override val name = "MoviesDrive"
    override val domain = "https://moviesdrive.channel"
    override val categories = listOf(Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val movieDriveAPI = getDomains()?.moviesdrive ?: return
        val cleanTitle = data.title.orEmpty()
        val season =data.season
        val episode=data.episode
        val year= data.year
        val searchUrl = buildString {
            append("$movieDriveAPI/?s=$cleanTitle")
            if (season != null && !cleanTitle.contains(season.toString(), ignoreCase = true)) {
                append(" $season")
            } else if (season == null && year != null) {
                append(" $year")
            }
        }

        val figures = retry {
            val allFigures =
                app.get(searchUrl, interceptor = CloudflareKiller()).documentLarge.select("figure")
            if (season == null) {
                allFigures
            } else {
                val seasonPattern = Regex("""season\s*${season}\b""", RegexOption.IGNORE_CASE)
                allFigures.filter { figure ->
                    val img = figure.selectFirst("img")
                    val alt = img?.attr("alt").orEmpty()
                    val titleAttr = img?.attr("title").orEmpty()
                    seasonPattern.containsMatchIn(alt) || seasonPattern.containsMatchIn(titleAttr)
                }
            }
        } ?: return

        for (figure in figures) {
            val detailUrl = figure.selectFirst("a[href]")?.attr("href").orEmpty()
            if (detailUrl.isBlank()) continue

            val detailDoc = retry {
                app.get(detailUrl, interceptor = CloudflareKiller()).documentLarge
            } ?: continue

            val imdbId = detailDoc
                .select("a[href*=\"imdb.com/title/\"]")
                .firstOrNull()
                ?.attr("href")
                ?.substringAfter("title/")
                ?.substringBefore("/")
                ?.takeIf { it.isNotBlank() } ?: continue

            val titleMatch = imdbId == data.imdbId.orEmpty() || detailDoc
                .select("main > p:nth-child(10)")
                .firstOrNull()
                ?.text()
                ?.contains(cleanTitle, ignoreCase = true) == true

            if (!titleMatch) continue

            if (season == null) {
                val links = detailDoc.select("h5 a")
                for (element in links) {
                    val urls = retry { extractMdrive(element.attr("href")) } ?: continue
                    for (serverUrl in urls) {
                        processMoviesdriveUrl(serverUrl, subtitleCallback, callback)
                    }
                }
            } else {
                val seasonPattern = "(?i)Season\\s*0?$season\\b|S0?$season\\b"
                val episodePattern =
                    "(?i)Ep\\s?0?$episode\\b|Episode\\s+0?$episode\\b|V-Cloud|G-Direct|OXXFile"

                val seasonElements = detailDoc.select("h5:matches($seasonPattern)")
                if (seasonElements.isEmpty()) continue

                val allLinks = mutableListOf<String>()

                for (seasonElement in seasonElements) {
                    val seasonHref = seasonElement.nextElementSibling()
                        ?.selectFirst("a")
                        ?.attr("href")
                        ?.takeIf { it.isNotBlank() } ?: continue

                    val episodeDoc = retry { app.get(seasonHref).documentLarge } ?: continue
                    val episodeHeaders = episodeDoc.select("h5:matches($episodePattern)")

                    for (header in episodeHeaders) {

                        val siblingLinks =
                            generateSequence(header.nextElementSibling()) { it.nextElementSibling() }
                                .takeWhile { it.tagName() != "hr" }
                                .filter { it.tagName() == "h5" }
                                .mapNotNull { h5 ->
                                    h5.selectFirst("a")?.takeIf { a ->
                                        !a.text()
                                            .contains("Zip", ignoreCase = true) && a.hasAttr("href")
                                    }?.attr("href")
                                }.toList()

                        allLinks.addAll(siblingLinks)
                    }
                }
                if (allLinks.isNotEmpty()) {
                    for (serverUrl in allLinks) {
                        processMoviesdriveUrl(serverUrl, subtitleCallback, callback)
                    }
                } else {
                    detailDoc.select("h5 a:contains(HubCloud)")
                        .mapNotNull { it.attr("href").takeIf { href -> href.isNotBlank() } }
                        .forEach { fallbackUrl ->
                            processMoviesdriveUrl(fallbackUrl, subtitleCallback, callback)
                        }
                }
            }
        }
    }


    @RequiresApi(Build.VERSION_CODES.O)
    private suspend fun processMoviesdriveUrl(
        serverUrl: String,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        when {
            serverUrl.contains("hubcloud", ignoreCase = true) -> {
                commonLinkLoader(
                    name,
                    Hubcloud,
                    serverUrl,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }

            serverUrl.contains("gdlink", ignoreCase = true) -> {
                commonLinkLoader(
                    name,
                    GDFlix,
                    serverUrl,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }
            else -> {
                loadExtractor(serverUrl, referer = "MoviesDrive", subtitleCallback, callback)
            }
        }
    }
    // Extractor



    private suspend fun extractMdrive(url: String): List<String> {
        val regex = Regex("hubcloud|gdflix|gdlink", RegexOption.IGNORE_CASE)

        return try {
            app.get(url).documentLarge
                .select("a[href]")
                .mapNotNull { element ->
                    val href = element.attr("href")
                    if (regex.containsMatchIn(href)) {
                        href
                    } else {
                        null
                    }
                }
        } catch (e: Exception) {
            Log.e("Error Mdrive", "Error extracting links: ${e.localizedMessage}")
            emptyList()
        }
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/MultiEmbededAPI.kt
================================================
package com.phisher98

import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.mozilla.javascript.Scriptable

class MultiEmbededAPIProvider : MediaProvider() {
    override val name = "MultiEmbeded API"
    override val domain = "https://multiembed.mov"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val mediaUrl =
                if (data.season == null) {
                    "$url/directstream.php?video_id=${data.imdbId}"
                } else {
                    "$url/directstream.php?video_id=${data.imdbId}&s=${data.season}&e=${data.episode}"
                }
        val res = app.get(mediaUrl, referer = mediaUrl).documentLarge
        val script =
                res.selectFirst("script:containsData(function(h,u,n,t,e,r))")?.data().toString()
        if (script.isNotEmpty()) {
            val firstJS =
                    """
        var globalArgument = null;
        function Playerjs(arg) {
        globalArgument = arg;
        };
        """.trimIndent()
            val rhino = org.mozilla.javascript.Context.enter()
            rhino.setInterpretedMode(true)
            val scope: Scriptable = rhino.initSafeStandardObjects()
            rhino.evaluateString(scope, firstJS + script, "JavaScript", 1, null)
            val file =
                    (scope.get("globalArgument", scope).toJson())
                            .substringAfter("file\":\"")
                            .substringBefore("\",")
            callback.invoke(
                newExtractorLink(
                    "MultiEmbeded API",
                    "MultiEmbeded API",
                    file,
                    INFER_TYPE
                )
                {
                    this.quality = Qualities.Unknown.value
                }
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes

    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/MultiMovies.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaMediaProvidersUtils.createSlug
import com.phisher98.UltimaMediaProvidersUtils.getBaseUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class MultiMoviesProvider : MediaProvider() {
    override val name = "MultiMovies"
    override val domain = "https://multimovies.coupons"
    override val categories = listOf(Category.MEDIA)
    private val xmlHeader = mapOf("X-Requested-With" to "XMLHttpRequest")

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val multimoviesAPI = getDomains()?.multiMovies ?: return

        val fixTitle = data.title.createSlug()
        val mediaurl =
                if (data.season == null) {
                    "$multimoviesAPI/movies/$fixTitle"
                } else {
                    "$multimoviesAPI/episodes/$fixTitle-${data.season}x${data.episode}"
                }
        val req = app.get(mediaurl).documentLarge
        req.select("ul#playeroptionsul li").amap {
            val id = it.attr("data-post")
            val nume = it.attr("data-nume")
            val type = it.attr("data-type")
            if (nume.contains("trailer")) return@amap
            val apiUrl = "$url/wp-admin/admin-ajax.php"
            val postData =
                mapOf(
                    "action" to "doo_player_ajax",
                    "post" to id,
                    "nume" to nume,
                    "type" to type
                )
            val source =
                app.post(url = apiUrl, data = postData, referer = url, headers = xmlHeader)
                    .parsed<ResponseHash>()
                    .embed_url
            val link = source.substringAfter("\"").substringBefore("\"")
            val domain = getBaseUrl(link)
            val serverName =
                when (domain) {
                    "https://aa.clonimeziud" -> ServerName.Vidhide
                    "https://server2.shop" -> ServerName.Vidhide
                    "https://multimovies.cloud" -> ServerName.StreamWish
                    "https://allinonedownloader.fun" -> ServerName.StreamWish
                    else -> ServerName.NONE
                }
            commonLinkLoader(name, serverName, link, null, null, subtitleCallback, callback)
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes

    data class ResponseHash(
            @JsonProperty("embed_url") val embed_url: String,
            @JsonProperty("key") val key: String? = null,
            @JsonProperty("type") val type: String? = null,
    )
    // #endregion - Data classes
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/Noverse.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.createSlug
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import kotlinx.coroutines.delay

class NoverseMediaProvider : MediaProvider() {
    override val name = "Noverse"
    override val domain = "https://www.thenollyverse.com"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val fixTitle = data.title.createSlug()
        val mediaUrl =
                if (data.season == null) {
                    "$url/movie/$fixTitle/download/"
                } else {
                    "$url/serie/$fixTitle/season-${data.season}"
                }

        val doc = app.get(mediaUrl).documentLarge
        val links =
                if (data.season == null) {
                    doc.select("div.section-row table.table-striped tbody tr").map {
                        it.select("a").attr("href") to it.selectFirst("td")?.text()
                    }
                } else {
                    doc.select("div.section-row table.table-striped tbody tr")
                            .find { it.text().contains("Episode ${data.episode}") }
                            ?.select("td")
                            ?.map { it.select("a").attr("href") to it.select("a").text() }
                }
                        ?: return

        delay(4000)
        links.map { (link, quality) ->
            // if (quality.equals("Subtitles")) return@mapNotNull
            val tag = quality?.split(".")?.getOrNull(1)
            UltimaMediaProvidersUtils.commonLinkLoader(
                name,
                ServerName.Custom,
                link,
                null,
                null,
                subtitleCallback,
                callback,
                getQualityFromName("${quality?.substringBefore("p")?.trim()}p"),
                tag = tag,
            )
        }
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/NowTv.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.getEpisodeSlug
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class NowTvMediaProvider : MediaProvider() {
    override val name = "NowTv"
    override val domain = "https://myfilestorage.xyz"
    override val categories = listOf(Category.MEDIA)
    private val referer = "https://w1.nites.is/"

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        suspend fun String.isSuccess(): Boolean {
            return app.get(this, referer = referer).isSuccessful
        }

        val slug = getEpisodeSlug(data.season, data.episode)
        var mediaUrl =
                if (data.season == null) "$url/${data.tmdbId}.mp4"
                else "$url/tv/${data.tmdbId}/s${data.season}e${slug.second}.mp4"
        if (!mediaUrl.isSuccess()) {
            mediaUrl =
                    if (data.season == null) {
                        val temp = "$url/${data.imdbId}.mp4"
                        if (temp.isSuccess()) temp else "$url/${data.tmdbId}-1.mp4"
                    } else {
                        "$url/tv/${data.imdbId}/s${data.season}e${slug.second}.mp4"
                    }
            if (!app.get(mediaUrl, referer = referer).isSuccessful) return
        }
        UltimaMediaProvidersUtils.commonLinkLoader(
            name,
            ServerName.Custom,
            mediaUrl,
            url,
            null,
            subtitleCallback,
            callback
        )
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/PrimeWireProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64DecodeArray
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import javax.crypto.Cipher
import javax.crypto.spec.SecretKeySpec

class PrimeWireProvider : MediaProvider() {
    override val name = "PrimeWireProvider"
    override val domain = "https://www.primewire.tf"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val apiurl = if (data.season == null) {
            "$domain/embed/movie?imdb=${data.imdbId}"
        } else {
            "$domain/embed/tv?imdb=${data.imdbId}&season=${data.season}&episode=${data.episode}"
        }

        val doc = app.get(apiurl, timeout = 10).documentLarge
        val userData = doc.select("#user-data")
        val decryptedLinks = decryptLinks(userData.attr("v"))
        for (link in decryptedLinks) {
            val href = "$domain/links/gos/$link"
            val token= app.get("https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Primetoken.txt").text
            val oUrl = app.get(href, timeout = 10)
            val iframeurl= app.get("${oUrl.url.replace("/gos/","/go/")}?token=$token").parsedSafe<Root>()?.link
            if (iframeurl != null) {
                loadSourceNameExtractor(
                    "Primewire ",
                    iframeurl,
                    "",
                    subtitleCallback,
                    callback,
                    quality = getQualityFromName("")
                )
            }
        }
    }

    private fun decryptLinks(data: String): List<String> {
        val key = data.substring(data.length - 10)
        val ct = data.substring(0, data.length - 10)
        val pt = decryptBase64BlowfishEbc(ct, key)
        return pt.chunked(5)
    }

    private fun decryptBase64BlowfishEbc(base64Encrypted: String, key: String): String {
        try {
            val encryptedBytes = base64DecodeArray(base64Encrypted)
            val secretKeySpec = SecretKeySpec(key.toByteArray(), "Blowfish")
            val cipher = Cipher.getInstance("Blowfish/ECB/NoPadding")
            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec)
            val decryptedBytes = cipher.doFinal(encryptedBytes)
            return String(decryptedBytes)
        } catch (e: Exception) {
            e.printStackTrace()
            return "Decryption failed: ${e.message}"
        }
    }

    private suspend fun loadSourceNameExtractor(
        source: String,
        url: String,
        referer: String? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
        quality: Int? = null,
    ) {
        loadExtractor(url, referer, subtitleCallback) { link ->
            CoroutineScope(Dispatchers.IO).launch {
                callback.invoke(
                    newExtractorLink(
                        "$source[${link.source}]",
                        "$source[${link.source}]",
                        link.url,
                    ) {
                        this.quality = link.quality
                        this.type = link.type
                        this.referer = link.referer
                        this.headers = link.headers
                        this.extractorData = link.extractorData
                    }
                )
            }
        }
    }
    
    data class Root(
        val link: String,
        @JsonProperty("host_id")
        val hostId: Long,
        val host: String,
    )
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/TwoEmbed.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.getBaseUrl
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink

class TwoEmbedMediaProvider : MediaProvider() {
    override val name = "2Embed"
    override val domain = "https://www.2embed.cc"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
            url: String,
            data: LinkData,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ) {
        val mediaUrl =
                if (data.season == null) {
                    "$url/embed/${data.imdbId}"
                } else {
                    "$url/embedtv/${data.imdbId}&s=${data.season}&e=${data.episode}"
                }
        val framesrc =
                app.get(mediaUrl).documentLarge.selectFirst("iframe#iframesrc")?.attr("data-src")
                        ?: return
        val referer = getBaseUrl(framesrc) + "/"
        val id = framesrc.substringAfter("id=").substringBefore("&")
        val finalUrl = "https://uqloads.xyz/e/$id"
        UltimaMediaProvidersUtils.commonLinkLoader(
            name,
            ServerName.Uqload,
            finalUrl,
            referer,
            null,
            subtitleCallback,
            callback
        )
    }

    // #region - Encryption and Decryption handlers
    // #endregion - Encryption and Decryption handlers

    // #region - Data classes
    // #endregion - Data classes

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/VegaMovies.kt
================================================
package com.phisher98.MediaProviders

import android.os.Build
import androidx.annotation.RequiresApi
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.network.CloudflareKiller
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.MediaProvider
import com.phisher98.UltimaMediaProvidersUtils.ServerName.Vcloud
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.phisher98.getDomains
import kotlinx.coroutines.delay


class VegaMoviesProvider : MediaProvider() {
    override val name = "VegaMovies"
    override val domain = "https://vegamovies.moi"
    override val categories = listOf(Category.MEDIA)

    @RequiresApi(Build.VERSION_CODES.O)
    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
            "cookie" to "xla=s4t",
            "Accept-Language" to "en-US,en;q=0.9",
            "sec-ch-ua" to "\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Microsoft Edge\";v=\"120\"",
            "sec-ch-ua-mobile" to "?0",
            "sec-ch-ua-platform" to "\"Linux\"",
            "Sec-Fetch-Dest" to "document",
            "Sec-Fetch-Mode" to "navigate",
            "Sec-Fetch-Site" to "none",
            "Sec-Fetch-User" to "?1",
            "Upgrade-Insecure-Requests" to "1",
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/137.0.0.0 Safari/537.36"
        )

        val vegaMoviesAPI = getDomains()?.vegamovies ?: return
        val title=data.title
        val season=data.season
        val year=data.year
        val imdbId=data.imdbId
        val cfInterceptor = CloudflareKiller()
        val fixtitle =
            title?.substringBefore("-")?.substringBefore(":")?.replace("&", " ")?.trim().orEmpty()
        val query = if (season == null) "$fixtitle $year" else "$fixtitle season $season $year"
        val primaryUrl = "$vegaMoviesAPI/?s=$query"
        val secondaryUrl = "$vegaMoviesAPI/?search=$query"
        val excludedButtonTexts = setOf("Filepress", "GDToT", "DropGalaxy")

        val searchDoc = retry { app.get(primaryUrl, interceptor = cfInterceptor, headers = headers).documentLarge }
            ?: retry { app.get(secondaryUrl, interceptor = cfInterceptor, headers = headers).documentLarge }
            ?: return
        val articles = searchDoc.select("article h2")
        if (articles.isEmpty()) return

        var foundLinks = false

        for (article in articles) {
            val hrefpattern = article.selectFirst("a")?.attr("href").orEmpty()
            if (hrefpattern.isBlank()) continue

            val doc = retry { app.get(hrefpattern).documentLarge } ?: continue

            val imdbAnchor =
                doc.selectFirst("div.entry-inner p strong a[href*=\"imdb.com/title/tt\"]")
            val imdbHref = imdbAnchor?.attr("href")?.lowercase()

            if (imdbId != null && (imdbHref == null || !imdbHref.contains(imdbId.lowercase()))) {
                Log.i("Skip", "IMDb ID mismatch: $imdbHref != $imdbId")
                continue
            }

            if (season == null) {
                // Movie Mode
                val btnLinks = doc.select("button.dwd-button")
                    .filterNot { btn ->
                        excludedButtonTexts.any {
                            btn.text().contains(it, ignoreCase = true)
                        }
                    }
                    .mapNotNull {
                        it.closest("a")?.attr("href")?.takeIf { link -> link.isNotBlank() }
                    }

                if (btnLinks.isEmpty()) continue

                for (detailUrl in btnLinks) {
                    val detailDoc = retry { app.get(detailUrl).documentLarge } ?: continue

                    val streamingLinks = detailDoc.select("button.btn.btn-sm.btn-outline")
                        .filterNot { btn ->
                            excludedButtonTexts.any {
                                btn.text().contains(it, ignoreCase = true)
                            }
                        }
                        .mapNotNull {
                            it.closest("a")?.attr("href")?.takeIf { link -> link.isNotBlank() }
                        }

                    if (streamingLinks.isEmpty()) continue

                    for (streamingUrl in streamingLinks) {
                        commonLinkLoader(
                            name,
                            Vcloud,
                            streamingUrl,
                            null,
                            null,
                            subtitleCallback,
                            callback
                        )
                        foundLinks = true
                    }
                }

            } else {
                // TV Show Mode
                val seasonPattern = "(?i)(Season $season)"
                val episodePattern = "(?i)(V-Cloud|Single|Episode|G-Direct)"

                val seasonElements =
                    doc.select("h4:matches($seasonPattern), h3:matches($seasonPattern)")

                if (seasonElements.isEmpty()) continue

                for (seasonElement in seasonElements) {
                    val episodeLinks = seasonElement.nextElementSibling()
                        ?.select("a:matches($episodePattern)")
                        ?.mapNotNull { it.attr("href").takeIf { link -> link.isNotBlank() } }
                        ?: continue

                    if (episodeLinks.isEmpty()) continue

                    for (episodeUrl in episodeLinks) {
                        val episodeDoc = retry { app.get(episodeUrl).documentLarge } ?: continue

                        val matchBlock =
                            episodeDoc.selectFirst("h4:contains(Episodes):contains(${data.episode})")
                                ?.nextElementSibling()
                                ?.select("a:matches((?i)(V-Cloud|G-Direct|OxxFile))")
                                ?.mapNotNull {
                                    it.attr("href").takeIf { link -> link.isNotBlank() }
                                }

                        if (matchBlock.isNullOrEmpty()) continue

                        for (streamingUrl in matchBlock) {
                            commonLinkLoader(
                                name,
                                Vcloud,
                                streamingUrl,
                                null,
                                null,
                                subtitleCallback,
                                callback
                            )
                            foundLinks = true
                        }
                    }
                }
            }
        }

        if (!foundLinks) {
            Log.d("VegaMovies", "No valid streaming links found for: $title")
            return
        }
    }
}

private suspend fun <T> retry(
    times: Int = 3,
    delayMillis: Long = 1000,
    block: suspend () -> T
): T? {
    repeat(times - 1) {
        runCatching { return block() }.onFailure { delay(delayMillis) }
    }
    return runCatching { block() }.getOrNull()
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/Vidflast.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.google.gson.reflect.TypeToken
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class VidFlastProvider : MediaProvider() {
    override val name = "VidFast"
    override val domain = "https://www.vidfast.pro"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val apiurl = if (data.season == null) {
            "$domain/movie/${data.imdbId}"
        } else {
            "$domain/tv/${data.imdbId}/${data.season}/${data.episode}"
        }

        val regexData = app.get(apiurl).text
        val regex = Regex("""\\"en\\":\\"(.*?)\\""")

        val rawData = regex.find(regexData)?.groupValues?.getOrNull(1)
            ?: return println("❌ No match found.")

        val keyHex = "13346e2c05211f72e46a465e953fd5410826715e28d927f92ea5f4daee985c8b"
        val ivHex = "b83bcd42b90f5364e9b95c398264bca4"
        val aesKey = keyHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        val aesIv = ivHex.chunked(2).map { it.toInt(16).toByte() }.toByteArray()

        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        val keySpec = SecretKeySpec(aesKey, "AES")
        val ivSpec = IvParameterSpec(aesIv)
        cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec)

        val blockSize = 16
        val padLength = blockSize - rawData.toByteArray().size % blockSize
        val paddedData = rawData.toByteArray() + ByteArray(padLength) { padLength.toByte() }
        val encrypted = cipher.doFinal(paddedData)

        val xorKey = "3fc3e051ddc9dd8a74".chunked(2).map { it.toInt(16).toByte() }.toByteArray()
        val xorResult = ByteArray(encrypted.size) { i ->
            (encrypted[i].toInt() xor xorKey[i % xorKey.size].toInt()).toByte()
        }
        val headers = mapOf(
            "Accept" to "*/*",
            "Referer" to domain,
            "x-session" to "",
            "X-Requested-With" to "XMLHttpRequest",
            "X-Csrf-Token" to "lVx7BVtk9c3SMNbF49PNvUc7GV5zzdem"
        )

        val encodedFinal = customBase64EncodeVidfast(xorResult)
        val staticPath = "rebivol/ad/w/2c7998b18129848378021254f87db35df8f562b2/2cf30a7c/APA91nNHHa3xbnvasl8ciswLATkt2fIiVFciF5RLarK4oR7nrTpEDSBjO_kRoBJD730BWfo6bQZIpxCr-PAlSGc8GAAxueegNH5gNzrcqhPDliciuUDv0GTqb_2t1ik9pIAXpVaZ8inm6ey56Qf44wrOOPUfZYlkKuKs18mNKqBluBYTB5lBXWF/775d49bf3b9b4d082f5156cd9f36e21d42014547cd9282b1fe62ccbe3d09f66b/1000094661747536"
        val apiServersUrl = "https://vidfast.pro/$staticPath/k33a7dwPZst1/$encodedFinal"
        val gson = Gson()
        val jsonMedia = "{}".toRequestBody("application/json".toMediaTypeOrNull())
        val responseBody = app.post(apiServersUrl, headers = headers, requestBody = jsonMedia).body.string()
        val type = object : TypeToken<List<VidfastServerData>>() {}.type
        val apiResponse: List<VidfastServerData>? = gson.fromJson(responseBody, type)

        if (apiResponse != null) {
            for (item in apiResponse) {
                val serverName = item.name
                val serverData = item.data ?: continue
                val apiStream = "https://vidfast.pro/$staticPath/p6PWA5s/$serverData"

                try {
                    val streamResponse = app.post(apiStream, headers = headers, requestBody = jsonMedia)
                    val streamBody = streamResponse.body.string()
                    val resultJson = JSONObject(streamBody)

                    val streamUrl = if (resultJson.has("url")) resultJson.getString("url") else null
                    val m3u8headers = mapOf(
                        "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0",
                        "Referer" to "https://vidfast.pro/",
                        "Origin" to "https://vidfast.pro",
                    )

                    if (streamUrl != null) {
                        if (streamUrl.contains(".m3u8")) {
                            M3u8Helper.generateM3u8("Vidfast [$serverName]", streamUrl, domain, headers = m3u8headers)
                                .forEach(callback)
                        } else {
                            callback.invoke(
                                newExtractorLink(
                                    "Vidfast",
                                    "Vidfast D [$serverName]",
                                    streamUrl,
                                    INFER_TYPE
                                ) {
                                    referer = domain
                                    quality = Qualities.Unknown.value
                                    this.headers = m3u8headers
                                }
                            )
                        }
                    }
                } catch (e: Exception) {
                    Log.e("Vidfast Error:", "❌ [$serverName] Failed for $apiStream: ${e.message}")
                }
            }
        }
    }


    private fun customBase64EncodeVidfast(input: ByteArray): String {
        val sourceChars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_"
        val targetChars = "Ju9Egn27FZNe-kaMUtOBAmf0qp3xDYlTX6PhiL5SRjzQIsHvoVw_WC4dGc1Ky8rb"

        // Standard Base64 URL-safe encode, no padding or wrap
        val base64 = android.util.Base64.encodeToString(
            input,
            android.util.Base64.URL_SAFE or android.util.Base64.NO_PADDING or android.util.Base64.NO_WRAP
        )

        // Translate characters to custom charset
        val translationMap = sourceChars.zip(targetChars).toMap()
        return base64.map { translationMap[it] ?: it }.joinToString("")
    }


    // #region - Data classes

    data class VidfastServerData(
        val name: String,
        val description: String,
        val image: String,
        val data: String?
    )

    // #endregion - Data classes

}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/Vidsrccc.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import java.security.MessageDigest
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec


class VidsrcccProvider : MediaProvider() {
    override val name = "VidSrc CC"
    override val domain = "https://vidsrc.cc"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val url = if (data.season == null) {
            "$domain/v2/embed/movie/${data.tmdbId}?autoPlay=false"
        } else {
            "$domain/v2/embed/tv/${data.tmdbId}/${data.season}/${data.episode}?autoPlay=false"
        }
        val doc = app.get(url).documentLarge.toString()
        val regex = Regex("""var\s+(\w+)\s*=\s*(?:"([^"]*)"|(\w+));""")
        val variables = mutableMapOf<String, String>()

        regex.findAll(doc).forEach { match ->
            val key = match.groupValues[1]
            val value = match.groupValues[2].ifEmpty { match.groupValues[3] }
            variables[key] = value
        }
        val vvalue = variables["v"] ?: ""
        val userId = variables["userId"] ?: ""
        val imdbId = variables["imdbId"] ?: ""
        val movieId = variables["movieId"] ?: ""
        val movieType = variables["movieType"] ?: ""

        val vrf = generateVidsrcVrf(movieId,userId)
        val apiurl = if (data.season == null) {
            "${domain}/api/${data.tmdbId}/servers?id=${data.tmdbId}&type=$movieType&v=$vvalue=&vrf=$vrf&imdbId=$imdbId"
        } else {
            "${domain}/api/${data.tmdbId}/servers?id=${data.tmdbId}&type=$movieType&season=${data.season}&episode=${data.episode}&v=$vvalue&vrf=${vrf}&imdbId=$imdbId"
        }
        app.get(apiurl).parsedSafe<Vidsrcccservers>()?.data?.forEach {
            val servername = it.name
            val iframe = app.get("$domain/api/source/${it.hash}")
                .parsedSafe<Vidsrcccm3u8>()?.data?.source
            val sourceUrl = iframe?.let { iframeUrl ->
                val response = app.get(iframeUrl, referer = domain).text
                val urlregex = Regex("""var\s+source\s*=\s*"([^"]+)"""")
                val match = urlregex.find(response)
                match?.groups?.get(1)?.value?.replace("""\\/""".toRegex(), "/")
            }

            sourceUrl?.let { url->
                commonLinkLoader(
                    "⌜ Vidsrc ⌟ | [$servername]",
                    ServerName.Videostr,
                    url,
                    null,
                    null,
                    subtitleCallback,
                    callback
                )
            }
        }
    }

    private fun generateVidsrcVrf(movieId: String, userId: String): String {
        val keyBytes = MessageDigest.getInstance("SHA-256").digest(userId.toByteArray())
        val key = SecretKeySpec(keyBytes, "AES")
        val iv = IvParameterSpec(ByteArray(16))
        val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
        cipher.init(Cipher.ENCRYPT_MODE, key, iv)
        val plaintext = movieId.toByteArray()
        val ciphertext = cipher.doFinal(plaintext)
        val encoded = base64Encode(ciphertext)
        val urlSafe = encoded.replace('+', '-').replace('/', '_').replace("=", "")
        return urlSafe
    }

    data class Vidsrcccservers(
        val data: List<VidsrcccDaum>,
        val success: Boolean,
    )

    data class VidsrcccDaum(
        val name: String,
        val hash: String,
    )

    data class Vidsrcccm3u8(
        val data: VidsrcccData,
        val success: Boolean,
    )

    data class VidsrcccData(
        val type: String,
        val source: String,
    )
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/Watch32.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.phisher98.UltimaMediaProvidersUtils.commonLinkLoader
import com.phisher98.UltimaMediaProvidersUtils.ServerName
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData

class Watch32Provider : MediaProvider() {
    override val name = "Watch32"
    override val domain = "https://watch32.sx"
    override val categories = listOf(Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        if (data.title.isNullOrBlank()) return

        val type = if (data.season == null) "Movie" else "TV"
        val searchUrl = "$domain/search/${data.title.trim().replace(" ", "-")}"

        val matchedElement = runCatching {
            val doc = app.get(searchUrl, timeout = 120L).documentLarge
            val results = doc.select("div.flw-item")

            results.firstOrNull { item ->
                val titleElement = item.selectFirst("h2.film-name a")
                val typeElement = item.selectFirst("span.fdi-type")
                val name = titleElement?.text()?.trim() ?: return@firstOrNull false
                val mediaType = typeElement?.text()?.trim() ?: return@firstOrNull false

                name.contains(data.title, ignoreCase = true) && mediaType.equals(type, ignoreCase = true)
            }?.selectFirst("h2.film-name a")
        }.getOrNull() ?: return
        val detailUrl = domain+matchedElement.attr("href")
        val typee=if (type=="Movie") TvType.Movie else TvType.TvSeries
        val infoId=detailUrl.substringAfterLast("-")

        if (typee == TvType.TvSeries) {
            val seasonLinks = runCatching {
                app.get("$domain/ajax/season/list/$infoId").documentLarge.select("div.dropdown-menu a")
            }.getOrNull() ?: return

            val matchedSeason = seasonLinks.firstOrNull {
                it.text().contains("Season ${data.season}", ignoreCase = true)
            } ?: return

            val seasonId = matchedSeason.attr("data-id")

            val episodeLinks = runCatching {
                app.get("$domain/ajax/season/episodes/$seasonId").documentLarge.select("li.nav-item a")
            }.getOrNull() ?: return

            val matchedEpisode = episodeLinks.firstOrNull {
                it.text().contains("Eps ${data.episode}:", ignoreCase = true)
            } ?: return

            val dataId = matchedEpisode.attr("data-id")

            val serverDoc = runCatching {
                app.get("$domain/ajax/episode/servers/$dataId").documentLarge
            }.getOrNull() ?: return

            val sourceButtons = serverDoc.select("li.nav-item a")
            for (source in sourceButtons) {
                val sourceId = source.attr("data-id") ?: continue

                val iframeUrl = runCatching {
                    app.get("$domain/ajax/episode/sources/$sourceId")
                        .parsedSafe<Watch32>()?.link
                }.getOrNull() ?: continue
                commonLinkLoader(name, ServerName.Videostr, iframeUrl, null, null, subtitleCallback, callback)
            }
        }
        else
        {
            val episodeLinks = runCatching {
                app.get("$domain/ajax/episode/list/$infoId").documentLarge.select("li.nav-item a")
            }.getOrNull() ?: return

            episodeLinks.forEach { ep ->
                val dataId = ep.attr("data-id")
                val iframeUrl = runCatching {
                    app.get("$domain/ajax/episode/sources/$dataId")
                        .parsedSafe<Watch32>()?.link
                }.getOrNull() ?: return@forEach
                commonLinkLoader(name, ServerName.Videostr, iframeUrl, null, null, subtitleCallback, callback)
            }
        }
    }

    data class Watch32(
        val type: String,
        val link: String,
    )
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MediaProviders/XPrimeProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.KotlinModule
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.api.Log
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.newExtractorLink

class XPrimeProvider : MediaProvider() {
    override val name = "XPrimeProvider"
    override val domain = "https://xprime.tv"
    override val categories = listOf(UltimaUtils.Category.MEDIA)

    override suspend fun loadContent(
        url: String,
        data: UltimaUtils.LinkData,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val backendAPI = getDomains()?.xprime ?: return
        val servers = app.get("$backendAPI/servers").parsedSafe<XprimeServers>() ?: return

        val objectMapper = ObjectMapper()
            .registerModule(KotlinModule.Builder().build())
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)

        servers.servers.forEach { server ->
            if (server.status != "ok") return@forEach

            val baseUrl = "$backendAPI/${server.name}"
            val queryParams = buildString {
                append("?name=${data.title.orEmpty()}")
                when (server.name) {
                    "primebox" -> {
                        if (data.year != null) append("&fallback_year=${data.year}")
                        if (data.season != null && data.episode != null) append("&season=${data.season}&episode=${data.episode}")
                    }
                    else -> {
                        if (data.year != null) append("&year=${data.year}")
                        if (!data.imdbId.isNullOrBlank()) append("&id=${data.tmdbId}&imdb=${data.imdbId}")
                        if (data.season != null && data.episode != null) append("&season=${data.season}&episode=${data.episode}")
                    }
                }
            }

            val finalUrl = baseUrl + queryParams

            try {
                val response = app.get(finalUrl)
                val json = response.text
                val serverLabel = "Xprime ${server.name.replaceFirstChar { it.uppercaseChar() }}"

                if (server.name == "primebox") {
                    val stream = objectMapper.readValue<XprimeStream>(json)
                    val streamsJson = objectMapper.readTree(json).get("streams")

                    stream.qualities.forEach { quality ->
                        val href = streamsJson?.get(quality)?.textValue()
                        if (!href.isNullOrBlank()) {
                            callback(
                                newExtractorLink(
                                    source = serverLabel,
                                    name = serverLabel,
                                    url = href,
                                    type = ExtractorLinkType.VIDEO
                                ) {
                                    this.quality = getQualityFromName(quality)
                                    this.headers = mapOf("Origin" to domain)
                                    this.referer = domain
                                }
                            )
                        }
                    }

                    if (stream.hasSubtitles) {
                        stream.subtitles.forEach { subtitle ->
                            val subUrl = subtitle.file.orEmpty()
                            if (subUrl.isNotBlank()) {
                                subtitleCallback(
                                    newSubtitleFile(
                                        lang = subtitle.label ?: "Unknown",
                                        url = subUrl
                                    )
                                )
                            }
                        }
                    }
                } else {
                    val href = objectMapper.readTree(json).get("url")?.textValue().orEmpty()
                    if (href.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                source = serverLabel,
                                name = serverLabel,
                                url = href,
                                type = ExtractorLinkType.M3U8
                            ) {
                                this.headers = mapOf("Origin" to domain)
                                this.referer = domain
                                this.quality = Qualities.Unknown.value
                            }
                        )
                    }
                }
            } catch (e: Exception) {
                Log.e("XPrimeAPI", "Error on server ${server.name} $e")
            }
        }
    }
    data class XprimeServers(
        val servers: List<XprimeServer1>,
    )

    data class XprimeServer1(
        val name: String,
        val status: String,
        val language: String,
    )


    data class XprimeStream(
        @JsonProperty("available_qualities") val qualities: List<String>,
        @JsonProperty("status") val status: String,
        @JsonProperty("has_subtitles") val hasSubtitles: Boolean,
        @JsonProperty("subtitles") val subtitles: List<XprimePrimeSubs>
    )

    data class XprimePrimeSubs(
        @JsonProperty("file") val file: String? = null,
        @JsonProperty("label") val label: String? = null,
    )
}


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/AniList.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import com.lagradost.api.Log
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addAniListId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.CoverImage
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.LikePageInfo
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Media
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.RecommendationConnection
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.SeasonNextAiringEpisode
import com.lagradost.cloudstream3.syncproviders.providers.AniListApi.Title
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.nicehttp.RequestBodyTypes
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody

class AniList(val plugin: UltimaBetaPlugin) : MainAPI() {
    override var name = "AniList"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.aniListApi)
    private val apiUrl = "https://graphql.anilist.co"
    private final val mediaLimit = 20
    private final val isAdult = false
    private val headerJSON =
            mapOf("Accept" to "application/json", "Content-Type" to "application/json")

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun anilistAPICall(query: String): AnilistAPIResponse {
        val data = mapOf("query" to query)
        val test = app.post(apiUrl, headers = headerJSON, data = data)
        val res =
                test.parsedSafe<AnilistAPIResponse>()
                        ?: throw Exception("Unable to fetch or parse Anilist api response")
        return res
    }

    private fun AniListApi.Media.toSearchResponse(): SearchResponse {
        val title = this.title.english ?: this.title.romaji ?: ""
        val url = "$mainUrl/anime/${this.id}"
        val posterUrl = this.coverImage.large
        return newAnimeSearchResponse(title, url, TvType.Anime) { this.posterUrl = posterUrl }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
            page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val res = anilistAPICall(this.data.replace("###", "$page"))
        val data =
                res.data.page?.media?.map { it.toSearchResponse() }
                        ?: throw Exception("Unable to read media data")
        val hasNextPage = res.data.page.pageInfo.hasNextPage ?: false
        return data to hasNextPage
    }

    override val mainPage =
            mainPageOf(
                    "query (\$page: Int = ###, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                            "Trending Now",
                    "query (\$page: Int = ###, \$seasonYear: Int = 2024, \$sort: [MediaSort] = [TRENDING_DESC, POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, seasonYear: \$seasonYear, season: SPRING, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                            "Popular This Season",
                    "query (\$page: Int = ###, \$sort: [MediaSort] = [POPULARITY_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                            "All Time Popular",
                    "query (\$page: Int = ###, \$sort: [MediaSort] = [SCORE_DESC], \$isAdult: Boolean = $isAdult) { Page(page: \$page, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(sort: \$sort, isAdult: \$isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }" to
                            "Top 100 Anime",
                    "Personal" to "Personal"
            )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res =
                anilistAPICall(
                        "query (\$search: String = \"$query\") { Page(page: 1, perPage: $mediaLimit) { pageInfo { total perPage currentPage lastPage hasNextPage } media(search: \$search, isAdult: $isAdult, type: ANIME) { id idMal season seasonYear format episodes chapters title { english romaji } coverImage { extraLarge large medium } synonyms nextAiringEpisode { timeUntilAiring episode } } } }"
                )
        return res.data.page?.media?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                    ?: return newHomePageResponse(
                            "Login required for personal content.",
                            emptyList<SearchResponse>(),
                            false
                    )
            var homePageList =
                    repo.library()?.getOrThrow()!!.allLibraryLists.mapNotNull {
                        if (it.items.isEmpty()) return@mapNotNull null
                        val libraryName =
                                it.name.asString(plugin.activity ?: return@mapNotNull null)
                        HomePageList("${request.name}: $libraryName", it.items)
                    }
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is
            // overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data = anilistAPICall(
            "query (\$id: Int = $id) { Media(id: \$id, type: ANIME) { id title { romaji english } startDate { year } genres description averageScore bannerImage coverImage { extraLarge large medium } bannerImage episodes format nextAiringEpisode { episode } airingSchedule { nodes { episode } } recommendations { edges { node { id mediaRecommendation { id title { romaji english } coverImage { extraLarge large medium } } } } } } }"
        ).data.media ?: throw Exception("Unable to fetch media details")

        val anititle = data.getTitle()
        val aniyear = data.startDate.year
        val anitype = if (data.format!!.contains("MOVIE", ignoreCase = true)) TvType.AnimeMovie else TvType.TvSeries
        val ids = tmdbToAnimeId(anititle, aniyear, anitype)

        val jpTitle = data.title.romaji


        val syncMetaData = app.get("https://api.ani.zip/mappings?anilist_id=${ids.id}").toString()
        val animeMetaData = parseAnimeData(syncMetaData)

        val href = LinkData(
            malId = ids.idMal,
            aniId = ids.id,
            title = data.getTitle(),
            jpTitle = jpTitle,
            year = data.startDate.year,
            isAnime = true
        ).toStringData()

        // --- Helper to get best episode title ---
        fun resolveTitle(epData: MetaEpisode?): String {
            val jsonTitle = epData?.title?.get("en")
                ?: epData?.title?.get("ja")
                ?: epData?.title?.get("x-jat")
                ?: animeMetaData.titles?.get("en")
                ?: animeMetaData.titles?.get("ja")
                ?: animeMetaData.titles?.get("x-jat")
                ?: ""
            return jsonTitle.ifBlank { "Episode ${epData?.episode ?: ""}" }
        }

        fun createEpisode(i: Int, isDub: Boolean): Episode {
            val epData = animeMetaData.episodes?.get(i.toString())
            val linkData = LinkData(
                malId = ids.idMal,
                aniId = ids.id,
                title = data.getTitle(),
                jpTitle = jpTitle,
                year = data.startDate.year,
                season = 1,
                episode = i,
                isAnime = true,
                isDub = isDub
            ).toStringData()

            return newEpisode(linkData) {
                this.season = 1
                this.episode = i
                this.name = resolveTitle(epData)
                this.posterUrl = epData?.image ?: animeMetaData.images?.firstOrNull()?.url ?: ""
                this.description = epData?.overview ?: "No summary available"
                this.score = Score.from10(epData?.rating)
                this.runTime = epData?.runtime
                this.addDate(epData?.airDateUtc)
            }
        }

        val episodes = (1..data.totalEpisodes()).map { createEpisode(it, false) }


        return if (data.format.contains("Movie",ignoreCase = true)) {
            newMovieLoadResponse(data.getTitle(), url, TvType.AnimeMovie, href) {
                addAniListId(id.toInt())
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.bannerImage
                this.posterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url ?: data.getCoverImage()
                this.tags = data.genres
            }
        } else {
            newAnimeLoadResponse(data.getTitle(), url, TvType.Anime) {
                addAniListId(id.toInt())
                addEpisodes(DubStatus.Subbed, episodes)
                this.year = data.startDate.year
                this.plot = data.description
                this.backgroundPosterUrl =
                    animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url
                        ?: data.bannerImage
                this.posterUrl = animeMetaData.images?.firstOrNull { it.coverType == "Fanart" }?.url
                    ?: data.getCoverImage()
                this.tags = data.genres
                this.recommendations = data.recommendations?.edges
                    ?.mapNotNull { edge ->
                        val recommendation = edge.node.mediaRecommendation ?: return@mapNotNull null
                        val title = recommendation.title?.english
                            ?: recommendation.title?.romaji
                            ?: "Unknown"
                        val recommendationUrl = "$mainUrl/anime/${recommendation.id}"
                        newAnimeSearchResponse(title, recommendationUrl, TvType.Anime).apply {
                            this.posterUrl = recommendation.coverImage?.large
                        }
                    }
            }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        Log.d("Phisher ANilist",mediaData.toJson())
        invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        return true
    }

    data class AnilistAPIResponse(
            @JsonProperty("data") val data: AnilistData,
    ) {
        data class AnilistData(
                @JsonProperty("Page") val page: AnilistPage?,
                @JsonProperty("Media") val media: anilistMedia?,
        ) {
            data class AnilistPage(
                    @JsonProperty("pageInfo") val pageInfo: LikePageInfo,
                    @JsonProperty("media") val media: List<Media>,
            )
        }

        data class anilistMedia(
                @JsonProperty("id") val id: Int,
                @JsonProperty("startDate") val startDate: StartDate,
                @JsonProperty("episodes") val episodes: Int?,
                @JsonProperty("title") val title: Title,
                @JsonProperty("genres") val genres: List<String>,
                @JsonProperty("description") val description: String?,
                @JsonProperty("coverImage") val coverImage: CoverImage,
                @JsonProperty("bannerImage") val bannerImage: String?,
                @JsonProperty("nextAiringEpisode") val nextAiringEpisode: SeasonNextAiringEpisode?,
                @JsonProperty("airingSchedule") val airingSchedule: AiringScheduleNodes?,
                @JsonProperty("recommendations") val recommendations: RecommendationConnection?,
                @JsonProperty("format") val format: String?,
        ) {
            data class StartDate(@JsonProperty("year") val year: Int)

            data class AiringScheduleNodes(
                    @JsonProperty("nodes") val nodes: List<SeasonNextAiringEpisode>?
            )

            fun totalEpisodes(): Int {
                return nextAiringEpisode?.episode?.minus(1)
                        ?: episodes ?: airingSchedule?.nodes?.getOrNull(0)?.episode
                                ?: throw Exception("Unable to calculate total episodes")
            }

            fun getTitle(): String {
                return title.english
                        ?: title.romaji ?: throw Exception("Unable to calculate total episodes")
            }

            fun getCoverImage(): String? {
                return coverImage.extraLarge ?: coverImage.large ?: coverImage.medium
            }
        }
    }

    private suspend fun tmdbToAnimeId(title: String?, year: Int?, type: TvType): AniIds {
        if (title.isNullOrBlank()) return AniIds(null, null)

        val query = """
        query (
          ${'$'}page: Int = 1
          ${'$'}search: String
          ${'$'}sort: [MediaSort] = [POPULARITY_DESC, SCORE_DESC]
          ${'$'}type: MediaType
          ${'$'}season: MediaSeason
          ${'$'}seasonYear: Int
          ${'$'}format: [MediaFormat]
        ) {
          Page(page: ${'$'}page, perPage: 20) {
            media(
              search: ${'$'}search
              sort: ${'$'}sort
              type: ${'$'}type
              season: ${'$'}season
              seasonYear: ${'$'}seasonYear
              format_in: ${'$'}format
            ) {
              id
              idMal
            }
          }
        }
    """.trimIndent()

        val variables = mutableMapOf(
            "search" to title,
            "sort" to listOf("SEARCH_MATCH"),
            "type" to "ANIME",
            "format" to listOf(
                if (type == TvType.AnimeMovie) "MOVIE" else "TV",
                "ONA",
                "OVA"
            )
        )

        val data = mapOf(
            "query" to query,
            "variables" to variables
        ).toJson().toRequestBody(RequestBodyTypes.JSON.toMediaTypeOrNull())

        val res = app.post(apiUrl, requestBody = data)
            .parsedSafe<AniSearch>()
            ?.data
            ?.let { it.Page?.media ?: it.media }
            ?.firstOrNull()
        return AniIds(res?.id, res?.idMal)
    }
}

fun parseAnimeData(jsonString: String): MetaAnimeData {
    val objectMapper = ObjectMapper()
    return objectMapper.readValue(jsonString, MetaAnimeData::class.java)
}


@JsonIgnoreProperties(ignoreUnknown = true)
data class ImageData(
    @JsonProperty("coverType") val coverType: String?,
    @JsonProperty("url") val url: String?
)

@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaEpisode(
    @JsonProperty("episode") val episode: String?,
    @JsonProperty("airdate") val airdate: String?,
    @JsonProperty("airDateUtc") val airDateUtc: String?,
    @JsonProperty("length") val length: Int?,
    @JsonProperty("runtime") val runtime: Int?,
    @JsonProperty("image") val image: String?,
    @JsonProperty("title") val title: Map<String, String>?,
    @JsonProperty("overview") val overview: String?,
    @JsonProperty("rating") val rating: String?,
    @JsonProperty("finaleType") val finaleType: String?
)


@JsonIgnoreProperties(ignoreUnknown = true)
data class MetaAnimeData(
    @JsonProperty("titles") val titles: Map<String, String>? = null,
    @JsonProperty("images") val images: List<ImageData>? = null,
    @JsonProperty("episodes") val episodes: Map<String, MetaEpisode>? = null,
)

data class AniMedia(
    @JsonProperty("id") var id: Int? = null,
    @JsonProperty("idMal") var idMal: Int? = null
)

data class AniPage(
    @JsonProperty("media") var media: ArrayList<AniMedia> = arrayListOf()
)

data class AniData(
    @JsonProperty("Page") var Page: AniPage? = null,
    @JsonProperty("media") var media: ArrayList<AniMedia>? = null
)

data class AniSearch(
    @JsonProperty("data") var data: AniData? = null
)

data class AniIds(var id: Int? = null, var idMal: Int? = null)


================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/MetaProviders.kt
================================================
package com.phisher98

object UltimaMetaProviderUtils {
    val metaProviders =
            arrayOf(
                    "Simkl" to false,
                    "AniList" to false,
                    "MyAnimeList" to false,
                    "TMDB" to false,
                    "Trakt" to false
            )
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/MyAnimeList.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.AcraApplication
import com.lagradost.cloudstream3.DubStatus
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addMalId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addEpisodes
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newAnimeLoadResponse
import com.lagradost.cloudstream3.newAnimeSearchResponse
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager.Companion.malApi
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.MALApi
import com.lagradost.cloudstream3.syncproviders.providers.MALApi.MalAnime
import com.lagradost.cloudstream3.syncproviders.providers.MALApi.Recommendations
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink

open class MyAnimeList(val plugin: UltimaBetaPlugin) : MainAPI() {
    override var name = "MyAnimeList"
    override var mainUrl = "https://myanimelist.net"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.MyAnimeList)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(malApi)
    private val apiUrl = "https://api.myanimelist.net/v2"
    private val mediaLimit = 20


    private fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private suspend fun malAPICall(query: String): MalApiResponse {
        //val accountId = "${malApi.idPrefix}_account_${malApi.accountIndex}"
        //val authToken = AcraApplication.getKey<String>(accountId, MALApi.MAL_TOKEN_KEY)
        val res =
                app.get(query, headers = mapOf("Authorization" to "Bearer $"))
                        .parsedSafe<MalApiResponse>()
                        ?: throw Exception("Unable to fetch content from API")
        return res
    }

    private fun MalApiResponse.MalApiData.toSearchResponse(): SearchResponse {
        val url = "$mainUrl/${this.node.id}"
        val posterUrl = this.node.picture.large
        val res = newAnimeSearchResponse(this.node.title, url) { this.posterUrl = posterUrl }
        return res
    }

    private fun Recommendations.toSearchResponse(): SearchResponse {
        val node = this.node ?: throw Exception("Unable to parse Recommendation")
        val url = "$mainUrl/${node.id}"
        val posterUrl = node.mainPicture?.large
        val res = newAnimeSearchResponse(node.title, url) { this.posterUrl = posterUrl }
        return res
    }

    override val mainPage =
            mainPageOf(
                    "$apiUrl/anime/ranking?ranking_type=all&limit=$mediaLimit&offset=" to
                            "Top Anime Series",
                    "$apiUrl/anime/ranking?ranking_type=airing&limit=$mediaLimit&offset=" to
                            "Top Airing Anime",
                    "$apiUrl/anime/ranking?ranking_type=bypopularity&limit=$mediaLimit&offset=" to
                            "Popular Anime",
                    "$apiUrl/anime/ranking?ranking_type=favorite&limit=$mediaLimit&offset=" to
                            "Top Favorited Anime",
                    "$apiUrl/anime/suggestions?limit=$mediaLimit&offset=" to "Suggestions",
                    "Personal" to "Personal"
            )

    override suspend fun search(query: String): List<SearchResponse>? {
        val res = malAPICall("$apiUrl/anime?q=$query&limit=$mediaLimit")
        return res.data?.map { it.toSearchResponse() }
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                    ?: return newHomePageResponse(
                            "Login required for personal content.",
                            emptyList<SearchResponse>(),
                            false
                    )
            val homePageList =
                    repo.library()?.getOrThrow()!!.allLibraryLists.mapNotNull {
                        if (it.items.isEmpty()) return@mapNotNull null
                        val libraryName =
                                it.name.asString(plugin.activity ?: return@mapNotNull null)
                        HomePageList("${request.name}: $libraryName", it.items)
                    }
            return newHomePageResponse(homePageList, false)
        } else {
            val res = malAPICall("${request.data}${(page - 1) * mediaLimit}")
            val media =
                    res.data?.map { it.toSearchResponse() }
                            ?: return newHomePageResponse(request.name, emptyList(), false)
            return newHomePageResponse(request.name, media, true)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data =
                app.get(
                                "$apiUrl/anime/$id?fields=id,title,synopsis,main_picture,start_season,num_episodes,recommendations,genres",
                                headers = mapOf("Authorization" to "Bearer ")
                        )
                        .parsedSafe<MalAnime>()
                        ?: throw ErrorLoadingException("Unable to fetch show details")
        val year = data.startSeason?.year
        val epCount = data.numEpisodes ?: 0
        val episodes =
                (1..epCount).map { i ->
                    val linkData =
                            LinkData(
                                            title = data.title,
                                            year = year,
                                            season = 1,
                                            episode = i,
                                            isAnime = true
                                    )
                                    .toStringData()
                    newEpisode(linkData)
                    {
                        this.season= 1
                        this.episode = i
                    }
                }
        return newAnimeLoadResponse(
                data.title ?: throw NotImplementedError("Unable to parse title"),
                url,
                TvType.Anime
        ) {
            this.year = data.startSeason?.year
            this.posterUrl = data.mainPicture?.large
            this.plot = data.synopsis
            this.tags = data.genres?.map { it.name }
            addMalId(id.toInt())
            addEpisodes(DubStatus.Subbed, episodes)
            this.recommendations = data.recommendations?.map { it.toSearchResponse() }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<LinkData>(data)
        invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        return true
    }

    data class MalApiResponse(
            @JsonProperty("data") val data: Array<MalApiData>? = null,
    ) {
        data class MalApiData(
                @JsonProperty("node") val node: MalApiNode,
        ) {
            data class MalApiNode(
                    @JsonProperty("id") val id: Int,
                    @JsonProperty("title") val title: String,
                    @JsonProperty("main_picture") val picture: MalApiNodePicture
            ) {
                data class MalApiNodePicture(
                        @JsonProperty("medium") val medium: String,
                        @JsonProperty("large") val large: String,
                )
            }
        }
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/Simkl.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addSimklId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.syncproviders.AccountManager
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.syncproviders.SyncRepo
import com.lagradost.cloudstream3.syncproviders.providers.SimklApi.Companion.MediaObject
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.syncproviders.providers.SimklApi.Companion.getPosterUrl
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink

class Simkl(val plugin: UltimaBetaPlugin) : MainAPI() {
    override var name = "Simkl"
    override var mainUrl = "https://simkl.com"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Simkl)
    override val hasMainPage = true
    override val hasQuickSearch = false
    private val repo = SyncRepo(AccountManager.simklApi)
    private val apiUrl = "https://api.simkl.com"
    private final val mediaLimit = 20

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private fun SimklMediaObject.toSearchResponse(): SearchResponse {
        val poster = getPosterUrl(poster ?: "")
        return newMovieSearchResponse(title, "$mainUrl/shows/${ids?.simkl}") {
            this.posterUrl = poster
        }
    }

    private suspend fun MainPageRequest.toSearchResponseList(
            page: Int
    ): Pair<List<SearchResponse>, Boolean> {
        val emptyData = emptyList<SearchResponse>() to false
        val res =
                app.get(this.data + page).parsedSafe<Array<SimklMediaObject>>() ?: return emptyData
        return res.map {
            newMovieSearchResponse("${it.title}", "$mainUrl/shows/${it.ids?.simkl2}") {
                this.posterUrl = getPosterUrl(it.poster.toString())
            }
        } to res.size.equals(mediaLimit)
    }

    private fun SimklMediaObject.toLinkData(): LinkData {
        return LinkData(
                simklId = ids?.simkl,
                imdbId = ids?.imdb,
                tmdbId = ids?.tmdb,
                aniId = ids?.anilist?.toIntOrNull(),
                malId = ids?.mal?.toIntOrNull(),
                title = title,
                year = year,
                type = type,
                isAnime = type.equals("anime")
        )
    }

    private fun SimklEpisodeObject.toLinkData(
            showName: String,
            ids: SimklIds?,
            year: Int?,
            isAnime: Boolean
    ): LinkData {
        return LinkData(
                simklId = ids?.simkl,
                imdbId = ids?.imdb,
                tmdbId = ids?.tmdb,
                aniId = ids?.anilist?.toIntOrNull(),
                malId = ids?.mal?.toIntOrNull(),
                title = showName,
                year = year,
                season = season,
                episode = episode,
                type = type,
                isAnime = isAnime
        )
    }

    private fun SimklEpisodeObject.toEpisode(
            showName: String,
            ids: SimklIds?,
            year: Int?,
            isAnime: Boolean
    ): Episode {
        val poster = "https://simkl.in/episodes/${img}_c.webp"
        val linkData = this.toLinkData(showName, ids, year, isAnime).toStringData()
        return newEpisode(linkData)
        {
            this.name = title
            this.description = desc
            this.posterUrl = poster
        }
    }

    // this method is added to tackle current API limitation of 100 req per day
    private fun MediaObject.toSimklMediaObject(): SimklMediaObject? {
        return parseJson<SimklMediaObject>(this.toStringData())
    }

    // this method is added to tackle current API limitation of 100 req per day
    private fun buildSimklEpisodes(total: Int?): Array<SimklEpisodeObject>? {
        if (total == null) return null
        var data = emptyArray<SimklEpisodeObject>()
        (1..total).forEach {
            data += SimklEpisodeObject(season = 1, episode = it, ids = null, type = "episode")
        }
        return data
    }

    override val mainPage =
            mainPageOf(
                    "$apiUrl/tv/trending/month?type=series&client_id=&extended=overview&limit=$mediaLimit&page=" to
                            "Trending TV Shows",
                    "$apiUrl/movies/trending/month?client_id=&extended=overview&limit=$mediaLimit&page=" to
                            "Trending Movies",
                    "$apiUrl/tv/best/all?type=series&client_id=&extended=overview&limit=$mediaLimit&page=" to
                            "Best TV Shows",
                    //"$apiUrl/movies/best/all?client_id=&extended=overview&limit=$mediaLimit&page=" to
                    //       "Best Movies",
                    "Personal" to "Personal"
            )

    override suspend fun search(query: String): List<SearchResponse>? {
        //return api.search(query)
        return null
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        if (request.name.contains("Personal")) {
            // Reading and manipulating personal library
            repo.authUser()
                    ?: return newHomePageResponse(
                            "Login required for personal content.",
                            emptyList<SearchResponse>(),
                            false
                    )
            val homePageList =
                    repo.library()?.getOrThrow()?.allLibraryLists?.mapNotNull {
                        if (it.items.isEmpty()) return@mapNotNull null
                        val libraryName =
                                it.name.asString(plugin.activity ?: return@mapNotNull null)
                        HomePageList("${request.name}: $libraryName", it.items)
                    }
                            ?: return null
            return newHomePageResponse(homePageList, false)
        } else {
            // Other new sections will be generated if toSearchResponseList() is overridden
            val data = request.toSearchResponseList(page)
            return newHomePageResponse(request.name, data.first, data.second)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val id = url.removeSuffix("/").substringAfterLast("/")
        val data =
                app.get("$apiUrl/tv/$id?client_id=&extended=full")
                        .parsedSafe<SimklMediaObject>()
                        ?: throw ErrorLoadingException("Unable to load data")
        val year = data.year
        val posterUrl = getPosterUrl(data.poster ?: "")
        return if (data.type.equals("movie")) {
            val linkData = data.toLinkData().toStringData()
            newMovieLoadResponse(data.title, url, TvType.Movie, linkData) {
                this.addSimklId(id.toInt())
                this.year = year
                this.posterUrl = posterUrl
                this.plot = data.overview
                this.recommendations = data.recommendations?.map { it.toSearchResponse() }
            }
        } else {
            val eps =
                    app.get("$apiUrl/tv/episodes/$id?client_id=&extended=full")
                            .parsedSafe<Array<SimklEpisodeObject>>()
                            ?: buildSimklEpisodes(data.total_episodes)
                                    ?: throw Exception("Unable to fetch episodes")
            val episodes =
                    eps.filter { it.type.equals("episode") }.map {
                        it.toEpisode(data.title, data.ids, year, data.type.equals("anime"))
                    }
            newTvSeriesLoadResponse(data.title, url, TvType.TvSeries, episodes) {
                this.addSimklId(id.toInt())
                this.year = year
                this.posterUrl = posterUrl
                this.plot = data.overview
                this.recommendations = data.recommendations?.map { it.toSearchResponse() }
            }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = parseJson<LinkData>(data)
        if (mediaData.isAnime)
                invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }

    open class SimklMediaObject(
            @JsonProperty("title") val title: String,
            @JsonProperty("year") val year: Int? = null,
            @JsonProperty("ids") val ids: SimklIds?,
            @JsonProperty("total_episodes") val total_episodes: Int? = null,
            @JsonProperty("status") val status: String? = null,
            @JsonProperty("poster") val poster: String? = null,
            @JsonProperty("type") val type: String? = null,
            @JsonProperty("overview") val overview: String? = null,
            @JsonProperty("genres") val genres: List<String>? = null,
            @JsonProperty("users_recommendations")
            val recommendations: List<SimklMediaObject>? = null,
    )

    open class SimklEpisodeObject(
            @JsonProperty("title") val title: String? = null,
            @JsonProperty("description") val desc: String? = null,
            @JsonProperty("season") val season: Int? = null,
            @JsonProperty("episode") val episode: Int? = null,
            @JsonProperty("type") val type: String? = null,
            @JsonProperty("aired") val aired: Boolean? = null,
            @JsonProperty("img") val img: String? = null,
            @JsonProperty("ids") val ids: SimklIds?,
    )

    data class SimklIds(
            @JsonProperty("simkl") val simkl: Int? = null,
            @JsonProperty("simkl_id") val simkl2: Int? = null,
            @JsonProperty("imdb") val imdb: String? = null,
            @JsonProperty("tmdb") val tmdb: Int? = null,
            @JsonProperty("mal") val mal: String? = null,
            @JsonProperty("anilist") val anilist: String? = null,
    )
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/Tmdb.kt
================================================
package com.phisher98

import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.amap
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import java.util.Locale


class Tmdb(val plugin: UltimaBetaPlugin) : TmdbProvider() {
    override var name = "TMDB"
    override var mainUrl = "https://www.themoviedb.org"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama)
    override var lang = "en"
    override val hasMainPage = true
    override val hasQuickSearch = false
    override val useMetaLoadResponse = true
    private val apiUrl = "https://api.themoviedb.org"

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    private fun TmdbLink.toLinkData(): LinkData {
        return LinkData(
                imdbId = imdbID,
                tmdbId = tmdbID,
                title = movieName,
                season = season,
                episode = episode,
        )
    }

    @RequiresApi(Build.VERSION_CODES.N)
    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<TmdbLink>(data).toLinkData()
        invokeSubtitleAPI(mediaData.imdbId, mediaData.season, mediaData.episode, subtitleCallback)
        //invokeWyZIESUBAPI(mediaData.imdbId, mediaData.season, mediaData.episode, subtitleCallback)
        if (mediaData.isAnime)
                invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }

    private suspend fun invokeSubtitleAPI(
        id: String? = null,
        season: Int? = null,
        episode: Int? = null,
        subtitleCallback: (SubtitleFile) -> Unit,
    ) {
        val url = if (season == null) {
            "https://opensubtitles-v3.strem.io/subtitles/movie/$id.json"
        } else {
            "https://opensubtitles-v3.strem.io/subtitles/series/$id:$season:$episode.json"
        }
        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.0.0 Safari/537.36",
        )
        app.get(url, headers = headers, timeout = 100L)
            .parsedSafe<SubtitlesAPI>()?.subtitles?.amap { it ->
                val lan = getLanguage(it.lang) ?: "Unknown"
                val suburl = it.url
                subtitleCallback.invoke(
                    newSubtitleFile(
                        lan.replaceFirstChar { if (it.isLowerCase()) it.titlecase(Locale.getDefault()) else it.toString() },  // Use label for the name
                        suburl     // Use extracted URL
                    )
                )
        }
    }
    data class SubtitlesAPI(
        val subtitles: List<Subtitle>,
        val cacheMaxAge: Long,
    )

    data class Subtitle(
        val id: String,
        val url: String,
        @JsonProperty("SubEncoding")
        val subEncoding: String,
        val lang: String,
        val m: String,
        val g: String,
    )
}

val languageMap = mapOf(
    "Afrikaans" to Pair("af", "afr"),
    "Albanian" to Pair("sq", "sqi"),
    "Amharic" to Pair("am", "amh"),
    "Arabic" to Pair("ar", "ara"),
    "Armenian" to Pair("hy", "hye"),
    "Azerbaijani" to Pair("az", "aze"),
    "Basque" to Pair("eu", "eus"),
    "Belarusian" to Pair("be", "bel"),
    "Bengali" to Pair("bn", "ben"),
    "Bosnian" to Pair("bs", "bos"),
    "Bulgarian" to Pair("bg", "bul"),
    "Catalan" to Pair("ca", "cat"),
    "Chinese" to Pair("zh", "zho"),
    "Croatian" to Pair("hr", "hrv"),
    "Czech" to Pair("cs", "ces"),
    "Danish" to Pair("da", "dan"),
    "Dutch" to Pair("nl", "nld"),
    "English" to Pair("en", "eng"),
    "Estonian" to Pair("et", "est"),
    "Filipino" to Pair("tl", "tgl"),
    "Finnish" to Pair("fi", "fin"),
    "French" to Pair("fr", "fra"),
    "Galician" to Pair("gl", "glg"),
    "Georgian" to Pair("ka", "kat"),
    "German" to Pair("de", "deu"),
    "Greek" to Pair("el", "ell"),
    "Gujarati" to Pair("gu", "guj"),
    "Hebrew" to Pair("he", "heb"),
    "Hindi" to Pair("hi", "hin"),
    "Hungarian" to Pair("hu", "hun"),
    "Icelandic" to Pair("is", "isl"),
    "Indonesian" to Pair("id", "ind"),
    "Italian" to Pair("it", "ita"),
    "Japanese" to Pair("ja", "jpn"),
    "Kannada" to Pair("kn", "kan"),
    "Kazakh" to Pair("kk", "kaz"),
    "Korean" to Pair("ko", "kor"),
    "Latvian" to Pair("lv", "lav"),
    "Lithuanian" to Pair("lt", "lit"),
    "Macedonian" to Pair("mk", "mkd"),
    "Malay" to Pair("ms", "msa"),
    "Malayalam" to Pair("ml", "mal"),
    "Maltese" to Pair("mt", "mlt"),
    "Marathi" to Pair("mr", "mar"),
    "Mongolian" to Pair("mn", "mon"),
    "Nepali" to Pair("ne", "nep"),
    "Norwegian" to Pair("no", "nor"),
    "Persian" to Pair("fa", "fas"),
    "Polish" to Pair("pl", "pol"),
    "Portuguese" to Pair("pt", "por"),
    "Punjabi" to Pair("pa", "pan"),
    "Romanian" to Pair("ro", "ron"),
    "Russian" to Pair("ru", "rus"),
    "Serbian" to Pair("sr", "srp"),
    "Sinhala" to Pair("si", "sin"),
    "Slovak" to Pair("sk", "slk"),
    "Slovenian" to Pair("sl", "slv"),
    "Spanish" to Pair("es", "spa"),
    "Swahili" to Pair("sw", "swa"),
    "Swedish" to Pair("sv", "swe"),
    "Tamil" to Pair("ta", "tam"),
    "Telugu" to Pair("te", "tel"),
    "Thai" to Pair("th", "tha"),
    "Turkish" to Pair("tr", "tur"),
    "Ukrainian" to Pair("uk", "ukr"),
    "Urdu" to Pair("ur", "urd"),
    "Uzbek" to Pair("uz", "uzb"),
    "Vietnamese" to Pair("vi", "vie"),
    "Welsh" to Pair("cy", "cym"),
    "Yiddish" to Pair("yi", "yid")
)

fun getLanguage(language: String?): String? {
    language ?: return null
    val normalizedLang = language.substringBefore("-")
    return languageMap.entries.find { it.value.first == normalizedLang || it.value.second == normalizedLang }?.key
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/Trakt.kt
================================================
package com.phisher98

import com.phisher98.UltimaMediaProvidersUtils.invokeExtractors
import com.phisher98.UltimaUtils.Category
import com.phisher98.UltimaUtils.LinkData as UltimaLinkData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.metaproviders.TraktProvider
import com.lagradost.cloudstream3.syncproviders.SyncIdName
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorLink

class Trakt(val plugin: UltimaBetaPlugin) : TraktProvider() {
    override var name = "Trakt"
    override var mainUrl = "https://trakt.tv"
    override var supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.AsianDrama)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Trakt)
    override val hasMainPage = true
    override val hasQuickSearch = false

    private val traktClientId =
            base64Decode(
                    "N2YzODYwYWQzNGI4ZTZmOTdmN2I5MTA0ZWQzMzEwOGI0MmQ3MTdlMTM0MmM2NGMxMTg5NGE1MjUyYTQ3NjE3Zg=="
            )
    private val traktApiUrl = base64Decode("aHR0cHM6Ly9hcGl6LnRyYWt0LnR2")

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    override val mainPage =
            mainPageOf(
                    "$traktApiUrl/movies/trending?extended=cloud9,full&limit=25" to
                            "Trending Movies",
                    "$traktApiUrl/movies/popular?extended=cloud9,full&limit=25" to "Popular Movies",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25" to "Trending Shows",
                    "$traktApiUrl/shows/popular?extended=cloud9,full&limit=25" to "Popular Shows",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=53,1465" to
                            "Netflix",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=47,2385" to
                            "Amazon Prime Video",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=256" to
                            "Apple TV+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=41,2018,2566,2567,2597" to
                            "Disney+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=87" to
                            "Hulu",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=1623" to
                            "Paramount+",
                    "$traktApiUrl/shows/trending?extended=cloud9,full&limit=25&network_ids=550,3027" to
                            "Peacock",
            )

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mediaData = AppUtils.parseJson<UltimaLinkData>(data)
        if (mediaData.isAnime)
                invokeExtractors(Category.ANIME, mediaData, subtitleCallback, callback)
        else invokeExtractors(Category.MEDIA, mediaData, subtitleCallback, callback)
        return true
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/MetaProviders/WatchSync.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.syncproviders.SyncIdName

open class WatchSync(val plugin: UltimaBetaPlugin) : MainAPI() {
    override var name = "WatchSync"
    override var mainUrl = "https://anilist.co"
    override var supportedTypes = setOf(TvType.Anime, TvType.AnimeMovie, TvType.OVA)
    override var lang = "en"
    override val supportedSyncNames = setOf(SyncIdName.Anilist)
    override val hasMainPage = true
    private val apiUrl = "https://graphql.anilist.co"

    protected fun Any.toStringData(): String {
        return mapper.writeValueAsString(this)
    }

    override val mainPage = mainPageOf("" to "")

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse? {
        return null
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Settings/ConfigureExtensions.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.core.view.isVisible
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.api.Log

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaConfigureExtensions(val plugin: UltimaBetaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")
    private val extensions = sm.fetchExtensions().also {
        Log.d("UltimaDebug", "Fetched ${it.size} extensions.")
        it.forEach { ext ->
            Log.d("UltimaDebug", "→ Extension: ${ext.name}")
            ext.sections?.forEach { sec ->
                Log.d("UltimaDebug", " - Section: ${sec.name}, enabled=${sec.enabled}")
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - Utility functions
    @SuppressLint("DiscouragedApi")
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Drawable $name not found")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion

    @SuppressLint("UseSwitchCompatOrMaterialCode")
    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        val settings = getLayout("configure_extensions", inflater, container)

        // Save button
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            // Debug log all selected sections
            extensions.forEach { ext ->
                Log.d("UltimaDebug", "Saving Extension: ${ext.name}")
                ext.sections?.forEach { sec ->
                    Log.d("UltimaDebug", "-- Section: ${sec.name} enabled=${sec.enabled}")
                }
            }

            sm.currentExtensions = extensions
            plugin.reload()
            showToast("Saved")
            dismiss()
        }

        // Toggle switch: Show extension name on home
        val extNameOnHomeBtn = settings.findView<Switch>("ext_name_on_home_toggle")
        extNameOnHomeBtn.makeTvCompatible()
        extNameOnHomeBtn.isChecked = sm.extNameOnHome
        extNameOnHomeBtn.setOnClickListener {
            sm.extNameOnHome = extNameOnHomeBtn.isChecked
        }

        // Extensions list
        val extensionsListLayout = settings.findView<LinearLayout>("extensions_list")
        extensions.forEach { extension ->
            val extensionLayoutView = buildExtensionView(extension, inflater, container)
            extensionsListLayout.addView(extensionLayoutView)
        }

        return settings
    }

    // Create one full view for each extension
    private fun buildExtensionView(
        extension: UltimaUtils.ExtensionInfo,
        inflater: LayoutInflater,
        container: ViewGroup?
    ): View {

        fun buildSectionView(
            section: UltimaUtils.SectionInfo,
            inflater: LayoutInflater,
            container: ViewGroup?
        ): View {
            val sectionView = getLayout("list_section_item", inflater, container)
            val checkBox = sectionView.findView<CheckBox>("section_checkbox")
            checkBox.text = section.name
            checkBox.makeTvCompatible()

            // Auto-enable sections by default if not already toggled
            if (section.enabled == null) section.enabled = true

            checkBox.isChecked = section.enabled == true
            checkBox.setOnCheckedChangeListener { _, isChecked ->
                section.enabled = isChecked
                Log.d("UltimaDebug", "Section '${section.name}' in '${extension.name}' set to $isChecked")
            }

            return sectionView
        }

        val extView = getLayout("list_extension_item", inflater, container)
        val extensionDataBtn = extView.findView<LinearLayout>("extension_data")
        val expandImage = extView.findView<ImageView>("expand_icon")
        val extensionNameBtn = extensionDataBtn.findView<TextView>("extension_name")
        val childList = extView.findView<LinearLayout>("sections_list")

        expandImage.setImageDrawable(getDrawable("triangle"))
        expandImage.rotation = 90f

        extensionNameBtn.text = extension.name
        extensionDataBtn.makeTvCompatible()
        extensionDataBtn.setOnClickListener {
            val isVisible = childList.isVisible
            childList.visibility = if (isVisible) View.GONE else View.VISIBLE
            expandImage.rotation = if (isVisible) 90f else 180f
        }

        // Add sections
        extension.sections?.forEach { section ->
            val sectionView = buildSectionView(section, inflater, container)
            childList.addView(sectionView)
        }

        return extView
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
            activity?.supportFragmentManager ?: throw Exception("Unable to open configure settings"),
            ""
        )
        super.onDetach()
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Settings/ConfigureWatchSync.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.EditText
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import androidx.appcompat.app.AlertDialog
import androidx.lifecycle.coroutineScope
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.cloudstream3.utils.AppContextUtils.setDefaultFocus
import com.phisher98.WatchSyncUtils.WatchSyncCreds
import kotlinx.coroutines.launch

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaConfigureWatchSync(private val plugin: UltimaBetaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val deviceData = sm.deviceSyncCreds
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")
    private val packageName = BuildConfig.LIBRARY_PACKAGE_NAME

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    @SuppressLint("DiscouragedApi")
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", packageName)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", packageName)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", packageName)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", packageName)
        return this.findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", packageName)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion

    @SuppressLint("UseSwitchCompatOrMaterialCode", "SetTextI18n")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("configure_watch_sync", inflater, container)

        // #region - save button
        settings.findView<ImageView>("save").apply {
            setImageDrawable(getDrawable("save_icon"))
            makeTvCompatible()
            setOnClickListener {
                sm.deviceSyncCreds = deviceData
                plugin.reload()
                showToast("Saved")
                dismiss()
            }
        }
        // #endregion

        // #region - watch sync creds
        settings.findView<ImageView>("watch_sync_creds_btn").apply {
            setImageDrawable(getDrawable("edit_icon"))
            makeTvCompatible()
            setOnClickListener {
                val credsView = getLayout("watch_sync_creds", inflater, container)
                val tokenInput = credsView.findView<EditText>("token")
                val prNumInput = credsView.findView<EditText>("project_num")
                val deviceNameInput = credsView.findView<EditText>("device_name")

                tokenInput.setText(sm.deviceSyncCreds?.token)
                prNumInput.setText(sm.deviceSyncCreds?.projectNum?.toString())
                deviceNameInput.setText(sm.deviceSyncCreds?.deviceName)

                AlertDialog.Builder(requireContext())
                    .setTitle("Set your creds")
                    .setView(credsView)
                    .setPositiveButton("Save") { _, _ ->
                        val token = tokenInput.text.trim().toString()
                        val prNum = prNumInput.text.toString().toIntOrNull()
                        val deviceName = deviceNameInput.text.trim().toString()

                        if (token.isEmpty() || prNum == null || deviceName.isEmpty()) {
                            showToast("Invalid details")
                        } else {
                            activity?.lifecycle?.coroutineScope?.launch {
                                sm.deviceSyncCreds = WatchSyncCreds(token, prNum, deviceName)
                                showToast(
                                    sm.deviceSyncCreds
                                        ?.syncProjectDetails()
                                        ?.second
                                )
                            }
                        }
                        dismiss()
                    }
                    .setNegativeButton("Reset") { _, _ ->
                        sm.deviceSyncCreds = WatchSyncCreds()
                        showToast("Credentials removed")
                        dismiss()
                    }
                    .show()
                    .setDefaultFocus()
            }
        }
        // #endregion

        // #region - toggle for sync this device
        settings.findView<Switch>("sync_this_device").apply {
            makeTvCompatible()
            isChecked = sm.deviceSyncCreds?.isThisDeviceSync ?: false
            setOnClickListener {
                activity?.lifecycle?.coroutineScope?.launch {
                    sm.deviceSyncCreds?.let {
                        val res = if (isChecked) it.registerThisDevice()
                        else it.deregisterThisDevice()
                        showToast(res.second)
                        if (res.first) dismiss()
                    }
                }
            }
        }
        // #endregion

        // #region - list of devices
        val devicesListLayout = settings.findView<LinearLayout>("devices_list")
        val activeDevices = deviceData?.enabledDevices?.toMutableList() ?: mutableListOf()
        activity?.lifecycle?.coroutineScope?.launch {
            val devices = deviceData?.fetchDevices()
            devices?.forEach { device ->
                val currentDevice = sm.deviceSyncCreds?.deviceId.equals(device.deviceId)
                val syncDeviceView = getLayout("watch_sync_device", inflater, container)
                val deviceName = syncDeviceView.findView<Switch>("watch_sync_device_name")
                deviceName.text = device.name + if (currentDevice) " (current device)" else ""
                deviceName.isChecked =
                    sm.deviceSyncCreds?.enabledDevices?.contains(device.deviceId) ?: false
                deviceName.setOnClickListener {
                    if (deviceName.isChecked) {
                        if (currentDevice) deviceName.isChecked = false
                        else activeDevices.add(device.deviceId)
                    } else activeDevices.remove(device.deviceId)
                    deviceData?.enabledDevices = activeDevices
                }
                devicesListLayout.addView(syncDeviceView)
            }
        }
        // #endregion

        return settings
    }

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
            activity?.supportFragmentManager
                ?: throw Exception("Unable to open configure settings"),
            ""
        )
        super.onDetach()
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Settings/MetaProviders.kt
================================================
package com.phisher98

import android.app.AlertDialog
import android.content.DialogInterface
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.text.InputType
import android.view.LayoutInflater
import android.view.View
import android.view.View.OnClickListener
import android.view.ViewGroup
import android.widget.CheckBox
import android.widget.CompoundButton
import android.widget.CompoundButton.OnCheckedChangeListener
import android.widget.EditText
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.Switch
import android.widget.TextView
import androidx.annotation.RequiresApi
import com.phisher98.UltimaUtils.MediaProviderState
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.phisher98.BuildConfig
import kotlin.collections.toList

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaMetaProviders(val plugin: UltimaBetaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private var sm = UltimaStorageManager
    private var metaProviders = sm.currentMetaProviders.toList()
    private var mediaProviders = sm.currentMediaProviders.toList()
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion - necessary functions

    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("meta_providers", inflater, container)

        // #region - building save button and its click listener
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        sm.currentMetaProviders = metaProviders.toTypedArray()
                        sm.currentMediaProviders = mediaProviders.toTypedArray()
                        plugin.reload()
                        showToast("Saved")
                        dismiss()
                    }
                }
        )
        // #endregion - building save button and its click listener

        // #region - building list of meta providers and its sections with its click listener
        val metaProvidersListLayout = settings.findView<LinearLayout>("meta_providers_list")
        metaProviders.forEach { metaProvider ->
            val extensionLayoutView = buildMetaProviderView(metaProvider, inflater, container)
            metaProvidersListLayout.addView(extensionLayoutView)
        }
        // #endregion - building list of meta providers and its sections with its click listener

        // #region - building list of media providers and its sections with its click listener
        val mediaProvidersListLayout = settings.findView<LinearLayout>("media_providers_list")
        mediaProviders.forEach { mediaProvider ->
            val extensionLayoutView = buildMediaProviderView(mediaProvider, inflater, container)
            mediaProvidersListLayout.addView(extensionLayoutView)
        }
        // #endregion - building list of media providers and its sections with its click listener

        return settings
    }

    fun buildMetaProviderView(
            metaProvider: Pair<String, Boolean>,
            inflater: LayoutInflater,
            container: ViewGroup?
    ): View {

        // collecting required resources
        val metaProviderLayoutView = getLayout("list_meta_provider_item", inflater, container)
        val metaProviderNameBtn = metaProviderLayoutView.findView<Switch>("meta_provider_name")

        // building extension textview and its click listener
        metaProviderNameBtn.text = metaProvider.first
        metaProviderNameBtn.isChecked = metaProvider.second
        metaProviderNameBtn.makeTvCompatible()
        metaProviderNameBtn.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        metaProviders =
                                metaProviders.map {
                                    if (it.first.equals(metaProvider.first))
                                            it.first to metaProviderNameBtn.isChecked
                                    else it
                                }
                    }
                }
        )

        return metaProviderLayoutView
    }

    fun buildMediaProviderView(
            mediaProvider: MediaProviderState,
            inflater: LayoutInflater,
            container: ViewGroup?
    ): View {
        val mediaProviderLayoutView = getLayout("list_media_provider_item", inflater, container)
        val providerCheckBox = mediaProviderLayoutView.findView<CheckBox>("provider")
        providerCheckBox.makeTvCompatible()

        val domainEdit = mediaProviderLayoutView.findView<ImageView>("domain_edit")
        domainEdit.setImageDrawable(getDrawable("edit_icon"))
        domainEdit.makeTvCompatible()

        providerCheckBox.text =
                mediaProvider.name + if (mediaProvider.customDomain.isNullOrBlank()) "" else "*"
        providerCheckBox.isChecked = mediaProvider.enabled
        providerCheckBox.setOnCheckedChangeListener(
                object : OnCheckedChangeListener {
                    override fun onCheckedChanged(buttonView: CompoundButton, isChecked: Boolean) {
                        mediaProvider.enabled = isChecked
                    }
                }
        )

        // #region - Set domain and its edit + reset buttons with listeners
        val domain = mediaProviderLayoutView.findView<TextView>("domain")
        domain.text = mediaProvider.customDomain ?: mediaProvider.getDomain()
        domainEdit.setOnClickListener(
                object : OnClickListener {
                    override fun onClick(btn: View) {
                        val editText = EditText(context)
                        editText.setText(mediaProvider.getDomain())
                        editText.setInputType(InputType.TYPE_CLASS_TEXT)

                        AlertDialog.Builder(
                                        context ?: throw Exception("Unable to build alert dialog")
                                )
                                .setTitle("Update Domain")
                                .setView(editText)
                                .setPositiveButton(
                                        "Save",
                                        object : DialogInterface.OnClickListener {
                                            override fun onClick(p0: DialogInterface, p1: Int) {
                                                mediaProvider.customDomain =
                                                        editText.text.toString()
                                                domain.text = mediaProvider.getDomain()
                                                providerCheckBox.text = mediaProvider.name + "*"
                                            }
                                        }
                                )
                                .setNegativeButton(
                                        "Reset",
                                        object : DialogInterface.OnClickListener {
                                            override fun onClick(p0: DialogInterface, p1: Int) {
                                                mediaProvider.customDomain = null
                                                domain.text = mediaProvider.getDomain()
                                                providerCheckBox.text = mediaProvider.name
                                            }
                                        }
                                )
                                .show()
                    }
                }
        )
        // #endregion - Set domain and its edit + reset buttons with listeners

        return mediaProviderLayoutView
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        val settings = UltimaSettings(plugin)
        settings.show(
                activity?.supportFragmentManager
                        ?: throw Exception("Unable to open configure settings"),
                ""
        )
        super.onDetach()
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Settings/Reorder.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.res.Resources
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.graphics.drawable.Drawable
import android.graphics.drawable.LayerDrawable
import android.os.Build
import android.os.Bundle
import android.view.*
import android.widget.ImageView
import android.widget.LinearLayout
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.lifecycle.lifecycleScope
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"
private var selectedSection: UltimaUtils.SectionInfo? = null

class UltimaReorder(val plugin: UltimaBetaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val extensions = sm.fetchExtensions()
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // region - resource helpers
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        return inflater.inflate(res.getLayout(id), container, false)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null)
            ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    @SuppressLint("UseCompatLoadingForDrawables")
    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        background = res.getDrawable(outlineId, null)
    }

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val root = getLayout("reorder", inflater, container)

        val saveBtn = root.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            lifecycleScope.launch {
                withContext(Dispatchers.IO) {
                    sm.currentExtensions = extensions
                    plugin.reload()
                }

                showToast("Saved. Please restart the app to apply changes.")
                dismiss()
            }
        }

        val noSectionWarning = root.findView<TextView>("no_section_warning")
        val sectionsListView = root.findView<LinearLayout>("section_list")
        updateSectionList(sectionsListView, inflater, container, noSectionWarning)

        return root
    }

    private fun updateSectionList(
        sectionsListView: LinearLayout,
        inflater: LayoutInflater,
        container: ViewGroup?,
        noSectionWarning: TextView? = null,
        currentSections: List<UltimaUtils.SectionInfo>? = null,
        focusingSection: Int? = null,
        focusOn: String? = null,
    ) {
        sectionsListView.removeAllViews()

        val sections = currentSections ?: run {
            var freshSections = emptyList<UltimaUtils.SectionInfo>()
            extensions.forEach { ext ->
                ext.sections?.filter { it.enabled }?.let { freshSections += it }
            }
            freshSections
        }

        if (sections.isEmpty()) {
            noSectionWarning?.visibility = View.VISIBLE
            return
        }

        val sortedSections = sections.sortedByDescending { it.priority }
        var counter = sortedSections.size

        val displaySections = (currentSections ?: run {
            val freshSections = emptyList<UltimaUtils.SectionInfo>().toMutableList()
            extensions.forEach { ext ->
                ext.sections?.filter { it.enabled }?.let { freshSections += it }
            }
            freshSections
        }).sortedByDescending { it.priority }

        if (displaySections.isEmpty()) {
            noSectionWarning?.visibility = View.VISIBLE
            return
        }

        displaySections.forEach { section ->
            val sectionView = getLayout("list_section_reorder_item", inflater, container)
            val sectionName = sectionView.findView<TextView>("section_name")

            if (section.priority == 0) section.priority = counter
            sectionName.text = "${section.pluginName}: ${section.name}"

            sectionView.background = LayerDrawable(
                arrayOf(
                    ColorDrawable(if (section == selectedSection) 0x2200FF00.toInt() else Color.TRANSPARENT),
                    getDrawable("outline")
                )
            )

            sectionView.setOnClickListener {
                when (selectedSection) {
                    null -> {
                        selectedSection = section
                        showToast("Picked! Now tap a target.")
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            displaySections
                        )
                    }
                    section -> {
                        selectedSection = null
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            displaySections
                        )
                    }
                    else -> {
                        val selected = selectedSection!!
                        val sectionsMutable = displaySections.toMutableList()

                        val selectedIndex = sectionsMutable.indexOf(selected)
                        val targetIndex = sectionsMutable.indexOf(section)

                        if (selectedIndex == targetIndex) {
                            showToast("Already in this position")
                            return@setOnClickListener
                        }

                        sectionsMutable.removeAt(selectedIndex)
                        sectionsMutable.add(targetIndex, selected)

                        sectionsMutable.forEachIndexed { index, sec ->
                            sec.priority = sectionsMutable.size - index
                        }

                        selectedSection = null
                        updateSectionList(
                            sectionsListView,
                            inflater,
                            container,
                            noSectionWarning,
                            sectionsMutable
                        )
                        showToast("Section moved to position ${targetIndex + 1}")
                    }
                }

                sectionsListView.post {
                    for (i in 0 until sectionsListView.childCount) {
                        val child = sectionsListView.getChildAt(i)
                        val nameView = child.findView<TextView>("section_name")
                        if (nameView.text.contains(section.name, ignoreCase = true)) {
                            child.requestFocus()
                            break
                        }
                    }
                }
            }

            val increaseBtn = sectionView.findView<ImageView>("increase")
            val decreaseBtn = sectionView.findView<ImageView>("decrease")
            increaseBtn.setImageDrawable(getDrawable("triangle"))
            decreaseBtn.setImageDrawable(getDrawable("triangle"))
            decreaseBtn.rotation = 180f

            increaseBtn.makeTvCompatible()
            decreaseBtn.makeTvCompatible()

            increaseBtn.setOnClickListener {
                val idx = displaySections.indexOf(section)
                if (idx > 0) {
                    val newList = displaySections.toMutableList()
                    newList.removeAt(idx)
                    newList.add(idx - 1, section)
                    newList.forEachIndexed { index, sec -> sec.priority = newList.size - index }
                    increaseBtn.contentDescription = "Move ${section.name} up"
                    updateSectionList(sectionsListView, inflater, container, noSectionWarning, newList)

                    sectionsListView.post {
                        for (i in 0 until sectionsListView.childCount) {
                            val child = sectionsListView.getChildAt(i)
                            val nameView = child.findView<TextView>("section_name")
                            if (nameView.text.contains(section.name, ignoreCase = true)) {
                                child.findView<ImageView>("increase").requestFocus()
                                break
                            }
                        }
                    }
                } else {
                    showToast("Already at the top")
                }
            }

            decreaseBtn.setOnClickListener {
                val idx = displaySections.indexOf(section)
                if (idx < displaySections.lastIndex) {
                    val newList = displaySections.toMutableList()
                    newList.removeAt(idx)
                    newList.add(idx + 1, section)
                    newList.forEachIndexed { index, sec -> sec.priority = newList.size - index }
                    decreaseBtn.contentDescription = "Move ${section.name} down"
                    updateSectionList(sectionsListView, inflater, container, noSectionWarning, newList)

                    sectionsListView.post {
                        for (i in 0 until sectionsListView.childCount) {
                            val child = sectionsListView.getChildAt(i)
                            val nameView = child.findView<TextView>("section_name")
                            if (nameView.text.contains(section.name, ignoreCase = true)) {
                                // Focus back to decrease button inside this row
                                child.findView<ImageView>("decrease").requestFocus()
                                break
                            }
                        }
                    }
                } else {
                    showToast("Already at the bottom")
                }
            }

            counter -= 1
            sectionsListView.addView(sectionView)
        }
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}

    override fun onDetach() {
        super.onDetach()
        UltimaSettings(plugin).show(
            activity?.supportFragmentManager
                ?: throw Exception("Unable to open configure settings"),
            ""
        )
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Settings/Settings.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.content.Intent
import android.content.res.Resources
import android.graphics.drawable.Drawable
import android.os.Build
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AlertDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.lagradost.cloudstream3.CommonActivity.showToast
import com.lagradost.cloudstream3.utils.AppContextUtils.setDefaultFocus
import com.phisher98.BuildConfig
import androidx.core.net.toUri

private const val ARG_PARAM1 = "param1"
private const val ARG_PARAM2 = "param2"

class UltimaSettings(val plugin: UltimaBetaPlugin) : BottomSheetDialogFragment() {
    private var param1: String? = null
    private var param2: String? = null
    private val sm = UltimaStorageManager
    private val res: Resources = plugin.resources ?: throw Exception("Unable to read resources")

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        arguments?.let {
            param1 = it.getString(ARG_PARAM1)
            param2 = it.getString(ARG_PARAM2)
        }
    }

    // #region - necessary functions
    private fun getLayout(name: String, inflater: LayoutInflater, container: ViewGroup?): View {
        val id = res.getIdentifier(name, "layout", BuildConfig.LIBRARY_PACKAGE_NAME)
        val layout = res.getLayout(id)
        return inflater.inflate(layout, container, false)
    }

    private fun getDrawable(name: String): Drawable {
        val id = res.getIdentifier(name, "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getDrawable(id, null) ?: throw Exception("Unable to find drawable $name")
    }

    private fun getString(name: String): String {
        val id = res.getIdentifier(name, "string", BuildConfig.LIBRARY_PACKAGE_NAME)
        return res.getString(id)
    }

    private fun <T : View> View.findView(name: String): T {
        val id = res.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return this.findViewById(id)
    }

    private fun View.makeTvCompatible() {
        val outlineId = res.getIdentifier("outline", "drawable", BuildConfig.LIBRARY_PACKAGE_NAME)
        this.background = res.getDrawable(outlineId, null)
    }
    // #endregion - necessary functions

    @SuppressLint("SetTextI18n")
    override fun onCreateView(
            inflater: LayoutInflater,
            container: ViewGroup?,
            savedInstanceState: Bundle?
    ): View? {
        val settings = getLayout("settings", inflater, container)

        // #region - building save button and its click listener
        val saveBtn = settings.findView<ImageView>("save")
        saveBtn.setImageDrawable(getDrawable("save_icon"))
        saveBtn.makeTvCompatible()
        saveBtn.setOnClickListener {
            AlertDialog.Builder(requireContext())
                .setTitle("Restart Required")
                .setMessage("Changes have been saved. Do you want to restart the app to apply them ?")
                .setPositiveButton("Yes") { _, _ ->
                    plugin.reload()
                    showToast("Saved and Restarting...")
                    dismiss()
                    restartApp()
                }
                .setNegativeButton("No") { dialog, _ ->
                    showToast("Saved. Restart later to apply changes.")
                    dialog.dismiss()
                    dismiss()
                }.show()
        }
        // #endregion - building save button and its click listener

        // #region - building meta providers button and its click listener
        val metaProvidersBtn = settings.findView<ImageView>("meta_providers_img")
        metaProvidersBtn.setImageDrawable(getDrawable("edit_icon"))
        metaProvidersBtn.makeTvCompatible()
        metaProvidersBtn.setOnClickListener {
            val configure = UltimaMetaProviders(plugin)
            configure.show(
                activity?.supportFragmentManager
                    ?: throw Exception(
                        "Unable to open meta providers settings"
                    ),
                ""
            )
            dismiss()
        }
        // #endregion - building meta providers button and its click listener

        // #region - building config extensions button and its click listener
        val configBtn = settings.findView<ImageView>("config_img")
        configBtn.setImageDrawable(getDrawable("edit_icon"))
        configBtn.makeTvCompatible()
        configBtn.setOnClickListener {
            val configure = UltimaConfigureExtensions(plugin)
            configure.show(
                activity?.supportFragmentManager
                    ?: throw Exception(
                        "Unable to open configure extensions settings"
                    ),
                ""
            )
            dismiss()
        }
        // #endregion - building config extensions button and its click listener

        // #region - building reorder button and its click listener
        val reorderBtn = settings.findView<ImageView>("reorder_img")
        reorderBtn.setImageDrawable(getDrawable("edit_icon"))
        reorderBtn.makeTvCompatible()
        reorderBtn.setOnClickListener {
            val reorder = UltimaReorder(plugin)
            reorder.show(
                activity?.supportFragmentManager
                    ?: throw Exception("Unable to open reorder settings"),
                ""
            )
            dismiss()
        }
        // #endregion - building reorder button and its click listener

        // #region - building reorder button and its click listener
        val watchSyncBtn = settings.findView<ImageView>("watch_sync_img")
        watchSyncBtn.setImageDrawable(getDrawable("edit_icon"))
        watchSyncBtn.makeTvCompatible()
        watchSyncBtn.setOnClickListener {
            val reorder = UltimaConfigureWatchSync(plugin)
            reorder.show(
                activity?.supportFragmentManager
                    ?: throw Exception("Unable to open reorder settings"),
                ""
            )
            dismiss()
        }
        // #endregion - building reorder button and its click listener

        val guideIcon = settings.findView<ImageView>("guide_icon")
        guideIcon.setImageDrawable(getDrawable("ic_eye"))
        guideIcon.makeTvCompatible()
        guideIcon.setOnClickListener {
            val url = "https://github.com/phisher98/cloudstream-extensions-phisher/blob/master/docs/ULTIMA_SYNC_SETUP.md"
            val intent = Intent(Intent.ACTION_VIEW, url.toUri())
            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
            activity?.startActivity(intent)
        }

        // #region - building delete button with its click listener
        val deleteBtn = settings.findView<TextView>("delete_img")

        deleteBtn.text = "Reset"
        deleteBtn.makeTvCompatible()

        deleteBtn.setOnClickListener {
            AlertDialog.Builder(
                context ?: throw Exception("Unable to build alert dialog")
            )
                .setTitle("Reset Ultima")
                .setMessage("This will delete all selected sections.")
                .setPositiveButton("Reset") { _, _ ->
                    sm.deleteAllData()
                    plugin.reload()
                    showToast("Sections cleared")
                    dismiss()
                }
                .setNegativeButton("Cancel", null)
                .show()
                .setDefaultFocus()
        }
        // #endregion - building delete button with its click listener

        return settings
    }

    @RequiresApi(Build.VERSION_CODES.M)
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {}


    private fun restartApp() {
        val context = requireContext().applicationContext
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Utils/StorageManager.kt
================================================
package com.phisher98

// import com.phisher98.UltimaUtils.Provider

import com.lagradost.api.Log
import com.phisher98.UltimaUtils.ExtensionInfo
import com.phisher98.UltimaUtils.MediaProviderState
import com.phisher98.UltimaUtils.SectionInfo
import com.phisher98.WatchSyncUtils.WatchSyncCreds
import com.lagradost.cloudstream3.APIHolder.allProviders
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.AcraApplication.Companion.setKey

object UltimaStorageManager {

    // #region - custom data variables

    var extNameOnHome: Boolean
        get() = getKey("ULTIMA_EXT_NAME_ON_HOME") ?: true
        set(value) {
            setKey("ULTIMA_EXT_NAME_ON_HOME", value)
        }

    var currentExtensions: Array<ExtensionInfo>
        get() = getKey("ULTIMA_EXTENSIONS_LIST") ?: emptyArray<ExtensionInfo>()
        set(value) {
            setKey("ULTIMA_EXTENSIONS_LIST", value)
        }

    var currentMetaProviders: Array<Pair<String, Boolean>>
        get() = listMetaProviders()
        set(value) {
            setKey("ULTIMA_CURRENT_META_PROVIDERS", value)
        }

    var currentMediaProviders: Array<MediaProviderState>
        get() = listMediaProviders()
        set(value) {
            setKey("ULTIMA_CURRENT_MEDIA_PROVIDERS", value)
        }

    var deviceSyncCreds: WatchSyncCreds?
        get() = getKey("ULTIMA_WATCH_SYNC_CREDS")
        set(value) {
            setKey("ULTIMA_WATCH_SYNC_CREDS", value)
        }

    // #endregion - custom data variables

    fun deleteAllData() {
        listOf(
                        "ULTIMA_PROVIDER_LIST", // old key
                        "ULTIMA_EXT_NAME_ON_HOME",
                        "ULTIMA_EXTENSIONS_LIST",
                        "ULTIMA_CURRENT_META_PROVIDERS",
                        "ULTIMA_CURRENT_MEDIA_PROVIDERS",
                        "ULTIMA_WATCH_SYNC_CREDS"
                )
                .forEach { setKey(it, null) }
    }


    fun fetchExtensions(): Array<ExtensionInfo> = synchronized(allProviders) {
        val cachedExtensions = getKey<Array<ExtensionInfo>>("ULTIMA_EXTENSIONS_LIST")
        val providers = allProviders.filter { it.name != "Ultima Beta" }

        providers.map { provider ->
            val existing = cachedExtensions?.find { it.name == provider.name }
            existing ?: ExtensionInfo(
                name = provider.name,
                provider.mainPage.map { section ->
                    SectionInfo(
                        name = section.name,
                        section.data,
                        provider.name,
                        false
                    )
                }.toTypedArray()
            )
        }.toTypedArray()
    }


    private fun listMetaProviders(): Array<Pair<String, Boolean>> {
        val currentProviders = UltimaMetaProviderUtils.metaProviders
        val storedProviders = getKey<Array<Pair<String, Boolean>>>("ULTIMA_CURRENT_META_PROVIDERS")
            ?: return currentProviders

        val currentNames = currentProviders.map { it.first }.sorted()
        val storedNames = storedProviders.map { it.first }.sorted()

        // If the names match (ignoring order), use the stored version
        if (currentNames == storedNames) return storedProviders

        // Merge stored flags if available, otherwise use default
        return currentProviders.map { provider ->
            storedProviders.find { it.first == provider.first } ?: provider
        }.toTypedArray()
    }


    private fun listMediaProviders(): Array<MediaProviderState> {
        val currentProviderNames = UltimaMediaProvidersUtils.mediaProviders.map { it.name }
        val stored = getKey<Array<MediaProviderState>>("ULTIMA_CURRENT_MEDIA_PROVIDERS")
            ?: return currentProviderNames.map { MediaProviderState(it, enabled = true, null) }.toTypedArray()

        val storedNames = stored.map { it.name }.sorted()
        if (currentProviderNames.sorted() == storedNames) return stored

        return currentProviderNames.map { name ->
            stored.find { it.name == name } ?: MediaProviderState(name, enabled = true,  null)
        }.toTypedArray()
    }

}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Utils/UltimaUtils.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.app
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.awaitAll
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit

object UltimaUtils {
    data class SectionInfo(
            @JsonProperty("name") var name: String,
            @JsonProperty("url") var url: String,
            @JsonProperty("pluginName") var pluginName: String,
            @JsonProperty("enabled") var enabled: Boolean = false,
            @JsonProperty("priority") var priority: Int = 0
    )

    data class ExtensionInfo(
            @JsonProperty("name") var name: String? = null,
            @JsonProperty("sections") var sections: Array<SectionInfo>? = null
    )

    enum class Category {
        ANIME,
        MEDIA,
        NONE
    }

    data class MediaProviderState(
            @JsonProperty("name") var name: String,
            @JsonProperty("enabled") var enabled: Boolean = true,
            @JsonProperty("customDomain") var customDomain: String? = null
    ) {
        fun getProvider(): MediaProvider {
            return UltimaMediaProvidersUtils.mediaProviders.find { it.name.equals(name) }
                    ?: throw Exception("Unable to find media provider for $name")
        }

        fun getDomain(): String {
            return customDomain ?: getProvider().domain
        }
    }

    data class LinkData(
        @JsonProperty("simklId") val simklId: Int? = null,
        @JsonProperty("traktId") val traktId: Int? = null,
        @JsonProperty("imdbId") val imdbId: String? = null,
        @JsonProperty("tmdbId") val tmdbId: Int? = null,
        @JsonProperty("tvdbId") val tvdbId: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("aniId") val aniId: Int? = null,
        @JsonProperty("malId") val malId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("orgTitle") val orgTitle: String? = null,
        @JsonProperty("isAnime") val isAnime: Boolean = false,
        @JsonProperty("airedYear") val airedYear: Int? = null,
        @JsonProperty("lastSeason") val lastSeason: Int? = null,
        @JsonProperty("epsTitle") val epsTitle: String? = null,
        @JsonProperty("jpTitle") val jpTitle: String? = null,
        @JsonProperty("date") val date: String? = null,
        @JsonProperty("airedDate") val airedDate: String? = null,
        @JsonProperty("isAsian") val isAsian: Boolean = false,
        @JsonProperty("isBollywood") val isBollywood: Boolean = false,
        @JsonProperty("isCartoon") val isCartoon: Boolean = false,
        @JsonProperty("isDub") val isDub: Boolean = false,
    )
}

suspend fun <T> retry(
    times: Int = 3,
    delayMillis: Long = 1000,
    block: suspend () -> T
): T? {
    repeat(times - 1) {
        runCatching { return block() }.onFailure { delay(delayMillis) }
    }
    return runCatching { block() }.getOrNull()
}

data class DomainsParser(
    val moviesdrive: String,
    @JsonProperty("HDHUB4u")
    val hdhub4u: String,
    @JsonProperty("4khdhub")
    val n4khdhub: String,
    @JsonProperty("MultiMovies")
    val multiMovies: String,
    val bollyflix: String,
    @JsonProperty("UHDMovies")
    val uhdmovies: String,
    val moviesmod: String,
    val topMovies: String,
    val hdmovie2: String,
    val vegamovies: String,
    val rogmovies: String,
    val luxmovies: String,
    val xprime: String,
    val extramovies:String,
    val dramadrip:String
)

// ----------- Constants and Cache -----------
private var cachedDomains: DomainsParser? = null
private const val DOMAINS_URL =
    "https://raw.githubusercontent.com/phisher98/TVVVV/main/domains.json"

// ----------- Domain Fetch Function -----------
suspend fun getDomains(forceRefresh: Boolean = false): DomainsParser? {
    if (cachedDomains == null || forceRefresh) {
        try {
            val response = app.get(DOMAINS_URL)
            cachedDomains = response.parsedSafe<DomainsParser>()
            if (cachedDomains == null) {
                Log.e("getDomains", "Parsed domains are null. Possibly malformed JSON.")
            }
        } catch (e: Exception) {
            Log.e("getDomains", "Error fetching/parsing domains: ${e.message}")
            return null
        }
    }
    return cachedDomains
}

suspend fun <T> runLimitedParallel(
    limit: Int = 4,
    blockList: List<suspend () -> T>
): List<T> {
    val semaphore = Semaphore(limit)
    return coroutineScope {
        blockList.map { block ->
            async(Dispatchers.IO) {
                semaphore.withPermit { block() }
            }
        }.awaitAll()
    }
}

fun cleanTitle(title: String): String {
    val parts = title.split(".", "-", "_")

    val qualityTags = listOf(
        "WEBRip", "WEB-DL", "WEB", "BluRay", "HDRip", "DVDRip", "HDTV",
        "CAM", "TS", "R5", "DVDScr", "BRRip", "BDRip", "DVD", "PDTV",
        "HD"
    )

    val audioTags = listOf(
        "AAC", "AC3", "DTS", "MP3", "FLAC", "DD5", "EAC3", "Atmos"
    )

    val subTags = listOf(
        "ESub", "ESubs", "Subs", "MultiSub", "NoSub", "EnglishSub", "HindiSub"
    )

    val codecTags = listOf(
        "x264", "x265", "H264", "HEVC", "AVC"
    )

    val startIndex = parts.indexOfFirst { part ->
        qualityTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    val endIndex = parts.indexOfLast { part ->
        subTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                audioTags.any { tag -> part.contains(tag, ignoreCase = true) } ||
                codecTags.any { tag -> part.contains(tag, ignoreCase = true) }
    }

    return if (startIndex != -1 && endIndex != -1 && endIndex >= startIndex) {
        parts.subList(startIndex, endIndex + 1).joinToString(".")
    } else if (startIndex != -1) {
        parts.subList(startIndex, parts.size).joinToString(".")
    } else {
        parts.takeLast(3).joinToString(".")
    }
}



================================================
FILE: UltimaBeta/src/main/kotlin/com/phisher98/Utils/WatchSyncUtils.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.AcraApplication
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.base64Encode
import com.lagradost.cloudstream3.mapper
import com.lagradost.cloudstream3.ui.home.HomeViewModel.Companion.getResumeWatching
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.DataStore.getSharedPrefs
import com.lagradost.cloudstream3.utils.DataStoreHelper.ResumeWatchingResult
import com.phisher98.UltimaStorageManager as sm

object WatchSyncUtils {

    data class WatchSyncCreds(
        @JsonProperty("token") var token: String? = null,
        @JsonProperty("projectNum") var projectNum: Int? = null,
        @JsonProperty("deviceName") var deviceName: String? = null,
        @JsonProperty("deviceId") var deviceId: String? = null,  // draftIssueID
        @JsonProperty("itemId") var itemId: String? = null,       // projectItemID
        @JsonProperty("projectId") var projectId: String? = null,
        @JsonProperty("isThisDeviceSync") var isThisDeviceSync: Boolean = false,
        @JsonProperty("enabledDevices") var enabledDevices: MutableList<String>? = null
    ) {

        // --- API Response Models ---
        data class APIRes(@JsonProperty("data") var data: Data) {
            data class Data(
                @JsonProperty("viewer") var viewer: Viewer?,
                @JsonProperty("addProjectV2DraftIssue") var issue: Issue?,
                @JsonProperty("deleteProjectV2Item") var delItem: DelItem?
            ) {
                data class Viewer(@JsonProperty("projectV2") var projectV2: ProjectV2) {
                    data class ProjectV2(
                        @JsonProperty("id") var id: String,
                        @JsonProperty("items") var items: Items?
                    ) {
                        data class Items(
                            @JsonProperty("nodes") var nodes: Array<Node>?,
                        ) {
                            data class Node(
                                @JsonProperty("id") var id: String,
                                @JsonProperty("content") var content: Content
                            ) {
                                data class Content(
                                    @JsonProperty("id") var id: String,
                                    @JsonProperty("title") var title: String,
                                    @JsonProperty("bodyText") var bodyText: String,
                                )
                            }
                        }
                    }
                }

                data class Issue(@JsonProperty("projectItem") var projectItem: ProjectItem) {
                    data class ProjectItem(
                        @JsonProperty("id") var id: String,
                        @JsonProperty("content") var content: Content
                    ) {
                        data class Content(@JsonProperty("id") var id: String)
                    }
                }

                data class DelItem(@JsonProperty("deletedItemId") var deletedItemId: String)
            }
        }

        data class SyncDevice(
            @JsonProperty("name") var name: String,
            @JsonProperty("deviceId") var deviceId: String,
            @JsonProperty("itemId") var itemId: String,
            @JsonProperty("payload") var payload: SyncPayload? = null
        )

        data class SyncPayload(
            @JsonProperty("resumeWatching") val resumeWatching: List<ResumeWatchingResult>? = null,
            @JsonProperty("data") val data: Map<String, String>? = null,
            @JsonProperty("extensions") val extensions: Array<UltimaUtils.ExtensionInfo>? = null,
            @JsonProperty("metaProviders") val metaProviders: Array<Pair<String, Boolean>>? = null,
            @JsonProperty("mediaProviders") val mediaProviders: Array<UltimaUtils.MediaProviderState>? = null,
            val extNameOnHome: Boolean? = null,
        )

        private val apiUrl = "https://api.github.com/graphql"

        private fun Any.toStringData(): String = mapper.writeValueAsString(this)

        private fun isLoggedIn(): Boolean {
            return !(token.isNullOrEmpty() ||
                    projectNum == null ||
                    deviceName.isNullOrEmpty() ||
                    projectId.isNullOrEmpty())
        }

        private suspend fun apiCall(query: String): APIRes? {
            val header = mapOf(
                "Content-Type" to "application/json",
                "Authorization" to "Bearer " + (token ?: return null)
            )
            val data = """ { "query": $query } """
            val test = app.post(apiUrl, headers = header, json = data)
            return test.parsedSafe<APIRes>()
        }

        private val nonTransferableKeys = listOf(
            "result_resume_watching_migrated",
        )

        private fun String.isResume(): Boolean {
            return !nonTransferableKeys.any { this.contains(it) }
        }

        private fun String.isBackup(resumeWatching: List<ResumeWatchingResult>? = null): Boolean {
            var check = !nonTransferableKeys.any { this.contains(it) }
            if (check) {
                when {
                    this.contains("download_header_cache") -> {
                        val id = this.split("/").getOrNull(1)?.toIntOrNull()
                        check = id?.let { intId ->
                            resumeWatching?.any { if (it.parentId != null) it.parentId == intId else it.id == intId } == true
                        } ?: false
                    }
                    this.contains("video_pos_dur") -> {
                        val id = this.split("/").getOrNull(2)?.toIntOrNull()
                        check = id?.let { intId ->
                            resumeWatching?.any { it.id == intId } == true
                        } ?: false
                    }
                    this.contains("result_season") || this.contains("result_dub") || this.contains("result_episode") -> {
                        val id = this.split("/").getOrNull(2)?.toIntOrNull()
                        check = id?.let { intId ->
                            resumeWatching?.any { it.parentId == intId } == true
                        } ?: false
                    }
                }
            }
            return check
        }

        /** Build JSON with all fields we want to sync */
        private suspend fun buildSyncJson(): String {
            val context = AcraApplication.context
            val sharedPrefs = context?.getSharedPrefs()

            // Only keep keys that are not non-transferable
            val filteredPrefs = sharedPrefs?.all
                ?.filter { (key, _) ->
                    (key.contains("resume") || key.contains("download")) &&
                            key.isResume() &&
                            key.isBackup(getResumeWatching())
                }
                ?.toMap()
            Log.d("Phisher shared", filteredPrefs.toString())

            val map = mapOf(
                "resumeWatching" to getResumeWatching(),
                "data" to filteredPrefs,
                "extNameOnHome" to sm.extNameOnHome,
                "extensions" to sm.currentExtensions,
                "metaProviders" to sm.currentMetaProviders,
                "mediaProviders" to sm.currentMediaProviders
            )

            return mapper.writeValueAsString(map)
        }


        // --- API Methods ---
        suspend fun syncProjectDetails(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            val query =
                """ query Viewer { viewer { projectV2(number: ${projectNum ?: return failure}) { id } } } """
            val res = apiCall(query.toStringData()) ?: return failure
            projectId = res.data.viewer?.projectV2?.id ?: return failure
            sm.deviceSyncCreds = this
            return true to "Project details saved"
        }

        suspend fun registerThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn()) return failure

            val data = base64Encode(buildSyncJson().toByteArray())
            val query =
                """ mutation AddProjectV2DraftIssue {
                    addProjectV2DraftIssue(
                        input: { projectId: "$projectId", title: "$deviceName", body: "$data" }
                    ) { projectItem { id content { ... on DraftIssue { id } } } }
                } """

            val res = apiCall(query.toStringData()) ?: return failure
            itemId = res.data.issue?.projectItem?.id ?: return failure
            deviceId = res.data.issue?.projectItem?.content?.id ?: return failure
            isThisDeviceSync = true
            sm.deviceSyncCreds = this
            return true to "Device is registered"
        }

        suspend fun deregisterThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn()) return failure

            val query =
                """ mutation DeleteIssue {
                    deleteProjectV2Item(input: { projectId: "$projectId", itemId: "$itemId" }) {
                        deletedItemId
                    }
                } """

            val res = apiCall(query.toStringData()) ?: return failure
            return if (res.data.delItem?.deletedItemId.equals(itemId)) {
                itemId = null
                deviceId = null
                isThisDeviceSync = false
                sm.deviceSyncCreds = this
                true to "Device de-registered"
            } else failure
        }

        suspend fun syncThisDevice(): Pair<Boolean, String?> {
            val failure = false to "something went wrong"
            if (!isLoggedIn() || !isThisDeviceSync) return failure

            val data = base64Encode(buildSyncJson().toByteArray())
            val query =
                """ mutation UpdateProjectV2DraftIssue {
                    updateProjectV2DraftIssue(
                        input: { draftIssueId: "$deviceId", title: "$deviceName", body: "$data" }
                    ) { draftIssue { id } }
                } """

            apiCall(query.toStringData()) ?: return failure
            return true to "sync complete"
        }

        suspend fun fetchDevices(): List<SyncDevice>? {
            if (!isLoggedIn()) return null

            val query =
                """ query User {
                    viewer {
                        projectV2(number: ${projectNum ?: return null}) {
                            id
                            items(first: 50) {
                                nodes { id content { ... on DraftIssue { id title bodyText } } }
                                totalCount
                            }
                        }
                    }
                } """

            val res = apiCall(query.toStringData()) ?: return null

            return res.data.viewer?.projectV2?.items?.nodes?.mapNotNull { node ->
                val raw = base64Decode(node.content.bodyText)
                val payload = runCatching {
                    parseJson<SyncPayload?>(raw) ?: run {
                        val oldResume = parseJson<List<ResumeWatchingResult>?>(raw)
                        SyncPayload(resumeWatching = oldResume)
                    }
                }.getOrElse {
                    Log.e("fetchDevices", "Failed to parse payload for ${node.content.title}: ${it.message}")
                    null
                }

                payload?.let {
                    SyncDevice(
                        name = node.content.title,
                        deviceId = node.content.id,
                        itemId = node.id,
                        payload = it
                    )
                }
            }?.also { Log.i("fetchDevices", "Fetched ${it.size} devices") }
        }
    }
}



================================================
FILE: UltimaBeta/src/main/res/drawable/delete_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48">
    <path
        android:fillColor="#FFFFFFFF"
        android:pathData="M12.95,42.8 C11.5,42.8 10.4,41.7 10.4,39.15 V10.4 H8.75 C8,10.4 7.475,9.85 7.475,8.55 C7.475,7.8 8,6.75 8.75,6.75 H17.35 C17.35,6 17.875,5.525 19.15,5.05 H28.9 C29.65,5.05 30.175,6 30.7,6.75 H39.3 C40.05,6.75 40.6,7.8 40.6,8.55 C40.6,9.3 40.05,10.4 39.3,10.4 H38.75 V39.15 C38.75,40.6 37.65,41.7 35.1,42.8 Z M12.95,10.4 V39.15 H35.1 V10.4 Z M17.85,33 C17.85,33.75 18.375,34.275 19.65,34.8 C20.4,34.8 20.95,33.75 21.5,33 V16.5 C21.5,15.75 20.95,15.2 19.65,14.65 C18.9,14.65 17.85,15.75 17.85,16.5 Z M26.6,33 C26.6,33.75 27.125,34.275 28.4,34.8 C29.15,34.8 30.25,33.75 30.25,33 V16.5 C30.25,15.75 29.7,15.2 28.4,14.65 C27.65,14.65 26.6,15.75 26.6,16.5 Z" />
</vector>



================================================
FILE: UltimaBeta/src/main/res/drawable/edit_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M27.6,44.8H20.4Q19.7,44.8 19.175,44.4Q18.65,44 18.6,43.3L17.8,38.3Q17,38 16.025,37.475Q15.05,36.95 14.35,36.35L9.75,38.45Q9.15,38.8 8.45,38.55Q7.75,38.3 7.4,37.65L3.8,31.15Q3.4,30.55 3.6,29.9Q3.8,29.25 4.35,28.85L8.5,25.75Q8.45,25.4 8.425,24.85Q8.4,24.3 8.4,23.9Q8.4,23.55 8.425,23.025Q8.45,22.5 8.5,22.1L4.35,19.1Q3.75,18.7 3.6,18.025Q3.45,17.35 3.8,16.75L7.4,10.3Q7.8,9.7 8.45,9.45Q9.1,9.2 9.75,9.5L14.25,11.6Q14.95,11.05 15.95,10.475Q16.95,9.9 17.8,9.6L18.6,4.65Q18.65,3.95 19.175,3.55Q19.7,3.15 20.4,3.15H27.6Q28.3,3.15 28.825,3.55Q29.35,3.95 29.45,4.65L30.2,9.6Q31.05,9.9 32.075,10.475Q33.1,11.05 33.75,11.6L38.25,9.5Q38.85,9.2 39.55,9.45Q40.25,9.7 40.6,10.3L44.2,16.7Q44.55,17.3 44.4,18Q44.25,18.7 43.7,19.1L39.45,22.05Q39.5,22.5 39.55,23.05Q39.6,23.6 39.6,24Q39.6,24.4 39.55,24.925Q39.5,25.45 39.5,25.85L43.65,28.85Q44.2,29.25 44.375,29.925Q44.55,30.6 44.2,31.2L40.6,37.7Q40.2,38.35 39.525,38.575Q38.85,38.8 38.25,38.45L33.65,36.35Q32.95,36.9 32,37.475Q31.05,38.05 30.25,38.3L29.45,43.3Q29.35,44 28.825,44.4Q28.3,44.8 27.6,44.8ZM23.95,31.15Q26.95,31.15 29.05,29.05Q31.15,26.95 31.15,23.95Q31.15,20.95 29.05,18.85Q26.95,16.75 23.95,16.75Q20.95,16.75 18.85,18.85Q16.75,20.95 16.75,23.95Q16.75,26.95 18.85,29.05Q20.95,31.15 23.95,31.15ZM23.9,27.5Q22.45,27.5 21.425,26.45Q20.4,25.4 20.4,23.95Q20.4,22.45 21.425,21.425Q22.45,20.4 23.95,20.4Q25.4,20.4 26.45,21.45Q27.5,22.5 27.5,23.95Q27.5,25.45 26.45,26.475Q25.4,27.5 23.9,27.5ZM24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95Q24,23.95 24,23.95ZM21.8,41.15H26.2L26.9,35.5Q28.6,35.1 30.1,34.25Q31.6,33.4 32.85,32.15L38.1,34.45L40.1,30.85L35.45,27.4Q35.65,26.55 35.8,25.7Q35.95,24.85 35.95,23.95Q35.95,23.05 35.825,22.225Q35.7,21.4 35.5,20.5L40.1,17.1L38.15,13.5L32.85,15.75Q31.7,14.45 30.2,13.525Q28.7,12.6 26.9,12.35L26.25,6.8H21.75L21.1,12.35Q19.3,12.75 17.775,13.625Q16.25,14.5 15.1,15.75L9.9,13.5L7.85,17.1L12.5,20.55Q12.3,21.45 12.175,22.275Q12.05,23.1 12.05,23.9Q12.05,24.75 12.175,25.6Q12.3,26.45 12.5,27.4L7.85,30.85L9.9,34.45L15.15,32.15Q16.45,33.45 17.95,34.3Q19.45,35.15 21.1,35.55Z" />
</vector>


================================================
FILE: UltimaBeta/src/main/res/drawable/ic_eye.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="48"
    android:viewportHeight="48"
    android:tint="@android:color/white">

    <path
        android:fillColor="@android:color/white"
        android:pathData="M24,4C12.95,4 4,12.95 4,24s8.95,20 20,20 20,-8.95 20,-20S35.05,4 24,4zM26,34h-4V20h4v14zM26,16h-4v-4h4v4z"/>
</vector>



================================================
FILE: UltimaBeta/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="2dp"
                android:bottomRightRadius="2dp"
                android:topLeftRadius="2dp"
                android:topRightRadius="2dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: UltimaBeta/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
  android:width="24dp"
  android:height="24dp"
  android:viewportWidth="24"
  android:viewportHeight="24"
  android:tint="@android:color/white">
  <path
    android:fillColor="@android:color/white"
    android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: UltimaBeta/src/main/res/drawable/triangle.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="15dp"
    android:height="15dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M24 22h-24l12-20z" />
</vector>


================================================
FILE: UltimaBeta/src/main/res/layout/configure_extensions.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Configure Extension Sections"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp" />

            </LinearLayout>

        </LinearLayout>

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:textSize="14sp"
            android:text="set priority next to section (higher number to stay on top)" />

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <Switch
            android:id="@+id/ext_name_on_home_toggle"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:textSize="17sp"
            android:padding="5dp"
            android:text="Include extension name on home screen"
            android:focusable="true" />

        <LinearLayout
            android:id="@+id/extensions_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: UltimaBeta/src/main/res/layout/configure_watch_sync.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <!-- Header Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical"
            android:layout_marginTop="20dp"
            android:layout_marginBottom="5dp">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Sync Watch History"
                android:textSize="20sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/save"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="5dp"
                android:contentDescription="Save"
                android:focusable="true" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Credentials Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp"
            android:gravity="center_vertical">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:text="Login data"
                android:textSize="18sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/watch_sync_creds_btn"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="5dp"
                android:contentDescription="Edit"
                android:focusable="true" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Sync Toggle -->
        <Switch
            android:id="@+id/sync_this_device"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Sync this device"
            android:textSize="17sp"
            android:padding="5dp"
            android:layout_marginVertical="5dp" />

        <!-- Divider -->
        <ImageView
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginVertical="10dp"
            android:paddingStart="2dp"
            android:paddingEnd="2dp"
            android:scaleType="fitXY"
            android:src="@android:drawable/divider_horizontal_dark" />

        <!-- Device List Header -->
        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Devices"
            android:textSize="18sp"
            android:layout_marginBottom="5dp" />

        <!-- Devices List -->
        <LinearLayout
            android:id="@+id/devices_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp" />

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: UltimaBeta/src/main/res/layout/list_extension_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <LinearLayout
        android:id="@+id/extension_data"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:focusable="true">

        <ImageView
            android:id="@+id/expand_icon"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/extension_name"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="parent_name"
            android:textSize="16sp"
            android:textStyle="bold"
            android:layout_marginLeft="10dp" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/sections_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginStart="10dp"
        android:visibility="gone"
        android:paddingBottom="10dp">
    </LinearLayout>

</LinearLayout>


================================================
FILE: UltimaBeta/src/main/res/layout/list_media_provider_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="horizontal">

    <CheckBox
        android:id="@+id/provider"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="10dp"
        android:text="provider"
        android:textSize="15sp"
        android:textStyle="bold"
        android:focusable="true" />


    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:gravity="right"
        android:orientation="horizontal"
        android:visibility="visible">

        <TextView
            android:id="@+id/domain"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:gravity="center"
            android:textSize="15sp"
            android:text="domain.com"
            android:paddingEnd="10dp" />

        <ImageView
            android:id="@+id/domain_edit"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:padding="5dp"
            android:layout_rowWeight="1"
            android:focusable="true" />
    </LinearLayout>

</LinearLayout>


================================================
FILE: UltimaBeta/src/main/res/layout/list_meta_provider_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <Switch
        android:id="@+id/meta_provider_name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:text="test"
        android:focusable="true"
        tools:ignore="UseSwitchCompatOrMaterialXml" />

</LinearLayout>


================================================
FILE: UltimaBeta/src/main/res/layout/list_section_item.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="horizontal">

    <CheckBox
        android:id="@+id/section_checkbox"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:paddingRight="10dp"
        android:textSize="14sp"
        android:text="test"
        android:focusable="true" />

</LinearLayout>


================================================
FILE: UltimaBeta/src/main/res/layout/list_section_reorder_item.xml
================================================
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/section_container"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:paddingStart="16dp"
    android:paddingEnd="16dp"
    android:paddingTop="12dp"
    android:paddingBottom="12dp"
    android:background="?android:attr/selectableItemBackground"
    android:nextFocusRight="@+id/increase">

    <TextView
        android:id="@+id/section_name"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:textSize="16sp"
        android:textStyle="bold"
        android:textColor="#DDDDDD"
        android:maxLines="1"
        android:ellipsize="end"
        android:gravity="center_vertical"
        android:focusable="false"
        android:clickable="false" />

    <ImageView
        android:id="@+id/increase"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="8dp"
        android:nextFocusLeft="@id/section_container"
        android:nextFocusRight="@id/decrease" />

    <ImageView
        android:id="@+id/decrease"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:padding="8dp"
        android:nextFocusLeft="@id/section_container"
        android:nextFocusRight="@id/increase" />
</LinearLayout>



================================================
FILE: UltimaBeta/src/main/res/layout/meta_providers.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Meta Providers"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_rowWeight="1"
            android:layout_marginTop="5dp"
            android:layout_marginBottom="5dp"
            android:text="Meta Services"
            android:textSize="18sp" />

        <LinearLayout
            android:id="@+id/meta_providers_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_rowWeight="1"
            android:layout_marginTop="5dp"
            android:layout_marginBottom="5dp"
            android:text="Media Sources"
            android:textSize="18sp" />

        <LinearLayout
            android:id="@+id/media_providers_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">
        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: UltimaBeta/src/main/res/layout/reorder.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr"
    android:focusable="true"
    android:focusableInTouchMode="true">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <!-- Header Row -->
        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:gravity="center_vertical">

            <TextView
                android:layout_width="0dp"
                android:layout_height="wrap_content"
                android:layout_weight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Reorder Sections"
                android:textSize="20sp"
                android:textStyle="bold" />

            <ImageView
                android:id="@+id/save"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:padding="5dp" />
        </LinearLayout>

        <!-- Divider -->
        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:layout_marginVertical="10dp"
            android:paddingHorizontal="2dp" />

        <!-- Section List -->
        <LinearLayout
            android:id="@+id/section_list"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp" />

        <!-- No Section Warning -->
        <TextView
            android:id="@+id/no_section_warning"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:layout_marginTop="10dp"
            android:layout_marginBottom="20dp"
            android:text="You have not enabled any section"
            android:textSize="15sp"
            android:gravity="center"
            android:visibility="gone" />

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: UltimaBeta/src/main/res/layout/settings.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:layout_marginTop="20dp"
                android:layout_marginBottom="5dp"
                android:text="Ultima Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:layout_marginTop="20dp"
                    android:layout_marginBottom="5dp"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/meta_providers_img"
                    android:nextFocusUp="@id/save" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Configure Meta Providers"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/meta_providers_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/config_img"
                    android:nextFocusUp="@id/save" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Configure Extension Sections"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/config_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/reorder_img"
                    android:nextFocusUp="@id/meta_providers_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Reorder Sections"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/reorder_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/watch_sync_img"
                    android:nextFocusUp="@id/config_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Cross Device Watch Sync"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/watch_sync_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/guide_icon"
                    android:nextFocusUp="@id/reorder_img" />

            </LinearLayout>

        </LinearLayout>

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Ultima Setup Guide"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/guide_icon"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="5dp"
                    android:focusable="true"
                    android:nextFocusDown="@id/delete_img"
                    android:nextFocusUp="@id/watch_sync_img" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Reset Ultima"
                android:textSize="18sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <TextView
                    android:id="@+id/delete_img"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:padding="10dp"
                    android:focusable="true"
                    android:text="Reset"
                    android:textSize="18sp"
                    android:textStyle="bold"
                    android:nextFocusDown="@id/save"
                    android:nextFocusUp="@id/guide_icon" />

            </LinearLayout>

        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>


================================================
FILE: UltimaBeta/src/main/res/layout/watch_sync_creds.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="25dp"
        android:layout_marginLeft="25dp"
        android:layout_marginRight="25dp"
        android:orientation="vertical">

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="GitHub token"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/token"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:layout_marginBottom="10dp"
            android:inputType="text" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Project number"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/project_num"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:layout_marginBottom="10dp"
            android:inputType="text" />

        <TextView
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Device name"
            android:textSize="18sp" />

        <EditText
            android:id="@+id/device_name"
            android:layout_height="wrap_content"
            android:layout_width="match_parent"
            android:padding="5dp"
            android:inputType="text" />

    </LinearLayout>

</LinearLayout>


================================================
FILE: UltimaBeta/src/main/res/layout/watch_sync_device.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <Switch
        android:id="@+id/watch_sync_device_name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textSize="17sp"
        android:padding="5dp"
        android:layout_marginTop="5dp"
        android:layout_marginBottom="5dp"
        android:text="test"
        android:focusable="true" />

</LinearLayout>


================================================
FILE: Watch32/build.gradle.kts
================================================
// use an integer for version numbers
version = 9


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Watch movies and series from Watch32"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1

    tvTypes = listOf("Movies", "TV Series")

    language = "en"

    iconUrl = "https://img.watch32.sx/xxrz/400x400/100/a9/5e/a95e15a880a9df3c045f6a5224daf576/a95e15a880a9df3c045f6a5224daf576.png"

    isCrossPlatform = true
}




================================================
FILE: Watch32/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Watch32/src/main/kotlin/com/phisher98/Extractors.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import android.os.Build
import androidx.annotation.RequiresApi
import com.fasterxml.jackson.annotation.JsonProperty
import com.google.gson.Gson
import com.google.gson.annotations.SerializedName
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.USER_AGENT
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.M3u8Helper.Companion.generateM3u8
import java.net.URLEncoder

class Videostr : ExtractorApi() {
    override val name = "Videostr"
    override val mainUrl = "https://videostr.net"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val headers = mapOf(
            "Accept" to "*/*",
            "X-Requested-With" to "XMLHttpRequest",
            "Referer" to mainUrl
        )

        val id = url.substringAfterLast("/").substringBefore("?")
        val responsenonce = app.get(url, headers = headers).text
        val match1 = Regex("""\b[a-zA-Z0-9]{48}\b""").find(responsenonce)
        val match2 = Regex("""\b([a-zA-Z0-9]{16})\b.*?\b([a-zA-Z0-9]{16})\b.*?\b([a-zA-Z0-9]{16})\b""")
            .find(responsenonce)

        val nonce = match1?.value ?: match2?.let {
            it.groupValues[1] + it.groupValues[2] + it.groupValues[3]
        } ?: throw Exception("Nonce not found")

        val apiUrl = "$mainUrl/embed-1/v3/e-1/getSources?id=$id&_k=$nonce"
        val gson = Gson()
        val response = try {
            val json = app.get(apiUrl, headers).text
            gson.fromJson(json, VideostrResponse::class.java)
        } catch (e: Exception) {
            throw Exception("Failed to parse VideostrResponse: ${e.message}")
        }

        Log.d("Videostr", "Parsed VideostrResponse: $response")

        val key = try {
            val keyJson = app.get(
                "https://raw.githubusercontent.com/yogesh-hacker/MegacloudKeys/refs/heads/main/keys.json"
            ).text
            gson.fromJson(keyJson, Megakey::class.java)?.vidstr
        } catch (e: Exception) {
            throw Exception("Failed to parse Megakey: ${e.message}")
        } ?: throw Exception("Decryption key not found")

        val encodedSource = response.sources.firstOrNull()?.file
            ?: throw Exception("No sources found in response")

        val m3u8: String = if (".m3u8" in encodedSource) {
            encodedSource
        } else {
            val decodeUrl =
                "https://script.google.com/macros/s/AKfycbxHbYHbrGMXYD2-bC-C43D3njIbU-wGiYQuJL61H4vyy6YVXkybMNNEPJNPPuZrD1gRVA/exec"

            val fullUrl = buildString {
                append(decodeUrl)
                append("?encrypted_data=").append(URLEncoder.encode(encodedSource, "UTF-8"))
                append("&nonce=").append(URLEncoder.encode(nonce, "UTF-8"))
                append("&secret=").append(URLEncoder.encode(key, "UTF-8"))
            }

            val decryptedResponse = app.get(fullUrl).text
            Regex("\"file\":\"(.*?)\"")
                .find(decryptedResponse)
                ?.groupValues?.get(1)
                ?: throw Exception("Video URL not found in decrypted response")
        }

        val m3u8headers = mapOf(
            "Referer" to "$mainUrl/",
            "Origin" to mainUrl
        )

        try {
            generateM3u8(name, m3u8, mainUrl, headers = m3u8headers).forEach(callback)
        } catch (e: Exception) {
            Log.e("Videostr", "Error generating M3U8: ${e.message}")
        }

        response.tracks.forEach { track ->
            if (track.kind == "captions" || track.kind == "subtitles") {
                subtitleCallback(
                    newSubtitleFile(
                        track.label,
                        track.file
                    )
                )
            }
        }
    }

    data class VideostrResponse(
        val sources: List<VideostrSource>,
        val tracks: List<Track>,
        val encrypted: Boolean,
        @SerializedName("_f") val f: String,
        val server: Long,
    )

    data class VideostrSource(
        val file: String,
        val type: String,
    )

    data class Track(
        val file: String,
        val label: String,
        val kind: String,
        val s: String,
        val default: Boolean?,
    )

    data class Megakey(
        val rabbit: String,
        val mega: String,
        val vidstr: String
    )
}



================================================
FILE: Watch32/src/main/kotlin/com/phisher98/Watch32.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.ErrorLoadingException
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Document

class Watch32 : MainAPI() {
    override var mainUrl = "https://watch32.sx"
    override var name = "Watch32"
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries)
    override var lang = "en"
    override val hasMainPage = true

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search/${query.replace(" ", "-")}"
        val response = app.get(url)
        return if (response.code == 200) searchResponseBuilder(response.documentLarge)
        else listOf()
    }

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query)

    override val mainPage =
            mainPageOf(
                    "$mainUrl/movie?page=" to "Popular Movies",
                    "$mainUrl/tv-show?page=" to "Popular TV Shows",
                    "$mainUrl/coming-soon?page=" to "Coming Soon",
                    "$mainUrl/top-imdb?page=" to "Top IMDB Rating",
            )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = request.data + page
        val response = app.get(url)
        if (response.code == 200)
                return newHomePageResponse(
                        request.name,
                        searchResponseBuilder(response.documentLarge),
                        true
                )
        else throw ErrorLoadingException("Could not load data")
    }

    override suspend fun load(url: String): LoadResponse {
        val res = app.get(url)
        if (res.code != 200) throw ErrorLoadingException("Could not load data$url")

        val type = url
        val contentId = res.documentLarge.select("div.detail_page-watch").attr("data-id")
        val details = res.documentLarge.select("div.detail_page-infor")
        val name = details.select("h2.heading-name > a").text()
        val year = res.documentLarge.select("div.row-line:has(> span.type > strong:contains(Released))").text().replace("Released:", "").trim().substringBefore("-").toIntOrNull()
        val actors = res.documentLarge
            .select("div.row-line:has(> span.type > strong:contains(Casts)) a")
            .map { it.text().trim() }
        val genres = res.documentLarge
            .select("div.row-line:has(> span.type > strong:contains(Genre)) a")
            .map { it.text().trim() }

        if (type.contains("movie")) {
            return newMovieLoadResponse(name, url, TvType.Movie, "list/$contentId") {
                this.posterUrl = details.select("div.film-poster > img").attr("src")
                this.plot = details.select("div.description").text()
                this.year = year
                this.score = Score.from10(
                        details.select("button.btn-imdb")
                                .text()
                                .replace("N/A", "").substringAfter(":").trim())
                this.tags = genres
                addActors(actors)
                addTrailer(res.documentLarge.select("iframe#iframe-trailer").attr("data-src"))
            }
        } else {
            val episodes = ArrayList<Episode>()
            val seasonsRes =
                    app.get("$mainUrl/ajax/season/list/$contentId").documentLarge.select("a.ss-item")

            seasonsRes.forEach { season ->
                val seasonId = season.attr("data-id")
                val seasonNum = season.text().replace("Season ", "")
                app.get("$mainUrl/ajax/season/episodes/$seasonId")
                        .documentLarge
                        .select("a.eps-item")
                        .forEach { episode ->
                            val epId = episode.attr("data-id")
                            val (epNum, epName) =
                                    Regex("Eps (\\d+): (.+)").find(episode.attr("title"))!!
                                            .destructured

                            episodes.add(
                                    newEpisode(epId) {
                                        this.name = epName
                                        this.episode = epNum.toInt()
                                        this.season = seasonNum.replace("Series", "").trim().toInt()
                                        this.data = "servers/$epId"
                                    }
                            )
                        }
            }
            return newTvSeriesLoadResponse(name, url, TvType.TvSeries, episodes) {
                this.posterUrl = details.select("div.film-poster > img").attr("src")
                this.plot = details.select("div.description").text()
                this.year = year
                this.score = Score.from10(
                        details.select("button.btn-imdb")
                                .text()
                                .replace("N/A", "").substringAfter(":").trim())
                this.tags = genres
                addActors(actors)
                addTrailer(res.documentLarge.select("iframe#iframe-trailer").attr("data-src"))
            }
        }
    }

    override suspend fun loadLinks(
            data: String,
            isCasting: Boolean,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
    ): Boolean {
        val serversRes = app.get("$mainUrl/ajax/episode/$data").documentLarge.select("a.link-item")
        serversRes.forEach { server ->
            val linkId =
                server.attr("data-linkid").ifEmpty { server.attr("data-id") }
            val source = app.get("$mainUrl/ajax/episode/sources/$linkId").parsedSafe<Source>()
            loadExtractor(source?.link.toString(), subtitleCallback, callback)
        }
        return true
    }

    data class Source(
            @JsonProperty("type") var type: String,
            @JsonProperty("link") var link: String
    )

    private fun searchResponseBuilder(webDocument: Document): List<SearchResponse> {
        val searchCollection =
                webDocument.select("div.flw-item").mapNotNull { element ->
                    val title =
                            element.selectFirst("h2.film-name > a")?.attr("title")
                                    ?: return@mapNotNull null
                    val link =
                            element.selectFirst("h2.film-name > a")?.attr("href")
                                    ?: return@mapNotNull null
                    val poster =
                            element.selectFirst("img.film-poster-img")?.attr("data-src")
                                    ?: return@mapNotNull null
                    val quality = element.select("div.pick.film-poster-quality").text()
                    newMovieSearchResponse(title, link) {
                        this.posterUrl = poster
                        this.quality = getQualityFromString(quality)
                    }
                }
        return searchCollection
    }
}



================================================
FILE: Watch32/src/main/kotlin/com/phisher98/Watch32Parser.kt
================================================
package com.phisher98

data class MyFlixerParser(
    val sources: List<Source>,
    val tracks: List<Track>
) {
    data class Source(
        val `file`: String,
        val type: String
    )

    data class Track(
        val `file`: String,
        val label: String
    )
}


================================================
FILE: Watch32/src/main/kotlin/com/phisher98/Watch32Plugin.kt
================================================
package com.phisher98

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class MyFlixerPlugin : BasePlugin() {
    override fun load() {
        registerMainAPI(Watch32())
        registerExtractorAPI(Videostr())
    }
}



================================================
FILE: WatchMMAFull/build.gradle.kts
================================================
// use an integer for version numbers
version = 2


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "MMA Videos"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Other","Live")
    iconUrl="https://www.google.com/s2/favicons?domain=watchmmafull.com/&sz=%size%"

    isCrossPlatform = true

}



================================================
FILE: WatchMMAFull/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: WatchMMAFull/src/main/kotlin/com/WatchMMAFull/Extractor.kt
================================================
package com.WatchMMAFull

import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.extractors.Filesim
import com.lagradost.cloudstream3.extractors.StreamSB
import com.lagradost.cloudstream3.extractors.StreamWishExtractor
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.INFER_TYPE
import com.lagradost.cloudstream3.utils.JsUnpacker
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.newExtractorLink
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

class Vtbe : ExtractorApi() {
    override var name = "Vtbe"
    override var mainUrl = "https://vtbe.to"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink>? {
        val response = app.get(url,referer=mainUrl).documentLarge
        val extractedpack =response.selectFirst("script:containsData(function(p,a,c,k,e,d))")?.data().toString()
        JsUnpacker(extractedpack).unpack()?.let { unPacked ->
            Regex("sources:\\[\\{file:\"(.*?)\"").find(unPacked)?.groupValues?.get(1)?.let { link ->
                return listOf(
                    newExtractorLink(
                        this.name,
                        this.name,
                        url = link,
                        INFER_TYPE
                    ) {
                        this.referer = referer ?: ""
                        this.quality = Qualities.Unknown.value
                    }

                )
            }
        }
        return null
    }
}

class SuiSports : ExtractorApi() {
    override var name = "SuiSports"
    override var mainUrl = "https://suisports.upns.xyz"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {
        val headers= mapOf("User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0")
        val hash=url.substringAfterLast("#")
        val encoded= app.get("$mainUrl/api/v1/video?id=$hash",headers=headers).text.trim()
        val decryptedText = AesHelper.decryptAES(encoded, "kiemtienmua911ca", "0123456789abcdef")
        val m3u8=Regex("\"source\":\"(.*?)\"").find(decryptedText)?.groupValues?.get(1)?.replace("\\/","/") ?:""
        return listOf(
            newExtractorLink(
                this.name,
                this.name,
                url = m3u8,
                ExtractorLinkType.M3U8
            ) {
                this.referer = url
                this.quality = Qualities.Unknown.value
            }

        )
    }
}

object AesHelper {
    private const val TRANSFORMATION = "AES/CBC/PKCS5PADDING"

    fun decryptAES(inputHex: String, key: String, iv: String): String {
        val cipher = Cipher.getInstance(TRANSFORMATION)
        val secretKey = SecretKeySpec(key.toByteArray(Charsets.UTF_8), "AES")
        val ivSpec = IvParameterSpec(iv.toByteArray(Charsets.UTF_8))

        cipher.init(Cipher.DECRYPT_MODE, secretKey, ivSpec)
        val decryptedBytes = cipher.doFinal(inputHex.hexToByteArray())
        return String(decryptedBytes, Charsets.UTF_8)
    }

    private fun String.hexToByteArray(): ByteArray {
        check(length % 2 == 0) { "Hex string must have an even length" }
        return chunked(2).map { it.toInt(16).toByte() }.toByteArray()
    }
}


class Spcdn : ExtractorApi() {
    override var name = "SpCDN"
    override var mainUrl = "https://spcdn.xyz"
    override val requiresReferer = true

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {
        val vhash =url.substringAfter("data=")
        val m3u8="$mainUrl/cdn/hls/$vhash/master.txt?s=1&d="
        return listOf(
            newExtractorLink(
                this.name,
                this.name,
                url = m3u8,
                ExtractorLinkType.M3U8
            ) {
                this.referer = url
                this.quality = Qualities.Unknown.value
            }
        )
    }
}

class wishfast : StreamWishExtractor() {
    override var mainUrl = "https://wishfast.top"
    override var name = "StreamWish"
}

class waaw : StreamSB() {
    override var mainUrl = "https://waaw.to"
}

class FileMoonSx : Filesim() {
    override val mainUrl = "https://filemoon.sx"
    override val name = "FileMoonSx"
}


================================================
FILE: WatchMMAFull/src/main/kotlin/com/WatchMMAFull/WatchMMAFull.kt
================================================
package com.WatchMMAFull

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import org.jsoup.Jsoup

class WatchMMAFull : MainAPI() {
    override var mainUrl = "https://watchmmafull.com"
    override var name = "WatchMMAFull"
    override val hasMainPage = true
    override var lang = "en"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.Others, TvType.Live)

    override val mainPage = mainPageOf(
        "new" to "Latest",
        )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}/$page").documentLarge
        val home = document.select("ul.list-movies li").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = true
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select("a").attr("title")
        val href = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("img").attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }


    override suspend fun search(query: String): List<SearchResponse> {
            val document = app.get("${mainUrl}/search/$query").documentLarge
            val results = document.select("ul.list-movies li").mapNotNull { it.toSearchResult() }
            return results
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.select("meta[property=og:title]").attr("content")
        val rawposter = document.select("meta[property=og:image]").attr("content")
        val poster="$mainUrl$rawposter"
        val description = document.selectFirst("#app > main > div.body.player.has-sidebar > div.info-movie > article > p:nth-child(3)")?.ownText()?.trim()
        val tag=document.select("#extras a").map { it.text() }
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = description
                this.tags = tag
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).documentLarge.select("div.user-action  li").amap {
            val onclick=it.attr("onclick").substringAfter("(").substringBefore(")")
            val server= onclick.split(",")[0]
            val id= onclick.split(",")[1]
            val response= app.post("$mainUrl/ajax/change_link", data = mapOf("vl3x_server" to "1","id" to id,"server" to server)).parsedSafe<Root>()?.player
            val doc=Jsoup.parse(response!!)
            val iframe=doc.select("iframe").attr("src")
            loadExtractor(iframe,mainUrl,subtitleCallback, callback)
        }
        return true
    }
}


data class Root(
    val player: String,
)




================================================
FILE: WatchMMAFull/src/main/kotlin/com/WatchMMAFull/WatchMMAFullProvider.kt
================================================
package com.WatchMMAFull

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.extractors.FileMoon
import com.lagradost.cloudstream3.plugins.BasePlugin

@CloudstreamPlugin
class WatchMMAFullProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(WatchMMAFull())
        registerExtractorAPI(Vtbe())
        registerExtractorAPI(waaw())
        registerExtractorAPI(wishfast())
        registerExtractorAPI(FileMoonSx())
        registerExtractorAPI(FileMoon())
        registerExtractorAPI(Spcdn())
        registerExtractorAPI(SuiSports())
    }
}


================================================
FILE: XDMovies/build.gradle.kts
================================================
// use an integer for version numbers
version = 26


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "Watch Latest Movies"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
        "Cartoon",
        "AnimeMovie"
    )
    iconUrl = "https://new.xdmovies.wtf/assets/logo1.png"
    isCrossPlatform = true
}



================================================
FILE: XDMovies/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: XDMovies/src/main/kotlin/com/Phisher98/Extractor.kt
================================================
package com.phisher98

import android.annotation.SuppressLint
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.newExtractorLink
import com.phisher98.XDMovies.Companion.TMDBIMAGEBASEURL
import kotlinx.coroutines.runBlocking
import org.json.JSONObject
import java.net.URI

class Hubdrive : ExtractorApi() {
    override val name = "Hubdrive"
    override val mainUrl = "https://hubdrive.*"
    override val requiresReferer = false

    @SuppressLint("SuspiciousIndentation")
    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val href=app.get(url, timeout = 2000).documentLarge.select(".btn.btn-primary.btn-user.btn-success1.m-1").attr("href")
        if (href.contains("hubcloud",ignoreCase = true)) HubCloud().getUrl(href,"HubDrive",subtitleCallback,callback)
        else loadExtractor(href,"HubDrive",subtitleCallback, callback)
    }
}

class HubCloud : ExtractorApi() {

    override val name = "Hub-Cloud"
    override var mainUrl: String = runBlocking {
        XDMoviesProvider.getDomains()?.hubcloud ?: "https://hubcloud.foo"
    }
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val tag = "HubCloud"
        val ref = referer.orEmpty()

        val uri = runCatching { URI(url) }.getOrElse {
            Log.e(tag, "Invalid URL: ${it.message}")
            return
        }

        val realUrl = uri.toString()
        val baseUrl = "${uri.scheme}://${uri.host}"

        val href = runCatching {
            if ("hubcloud.php" in realUrl) {
                realUrl
            } else {
                val raw = app.get(realUrl).document
                    .selectFirst("#download")
                    ?.attr("href")
                    .orEmpty()

                if (raw.startsWith("http", true)) raw
                else baseUrl.trimEnd('/') + "/" + raw.trimStart('/')
            }
        }.getOrElse {
            Log.e(tag, "Failed to extract href: ${it.message}")
            ""
        }

        if (href.isBlank()) return

        val document = app.get(href).document
        val size = document.selectFirst("i#size")?.text().orEmpty()
        val header = document.selectFirst("div.card-header")?.text().orEmpty()

        val headerDetails = cleanTitle(header)
        val quality = getIndexQuality(header)

        val labelExtras = buildString {
            if (headerDetails.isNotEmpty()) append("[$headerDetails]")
            if (size.isNotEmpty()) append("[$size]")
        }

        document.select("a.btn").forEach { element ->
            val link = element.attr("href")
            val text = element.ownText()
            val label = text.lowercase()

            when {
                "fsl server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSL Server]",
                            "$ref [FSL Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "download file" in label -> {
                    callback(
                        newExtractorLink(
                            ref,
                            "$ref $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "buzzserver" in label -> {
                    val resp = app.get("$link/download", referer = link, allowRedirects = false)
                    val dlink = resp.headers["hx-redirect"]
                        ?: resp.headers["HX-Redirect"].orEmpty()

                    if (dlink.isNotBlank()) {
                        callback(
                            newExtractorLink(
                                "$ref [BuzzServer]",
                                "$ref [BuzzServer] $labelExtras",
                                dlink
                            ) { this.quality = quality }
                        )
                    } else {
                        Log.w(tag, "BuzzServer: No redirect")
                    }
                }

                "pixeldra" in label || "pixelserver" in label || "pixel server" in label || "pixeldrain" in label -> {
                    val base = getBaseUrl(link)
                    val finalUrl =
                        if ("download" in link) link
                        else "$base/api/file/${link.substringAfterLast("/")}?download"

                    callback(
                        newExtractorLink(
                            "$ref Pixeldrain",
                            "$ref Pixeldrain $labelExtras",
                            finalUrl
                        ) { this.quality = quality }
                    )
                }

                "s3 server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [S3 Server]",
                            "$ref [S3 Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "fslv2" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [FSLv2]",
                            "$ref [FSLv2] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }

                "mega server" in label -> {
                    callback(
                        newExtractorLink(
                            "$ref [Mega Server]",
                            "$ref [Mega Server] $labelExtras",
                            link
                        ) { this.quality = quality }
                    )
                }
                /*
                "10gbps" in label -> {
                    var current = link

                    repeat(3) {
                        val resp = app.get(current, allowRedirects = false)
                        val loc = resp.headers["location"] ?: return@repeat

                        if ("link=" in loc) {
                            callback(
                                newExtractorLink(
                                    "$ref 10Gbps [Download]",
                                    "$ref 10Gbps [Download] $labelExtras",
                                    loc.substringAfter("link=")
                                ) { this.quality = quality }
                            )
                        }
                        current = loc
                    }

                    Log.e(tag, "10Gbps: Redirect limit reached")
                }

                 */

                else -> {
                    loadExtractor(link, "", subtitleCallback, callback)
                }
            }
        }
    }

    private fun getIndexQuality(str: String?): Int {
        return Regex("(\\d{3,4})[pP]")
            .find(str.orEmpty())
            ?.groupValues
            ?.getOrNull(1)
            ?.toIntOrNull()
            ?: Qualities.P2160.value
    }

    private fun getBaseUrl(url: String): String {
        return runCatching {
            URI(url).let { "${it.scheme}://${it.host}" }
        }.getOrDefault("")
    }

    private fun cleanTitle(title: String): String {

        val name = title.replace(Regex("\\.[a-zA-Z0-9]{2,4}$"), "")

        val normalized = name
            .replace(Regex("WEB[-_. ]?DL", RegexOption.IGNORE_CASE), "WEB-DL")
            .replace(Regex("WEB[-_. ]?RIP", RegexOption.IGNORE_CASE), "WEBRIP")
            .replace(Regex("H[ .]?265", RegexOption.IGNORE_CASE), "H265")
            .replace(Regex("H[ .]?264", RegexOption.IGNORE_CASE), "H264")
            .replace(Regex("DDP[ .]?([0-9]\\.[0-9])", RegexOption.IGNORE_CASE), "DDP$1")

        val parts = normalized.split(" ", "_", ".")

        val sourceTags = setOf(
            "WEB-DL", "WEBRIP", "BLURAY", "HDRIP",
            "DVDRIP", "HDTV", "CAM", "TS", "BRRIP", "BDRIP"
        )

        val codecTags = setOf("H264", "H265", "X264", "X265", "HEVC", "AVC")

        val audioTags = setOf("AAC", "AC3", "DTS", "MP3", "FLAC", "DD", "DDP", "EAC3")

        val audioExtras = setOf("ATMOS")

        val hdrTags = setOf("SDR","HDR", "HDR10", "HDR10+", "DV", "DOLBYVISION")

        val filtered = parts.mapNotNull { part ->
            val p = part.uppercase()

            when {
                sourceTags.contains(p) -> p
                codecTags.contains(p) -> p
                audioTags.any { p.startsWith(it) } -> p
                audioExtras.contains(p) -> p
                hdrTags.contains(p) -> {
                    when (p) {
                        "DV", "DOLBYVISION" -> "DOLBYVISION"
                        else -> p
                    }
                }
                p == "NF" || p == "CR" -> p
                else -> null
            }
        }

        return filtered.distinct().joinToString(" ")
    }
}


class XdMoviesExtractor : ExtractorApi() {

    override val name = "XdMoviesExtractor"
    override val mainUrl = "https://link.xdmovies.wtf"
    override val requiresReferer = false

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val redirect = runCatching {
            app.get(url, allowRedirects = false).headers["location"]
        }.getOrNull()

        redirect?.let {
            loadExtractor(it, "HubCloud", subtitleCallback, callback)
        }
    }
}

fun parseTmdbActors(jsonText: String?): List<ActorData> {
    if (jsonText.isNullOrBlank()) return emptyList()

    val list = mutableListOf<ActorData>()
    val root = JSONObject(jsonText)
    val castArr = root.optJSONArray("cast") ?: return emptyList()

    for (i in 0 until castArr.length()) {
        val c = castArr.optJSONObject(i) ?: continue

        val name = c.optString("name").takeIf { it.isNotBlank() }
            ?: c.optString("original_name").orEmpty()

        val img = c.optString("profile_path")
            .takeIf { it.isNotBlank() }
            ?.let { "$TMDBIMAGEBASEURL$it" }

        val role = c.optString("character").takeIf { it.isNotBlank() }

        list += ActorData(
            Actor(name, img),
            roleString = role
        )
    }
    return list
}


suspend fun fetchTmdbLogoUrl(
    tmdbAPI: String,
    apiKey: String,
    type: TvType,
    tmdbId: Int?,
    appLangCode: String?
): String? {
    if (tmdbId == null) return null

    val appLang = appLangCode?.substringBefore("-")?.lowercase()
    val url = if (type == TvType.Movie) {
        "$tmdbAPI/movie/$tmdbId/images?api_key=$apiKey"
    } else {
        "$tmdbAPI/tv/$tmdbId/images?api_key=$apiKey"
    }

    val json = runCatching { JSONObject(app.get(url).text) }.getOrNull() ?: return null
    val logos = json.optJSONArray("logos") ?: return null
    if (logos.length() == 0) return null

    fun logoUrlAt(i: Int): String = "https://image.tmdb.org/t/p/w500${logos.getJSONObject(i).optString("file_path")}"
    fun isSvg(i: Int): Boolean = logos.getJSONObject(i).optString("file_path").endsWith(".svg", ignoreCase = true)

    if (!appLang.isNullOrBlank()) {
        var svgFallback: String? = null
        for (i in 0 until logos.length()) {
            val logo = logos.optJSONObject(i) ?: continue
            if (logo.optString("iso_639_1") == appLang) {
                if (isSvg(i)) {
                    if (svgFallback == null) svgFallback = logoUrlAt(i)
                } else {
                    return logoUrlAt(i)
                }
            }
        }
        if (svgFallback != null) return svgFallback
    }

    var enSvgFallback: String? = null
    for (i in 0 until logos.length()) {
        val logo = logos.optJSONObject(i) ?: continue
        if (logo.optString("iso_639_1") == "en") {
            if (isSvg(i)) {
                if (enSvgFallback == null) enSvgFallback = logoUrlAt(i)
            } else {
                return logoUrlAt(i)
            }
        }
    }
    if (enSvgFallback != null) return enSvgFallback

    for (i in 0 until logos.length()) {
        if (!isSvg(i)) return logoUrlAt(i)
    }

    return logoUrlAt(0)
}


================================================
FILE: XDMovies/src/main/kotlin/com/Phisher98/XDMovies.kt
================================================
package com.phisher98

import com.google.gson.Gson
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.base64Decode
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.json.JSONArray
import org.json.JSONObject
import org.jsoup.nodes.Element

class XDMovies : MainAPI() {
    override var mainUrl = "https://new.xdmovies.wtf"
    override var name = "XD Movies"
    override val hasMainPage = true
    override var lang = "en"
    override val hasDownloadSupport = true
    override val instantLinkLoading = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(TvType.Movie, TvType.TvSeries, TvType.Anime)

    companion object {
        val headers = mapOf(
            "x-auth-token" to base64Decode("NzI5N3Nra2loa2Fqd25zZ2FrbGFrc2h1d2Q="),
            "x-requested-with" to "XMLHttpRequest"
        )

        private val gson = Gson()

        private const val CINEMETAURL = "https://cinemeta-live.strem.io"
        const val TMDBIMAGEBASEURL = "https://image.tmdb.org/t/p/original"
        const val TMDBAPI = "https://divine-darkness-fad4.phisher13.workers.dev"

        private val titleRegex = Regex("""S(\d{1,2})E(\d{1,3})""", RegexOption.IGNORE_CASE)
        private val seasonNumRegex1 = Regex("""season-(?:packs|episodes)-(\d+)""")
        private val seasonNumRegex2 = Regex("""Season\s*(\d+)""", RegexOption.IGNORE_CASE)

        private fun extractTmdbId(url: String): Int? = url.substringAfterLast("-").toIntOrNull()

        private fun Element.safeText(selector: String) = this.selectFirst(selector)?.text().orEmpty()
        private fun Element.safeAttr(selector: String, attr: String) = this.selectFirst(selector)?.attr(attr).orEmpty()
    }

    override val mainPage = mainPageOf(
        "Homepage" to "HomePage",
        "category.php?ott=Netflix" to "Netflix",
        "category.php?ott=Amazon" to "Amazon Prime Video",
        "category.php?ott=DisneyPlus" to "Disney+",
        "category.php?ott=AppleTVPlus" to "Apple TV+",
        "category.php?ott=HBOMax" to "HBO Max",
        "category.php?ott=Hulu" to "Hulu",
        "category.php?ott=Zee5" to "Zee5",
        "category.php?ott=JioHotstar" to "Hotstar",
    )

    override suspend fun quickSearch(query: String): List<SearchResponse>? = search(query,1)?.items

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${if (request.data.contains("Homepage")) "?" else "${request.data}&"}page=$page").documentLarge
        val home = document.select("div.container div.movie-grid a").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list = HomePageList(
                name = request.name,
                list = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.safeText("h3")
        val href = fixUrl(this.attr("href"))
        val posterUrl = fixUrlNull(this.safeAttr("img", "src"))
        val quality = this.selectFirst("div.quality-badge")?.ownText()
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getSearchQuality(quality)
        }
    }


    private fun highestQuality(qualities: List<String>): String? {
        return qualities
            .mapNotNull { q ->
                q.filter { it.isDigit() }.toIntOrNull()?.let { res -> res to q }
            }
            .maxByOrNull { it.first }
            ?.second
    }


    private fun SearchData.SearchDataItem.toSearchResult(): SearchResponse {
        val isTv = type.equals("tv", ignoreCase = true) || type.equals("series", ignoreCase = true)
        val tvType = if (isTv) TvType.TvSeries else TvType.Movie
        val url = mainUrl + path
        val bestQuality = highestQuality(qualities)
        return newMovieSearchResponse(title, url, tvType) {
            this.posterUrl = TMDBIMAGEBASEURL + poster
            this.quality = getSearchQuality(bestQuality)
        }
    }

    override suspend fun search(query: String, page: Int): SearchResponseList? {
        val searchData = app.get(
            "$mainUrl/php/search_api.php?query=$query&fuzzy=true",
            headers
        ).parsedSafe<SearchData>() ?: return null
        val results = searchData.mapNotNull { it.toSearchResult() }
        return results.toNewSearchResponseList()
    }


    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val infoDiv = document.selectFirst("div.info")
        val detailsWrapper = document.selectFirst("div.details-wrapper")
        val headerStyle = document.selectFirst("#movie-header")?.attr("style").orEmpty()
        val downloadRoot = document.selectFirst("#download-links, .download")

        val title = infoDiv?.safeText("h2").orEmpty()
        val poster = detailsWrapper?.selectFirst("img")?.attr("src").orEmpty()
        val backgroundPoster = headerStyle.substringAfter("url('").substringBefore("');")
        val audios = document.select("span.neon-audio").text().split(",").map { it.trim() }
        val tags = (document.select("p:contains(Genres:)").first()?.ownText()?.split(",")?.map { it.trim() } ?: emptyList()) + audios
        val firstAirDate = document.select("p:contains(First Air Date:)").text().removePrefix("First Air Date:").trim()
        val year = firstAirDate.substringBefore("-").toIntOrNull()
        val description = document.select("p.overview").text()
        val rating = Score.from10(document.select("p:contains(Rating:)").text().removePrefix("Rating:").trim().substringBefore("/").trim())
        val contentType = url.substringAfter("$mainUrl/").substringBefore("/")
        val source = document.select("#source-info span").text()
        val tvType = when {
            contentType.equals("anime", ignoreCase = true) -> TvType.Anime
            contentType.equals("tv", ignoreCase = true) || contentType.equals("series", ignoreCase = true) -> TvType.TvSeries
            else -> TvType.Movie
        }

        val tmdbTvTypeSlug = if (tvType == TvType.Movie) "movie" else "tv"
        val tvTypeSlugForCinemeta = if (tvType == TvType.Movie) "movie" else "series"
        val tmdbId = extractTmdbId(url) ?: 0

        val tmdbResText: String? = runCatching {
            app.get(
                "$TMDBAPI/$tmdbTvTypeSlug/$tmdbId/external_ids?api_key=1865f43a0549ca50d341dd9ab8b29f49"
            ).text
        }.getOrNull()

        val tmdbRes = gson.fromJson(tmdbResText, IMDB::class.java)
        val imdbId = tmdbRes?.imdbId

        val creditsJsonText = runCatching {
            app.get("$TMDBAPI/$tmdbTvTypeSlug/$tmdbId/credits?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US").text
        }.getOrNull()

        val actors = parseTmdbActors(creditsJsonText)

        val detailsJsonText = runCatching {
            app.get(
                "$TMDBAPI/$tmdbTvTypeSlug/$tmdbId?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US"
            ).text
        }.getOrNull()

        val genres: List<String> = detailsJsonText
            ?.let { JSONObject(it) }
            ?.optJSONArray("genres")
            ?.let { array ->
                (0 until array.length()).mapNotNull { i ->
                    array.optJSONObject(i)?.optString("name").takeIf { it!!.isNotBlank() }
                }
            }
            ?: emptyList()

        val logoUrl = fetchTmdbLogoUrl(
            tmdbAPI = "https://api.themoviedb.org/3",
            apiKey = "98ae14df2b8d8f8f8136499daf79f0e0",
            type = tvType,
            tmdbId = tmdbId,
            appLangCode = "en"
        )

        val downloadLinks = document.select("div.download-item a")
            .mapNotNull { it.attr("href").trim().takeIf { link -> link.isNotEmpty() } }

        val href = JSONArray(downloadLinks).toString()

        val responseData = imdbId
            ?.takeIf { it.isNotBlank() && it != "0" }
            ?.let {
                val jsonResponse = app.get("$CINEMETAURL/meta/$tvTypeSlugForCinemeta/$it.json").text
                if (jsonResponse.startsWith("{")) gson.fromJson(jsonResponse, ResponseData::class.java) else null
            }

        if (tvType == TvType.TvSeries || tvType == TvType.Anime) {
            val episodes = mutableListOf<Episode>()
            val seasonSections = downloadRoot?.select("div.season-section") ?: emptyList()

            for (seasonSection in seasonSections) {
                val seasonNum = seasonNumRegex1.find(seasonSection.html())?.groupValues?.get(1)?.toIntOrNull()
                    ?: seasonNumRegex2.find(seasonSection.selectFirst("button.toggle-season-btn")?.text().orEmpty())?.groupValues?.get(1)?.toIntOrNull()
                    ?: 1

                val tmdbSeasonRes: TMDBRes? = runCatching {
                    val text = app.get(
                        "$TMDBAPI/tv/$tmdbId/season/$seasonNum?api_key=1865f43a0549ca50d341dd9ab8b29f49&language=en-US"
                    ).textLarge
                    gson.fromJson(text, TMDBRes::class.java)
                }.getOrNull()

                val episodeMap = mutableMapOf<Int, MutableList<String>>()
                val packs = mutableListOf<Pair<Int, Pair<String, String>>>() // index -> (link, title)

                seasonSection.select(".episode-card").forEach { card ->
                    val cardTitle = card.selectFirst(".episode-title")?.text().orEmpty()
                    val m = titleRegex.find(cardTitle)
                    val epNum = m?.groupValues?.get(2)?.toIntOrNull()
                        ?: (card.parent()?.children()?.indexOf(card)?.plus(1) ?: 1)
                    val links = card.select("a.movie-download-btn, a.download-button")
                        .mapNotNull { it -> it.attr("href").trim().takeIf { it.isNotEmpty() } }
                    if (links.isNotEmpty()) episodeMap.getOrPut(epNum) { mutableListOf() }.addAll(links)
                }

                seasonSection.select(".packs-grid .pack-card").forEachIndexed { idx, pack ->
                    val link = pack.selectFirst("a.download-button")?.attr("href")?.trim().takeIf { !it.isNullOrBlank() } ?: return@forEachIndexed
                    val title = "Episode ${idx + 1} [Packs/Zips]"
                    packs += Pair(idx + 1, Pair(link, title))
                }

                if (episodeMap.isNotEmpty()) {
                    for ((epNum, links) in episodeMap) {
                        val tmdbEpisode = tmdbSeasonRes?.episodes?.find { it.episodeNumber == epNum }
                        val info = responseData?.meta?.videos?.find { it.season == seasonNum && it.episode == epNum }
                        val name = tmdbEpisode?.name ?: info?.name ?: "Episode $epNum"
                        val desc = tmdbEpisode?.overview ?: info?.overview
                        val poster = tmdbEpisode?.stillPath?.let { TMDBIMAGEBASEURL + it }
                        val score = Score.from10(tmdbEpisode?.voteAverage)
                        val airDate = tmdbEpisode?.airDate

                        episodes += newEpisode(links.toJson()) {
                            this.name = name
                            this.season = seasonNum
                            this.episode = epNum
                            this.posterUrl = poster
                            this.description = desc
                            this.score = score
                            this.addDate(airDate)
                        }
                    }
                } else if (packs.isNotEmpty()) {
                    for ((idx, pair) in packs) {
                        val (link, title) = pair
                        val epNum = idx
                        val tmdbEpisode = tmdbSeasonRes?.episodes?.find { it.episodeNumber == epNum }
                        val info = responseData?.meta?.videos?.find { it.season == seasonNum && it.episode == epNum }
                        val name = title
                        val desc = tmdbEpisode?.overview ?: info?.overview
                        val poster = tmdbEpisode?.stillPath?.let { TMDBIMAGEBASEURL + it }
                        val score = Score.from10(tmdbEpisode?.voteAverage)
                        val airDate = tmdbEpisode?.airDate

                        episodes += newEpisode(listOf(link).toJson()) {
                            this.name = name
                            this.season = seasonNum
                            this.episode = epNum
                            this.posterUrl = poster
                            this.description = desc
                            this.score = score
                            this.addDate(airDate)
                        }
                    }
                }
            }

            return newTvSeriesLoadResponse(title, url, tvType, episodes) {
                this.posterUrl = poster
                this.backgroundPosterUrl = backgroundPoster
                try { this.logoUrl = logoUrl } catch(_:Throwable){}
                this.year = year
                this.plot = description
                this.tags = tags.ifEmpty { genres }
                this.score = rating
                this.contentRating = source
                this.actors=actors
                addImdbId(imdbId)
            }
        }

        return newMovieLoadResponse(title, url, TvType.Movie, href) {
            this.posterUrl = poster
            this.backgroundPosterUrl = backgroundPoster
            try { this.logoUrl = logoUrl } catch(_:Throwable){}
            this.year = year
            this.plot = description
            this.tags = tags.ifEmpty { genres }
            this.score = rating
            this.contentRating = source
            this.actors=actors
            addImdbId(imdbId)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data.isBlank()) return false

        val links = runCatching {
            JSONArray(data).let { arr ->
                buildList(arr.length()) {
                    for (i in 0 until arr.length()) {
                        arr.optString(i).trim().takeIf { it.isNotEmpty() }?.let { add(it) }
                    }
                }
            }
        }.getOrElse {
            listOf(data.trim()).filter { it.isNotEmpty() }
        }

        var success = false

        links.forEach { link ->
            runCatching {
                loadExtractor(link, name, subtitleCallback, callback)
                success = true
            }.onFailure {
                Log.e("XDMovies", "Failed to load link: $link")
            }
        }

        return success
    }

}



================================================
FILE: XDMovies/src/main/kotlin/com/Phisher98/XDMoviesParser.kt
================================================
package com.phisher98

import com.google.gson.annotations.SerializedName
import com.lagradost.cloudstream3.SearchQuality
import java.text.Normalizer

class SearchData : ArrayList<SearchData.SearchDataItem>(){
    data class SearchDataItem(
        val audio_languages: String,
        val exact_match: Int,
        val id: Int,
        val path: String,
        val poster: String,
        val qualities: List<String>,
        val release_year: String,
        val title: String,
        val tmdb_id: Int,
        val type: String
    )
}

data class IMDB(
    @SerializedName("imdb_id")
    val imdbId: String? = null
)

data class Meta(
    val id: String?,
    val imdb_id: String?,
    val type: String?,
    val poster: String?,
    val logo: String?,
    val background: String?,
    val moviedb_id: Int?,
    val name: String?,
    val description: String?,
    val genre: List<String>?,
    val releaseInfo: String?,
    val status: String?,
    val runtime: String?,
    val cast: List<String>?,
    val language: String?,
    val country: String?,
    val imdbRating: String?,
    val slug: String?,
    val year: String?,
    val videos: List<EpisodeDetails>?
)

data class EpisodeDetails(
    val id: String?,
    val name: String?,
    val title: String?,
    val season: Int?,
    val episode: Int?,
    val released: String?,
    val overview: String?,
    val thumbnail: String?,
    val moviedb_id: Int?
)

data class ResponseData(
    val meta: Meta?
)


data class TMDBRes(
    @SerializedName("_id")
    val id: String? = null,

    @SerializedName("air_date")
    val airDate: String? = null,

    val episodes: List<TMDBEpisode>? = null,

    val name: String? = null,

    val networks: List<Network>? = null,

    val overview: String? = null,

    @SerializedName("id")
    val id2: Long? = null,

    @SerializedName("poster_path")
    val posterPath: String? = null,

    @SerializedName("season_number")
    val seasonNumber: Int? = null,

    @SerializedName("vote_average")
    val voteAverage: Double? = null
)

data class TMDBEpisode(
    @SerializedName("air_date")
    val airDate: String? = null,

    @SerializedName("episode_number")
    val episodeNumber: Int? = null,

    @SerializedName("episode_type")
    val episodeType: String? = null,

    val id: Long? = null,

    val name: String? = null,

    val overview: String? = null,

    @SerializedName("production_code")
    val productionCode: String? = null,

    val runtime: Int? = null,

    @SerializedName("season_number")
    val seasonNumber: Int? = null,

    @SerializedName("show_id")
    val showId: Long? = null,

    @SerializedName("still_path")
    val stillPath: String? = null,

    @SerializedName("vote_average")
    val voteAverage: Double? = null,

    @SerializedName("vote_count")
    val voteCount: Int? = null,

    val crew: List<Crew>? = null,

    @SerializedName("guest_stars")
    val guestStars: List<GuestStar>? = null
)

data class Network(
    val id: Long? = null,
    @SerializedName("logo_path")
    val logoPath: String? = null,
    val name: String? = null,
    @SerializedName("origin_country")
    val originCountry: String? = null
)

data class Crew(
    val id: Long? = null,
    val name: String? = null,
    val job: String? = null
)

data class GuestStar(
    val id: Long? = null,
    val name: String? = null,
    val character: String? = null,
    val order: Int? = null
)

fun getSearchQuality(check: String?): SearchQuality? {
    val s = check ?: return null
    val u = Normalizer.normalize(s, Normalizer.Form.NFKC).lowercase()
    val patterns = listOf(
        Regex("\\b(4k|ds4k|uhd|2160p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.FourK,

        // CAM / THEATRE SOURCES FIRST
        Regex("\\b(hdts|hdcam|hdtc)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HdCam,
        Regex("\\b(camrip|cam[- ]?rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip,
        Regex("\\b(cam)\\b", RegexOption.IGNORE_CASE) to SearchQuality.Cam,

        // WEB / RIP
        Regex("\\b(web[- ]?dl|webrip|webdl)\\b", RegexOption.IGNORE_CASE) to SearchQuality.WebRip,

        // BLURAY
        Regex("\\b(bluray|bdrip|blu[- ]?ray)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,

        // RESOLUTIONS
        Regex("\\b(1440p|qhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.BlueRay,
        Regex("\\b(1080p|fullhd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,
        Regex("\\b(720p)\\b", RegexOption.IGNORE_CASE) to SearchQuality.SD,

        // GENERIC HD LAST
        Regex("\\b(hdrip|hdtv)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HD,

        Regex("\\b(dvd)\\b", RegexOption.IGNORE_CASE) to SearchQuality.DVD,
        Regex("\\b(hq)\\b", RegexOption.IGNORE_CASE) to SearchQuality.HQ,
        Regex("\\b(rip)\\b", RegexOption.IGNORE_CASE) to SearchQuality.CamRip
    )


    for ((regex, quality) in patterns) if (regex.containsMatchIn(u)) return quality
    return null
}


================================================
FILE: XDMovies/src/main/kotlin/com/Phisher98/XDMoviesProvider.kt
================================================
package com.phisher98

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class XDMoviesProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(XDMovies())
        registerExtractorAPI(Hubdrive())
        registerExtractorAPI(HubCloud())
        registerExtractorAPI(XdMoviesExtractor())
    }

    companion object {
        private const val DOMAINS_URL =
            "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/domains.json"
        var cachedDomains: Domains? = null

        suspend fun getDomains(forceRefresh: Boolean = false): Domains? {
            if (cachedDomains == null || forceRefresh) {
                try {
                    cachedDomains = app.get(DOMAINS_URL).parsedSafe<Domains>()
                } catch (e: Exception) {
                    e.printStackTrace()
                    return null
                }
            }
            return cachedDomains
        }

        data class Domains(
            @JsonProperty("hubcloud")
            val hubcloud: String,
        )
    }
}


================================================
FILE: Yflix/build.gradle.kts
================================================
import org.jetbrains.kotlin.konan.properties.Properties

// use an integer for version numbers
version = 10


android {
    buildFeatures {
        buildConfig = true
        viewBinding = true
    }
    defaultConfig {
        val properties = Properties()
        properties.load(project.rootProject.file("local.properties").inputStream())
        android.buildFeatures.buildConfig=true
        buildConfigField("String", "YFXENC", "\"${properties.getProperty("YFXENC")}\"")
        buildConfigField("String", "YFXDEC", "\"${properties.getProperty("YFXDEC")}\"")
        buildConfigField("String", "KAIMEG", "\"${properties.getProperty("KAIMEG")}\"")
    }
}
dependencies {
    implementation("com.google.android.material:material:1.13.0")
}


cloudstream {
    language = "en"
    // All of these properties are optional, you can safely remove them
    description = "Movies & TV Series Etc\nSettings allow selecting domains such as 1Movies,SolarMovie and Sflix"
    authors = listOf("Phisher98")
    /**
     * Status int as the following:
     * 0: Down
     * 1: Ok
     * 2: Slow
     * 3: Beta only
     * */
    status = 1 // will be 3 if unspecified
    tvTypes = listOf(
        "AsianDrama",
        "TvSeries",
        "Anime",
        "Movie",
        "Cartoon",
        "AnimeMovie"
    )

    iconUrl = "https://www.google.com/s2/favicons?domain=yflix.to/&sz=%size%"

    requiresResources = true
    isCrossPlatform = false
}


================================================
FILE: Yflix/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: Yflix/src/main/kotlin/com/yflix/BottomSheet.kt
================================================
package com.yflix

import android.annotation.SuppressLint
import android.app.Dialog
import android.content.Context
import android.content.Intent
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.RadioButton
import android.widget.RadioGroup
import android.widget.Toast
import com.google.android.material.bottomsheet.BottomSheetBehavior
import com.google.android.material.bottomsheet.BottomSheetDialog
import com.google.android.material.bottomsheet.BottomSheetDialogFragment
import com.phisher98.BuildConfig

class BottomFragment(private val plugin: YflixPlugin) : BottomSheetDialogFragment() {

    @SuppressLint("UseCompatLoadingForDrawables", "SetTextI18n", "DiscouragedApi")
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val id = plugin.resources!!.getIdentifier(
            "bottom_sheet_layout",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val layout = plugin.resources!!.getLayout(id)
        val view = inflater.inflate(layout, container, false)

        val outlineId = plugin.resources!!.getIdentifier(
            "outline",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )

        // Save button
        val saveIconId = plugin.resources!!.getIdentifier(
            "save_icon",
            "drawable",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )
        val saveBtn = view.findView<ImageView>("save")
        saveBtn.setImageDrawable(plugin.resources!!.getDrawable(saveIconId, null))
        saveBtn.background = plugin.resources!!.getDrawable(outlineId, null)
        saveBtn.setOnClickListener {
            context?.let { ctx ->
                AlertDialog.Builder(ctx)
                    .setTitle("Restart App?")
                    .setMessage("Save changes and restart the app?")
                    .setPositiveButton("Yes") { _, _ ->
                        restartApp(ctx)
                    }
                    .setNegativeButton("No") { dialog, _ ->
                        dialog.dismiss()
                        Toast.makeText(ctx, "Changes saved", Toast.LENGTH_SHORT).show()
                        dismiss()
                    }
                    .show()
            }
        }

        // Server selection radio buttons
        val serverGroup = view.findView<RadioGroup>("server_group")
        val radioBtnId = plugin.resources!!.getIdentifier(
            "radio_button",
            "layout",
            BuildConfig.LIBRARY_PACKAGE_NAME
        )

        ServerList.entries.forEach { server ->
            val radioBtnLayout = plugin.resources!!.getLayout(radioBtnId)
            val radioBtnView = inflater.inflate(radioBtnLayout, container, false)
            val radioBtn = radioBtnView.findView<RadioButton>("radio_button")

            val name = YflixPlugin.getServerName(server.link.first)
            val url = server.link.first

            radioBtn.text = "$name [$url]"

            radioBtn.isEnabled = server.link.second

            val newId = View.generateViewId()
            radioBtn.id = newId
            radioBtn.background = plugin.resources!!.getDrawable(outlineId, null)

            radioBtn.setOnClickListener {
                YflixPlugin.currentYflixServer = server.link.first
                serverGroup.check(newId)
            }

            serverGroup.addView(radioBtnView)

            if (YflixPlugin.currentYflixServer == server.link.first) {
                serverGroup.check(newId)
            }
        }


        return view
    }

    private fun <T : View> View.findView(name: String): T {
        val id = plugin.resources!!.getIdentifier(name, "id", BuildConfig.LIBRARY_PACKAGE_NAME)
        return findViewById(id)
    }

    override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
        val dialog = super.onCreateDialog(savedInstanceState)
        (dialog as? BottomSheetDialog)?.behavior?.state = BottomSheetBehavior.STATE_EXPANDED
        return dialog
    }

    private fun restartApp(context: Context) {
        val packageManager = context.packageManager
        val intent = packageManager.getLaunchIntentForPackage(context.packageName)
        val componentName = intent?.component

        if (componentName != null) {
            val restartIntent = Intent.makeRestartActivityTask(componentName)
            context.startActivity(restartIntent)
            Runtime.getRuntime().exit(0)
        }
    }
}



================================================
FILE: Yflix/src/main/kotlin/com/yflix/Extractor.kt
================================================
package com.yflix

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.newSubtitleFile
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.phisher98.BuildConfig
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.net.URLDecoder
import java.nio.charset.StandardCharsets


class Fourspromax : MegaUp() {
    override var mainUrl = "https://4spromax.site"
    override val requiresReferer = true
}

class Rapidairmax : MegaUp() {
    override var mainUrl = "https://rapidairmax.site"
    override val requiresReferer = true
}


class rapidshare : MegaUp() {
    override var mainUrl = "https://rapidshare.cc"
    override val requiresReferer = true
}

//Thanks to https://github.com/AzartX47/EncDecEndpoints
open class MegaUp : ExtractorApi() {
    override var name = "MegaUp"
    override var mainUrl = "https://megaup.live"
    override val requiresReferer = true

    companion object {
        private val HEADERS = mapOf(
                "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0",
                "Accept" to "text/html, *//*; q=0.01",
                "Accept-Language" to "en-US,en;q=0.5",
                "Sec-GPC" to "1",
                "Sec-Fetch-Dest" to "empty",
                "Sec-Fetch-Mode" to "cors",
                "Sec-Fetch-Site" to "same-origin",
                "Priority" to "u=0",
                "Pragma" to "no-cache",
                "Cache-Control" to "no-cache",
                "referer" to "https://yflix.to/",
        )
    }

    override suspend fun getUrl(
        url: String,
        referer: String?,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {

        val mediaUrl = url.replace("/e/", "/media/").replace("/e2/", "/media/")
        val displayName = referer ?: this.name

        val encodedResult = app.get(mediaUrl, headers = HEADERS)
        .parsedSafe<YflixResponse>()
        ?.result

        if (encodedResult == null) return

        val body = """
        {
        "text": "$encodedResult",
        "agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:134.0) Gecko/20100101 Firefox/134.0"
        }
        """.trimIndent()
            .trim()
            .toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val m3u8Data=app.post(BuildConfig.KAIMEG, requestBody = body).text
        if (m3u8Data.isBlank()) {
            Log.d("Phisher", "Encoded result is null or empty")
            return
        }

        try {
            val root = JSONObject(m3u8Data)
            val result = root.optJSONObject("result")
            if (result == null) {
                Log.d("Error:", "No 'result' object in M3U8 JSON")
                return
            }

            val sources = result.optJSONArray("sources") ?: JSONArray()
            if (sources.length() > 0) {
                val firstSourceObj = sources.optJSONObject(0)
                val m3u8File = when {
                    firstSourceObj != null -> firstSourceObj.optString("file").takeIf { it.isNotBlank() }
                    else -> {
                        val maybeString = sources.optString(0)
                        maybeString.takeIf { it.isNotBlank() }
                    }
                }
                if (m3u8File != null) {
                    M3u8Helper.generateM3u8(displayName, m3u8File, mainUrl).forEach(callback)
                } else {
                    Log.d("Error:", "No 'file' found in first source")
                }
            } else {
                Log.d("Error:", "No sources found in M3U8 data")
            }

            val tracks = result.optJSONArray("tracks") ?: JSONArray()
            Log.d("Phisher",tracks.toString())
            for (i in 0 until tracks.length()) {
                val trackObj = tracks.optJSONObject(i) ?: continue
                val label = trackObj.optString("label").trim().takeIf { it.isNotEmpty() }
                val file = trackObj.optString("file").takeIf { it.isNotBlank() }
                if (label != null && file != null) {
                    subtitleCallback(newSubtitleFile(label, file))
                }
            }

            try {
                val subtitleUrl = URLDecoder.decode(
                    url.substringAfter("sub.list="),
                    StandardCharsets.UTF_8.name()
                )

                val response = app.get(subtitleUrl).text
                val subtitles = tryParseJson<List<Map<String, Any>>>(response)

                subtitles?.forEach { sub ->
                    val file = sub["file"]?.toString()
                    val label = sub["label"]?.toString()
                    if (!file.isNullOrBlank() && !label.isNullOrBlank()) {
                        subtitleCallback(
                            newSubtitleFile(
                                label,
                                file
                            )
                        )
                    }
                }
            } catch (e: Exception) {
                Log.e("SubtitleLoader", "Failed to load subtitles: ${e.message}")
            }

        } catch (_: JSONException) {
            Log.e("Error", "Failed to parse M3U8 JSON")
        }
      }

    data class YflixResponse(
        @JsonProperty("status") val status: Int,
        @JsonProperty("result") val result: String
    )

}


================================================
FILE: Yflix/src/main/kotlin/com/yflix/Yflix.kt
================================================
package com.yflix

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.api.Log
import com.lagradost.cloudstream3.Actor
import com.lagradost.cloudstream3.ActorData
import com.lagradost.cloudstream3.Episode
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.MainAPI
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SearchResponseList
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.addDate
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.getQualityFromString
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newEpisode
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.newTvSeriesLoadResponse
import com.lagradost.cloudstream3.toNewSearchResponseList
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.phisher98.BuildConfig
import kotlinx.coroutines.delay
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import org.jsoup.nodes.Element
import java.net.URLEncoder
import kotlin.random.Random


class Yflix : MainAPI() {
    override var mainUrl = YflixPlugin.currentYflixServer
    override var name = YflixPlugin.getCurrentServerName()
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val hasQuickSearch = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.OVA,
        TvType.AnimeMovie,
        TvType.Anime,
        TvType.Cartoon,
        TvType.AsianDrama
    )

    private fun Element.toSearchResult(): SearchResponse {
        val href = fixUrl(this.select("a.poster").attr("href"))
        val title = this.select("a.title").text()
        val posterUrl = fixUrl(this.select("a.poster img").attr("data-src"))
        val quality = this.select("div.quality").text()
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = getQualityFromString(quality)
        }
    }


    companion object {
        private const val SIMKL = "https://api.simkl.com"
        private const val TMDB_API_KEY = "1865f43a0549ca50d341dd9ab8b29f49"
        const val TMDBAPI = "https://orange-voice-abcf.phisher16.workers.dev"

        const val TMDBIMAGEBASEURL = "https://image.tmdb.org/t/p/original"
        suspend fun decode(text: String?): String {
            return try {
                val res = app.get("${BuildConfig.YFXENC}?text=$text").text
                JSONObject(res).getString("result")
            } catch (_: Exception) {
                ""
            }
        }

        private val JSON = "application/json; charset=utf-8".toMediaType()

        suspend fun decodeReverse(text: String): String {
            val jsonBody = """{"text":"$text"}""".toRequestBody(JSON)

            return try {
                val res = app.post(
                    BuildConfig.YFXDEC,
                    requestBody = jsonBody
                ).text
                JSONObject(res).getString("result")
            } catch (_: Exception) {
                ""
            }
        }

    }


    override val mainPage =
        mainPageOf(
            "$mainUrl/browser?type[]=movie&sort=trending" to "Trending Movies",
            "$mainUrl/browser?type[]=tv&sort=trending" to "Trending TV Shows",
            "$mainUrl/browser?type%5B%5D=movie&type%5B%5D=tv&sort=imdb" to "Top IMDB",
            "$mainUrl/browser?type%5B%5D=movie&type%5B%5D=tv&sort=release_date" to "Latest Release"
        )

    override suspend fun quickSearch(query: String): List<SearchResponse> = search(query,1).items

    override suspend fun search(query: String, page: Int): SearchResponseList {
        val link = "$mainUrl/browser?keyword=$query&page=$page"
        val res = app.get(link).documentLarge
        return res.select("div.item").map { it.toSearchResult() }
            .toNewSearchResponseList()
    }


    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        delay(Random.nextLong(1000, 2000))

        val headers = mapOf(
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36",
            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
            "Accept-Language" to "en-US,en;q=0.9",
            "Referer" to "$mainUrl/",
            "Connection" to "keep-alive",
            "Upgrade-Insecure-Requests" to "1",
            "Cookie" to "usertype=guest; session=Mv2Y6x1b2I8SEw3fj0eNDfQYJM3CTpH9KjJc3ACK; cf_clearance=z9kEgtOSx3us4aluy5_5MfYEL6Ei8RJ3jCbcFTD2R1E-1745122952-1.2.1.1-UYjW2QUhPKUmojZE3XUE.gqHf3g5O6lvdl0qDCNPb5IjjavrpZIOpbE64osKxLbcblCAWynfNLv6bKSO75WzURG.FqDtfcu_si3MrCHECNtbMJC.k9cuhqDRcsz8hHPgpQE2fY8rR1z5Z4HfGmCw2MWMT6GelsZW_RQrTMHUYtIqjaEiAtxfcg.O4v_RGPwio_2J2V3rP16JbWO8wRh_dObNvWSMwMW.t44PhOZml_xWuh7DH.EIxLu3AzI91wggYU9rw6JJkaWY.UBbvWB0ThZRPTAJZy_9wlx2QFyh80AXU2c5BPHwEZPQhTQHBGQZZ0BGZkzoAB8pYI3f3eEEpBUW9fEbEJ9uoDKs7WOow8g"
        )

        val res = app.get("${request.data}&page=$page", headers).documentLarge
        val items = res.select("div.item").map { it.toSearchResult() }
        return newHomePageResponse(request.name, items)
    }


    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val keyword = url.substringAfter("/watch/").substringBefore(".")
        val poster = document.select("div.poster img").attr("src")
        val title = document.selectFirst("h1.title")?.text().orEmpty()
        val plot = document.selectFirst("div.description")?.text()
        val year = document.select("div.metadata.set span:nth-child(4)").text().toIntOrNull()
        val rating = document.selectFirst("div.metadata.set span.IMDb")?.ownText()
        val contentRating = document.select("div.metadata.set span.ratingR").text()
        val genres = document.select("li:contains(Genres:) a").map { it.text() }
        val backgroundPoster =
            document.selectFirst("div.detail-bg,div.site-movie-bg")?.attr("style")?.substringAfter("url('")
                ?.substringBefore("'")
        val dataId = document.select("#movie-rating").attr("data-id")
        val decoded = decode(dataId)

        val epRes = app.get("$mainUrl/ajax/episodes/list?keyword=$keyword&id=$dataId&_=$decoded")
            .parsedSafe<Response>()?.getDocument()

        val movieNode = epRes?.selectFirst("ul.episodes a")
        val allLinks = epRes?.select("ul.episodes a") ?: emptyList()
        val recommendations =
            document.select("div.film-section.md div.item").map { it.toSearchResult() }

        if (allLinks.size == 1 && movieNode != null && movieNode.text().contains("Movie", ignoreCase = true)) {
            val movieId = movieNode.attr("eid")

            val tmdbMovieId = runCatching { fetchtmdb(title,true) }.getOrNull()

            val imdbIdFromMovie = tmdbMovieId?.let { id ->
                runCatching {
                    val url = "$TMDBAPI/movie/$id/external_ids?api_key=$TMDB_API_KEY"
                    val jsonText = app.get(url).textLarge
                    JSONObject(jsonText).optString("imdb_id").takeIf { it.isNotBlank() }
                }.getOrNull()
            }

            val logoPath = imdbIdFromMovie?.let {
                "https://live.metahub.space/logo/medium/$it/img"
            }

            val simklIdMovie = imdbIdFromMovie?.let { imdb ->
                runCatching {
                    val simklJson =
                        JSONObject(app.get("$SIMKL/movies/$imdb?client_id=${com.lagradost.cloudstream3.BuildConfig.SIMKL_CLIENT_ID}").text)
                    simklJson.optJSONObject("ids")?.optInt("simkl")?.takeIf { it != 0 }
                }.getOrNull()
            }

            val movieCreditsJsonText = tmdbMovieId?.let { id ->
                runCatching {
                    app.get("$TMDBAPI/movie/$id/credits?api_key=$TMDB_API_KEY&language=en-US").textLarge
                }.getOrNull()
            }

            val bgurl = runCatching {
                val json = app.get(
                    "$TMDBAPI/movie/$tmdbMovieId/images?api_key=$TMDB_API_KEY&language=en-US&include_image_language=en,null"
                ).textLarge

                val backdrops = JSONObject(json).optJSONArray("backdrops")
                val bestBackdrop = backdrops?.optJSONObject(0)?.optString("file_path")?.takeIf { it.isNotBlank() }

                bestBackdrop?.let { "https://image.tmdb.org/t/p/original$it" }
            }.getOrNull()



            val movieCastList = parseCredits(movieCreditsJsonText)

            return newMovieLoadResponse(title, url, TvType.Movie, movieId) {
                this.posterUrl = poster
                this.backgroundPosterUrl = bgurl ?: backgroundPoster ?: poster
                try { this.logoUrl = logoPath } catch(_:Throwable){}
                this.plot = plot
                this.year = year
                this.contentRating = contentRating
                this.tags = genres
                this.score = Score.from10(rating)
                this.recommendations = recommendations
                imdbIdFromMovie?.let { addImdbId(it) }
                this.actors = movieCastList
            }
        }

        val episodes = ArrayList<Episode>()
        val tmdbShowId = runCatching { fetchtmdb(title,false) }.getOrNull()
        if (title.contains("Special"))
        {
            Log.d("Phisher",tmdbShowId.toString())

        }
        val imdbIdFromShow = tmdbShowId?.let { id ->
            runCatching {
                val url = "$TMDBAPI/tv/$id/external_ids?api_key=$TMDB_API_KEY"
                val jsonText = app.get(url).textLarge
                JSONObject(jsonText).optString("imdb_id").takeIf { it.isNotBlank() }
            }.getOrNull()
        }

        val logoPath = imdbIdFromShow?.let {
            "https://live.metahub.space/logo/medium/$it/img"
        }

        val simklIdShow = imdbIdFromShow?.let { imdb ->
            runCatching {
                val simklJson =
                    JSONObject(app.get("$SIMKL/tv/$imdb?client_id=${com.lagradost.cloudstream3.BuildConfig.SIMKL_CLIENT_ID}").text)
                simklJson.optJSONObject("ids")?.optInt("simkl")?.takeIf { it != 0 }
            }.getOrNull()
        }

        // fetch show credits once (used for actors)
        val showCreditsJsonText = tmdbShowId?.let { id ->
            runCatching {
                app.get("$TMDBAPI/tv/$id/credits?api_key=$TMDB_API_KEY&language=en-US").textLarge
            }.getOrNull()
        }
        val castList: List<ActorData> = parseCredits(showCreditsJsonText)

        val bgurl = runCatching {
            val json = app.get(
                "$TMDBAPI/tv/$imdbIdFromShow/images?api_key=$TMDB_API_KEY&language=en-US&include_image_language=en,null"
            ).textLarge

            val backdrops = JSONObject(json).optJSONArray("backdrops")
            val bestBackdrop = backdrops?.optJSONObject(0)?.optString("file_path")?.takeIf { it.isNotBlank() }

            bestBackdrop?.let { "https://image.tmdb.org/t/p/original$it" }
        }.getOrNull()

        epRes?.select("ul.episodes")?.forEach { seasonBlock ->
            val seasonNumber = seasonBlock.attr("data-season").toIntOrNull() ?: 1
            val tmdbSeasonJson = tmdbShowId?.let { id ->
                runCatching {
                    app.get("$TMDBAPI/tv/$id/season/$seasonNumber?api_key=$TMDB_API_KEY&language=en-US").textLarge
                }.getOrNull()?.let { JSONObject(it) }
            }

            val tmdbEpisodeMap = tmdbSeasonJson?.optJSONArray("episodes")?.let { arr ->
                val map = HashMap<Int, JSONObject>(arr.length())
                for (i in 0 until arr.length()) {
                    val o = arr.optJSONObject(i) ?: continue
                    val epNum = o.optInt("episode_number", -1)
                    if (epNum >= 0) map[epNum] = o
                }
                map
            }

            seasonBlock.select("a").forEachIndexed { index, ep ->
                val epNum = ep.attr("num").toIntOrNull() ?: (index + 1)
                val tmdbEpJson = tmdbEpisodeMap?.get(epNum)
                val epTitle = tmdbEpJson?.optString("name")?.takeIf { it.isNotBlank() }
                    ?: ep.selectFirst("span:last-child")?.text()?.trim().orEmpty()
                val airDate = tmdbEpJson?.optString("air_date")?.takeIf { it.isNotBlank() }
                    ?: ep.attr("title").trim().takeIf { it.isNotBlank() }
                val eid = ep.attr("eid")
                val desc = tmdbEpJson?.optString("overview")?.takeIf { it.isNotBlank() }
                    ?: ep.selectFirst("span.description")?.text()?.takeIf { it.isNotBlank() }
                val posterUrl = tmdbEpJson?.optString("still_path")?.takeIf { it.isNotBlank() }
                    ?.let { "$TMDBIMAGEBASEURL$it" }
                val score =
                    tmdbEpJson?.optDouble("vote_average")?.let { Score.from10(it.toString()) }
                episodes += newEpisode(eid) {
                    this.name = epTitle
                    this.season = seasonNumber
                    this.episode = epNum
                    this.posterUrl = posterUrl
                    this.description = desc
                    this.score = score
                    this.addDate(airDate)
                }
            }
        }

        return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
            this.posterUrl = poster
            this.backgroundPosterUrl = bgurl ?: backgroundPoster ?: poster
            try { this.logoUrl = logoPath } catch(_:Throwable){}
            this.plot = plot
            this.year = year
            this.contentRating = contentRating
            this.tags = genres
            this.score = Score.from10(rating)
            this.recommendations = recommendations
            addImdbId(imdbIdFromShow)
            this.actors = castList
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val eid = data.substringAfterLast("/")
        try {
            val decodetoken = decode(eid)
            val listResp = app.get("$mainUrl/ajax/links/list?eid=$eid&_=$decodetoken")
                .parsedSafe<Response>()
            val document = listResp?.getDocument()

            if (document == null) {
                Log.d(name, "No document returned for links list")
                return false
            }

            val servers = document.select("li.server,div.server")
            if (servers.isEmpty()) {
                Log.d(name, "No servers found in the links list")
                return false
            }

            servers.forEach { serverNode ->
                try {
                    val lid = serverNode.attr("data-lid").trim()
                    if (lid.isBlank()) {
                        Log.d(name, "Skipping server with empty lid")
                        return@forEach
                    }

                    val serverName =
                        serverNode.selectFirst("span")?.text()?.trim()?.ifEmpty { "Server" }
                    val decodelid = decode(lid)
                    val viewResp = app.get("$mainUrl/ajax/links/view?id=$lid&_=$decodelid")
                        .parsedSafe<Response>()

                    val result = viewResp?.result
                    if (result.isNullOrBlank()) {
                        Log.d(name, "Empty result for server $serverName (lid=$lid)")
                        return@forEach
                    }

                    val decodedIframePayload = try {
                        decodeReverse(result)
                    } catch (e: Exception) {
                        Log.d(name, "Failed to decodeReverse for lid=$lid : ${e.message}")
                        return@forEach
                    }


                    val iframeUrl = try {
                        extractVideoUrlFromJson(decodedIframePayload)
                    } catch (e: Exception) {
                        Log.d(name, "Failed to extract video url for lid=$lid : ${e.message}")
                        null
                    }

                    if (iframeUrl.isNullOrBlank()) {
                        Log.d(
                            name,
                            "No iframe/video url extracted for server $serverName (lid=$lid)"
                        )
                        return@forEach
                    }

                    val displayName = "⌜ $name ⌟  |  $serverName"
                    loadExtractor(iframeUrl, displayName, subtitleCallback, callback)
                } catch (inner: Exception) {
                    Log.d(name, "Error processing server node: ${inner.message}")
                }
            }

            return true
        } catch (e: Exception) {
            Log.d(name, "loadLinks failed: ${e.message}")
            return false
        }
    }


    data class Response(
        @get:JsonProperty("result") val result: String
    ) {
        fun getDocument(): Document {
            return Jsoup.parse(result)
        }
    }

    private fun extractVideoUrlFromJson(jsonData: String): String {
        val jsonObject = JSONObject(jsonData)
        return jsonObject.getString("url")
    }

    suspend fun fetchtmdb(title: String, isMovie: Boolean): Int? {
        val url =
            "$TMDBAPI/search/multi?api_key=$TMDB_API_KEY&query=" +
                    URLEncoder.encode(title, "UTF-8")

        val json = JSONObject(app.get(url).text)
        val results = json.optJSONArray("results") ?: return null

        val targetType = if (isMovie) "movie" else "tv"

        for (i in 0 until results.length()) {
            val item = results.optJSONObject(i) ?: continue

            if (item.optString("media_type") != targetType) continue

            val resultTitle = if (isMovie)
                item.optString("title")
            else
                item.optString("name")

            if (resultTitle.equals(title, ignoreCase = true)) {
                return item.optInt("id")
            }
        }
        return null
    }


    fun parseCredits(jsonText: String?): List<ActorData> {
        if (jsonText.isNullOrBlank()) return emptyList()
        val list = ArrayList<ActorData>()
        val root = JSONObject(jsonText)
        val castArr = root.optJSONArray("cast") ?: return list
        for (i in 0 until castArr.length()) {
            val c = castArr.optJSONObject(i) ?: continue
            val name = c.optString("name").takeIf { it.isNotBlank() } ?: c.optString("original_name").orEmpty()
            val profile = c.optString("profile_path").takeIf { it.isNotBlank() }?.let { "$TMDBIMAGEBASEURL$it" }
            val character = c.optString("character").takeIf { it.isNotBlank() }
            val actor = Actor(name, profile)
            list += ActorData(actor, roleString = character)
        }
        return list
    }


}




================================================
FILE: Yflix/src/main/kotlin/com/yflix/YflixPlugin.kt
================================================
package com.yflix

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.AcraApplication.Companion.setKey
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin

enum class ServerList(val link: Pair<String, Boolean>) {
    Yflix("https://yflix.to" to true),
    Moviesz("https://1movies.bz" to true),
    SOLARMovie("https://solarmovie.fi" to true),
    Sfix("https://sflix.fi" to true),
    Movhub("https://movhub.ws" to true),
}

@CloudstreamPlugin
class YflixPlugin : Plugin() {
    override fun load(context: Context) {
        registerMainAPI(Yflix())
        registerExtractorAPI(MegaUp())
        registerExtractorAPI(Fourspromax())
        registerExtractorAPI(Rapidairmax())
        registerExtractorAPI(rapidshare())

        this.openSettings = { ctx ->
            val activity = ctx as AppCompatActivity
            val frag = BottomFragment(this)
            frag.show(activity.supportFragmentManager, "")
        }
    }

    companion object {
        private val serverNameMap = mapOf(
            ServerList.Yflix.link.first to "YFlix",
            ServerList.Moviesz.link.first to "1Movies",
            ServerList.SOLARMovie.link.first to "SolarMovie",
            ServerList.Sfix.link.first to "SFlix",
            ServerList.Movhub.link.first to "Movhub",
        )

        var currentYflixServer: String
            get() = getKey("Yflix_CURRENT_SERVER") ?: ServerList.Yflix.link.first
            set(value) {
                setKey("Yflix_CURRENT_SERVER", value)
            }

        fun getCurrentServerName(): String {
            return serverNameMap[currentYflixServer] ?: currentYflixServer
        }

        fun getServerName(url: String): String {
            return serverNameMap[url] ?: url
        }
    }
}




================================================
FILE: Yflix/src/main/res/drawable/outline.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_focused="true">
        <shape>
            <stroke android:width="2dp"
                android:color="#FFF" />
            <corners
                android:bottomLeftRadius="2dp"
                android:bottomRightRadius="2dp"
                android:topLeftRadius="2dp"
                android:topRightRadius="2dp" />
        </shape>
    </item>
    <item android:state_hovered="true">
        <shape>
            <solid android:color="#99FFFFFF" />
        </shape>
    </item>
</selector>


================================================
FILE: Yflix/src/main/res/drawable/save_icon.xml
================================================
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="24dp"
    android:height="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24"
    android:tint="@android:color/white">
    <path
        android:fillColor="@android:color/white"
        android:pathData="M21,12.4V7l-4,-4H5C3.89,3 3,3.9 3,5v14c0,1.1 0.89,2 2,2h7.4L21,12.4zM15,15c0,1.66 -1.34,3 -3,3s-3,-1.34 -3,-3s1.34,-3 3,-3S15,13.34 15,15zM6,6h9v4H6V6zM19.99,16.25l1.77,1.77L16.77,23H15v-1.77L19.99,16.25zM23.25,16.51l-0.85,0.85l-1.77,-1.77l0.85,-0.85c0.2,-0.2 0.51,-0.2 0.71,0l1.06,1.06C23.45,16 23.45,16.32 23.25,16.51z" />
</vector>


================================================
FILE: Yflix/src/main/res/layout/bottom_sheet_layout.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<androidx.core.widget.NestedScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layoutDirection="ltr">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:paddingStart="?android:attr/listPreferredItemPaddingStart"
        android:paddingEnd="?android:attr/listPreferredItemPaddingEnd"
        android:paddingBottom="20dp"
        tools:background="@color/cardview_dark_background">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="20dp">

            <TextView
                android:id="@+id/text1"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_rowWeight="1"
                android:text="Extension Settings"
                android:textSize="20sp"
                android:textStyle="bold" />

            <LinearLayout
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="right">

                <ImageView
                    android:id="@+id/save"
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:background="#FFF"
                    android:padding="5dp"
                    android:contentDescription="Save changes" />

            </LinearLayout>

        </LinearLayout>

        <ImageView
            android:src="@android:drawable/divider_horizontal_dark"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:scaleType="fitXY"
            android:paddingLeft="2dp"
            android:paddingRight="2dp"
            android:layout_marginBottom="10dp"
            android:layout_marginTop="10dp" />

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:paddingBottom="10dp">

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:paddingBottom="10dp"
                android:text="YFlix Domains"
                android:textSize="17sp"
                android:textStyle="bold" />

            <RadioGroup
                android:id="@+id/server_group"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:orientation="vertical"/>

        </LinearLayout>

    </LinearLayout>
</androidx.core.widget.NestedScrollView>



================================================
FILE: Yflix/src/main/res/layout/radio_button.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:orientation="vertical">

    <RadioButton
        android:id="@+id/radio_button"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:paddingRight="5dp"
        android:text="test" />
</LinearLayout>



================================================
FILE: YTS/build.gradle.kts
================================================
// use an integer for version numbers
version = 8


cloudstream {
    // All of these properties are optional, you can safely remove them

    description = "YTS Movies 4K Support (Torrent)"
    language    = "en"
    authors = listOf("Phisher98")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // List of video source types. Users are able to filter for extensions in a given category.
    // You can find a list of available types here:
    // https://recloudstream.github.io/cloudstream/html/app/com.lagradost.cloudstream3/-tv-type/index.html
    tvTypes = listOf("Movie","Torrent")

    iconUrl = "https://raw.githubusercontent.com/phisher98/TVVVV/refs/heads/main/Icons/yts.png"

    isCrossPlatform = true
}



================================================
FILE: YTS/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest />


================================================
FILE: YTS/src/main/kotlin/com/YTS/YTS MAX.kt
================================================
package com.YTS

import com.lagradost.api.Log
import com.lagradost.cloudstream3.HomePageList
import com.lagradost.cloudstream3.HomePageResponse
import com.lagradost.cloudstream3.LoadResponse
import com.lagradost.cloudstream3.MainPageRequest
import com.lagradost.cloudstream3.Score
import com.lagradost.cloudstream3.SearchResponse
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.fixUrl
import com.lagradost.cloudstream3.fixUrlNull
import com.lagradost.cloudstream3.mainPageOf
import com.lagradost.cloudstream3.newHomePageResponse
import com.lagradost.cloudstream3.newMovieLoadResponse
import com.lagradost.cloudstream3.newMovieSearchResponse
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ExtractorLinkType
import com.lagradost.cloudstream3.utils.newExtractorLink
import org.jsoup.nodes.Element

class YTSMX : YTS(){
    override var mainUrl              = "https://yts.lt"
    override var name                 = "YTS MX"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasQuickSearch       = true
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie, TvType.Torrent)
    override val mainPage = mainPageOf(
        "browse-movies" to "Latest",
        "browse-movies/0/all/all/0/featured/0/all" to "Featured Movies",
        "browse-movies/0/1080p.x265/all/0/latest/0/all" to "1080p Movies",
        "browse-movies/0/2160p/all/0/latest/0/all" to "4K Movies",
        "browse-movies/0/all/all/0/seeds/0/all" to "Best Seeds Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url:String
        if (page==1)
        {
            url="$mainUrl/${request.data}"
        }
        else
        {
            url="$mainUrl/${request.data}?page=$page"
        }
        val document = app.get(url).documentLarge
        val home     = document.select("div.row div.browse-movie-wrap").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.browse-movie-bottom a").text().trim()
        val href      = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("img").attr("src"))
        val year=this.selectFirst("a div.browse-movie-year")?.text()?.toIntOrNull()
        val rating = this.select("h4.rating").text().substringBefore("/".trim())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.year = year
            this.score = Score.from10(rating)
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("#mobile-movie-info h1")?.text()?.trim() ?:"No Title"
        val poster = document.select("#movie-poster img").attr("src")
        val year = document.selectFirst("#mobile-movie-info h2")?.text()?.trim()?.toIntOrNull()
        val tags = document.selectFirst("#mobile-movie-info > h2:nth-child(3)")?.text()?.trim()
            ?.split(" / ")
            ?.map { it.trim() }
        val description= document.selectFirst("#synopsis p")?.text()?.trim()
        val rating= document.select("#movie-info > div.bottom-info > div:nth-child(2) > span:nth-child(2)").text()
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
            this.posterUrl = poster
            this.plot = description
            this.year = year
            this.score = Score.from10(rating)
            this.tags = tags
        }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        val TRACKER_LIST_URL="https://newtrackon.com/api/stable"
        document.select("p.hidden-md.hidden-lg a").map {
            val infoHash=it.attr("href").substringAfter("download/").substringBefore("?")
            if (infoHash.startsWith("http"))
            {
                Log.d("Error","Subtitles")
            }
            else {
                val quality = it.ownText().substringBefore(".").replace("p", "").toInt()
                val magnet = generateMagnetLink(TRACKER_LIST_URL, infoHash)
                callback.invoke(
                    newExtractorLink(
                        "$name $quality",
                        name,
                        url = magnet,
                        ExtractorLinkType.MAGNET
                    ) {
                        this.referer = ""
                        this.quality = quality
                    }
                )
            }
        }
        return true
    }

    private suspend fun generateMagnetLink(url: String, hash: String?): String {
        // Fetch the content of the file from the provided URL
        val response = app.get(url)
        val trackerList = response.text.trim().split("\n") // Assuming each tracker is on a new line
        // Build the magnet link
        return buildString {
            append("magnet:?xt=urn:btih:$hash")
            trackerList.forEach { tracker ->
                if (tracker.isNotBlank()) {
                    append("&tr=").append(tracker.trim())
                }
            }
        }
    }
}


================================================
FILE: YTS/src/main/kotlin/com/YTS/YTS.kt
================================================
package com.YTS

import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*

open class YTS : MainAPI() {
    override var mainUrl              = "https://www.yts-official.cc"
    override var name                 = "YTS"
    override val hasMainPage          = true
    override var lang                 = "en"
    override val hasQuickSearch       = true
    override val hasDownloadSupport   = true
    override val supportedTypes       = setOf(TvType.Movie,TvType.Torrent)

    override val mainPage = mainPageOf(
        "browse-movies?keyword=&quality=2160p&genre=all&rating=0&year=0&order_by=latest" to "Latest",
        "browse-movies?keyword=&quality=all&genre=all&rating=0&year=0&order_by=featured" to "Featured",
        "browse-movies?keyword=&quality=2160p&genre=all&rating=0&year=0&order_by=latest" to "4K Movies",
        "browse-movies?keyword=&quality=1080p&genre=all&rating=0&year=0&order_by=latest" to "1080p Movies",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/${request.data}&page=$page").documentLarge
        val home     = document.select("div.row div.browse-movie-wrap").mapNotNull { it.toSearchResult() }

        return newHomePageResponse(
            list    = HomePageList(
                name               = request.name,
                list               = home,
                isHorizontalImages = false
            ),
            hasNext = true
        )
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title     = this.select("div.browse-movie-bottom a").text().trim()
        val href      = fixUrl(this.select("a").attr("href"))
        val posterUrl = fixUrlNull(this.select("img").attr("src"))
        val year=this.selectFirst("a div.browse-movie-year")?.text()?.toIntOrNull()
        val rating = this.select("h4.rating").text().substringBefore("/".trim())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.year = year
            this.score = Score.from10(rating)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse = mutableListOf<SearchResponse>()

        for (i in 1..3) {
            val document = app.get("${mainUrl}/browse-movies?keyword=$query&quality=all&genre=all&rating=0&order_by=latest&year=0&page=$i").documentLarge
            val results = document.select("div.row div.browse-movie-wrap").mapNotNull { it.toSearchResult() }
            if (!searchResponse.containsAll(results)) {
                searchResponse.addAll(results)
            } else {
                break
            }

            if (results.isEmpty()) break
        }

        return searchResponse
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).documentLarge
        val title = document.selectFirst("#mobile-movie-info h1")?.text()?.trim() ?:"No Title"
        val poster = getURL(document.select("#movie-poster img").attr("src"))
        val year = document.selectFirst("#mobile-movie-info h2")?.text()?.trim()?.toIntOrNull()
        val tags = document.selectFirst("#mobile-movie-info > h2:nth-child(3)")?.text()?.trim()
            ?.split(" / ")
            ?.map { it.trim() }
        val rating= document.select("#movie-info > div.bottom-info > div:nth-child(2) > span:nth-child(2)").text()
        return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.plot = title
                this.year = year
                this.score = Score.from10(rating)
                this.tags = tags
            }
    }

    override suspend fun loadLinks(data: String, isCasting: Boolean, subtitleCallback: (SubtitleFile) -> Unit, callback: (ExtractorLink) -> Unit): Boolean {
        val document = app.get(data).documentLarge
        document.select("p.hidden-md.hidden-lg a").amap {
            val href=getURL(it.attr("href").replace(" ","%20"))
            val quality =it.ownText().substringBefore(".").replace("p","").toInt()
            callback.invoke(
                newExtractorLink(
                    "$name $quality",
                    name,
                    url = fixUrl(href),
                    INFER_TYPE
                ) {
                    this.referer = ""
                    this.quality = quality
                }
            )
        }
        return true
    }

    private fun getURL(url: String): String {
            return "${mainUrl}$url"
    }
}



================================================
FILE: YTS/src/main/kotlin/com/YTS/YTSProvider.kt
================================================
package com.YTS

import com.lagradost.cloudstream3.plugins.BasePlugin
import com.lagradost.cloudstream3.plugins.CloudstreamPlugin

@CloudstreamPlugin
class YTSProvider: BasePlugin() {
    override fun load() {
        registerMainAPI(YTS())
        registerMainAPI(YTSMX())

    }
}



================================================
FILE: .github/ISSUE_TEMPLATE/01_report_issue.yml
================================================
name: 🐞 Issue report
description: Report a source issue
title: "[Site Issue] "
labels: [Bug]
assignees: phisher98
body:

  - type: input
    id: source
    attributes:
      label: Extension Name
      description: |
        You can find the extension name in App.
      placeholder: |
        Example: "Anplay"
    validations:
      required: true

  - type: dropdown
    id: issue-type
    attributes:
      label: "Issue Type"
      options:
        - "Site is broken/offline"
        - "Duplicate site"
        - "Other issue"
    validations:
      required: true

  - type: input
    id: language
    attributes:
      label: Source language
      placeholder: |
        Example: "Hindi"
    validations:
      required: true

  - type: textarea
    id: reproduce-steps
    attributes:
      label: Steps to reproduce
      description: Provide an example of the issue. Be as specific as possible.
      placeholder: |
        Example:
          1. First step (e.g. "Open Mahouka Koukou No Rettousei (first season)")
          2. Second step (e.g. "Try to watch episode 15")
          3. Issue here (e.g. "It shows a HTTP 403 error toast")
    validations:
      required: true

  - type: textarea
    id: expected-behavior
    attributes:
      label: Expected behavior
      placeholder: |
        Example:
          "This should happen..."
    validations:
      required: true

  - type: textarea
    id: actual-behavior
    attributes:
      label: Actual behavior
      placeholder: |
        Example:
          "This happened instead..."
    validations:
      required: true

  - type: input
    id: cs-version
    attributes:
      label: CloudStream Version
      description: |
        You can find your Cloudstream Version in Settings at Bottom.
      placeholder: |
        Example: "Red Icon  -Version" or "Blue Icon - Version"
    validations:
      required: true


  - type: textarea
    id: other-details
    attributes:
      label: Other details
      placeholder: |
        Additional details and attachments.

  - type: checkboxes
    id: acknowledgements
    attributes:
      label: Acknowledgements
      description: Your issue will be closed if you haven't done these steps.
      options:
        - label: I have searched the existing issues and this is a new ticket, **NOT** a duplicate or related to another open or closed issue.
          required: true
        - label: I have written a short but informative title.
          required: true
        - label: I have updated the app to version **[Pre Release Updated Version](https://github.com/recloudstream/cloudstream/releases/tag/pre-release)**.
          required: true
        - label: I will fill out all of the requested information in this form.
          required: true



================================================
FILE: .github/ISSUE_TEMPLATE/02_site-request.yml
================================================
name: ⭐ Source Request
description: Request a new Source
title: "[Site Suggestion] "
labels: [Site request]
assignees: phisher98
body:

  - type: input
    id: name
    attributes:
      label: Source name
      placeholder: |
        Example: "Not Real Source"
    validations:
      required: true

  - type: input
    id: link
    attributes:
      label: Source link
      placeholder: |
        Example: "https://notrealsource.org"
    validations:
      required: true

  - type: input
    id: language
    attributes:
      label: Source language
      placeholder: |
        Example: "Hindi"
    validations:
      required: true

  - type: textarea
    id: other-details
    attributes:
      label: Other details
      placeholder: |
        Additional details and attachments.
        Example: "+18/NSFW = yes"

  - type: checkboxes
    id: acknowledgements
    attributes:
      label: Acknowledgements
      description: Your issue will be closed if you haven't done these steps.
      options:
        - label: I have searched the existing issues and this is a new ticket, **NOT** a duplicate or related to another open or closed issue.
          required: true
        - label: I have written a title with source name.
          required: true
        - label: I have checked that the extension does not already exist on the any Dev Repo or Request.
          required: true
        - label: I have checked that the extension does not already exist by searching on CS and verified it.
          required: true
        - label: I will fill out all of the requested information in this form.
          required: true



================================================
FILE: .github/ISSUE_TEMPLATE/09_Other_Issue.yml
================================================
name: 👀 Other Issue
description: Any Other Issue
assignees: phisher98
body:

  - type: markdown
    attributes:
      value: |
        ### Other Issue
        If you have a any other Issue.

  - type: textarea
    id: Details
    attributes:
      label: Details
      placeholder: |
        Additional details and attachments.

  - type: checkboxes
    id: acknowledgements
    attributes:
      label: Acknowledgements
      description: Your issue will be closed if you haven't done these steps.
      options:
        - label: I have searched the existing issues and this is a new ticket, **NOT** a duplicate or related to another open or closed issue.
          required: true
        - label: I have written a title with source name.
          required: true
        - label: I have updated all installed extensions.
          required: true
        - label: I have opened WebView and checked that the source website is down.
          required: true
        - label: I will fill out all of the requested information in this form.
          required: true



================================================
FILE: .github/workflows/newrun.yml
================================================
name: Build

# https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#concurrency
concurrency:
  group: "build"
  cancel-in-progress: true

on:
  push:
    branches:
      # choose your default branch
      - master
      - main
    paths-ignore:
      - '*.md'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          path: "src"

      - name: Checkout builds
        uses: actions/checkout@v5
        with:
          ref: "builds"
          path: "builds"

      - name: Clean old builds
        run: |
          rm $GITHUB_WORKSPACE/builds/*.cs3 || true
          rm $GITHUB_WORKSPACE/builds/*.jar || true

      - name: Setup JDK 17
        uses: actions/setup-java@v5
        with:
          java-version: 17
          distribution: adopt
          cache: gradle

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3.2.2

      - name: Access Secrets
        env:
          TMDB_API: ${{ secrets.TMDB_API }}
          DUMP_API: ${{ secrets.DUMP_API }}
          DUMP_KEY: ${{ secrets.DUMP_KEY }}
          ANICHI_API: ${{ secrets.ANICHI_API }}
          ANICHI_SERVER: ${{ secrets.ANICHI_SERVER }}
          ANICHI_ENDPOINT: ${{ secrets.ANICHI_ENDPOINT }}
          ANICHI_APP: ${{ secrets.ANICHI_APP }}
          ZSHOW_API: ${{ secrets.ZSHOW_API }}
          SFMOVIES_API: ${{ secrets.SFMOVIES_API }}
          CINEMATV_API: ${{ secrets.CINEMATV_API }}
          GHOSTX_API: ${{ secrets.GHOSTX_API }}
          SUPERSTREAM_FIRST_API: ${{ secrets.SUPERSTREAM_FIRST_API }}
          SUPERSTREAM_SECOND_API: ${{ secrets.SUPERSTREAM_SECOND_API }}
          SUPERSTREAM_THIRD_API: ${{ secrets.SUPERSTREAM_THIRD_API }}
          SUPERSTREAM_FOURTH_API: ${{ secrets.SUPERSTREAM_FOURTH_API }}
          AsianDrama_API: ${{ secrets.AsianDrama_API }}
          FanCode_API: ${{ secrets.FanCode_API }}
          Whvx_API: ${{ secrets.Whvx_API }}
          JapanIPTV: ${{ secrets.JapanIPTV }}
          SonyIPTV: ${{ secrets.SonyIPTV }}
          PirateIPTV: ${{ secrets.PirateIPTV }}
          Su_sports: ${{ secrets.Su_sports }}
          CatflixAPI: ${{ secrets.CatflixAPI }}
          ConsumetAPI: ${{ secrets.ConsumetAPI }}
          FlixHQAPI: ${{ secrets.FlixHQAPI }}
          WhvxAPI: ${{ secrets.WhvxAPI }}
          WhvxT: ${{ secrets.WhvxT }}
          SharmaflixApikey: ${{ secrets.SharmaflixApikey }}
          SharmaflixApi: ${{ secrets.SharmaflixApi }}
          Theyallsayflix: ${{ secrets.Theyallsayflix }}
          HianimeAPI: ${{ secrets.HianimeAPI }}
          Vidsrccc: ${{ secrets.Vidsrccc }}
          WASMAPI: ${{ secrets.WASMAPI }}
          KissKh: ${{ secrets.KissKh }}
          KisskhSub: ${{ secrets.KisskhSub }}
          StreamPlayAPI: ${{ secrets.StreamPlayAPI }}
          PROXYAPI: ${{ secrets.PROXYAPI }}
          KAISVA: ${{ secrets.KAISVA }}
          MAL_API: ${{ secrets.MAL_API }}
          MOVIEBOX_SECRET_KEY_ALT: ${{ secrets.MOVIEBOX_SECRET_KEY_ALT }}
          MOVIEBOX_SECRET_KEY_DEFAULT: ${{ secrets.MOVIEBOX_SECRET_KEY_DEFAULT }}
          SuperToken: ${{ secrets.SuperToken }}
          KAIDEC: ${{ secrets.KAIDEC }}
          KAIENC: ${{ secrets.KAIENC }}
          KAIMEG: ${{ secrets.KAIMEG }}
          NuvioStreams: ${{ secrets.NuvioStreams }}
          YFXENC: ${{ secrets.YFXENC }}
          YFXDEC: ${{ secrets.YFXDEC }}
          VideasyDEC: ${{ secrets.VideasyDEC }}
        run: |
          cd $GITHUB_WORKSPACE/src
          echo TMDB_API=$TMDB_API >> local.properties
          echo DUMP_API=$DUMP_API >> local.properties
          echo DUMP_KEY=$DUMP_KEY >> local.properties
          echo ANICHI_API=$ANICHI_API >> local.properties
          echo ANICHI_SERVER=$ANICHI_SERVER >> local.properties
          echo ANICHI_ENDPOINT=$ANICHI_ENDPOINT >> local.properties
          echo ANICHI_APP=$ANICHI_APP >> local.properties
          echo ZSHOW_API=$ZSHOW_API >> local.properties
          echo SFMOVIES_API=$SFMOVIES_API >> local.properties
          echo CINEMATV_API=$CINEMATV_API >> local.properties
          echo GHOSTX_API=$GHOSTX_API >> local.properties
          echo SUPERSTREAM_FIRST_API=$SUPERSTREAM_FIRST_API >> local.properties
          echo SUPERSTREAM_SECOND_API=$SUPERSTREAM_SECOND_API >> local.properties
          echo SUPERSTREAM_THIRD_API=$SUPERSTREAM_THIRD_API >> local.properties
          echo SUPERSTREAM_FOURTH_API=$SUPERSTREAM_FOURTH_API >> local.properties
          echo AsianDrama_API=$AsianDrama_API >> local.properties
          echo FanCode_API=$FanCode_API >> local.properties
          echo Whvx_API=$Whvx_API >> local.properties
          echo Su_sports=$Su_sports >> local.properties
          echo PirateIPTV=$PirateIPTV >> local.properties
          echo SonyIPTV=$SonyIPTV >> local.properties
          echo JapanIPTV=$JapanIPTV >> local.properties
          echo CatflixAPI=$CatflixAPI >> local.properties
          echo ConsumetAPI=$ConsumetAPI >> local.properties
          echo FlixHQAPI=$FlixHQAPI >> local.properties
          echo WhvxAPI=$WhvxAPI >> local.properties
          echo WhvxT=$WhvxT >> local.properties
          echo SharmaflixApi=$SharmaflixApi >> local.properties
          echo SharmaflixApikey=$SharmaflixApikey >> local.properties
          echo HianimeAPI=$HianimeAPI >> local.properties
          echo Vidsrccc=$Vidsrccc >> local.properties
          echo WASMAPI=$WASMAPI >> local.properties
          echo KissKh=$KissKh >> local.properties
          echo KisskhSub=$KisskhSub >> local.properties
          echo StreamPlayAPI=$StreamPlayAPI >> local.properties
          echo PROXYAPI=$PROXYAPI >> local.properties
          echo KAISVA=$KAISVA >> local.properties
          echo MAL_API=$MAL_API >> local.properties
          echo MOVIEBOX_SECRET_KEY_DEFAULT=$MOVIEBOX_SECRET_KEY_DEFAULT >> local.properties
          echo MOVIEBOX_SECRET_KEY_ALT=$MOVIEBOX_SECRET_KEY_ALT >> local.properties
          echo SuperToken=$SuperToken >> local.properties
          echo KAIDEC=$KAIDEC >> local.properties
          echo KAIENC=$KAIENC >> local.properties
          echo KAIMEG=$KAIMEG >> local.properties
          echo NuvioStreams=$NuvioStreams >> local.properties
          echo YFXDEC=$YFXDEC >> local.properties
          echo YFXENC=$YFXENC >> local.properties
          echo VideasyDEC=$VideasyDEC >> local.properties
      - name: Build Plugins
        run: |
          cd $GITHUB_WORKSPACE/src
          chmod +x gradlew
          ./gradlew make makePluginsJson
          ./gradlew ensureJarCompatibility
          cp **/build/*.cs3 $GITHUB_WORKSPACE/builds
          cp **/build/*.jar $GITHUB_WORKSPACE/builds
          cp build/plugins.json $GITHUB_WORKSPACE/builds

      - name: Push builds
        run: |
          cd $GITHUB_WORKSPACE/builds
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          git add .
          git commit --amend -m "Build $GITHUB_SHA" || exit 0   # do not error if nothing to commit
          git push --force


