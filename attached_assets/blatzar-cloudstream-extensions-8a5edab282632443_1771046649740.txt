Directory structure:
└── blatzar-cloudstream-extensions/
    ├── README.md
    ├── build.gradle.kts
    ├── gradle.properties
    ├── gradlew
    ├── gradlew.bat
    ├── settings.gradle.kts
    ├── AkwamProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AkwamProvider.kt
    │                       └── AkwamProviderPlugin.kt
    ├── AllMoviesForYouProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AllMoviesForYouProvider.kt
    │                       └── AllMoviesForYouProviderPlugin.kt
    ├── AltadefinizioneProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AltadefinizioneProvider.kt
    │                       └── AltadefinizioneProviderPlugin.kt
    ├── AsiaFlixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AsiaFlixProvider.kt
    │                       └── AsiaFlixProviderPlugin.kt
    ├── AsianLoadProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AsianLoadProvider.kt
    │                       └── AsianLoadProviderPlugin.kt
    ├── BflixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── BflixProvider.kt
    │                       └── BflixProviderPlugin.kt
    ├── CinecalidadProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── CinecalidadProvider.kt
    │                       └── CinecalidadProviderPlugin.kt
    ├── CuevanaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── CuevanaProvider.kt
    │                       └── CuevanaProviderPlugin.kt
    ├── DopeboxProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── DopeboxProvider.kt
    │                       └── DopeboxProviderPlugin.kt
    ├── DoramasYTProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── DoramasYTProvider.kt
    │                       └── DoramasYTProviderPlugin.kt
    ├── DramaidProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── DramaidProvider.kt
    │                       └── DramaidProviderPlugin.kt
    ├── DramaSeeProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── DramaSeeProvider.kt
    │                       └── DramaSeeProviderPlugin.kt
    ├── DubokuProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── DubokuProvider.kt
    │                       └── DubokuProviderPlugin.kt
    ├── EgyBestProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── EgyBestProvider.kt
    │                       └── EgyBestProviderPlugin.kt
    ├── ElifilmsProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── ElifilmsProvider.kt
    │                       └── ElifilmsProviderPlugin.kt
    ├── EntrepeliculasyseriesProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── EntrepeliculasyseriesProvider.kt
    │                       └── EntrepeliculasyseriesProviderPlugin.kt
    ├── EstrenosDoramasProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── EstrenosDoramasProvider.kt
    │                       └── EstrenosDoramasProviderPlugin.kt
    ├── FaselHDProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── FaselHDProvider.kt
    │                       └── FaselHDProviderPlugin.kt
    ├── FilmanProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── FilmanProvider.kt
    │                       └── FilmanProviderPlugin.kt
    ├── FilmpertuttiProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── FilmpertuttiProvider.kt
    │                       └── FilmpertuttiProviderPlugin.kt
    ├── FmoviesToProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── FmoviesToProvider.kt
    │                       └── FmoviesToProviderPlugin.kt
    ├── FrenchStreamProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── FrenchStreamProvider.kt
    │                       └── FrenchStreamProviderPlugin.kt
    ├── gradle/
    │   └── wrapper/
    │       └── gradle-wrapper.properties
    ├── HDMovie5/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── HDMovie5.kt
    │                       └── HDMovie5Plugin.kt
    ├── HDMProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── HDMProvider.kt
    │                       └── HDMProviderPlugin.kt
    ├── HDrezkaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── HDrezkaProvider.kt
    │                       └── HDrezkaProviderPlugin.kt
    ├── HDTodayProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── HDTodayProvider.kt
    │                       └── HDTodayProviderPlugin.kt
    ├── IdlixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── IdlixProvider.kt
    │                       └── IdlixProviderPlugin.kt
    ├── IHaveNoTvProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── IHaveNoTvProvider.kt
    │                       └── IHaveNoTvProviderPlugin.kt
    ├── IlGenioDelloStreamingProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── IlGenioDelloStreamingProvider.kt
    │                       └── IlGenioDelloStreamingProviderPlugin.kt
    ├── KdramaHoodProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── KdramaHoodProvider.kt
    │                       └── KdramaHoodProviderPlugin.kt
    ├── KisskhProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── KisskhProvider.kt
    │                       └── KisskhProviderPlugin.kt
    ├── LayarKacaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── LayarKacaProvider.kt
    │                       └── LayarKacaProviderPlugin.kt
    ├── MeloMovieProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── MeloMovieProvider.kt
    │                       └── MeloMovieProviderPlugin.kt
    ├── MultiplexProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── MultiplexProvider.kt
    │                       └── MultiplexProviderPlugin.kt
    ├── MyCimaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── MyCimaProvider.kt
    │                       └── MyCimaProviderPlugin.kt
    ├── NginxProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── NginxProvider.kt
    │                       └── NginxProviderPlugin.kt
    ├── OlgplyProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── OlgplyProvider.kt
    │                       └── OlgplyProviderPlugin.kt
    ├── OpenVidsProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── OpenVidsProvider.kt
    │                       └── OpenVidsProviderPlugin.kt
    ├── PelisflixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PelisflixProvider.kt
    │                       └── PelisflixProviderPlugin.kt
    ├── PeliSmartProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PeliSmartProvider.kt
    │                       └── PeliSmartProviderPlugin.kt
    ├── PelisplusHDProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PelisplusHDProvider.kt
    │                       └── PelisplusHDProviderPlugin.kt
    ├── PelisplusProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PelisplusProvider.kt
    │                       └── PelisplusProviderPlugin.kt
    ├── PelisplusProviderTemplate/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PelisplusProviderTemplate.kt
    │                       └── PelisplusProviderTemplatePlugin.kt
    ├── PhimmoichillProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PhimmoichillProvider.kt
    │                       └── PhimmoichillProviderPlugin.kt
    ├── PinoyHDXyzProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PinoyHDXyzProvider.kt
    │                       └── PinoyHDXyzProviderPlugin.kt
    ├── PinoyMoviePediaProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PinoyMoviePediaProvider.kt
    │                       └── PinoyMoviePediaProviderPlugin.kt
    ├── PinoyMoviesEsProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── PinoyMoviesEsProvider.kt
    │                       ├── PinoyMoviesEsProviderPlugin.kt
    │                       └── VstreamhubHelper.kt
    ├── RebahinProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── RebahinProvider.kt
    │                       └── RebahinProviderPlugin.kt
    ├── SeriesflixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SeriesflixProvider.kt
    │                       └── SeriesflixProviderPlugin.kt
    ├── SflixProProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SflixProProvider.kt
    │                       └── SflixProProviderPlugin.kt
    ├── SflixProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SflixProvider.kt
    │                       └── SflixProviderPlugin.kt
    ├── SoaptwoDayProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SoaptwoDayProvider.kt
    │                       └── SoaptwoDayProviderPlugin.kt
    ├── SolarmovieProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SolarmovieProvider.kt
    │                       └── SolarmovieProviderPlugin.kt
    ├── StreamingcommunityProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── StreamingcommunityProvider.kt
    │                       └── StreamingcommunityProviderPlugin.kt
    ├── SuperStream/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── SuperStream.kt
    │                       └── SuperStreamPlugin.kt
    ├── TantiFilmProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── TantiFilmProvider.kt
    │                       └── TantiFilmProviderPlugin.kt
    ├── TheFlixToProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── TheFlixToProvider.kt
    │                       └── TheFlixToProviderPlugin.kt
    ├── TrailersTwoProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── TrailersTwoProvider.kt
    │                       └── TrailersTwoProviderPlugin.kt
    ├── TwoEmbedProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── TwoEmbedProvider.kt
    │                       └── TwoEmbedProviderPlugin.kt
    ├── UakinoProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── UakinoProvider.kt
    │                       └── UakinoProviderPlugin.kt
    ├── VfFilmProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── VfFilmProvider.kt
    │                       └── VfFilmProviderPlugin.kt
    ├── VfSerieProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── VfSerieProvider.kt
    │                       └── VfSerieProviderPlugin.kt
    ├── VidEmbedProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── VidEmbedProvider.kt
    │                       └── VidEmbedProviderPlugin.kt
    ├── VidSrcProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── VidSrcProvider.kt
    │                       └── VidSrcProviderPlugin.kt
    ├── VidstreamProviderTemplate/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── MultiQuality.kt
    │                       ├── Vidstream.kt
    │                       ├── VidstreamProviderTemplate.kt
    │                       └── VidstreamProviderTemplatePlugin.kt
    ├── VMoveeProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── VMoveeProvider.kt
    │                       └── VMoveeProviderPlugin.kt
    ├── WatchAsianProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── AsianEmbedHelper.kt
    │                       ├── WatchAsianProvider.kt
    │                       ├── WatchAsianProviderPlugin.kt
    │                       └── XStreamCdn.kt
    ├── XcineProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── XcineProvider.kt
    │                       └── XcineProviderPlugin.kt
    ├── YomoviesProvider/
    │   ├── build.gradle.kts
    │   └── src/
    │       └── main/
    │           ├── AndroidManifest.xml
    │           └── kotlin/
    │               └── com/
    │                   └── lagradost/
    │                       ├── YomoviesProvider.kt
    │                       └── YomoviesProviderPlugin.kt
    └── .github/
        └── workflows/
            └── build.yml

================================================
FILE: README.md
================================================
**⚠️ This is currently under development, dont use it yet if you're not comfortable with constantly merging new changes**

# Cloudstream 3 Movies Repository

Not all extractors are included, only those need to compile. We need to use loadExtractor in the future.

## Getting started with writing your first plugin

1. Open the root build.gradle.kts, read the comments and replace all the placeholders
2. Familiarize yourself with the project structure. Most files are commented
3. Build or deploy your first plugin using:
   - Windows: `.\gradlew.bat ExampleProvider:make` or `.\gradlew.bat ExampleProvider:deployWithAdb`
   - Linux & Mac: `./gradlew ExampleProvider:make` or `./gradlew ExampleProvider:deployWithAdb`

## License

Everything in this repo is released into the public domain. You may use it however you want with no conditions whatsoever


## Attribution

This template as well as the gradle plugin and the whole plugin system is **heavily** based on [Aliucord](https://github.com/Aliucord).
*Go use it, it's a great mobile discord client mod!*


================================================
FILE: build.gradle.kts
================================================
import com.lagradost.cloudstream3.gradle.CloudstreamExtension
import com.android.build.gradle.BaseExtension

buildscript {
    repositories {
        google()
        mavenCentral()
        // Shitpack repo which contains our tools and dependencies
        maven("https://jitpack.io")
    }

    dependencies {
        classpath("com.android.tools.build:gradle:7.0.4")
        // Cloudstream gradle plugin which makes everything work and builds plugins
        classpath("com.github.recloudstream:gradle:master-SNAPSHOT")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.7.10")
    }
}

allprojects {
    repositories {
        google()
        mavenCentral()
        maven("https://jitpack.io")
    }
}

fun Project.cloudstream(configuration: CloudstreamExtension.() -> Unit) =
    extensions.getByName<CloudstreamExtension>("cloudstream").configuration()

fun Project.android(configuration: BaseExtension.() -> Unit) =
    extensions.getByName<BaseExtension>("android").configuration()

subprojects {
    apply(plugin = "com.android.library")
    apply(plugin = "kotlin-android")
    apply(plugin = "com.lagradost.cloudstream3.gradle")

    cloudstream {
        // when running through github workflow, GITHUB_REPOSITORY should contain current repository name
        setRepo(System.getenv("GITHUB_REPOSITORY") ?: "user/repo")
    }

    android {
        compileSdkVersion(30)

        defaultConfig {
            minSdk = 24
            targetSdk = 30
        }

        compileOptions {
            sourceCompatibility = JavaVersion.VERSION_11
            targetCompatibility = JavaVersion.VERSION_11
        }

        tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
            kotlinOptions {
                jvmTarget = "11" // Required
                // Disables some unnecessary features
                freeCompilerArgs = freeCompilerArgs +
                        "-Xno-call-assertions" +
                        "-Xno-param-assertions" +
                        "-Xno-receiver-assertions"
            }
        }
    }

    dependencies {
        val apk by configurations
        val implementation by configurations

        // Stubs for all Cloudstream classes
        apk("com.lagradost:cloudstream3:pre-release")

        // these dependencies can include any of those which are added by the app,
        // but you dont need to include any of them if you dont need them
        // https://github.com/recloudstream/cloudstream/blob/master/app/build.gradle
        implementation(kotlin("stdlib")) // adds standard kotlin features, like listOf, mapOf etc
        implementation("com.github.Blatzar:NiceHttp:0.3.2") // http library
        implementation("com.fasterxml.jackson.module:jackson-module-kotlin:2.13.1")
        implementation("org.jsoup:jsoup:1.13.1") // html parser
        implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4") // html parser

        //run JS
        implementation("org.mozilla:rhino:1.7.14")
    }
}

task<Delete>("clean") {
    delete(rootProject.buildDir)
}



================================================
FILE: gradle.properties
================================================
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true
# AndroidX package structure to make it clearer which packages are bundled with the
# Android operating system, and which are packaged with your app"s APK
# https://developer.android.com/topic/libraries/support-library/androidx-rn
android.useAndroidX=true
# Automatically convert third-party libraries to use AndroidX
android.enableJetifier=true



================================================
FILE: gradlew
================================================
#!/usr/bin/env sh

#
# Copyright 2015 the original author or authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn () {
    echo "$*"
}

die () {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MSYS* | MINGW* )
    msys=true
    ;;
  NONSTOP* )
    nonstop=true
    ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" -a "$nonstop" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin or MSYS, switch paths to Windows format before running java
if [ "$cygwin" = "true" -o "$msys" = "true" ] ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`

    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=`expr $i + 1`
    done
    case $i in
        0) set -- ;;
        1) set -- "$args0" ;;
        2) set -- "$args0" "$args1" ;;
        3) set -- "$args0" "$args1" "$args2" ;;
        4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Escape application args
save () {
    for i do printf %s\\n "$i" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/' \\\\/" ; done
    echo " "
}
APP_ARGS=`save "$@"`

# Collect all arguments for the java command, following the shell quoting and substitution rules
eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS "\"-Dorg.gradle.appname=$APP_BASE_NAME\"" -classpath "\"$CLASSPATH\"" org.gradle.wrapper.GradleWrapperMain "$APP_ARGS"

exec "$JAVACMD" "$@"



================================================
FILE: gradlew.bat
================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto execute

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega



================================================
FILE: settings.gradle.kts
================================================
rootProject.name = "CloudstreamPlugins"

// This file sets what projects are included. Every time you add a new project, you must add it
// to the includes below.

// Plugins are included like this
include(
    "XcineProvider",
    "StreamingcommunityProvider",
    "FilmanProvider",
    "VMoveeProvider",
    "AsiaFlixProvider",
    "DoramasYTProvider",
//    "SflixProProvider",
    "PinoyMoviePediaProvider",
    "SeriesflixProvider",
    "TrailersTwoProvider",
    "PinoyMoviesEsProvider",
    "KisskhProvider",
    "DramaSeeProvider",
    "VidstreamProviderTemplate",
    "RebahinProvider",
    "AllMoviesForYouProvider",
    "UakinoProvider",
    "DramaidProvider",
    "FaselHDProvider",
    "MeloMovieProvider",
    "PelisplusProvider",
    "AsianLoadProvider",
    "YomoviesProvider",
    "AkwamProvider",
    "VidEmbedProvider",
    "IdlixProvider",
    "NginxProvider",
    "SoaptwoDayProvider",
    "PinoyHDXyzProvider",
    "AltadefinizioneProvider",
    "PelisflixProvider",
    "SflixProvider",
    "ElifilmsProvider",
    "VidSrcProvider",
    "EgyBestProvider",
    "WatchAsianProvider",
    "VfSerieProvider",
    "LayarKacaProvider",
    "EntrepeliculasyseriesProvider",
    "TantiFilmProvider",
    "TwoEmbedProvider",
    "SuperStream",
    "FilmpertuttiProvider",
    "FrenchStreamProvider",
    "KdramaHoodProvider",
    "MyCimaProvider",
    "IlGenioDelloStreamingProvider",
    "EstrenosDoramasProvider",
//    "HDTodayProvider",
    "DopeboxProvider",
    "DubokuProvider",
    "HDMProvider",
    "PhimmoichillProvider",
    "PelisplusProviderTemplate",
    "OlgplyProvider",
    "SolarmovieProvider",
    "PeliSmartProvider",
    "VfFilmProvider",
    "IHaveNoTvProvider",
    "CuevanaProvider",
    "CinecalidadProvider",
    "HDMovie5",
    "HDrezkaProvider",
    "PelisplusHDProvider",
    "MultiplexProvider",
    "OpenVidsProvider",
    //"BflixProvider",
//    "FmoviesToProvider",
    "TheFlixToProvider",
)



================================================
FILE: AkwamProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: AkwamProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: AkwamProvider/src/main/kotlin/com/lagradost/AkwamProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.nodes.Element

class AkwamProvider : MainAPI() {
    override var lang = "ar"
    override var mainUrl = "https://akwam.to"
    override var name = "Akwam"
    override val usesWebView = false
    override val hasMainPage = true
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie, TvType.Anime, TvType.Cartoon)

    private fun Element.toSearchResponse(): SearchResponse? {
        val url = select("a.box").attr("href") ?: return null
        if (url.contains("/games/") || url.contains("/programs/")) return null
        val poster = select("picture > img")
        val title = poster.attr("alt")
        val posterUrl = poster.attr("data-src")
        val year = select(".badge-secondary").text().toIntOrNull()

        // If you need to differentiate use the url.
        return MovieSearchResponse(
            title,
            url,
            this@AkwamProvider.name,
            TvType.TvSeries,
            posterUrl,
            year,
            null,
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        // Title, Url
        val moviesUrl = listOf(
            "Movies" to "$mainUrl/movies",
            "Series" to "$mainUrl/series",
            "Shows" to "$mainUrl/shows"
        )
        val pages = moviesUrl.apmap {
            val doc = app.get(it.second).document
            val list = doc.select("div.col-lg-auto.col-md-4.col-6.mb-12").mapNotNull { element ->
                element.toSearchResponse()
            }
            HomePageList(it.first, list)
        }.sortedBy { it.name }
        return HomePageResponse(pages)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search?q=$query"
        val doc = app.get(url).document
        return doc.select("div.col-lg-auto").mapNotNull {
            it.toSearchResponse()
        }
    }

    private fun String.getIntFromText(): Int? {
        return Regex("""\d+""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    private fun Element.toEpisode(): Episode {
        val a = select("a.text-white")
        val url = a.attr("href")
        val title = a.text()
        val thumbUrl = select("picture > img").attr("src")
        val date = select("p.entry-date").text()
        return newEpisode(url) {
            name = title
            episode = title.getIntFromText()
            posterUrl = thumbUrl
            addDate(date)
        }
    }


    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val isMovie = url.contains("/movie/")
        val title = doc.select("h1.entry-title").text()
        val posterUrl = doc.select("picture > img").attr("src")

        val year =
            doc.select("div.font-size-16.text-white.mt-2").firstOrNull {
                it.text().contains("السنة")
            }?.text()?.getIntFromText()

        // A bit iffy to parse twice like this, but it'll do.
        val duration =
            doc.select("div.font-size-16.text-white.mt-2").firstOrNull {
                it.text().contains("مدة الفيلم")
            }?.text()?.getIntFromText()

        val synopsis = doc.select("div.widget-body p:first-child").text()

        val rating = doc.select("span.mx-2").text().split("/").lastOrNull()?.toRatingInt()

        val tags = doc.select("div.font-size-16.d-flex.align-items-center.mt-3 > a").map {
            it.text()
        }

        val actors = doc.select("div.widget-body > div > div.entry-box > a").mapNotNull {
            val name = it?.selectFirst("div > .entry-title")?.text() ?: return@mapNotNull null
            val image = it.selectFirst("div > img")?.attr("src") ?: return@mapNotNull null
            Actor(name, image)
        }

        val recommendations =
            doc.select("div > div.widget-body > div.row > div > div.entry-box").mapNotNull {
                val recTitle = it?.selectFirst("div.entry-body > .entry-title > .text-white")
                    ?: return@mapNotNull null
                val href = recTitle.attr("href") ?: return@mapNotNull null
                val name = recTitle.text() ?: return@mapNotNull null
                val poster = it.selectFirst(".entry-image > a > picture > img")?.attr("data-src")
                    ?: return@mapNotNull null
                MovieSearchResponse(name, href, this.name, TvType.Movie, fixUrl(poster))
            }

        return if (isMovie) {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = synopsis
                this.rating = rating
                this.tags = tags
                this.duration = duration
                this.recommendations = recommendations
                addActors(actors)
            }
        } else {
            val episodes = doc.select("div.bg-primary2.p-4.col-lg-4.col-md-6.col-12").map {
                it.toEpisode()
            }.let {
                val isReversed = (it.lastOrNull()?.episode ?: 1) < (it.firstOrNull()?.episode ?: 0)
                if (isReversed)
                    it.reversed()
                else it
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.duration = duration
                this.posterUrl = posterUrl
                this.tags = tags.filterNotNull()
                this.rating = rating
                this.year = year
                this.plot = synopsis
                this.recommendations = recommendations
                addActors(actors)
            }
        }
    }


//    // Maybe possible to not use the url shortener but cba investigating that.
//    private suspend fun skipUrlShortener(url: String): AppResponse {
//        return app.get(app.get(url).document.select("a.download-link").attr("href"))
//    }

    private fun getQualityFromId(id: Int?): Qualities {
        return when (id) {
            2 -> Qualities.P360 // Extrapolated
            3 -> Qualities.P480
            4 -> Qualities.P720
            5 -> Qualities.P1080
            else -> Qualities.Unknown
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document

        val links = doc.select("div.tab-content.quality").map { element ->
            val quality = getQualityFromId(element.attr("id").getIntFromText())
            element.select(".col-lg-6 > a:contains(تحميل)").map { linkElement ->
                if (linkElement.attr("href").contains("/download/")) {
                    Pair(
                        linkElement.attr("href"),
                        quality,
                    )
                } else {
                    val url = "$mainUrl/download${
                        linkElement.attr("href").split("/link")[1]
                    }${data.split("/movie|/episode|/show/episode".toRegex())[1]}"
                    Pair(
                        url,
                        quality,
                    )
                    // just in case if they add the shorts urls again
                }
            }
        }.flatten()

        links.map {
            val linkDoc = app.get(it.first).document
            val button = linkDoc.select("div.btn-loader > a")
            val url = button.attr("href")

            callback.invoke(
                ExtractorLink(
                    this.name,
                    this.name,
                    url,
                    this.mainUrl,
                    it.second.value
                )
            )
        }
        return true
    }
}



================================================
FILE: AkwamProvider/src/main/kotlin/com/lagradost/AkwamProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class AkwamProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AkwamProvider())
    }
}


================================================
FILE: AllMoviesForYouProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: AllMoviesForYouProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: AllMoviesForYouProvider/src/main/kotlin/com/lagradost/AllMoviesForYouProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addDuration
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup

class AllMoviesForYouProvider : MainAPI() {
    companion object {
        fun getType(t: String): TvType {
            return when {
                t.contains("series") -> TvType.TvSeries
                t.contains("movies") -> TvType.Movie
                else -> TvType.Movie
            }
        }
    }

    // Fetching movies will not work if this link is outdated.
    override var mainUrl = "https://allmoviesforyou.net"
    override var name = "AllMoviesForYou"
    override val hasMainPage = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val soup = app.get(mainUrl).document
        val urls = listOf(
            Pair("Movies", "section[data-id=movies] article.TPost.B"),
            Pair("TV Series", "section[data-id=series] article.TPost.B"),
        )
        for ((name, element) in urls) {
            try {
                val home = soup.select(element).map {
                    val title = it.selectFirst("h2.title")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        TvType.Movie,
                        fixUrl(it.selectFirst("figure img")!!.attr("data-src")),
                        null,
                        null,
                    )
                }

                items.add(HomePageList(name, home))
            } catch (e: Exception) {
                logError(e)
            }
        }
        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val document = app.get(url).document

        val items = document.select("ul.MovieList > li > article > a")
        return items.map { item ->
            val href = item.attr("href")
            val title = item.selectFirst("> h2.Title")!!.text()
            val img = fixUrl(item.selectFirst("> div.Image > figure > img")!!.attr("data-src"))
            val type = getType(href)
            if (type == TvType.Movie) {
                MovieSearchResponse(title, href, this.name, type, img, null)
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    type,
                    img,
                    null,
                    null
                )
            }
        }
    }

//    private fun getLink(document: Document): List<String>? {
//         val list = ArrayList<String>()
//         Regex("iframe src=\"(.*?)\"").find(document.html())?.groupValues?.get(1)?.let {
//             list.add(it)
//         }
//         document.select("div.OptionBx")?.forEach { element ->
//             val baseElement = element.selectFirst("> a.Button")
//             val elementText = element.selectFirst("> p.AAIco-dns")?.text()
//             if (elementText == "Streamhub" || elementText == "Dood") {
//                 baseElement?.attr("href")?.let { href ->
//                     list.add(href)
//                 }
//             }
//         }
//
//         return if (list.isEmpty()) null else list
//     }

    override suspend fun load(url: String): LoadResponse {
        val type = getType(url)

        val document = app.get(url).document

        val title = document.selectFirst("h1.Title")!!.text()
        val descipt = document.selectFirst("div.Description > p")!!.text()
        val rating =
            document.selectFirst("div.Vote > div.post-ratings > span")?.text()?.toRatingInt()
        val year = document.selectFirst("span.Date")?.text()
        val duration = document.selectFirst("span.Time")!!.text()
        val backgroundPoster =
            fixUrlNull(document.selectFirst("div.Image > figure > img")?.attr("data-src"))

        if (type == TvType.TvSeries) {
            val list = ArrayList<Pair<Int, String>>()

            document.select("main > section.SeasonBx > div > div.Title > a").forEach { element ->
                val season = element.selectFirst("> span")?.text()?.toIntOrNull()
                val href = element.attr("href")
                if (season != null && season > 0 && !href.isNullOrBlank()) {
                    list.add(Pair(season, fixUrl(href)))
                }
            }
            if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            val episodeList = ArrayList<Episode>()

            for (season in list) {
                val seasonResponse = app.get(season.second).text
                val seasonDocument = Jsoup.parse(seasonResponse)
                val episodes = seasonDocument.select("table > tbody > tr")
                if (episodes.isNotEmpty()) {
                    episodes.forEach { episode ->
                        val epNum = episode.selectFirst("> td > span.Num")?.text()?.toIntOrNull()
                        val poster = episode.selectFirst("> td.MvTbImg > a > img")?.attr("data-src")
                        val aName = episode.selectFirst("> td.MvTbTtl > a")
                        val name = aName!!.text()
                        val href = aName.attr("href")
                        val date = episode.selectFirst("> td.MvTbTtl > span")?.text()

                        episodeList.add(
                            newEpisode(href) {
                                this.name = name
                                this.season = season.first
                                this.episode = epNum
                                this.posterUrl = fixUrlNull(poster)
                                addDate(date)
                            }
                        )
                    }
                }
            }
            return TvSeriesLoadResponse(
                title,
                url,
                this.name,
                type,
                episodeList,
                backgroundPoster,
                year?.toIntOrNull(),
                descipt,
                null,
                rating
            )
        } else {
            return newMovieLoadResponse(
                title,
                url,
                type,
                fixUrl(url)
            ) {
                posterUrl = backgroundPoster
                this.year = year?.toIntOrNull()
                this.plot = descipt
                this.rating = rating
                addDuration(duration)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document
        val iframe = doc.select("body iframe").map { fixUrl(it.attr("src")) }
        iframe.apmap { id ->
            if (id.contains("trembed")) {
                val soup = app.get(id).document
                soup.select("body iframe").map {
                    val link = fixUrl(it.attr("src").replace("streamhub.to/d/", "streamhub.to/e/"))
                    loadExtractor(link, data, subtitleCallback, callback)
                }
            } else loadExtractor(id, data, subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: AllMoviesForYouProvider/src/main/kotlin/com/lagradost/AllMoviesForYouProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class AllMoviesForYouProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AllMoviesForYouProvider())
    }
}


================================================
FILE: AltadefinizioneProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: AltadefinizioneProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: AltadefinizioneProvider/src/main/kotlin/com/lagradost/AltadefinizioneProvider.kt
================================================
package com.lagradost

//import androidx.core.text.parseAsHtml
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.cloudstream3.utils.AppUtils.html


class AltadefinizioneProvider : MainAPI() {
    override var lang = "it"
    override var mainUrl = "https://altadefinizione.tienda"
    override var name = "Altadefinizione"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie
    )

    override val mainPage = mainPageOf(
        Pair("$mainUrl/cerca/anno/2022/page/", "Ultimi Film"),
        Pair("$mainUrl/cerca/openload-quality/HD/page/", "Film in HD"),
        Pair("$mainUrl/cinema/page/", "Ora al cinema")
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = request.data + page

        val soup = app.get(url).document
        val home = soup.select("div.box").map {
            val title = it.selectFirst("img")!!.attr("alt")
            val link = it.selectFirst("a")!!.attr("href")
            val image = mainUrl + it.selectFirst("img")!!.attr("src")
            val quality = getQualityFromString(it.selectFirst("span")!!.text())

            MovieSearchResponse(
                title,
                link,
                this.name,
                TvType.Movie,
                image,
                null,
                null,
                quality,
            )
        }
        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val doc = app.post(
            "$mainUrl/index.php", data = mapOf(
                "do" to "search",
                "subaction" to "search",
                "story" to query,
                "sortby" to "news_read"
            )
        ).document
        return doc.select("div.box").map {
            val title = it.selectFirst("img")!!.attr("alt")
            val link = it.selectFirst("a")!!.attr("href")
            val image = mainUrl + it.selectFirst("img")!!.attr("src")
            val quality = getQualityFromString(it.selectFirst("span")!!.text())

            MovieSearchResponse(
                title,
                link,
                this.name,
                TvType.Movie,
                image,
                null,
                null,
                quality,
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val page = app.get(url)
        val document = page.document
        val title = document.selectFirst(" h1 > a")!!.text().replace("streaming", "")
        val description = document.select("#sfull").toString().substringAfter("altadefinizione")
            .substringBeforeLast("fonte trama").html().toString()
        val rating = null

        val year = document.selectFirst("#details > li:nth-child(2)")!!.childNode(2).toString()
            .filter { it.isDigit() }.toInt()

        val poster = fixUrl(document.selectFirst("div.thumbphoto > img")!!.attr("src"))

        val recomm = document.select("ul.related-list > li").map {
            val href = it.selectFirst("a")!!.attr("href")
            val posterUrl = mainUrl + it.selectFirst("img")!!.attr("src")
            val name = it.selectFirst("img")!!.attr("alt")
            MovieSearchResponse(
                name,
                href,
                this.name,
                TvType.Movie,
                posterUrl,
                null
            )

        }


        val actors: List<ActorData> =
            document.select("#staring > a").map {
                ActorData(actor = Actor(it.text()))
            }

        val tags: List<String> = document.select("#details > li:nth-child(1) > a").map { it.text() }

        val trailerurl = document.selectFirst("#showtrailer > div > div > iframe")?.attr("src")

        return newMovieLoadResponse(
            title,
            url,
            TvType.Movie,
            url
        ) {
            posterUrl = fixUrlNull(poster)
            this.year = year
            this.plot = description
            this.rating = rating
            this.recommendations = recomm
            this.duration = null
            this.actors = actors
            this.tags = tags
            addTrailer(trailerurl)
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document
        if (doc.select("div.guardahd-player").isNullOrEmpty()) {
            val videoUrl =
                doc.select("input").last { it.hasAttr("data-mirror") }.attr("value")
            loadExtractor(videoUrl, data, subtitleCallback, callback)
            doc.select("#mirrors > li > a").forEach {
                loadExtractor(fixUrl(it.attr("data-target")), data, subtitleCallback, callback)
            }
        } else {
            val pagelinks = doc.select("div.guardahd-player").select("iframe").attr("src")
            val docLinks = app.get(pagelinks).document
            docLinks.select("body > div > ul > li").forEach {
                loadExtractor(fixUrl(it.attr("data-link")), data, subtitleCallback, callback)
            }
        }

        return true
    }
}


================================================
FILE: AltadefinizioneProvider/src/main/kotlin/com/lagradost/AltadefinizioneProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class AltadefinizioneProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AltadefinizioneProvider())
    }
}


================================================
FILE: AsiaFlixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: AsiaFlixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: AsiaFlixProvider/src/main/kotlin/com/lagradost/AsiaFlixProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.JsonParser
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.cloudstream3.*
//import com.lagradost.cloudstream3.animeproviders.GogoanimeProvider.Companion.getStatus
import com.lagradost.cloudstream3.utils.DataStore.toKotlinObject
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import java.net.URI

class AsiaFlixProvider : MainAPI() {
    companion object {
        fun getType(t: String): TvType {
            return if (t.contains("OVA") || t.contains("Special")) TvType.OVA
            else if (t.contains("Movie")) TvType.AnimeMovie
            else TvType.Anime
        }

        fun getStatus(t: String): ShowStatus {
            return when (t) {
                "Completed" -> ShowStatus.Completed
                "Ongoing" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override var mainUrl = "https://asiaflix.app"
    override var name = "AsiaFlix"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = false
    override val supportedTypes = setOf(TvType.AsianDrama)

    private val apiUrl = "https://api.asiaflix.app/api/v2"

    data class DashBoardObject(
        @JsonProperty("sectionName") val sectionName: String,
        @JsonProperty("type") val type: String?,
        @JsonProperty("data") val data: List<Data>?
    )

    data class Episodes(
        @JsonProperty("_id") val _id: String,
        @JsonProperty("epUrl") val epUrl: String?,
        @JsonProperty("number") val number: Int?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("extracted") val extracted: String?,
        @JsonProperty("videoUrl") val videoUrl: String?
    )


    data class Data(
        @JsonProperty("_id") val _id: String,
        @JsonProperty("name") val name: String,
        @JsonProperty("altNames") val altNames: String?,
        @JsonProperty("image") val image: String?,
        @JsonProperty("tvStatus") val tvStatus: String?,
        @JsonProperty("genre") val genre: String?,
        @JsonProperty("releaseYear") val releaseYear: Int?,
        @JsonProperty("createdAt") val createdAt: Long?,
        @JsonProperty("episodes") val episodes: List<Episodes>?,
        @JsonProperty("views") val views: Int?
    )


    data class DramaPage(
        @JsonProperty("_id") val _id: String,
        @JsonProperty("name") val name: String,
        @JsonProperty("altNames") val altNames: String?,
        @JsonProperty("synopsis") val synopsis: String?,
        @JsonProperty("image") val image: String?,
        @JsonProperty("language") val language: String?,
        @JsonProperty("dramaUrl") val dramaUrl: String?,
        @JsonProperty("published") val published: Boolean?,
        @JsonProperty("tvStatus") val tvStatus: String?,
        @JsonProperty("firstAirDate") val firstAirDate: String?,
        @JsonProperty("genre") val genre: String?,
        @JsonProperty("releaseYear") val releaseYear: Int?,
        @JsonProperty("createdAt") val createdAt: Long?,
        @JsonProperty("modifiedAt") val modifiedAt: Long?,
        @JsonProperty("episodes") val episodes: List<Episodes>,
        @JsonProperty("__v") val __v: Int?,
        @JsonProperty("cdnImage") val cdnImage: String?,
        @JsonProperty("views") val views: Int?
    )

    private fun Data.toSearchResponse(): TvSeriesSearchResponse {
        return TvSeriesSearchResponse(
            name,
            _id,
            this@AsiaFlixProvider.name,
            TvType.AsianDrama,
            image,
            releaseYear,
            episodes?.size,
        )
    }

    private fun Episodes.toEpisode(): Episode? {
        if (videoUrl != null && videoUrl.contains("watch/null") || number == null) return null
        return videoUrl?.let {
            Episode(
                it,
                null,
                number,
            )
        }
    }

    private fun DramaPage.toLoadResponse(): TvSeriesLoadResponse {
        return TvSeriesLoadResponse(
            name,
            "$mainUrl$dramaUrl/$_id".replace("drama-detail", "show-details"),
            this@AsiaFlixProvider.name,
            TvType.AsianDrama,
            episodes.mapNotNull { it.toEpisode() }.sortedBy { it.episode },
            image,
            releaseYear,
            synopsis,
            getStatus(tvStatus ?: ""),
            null,
            genre?.split(",")?.map { it.trim() }
        )
    }

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val headers = mapOf("X-Requested-By" to "asiaflix-web")
        val response = app.get("$apiUrl/dashboard", headers = headers).text

        val customMapper =
            mapper.copy().configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true)
        // Hack, because it can either be object or a list
        val cleanedResponse = Regex(""""data":(\{.*?),\{"sectionName"""").replace(response) {
            """"data":null},{"sectionName""""
        }

        val dashBoard = customMapper.readValue<List<DashBoardObject>?>(cleanedResponse)

        val listItems = dashBoard?.mapNotNull {
            it.data?.map { data ->
                data.toSearchResponse()
            }?.let { searchResponse ->
                HomePageList(it.sectionName, searchResponse)
            }
        }
        return HomePageResponse(listItems ?: listOf())
    }

    data class Link(
        @JsonProperty("url") val url: String?,
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (isCasting) return false
        val headers = mapOf("X-Requested-By" to "asiaflix-web")
        app.get(
            "$apiUrl/utility/get-stream-links?url=$data",
            headers = headers
        ).text.toKotlinObject<Link>().url?.let {
//            val fixedUrl = "https://api.asiaflix.app/api/v2/utility/cors-proxy/playlist/${URLEncoder.encode(it, StandardCharsets.UTF_8.toString())}"
            callback.invoke(
                ExtractorLink(
                    name,
                    name,
                    it,
                    "https://asianload1.com/",
                    /** <------ This provider should be added instead */
                    getQualityFromName(it),
                    URI(it).path.endsWith(".m3u8")
                )
            )
        }
        return true
    }

    override suspend fun search(query: String): List<SearchResponse>? {
        val headers = mapOf("X-Requested-By" to "asiaflix-web")
        val url = "$apiUrl/drama/search?q=$query"
        val response = app.get(url, headers = headers).text
        return mapper.readValue<List<Data>?>(response)?.map { it.toSearchResponse() }
    }

    override suspend fun load(url: String): LoadResponse {
        val headers = mapOf("X-Requested-By" to "asiaflix-web")
        val requestUrl = "$apiUrl/drama?id=${url.split("/").lastOrNull()}"
        val response = app.get(requestUrl, headers = headers).text
        val dramaPage = response.toKotlinObject<DramaPage>()
        return dramaPage.toLoadResponse()
    }
}



================================================
FILE: AsiaFlixProvider/src/main/kotlin/com/lagradost/AsiaFlixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class AsiaFlixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AsiaFlixProvider())
    }
}


================================================
FILE: AsianLoadProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":VidstreamProviderTemplate")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: AsianLoadProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: AsianLoadProvider/src/main/kotlin/com/lagradost/AsianLoadProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.TvType

/** Needs to inherit from MainAPI() to
 * make the app know what functions to call
 */
class AsianLoadProvider : VidstreamProviderTemplate() {
    override var name = "AsianLoad"
    override var mainUrl = "https://asianembed.io"
    override val homePageUrlList = listOf(
        mainUrl,
        "$mainUrl/recently-added-raw",
        "$mainUrl/movies",
        "$mainUrl/kshow",
        "$mainUrl/popular",
        "$mainUrl/ongoing-series"
    )

    override val iv = "9262859232435825"
    override val secretKey = "93422192433952489752342908585752"
    override val secretDecryptKey = secretKey

    override val supportedTypes = setOf(TvType.AsianDrama)
}



================================================
FILE: AsianLoadProvider/src/main/kotlin/com/lagradost/AsianLoadProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class AsianLoadProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(AsianLoadProvider())
    }
}


================================================
FILE: BflixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: BflixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: BflixProvider/src/main/kotlin/com/lagradost/BflixProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.animeproviders.NineAnimeProvider.Companion.decodeVrf
import com.lagradost.cloudstream3.animeproviders.NineAnimeProvider.Companion.encode
import com.lagradost.cloudstream3.animeproviders.NineAnimeProvider.Companion.encodeVrf
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup

open class BflixProvider : MainAPI() {
    override var mainUrl = "https://bflix.ru"
    override var name = "Bflix"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    //override val uniqueId: Int by lazy { "BflixProvider".hashCode() }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val soup = app.get("$mainUrl/home").document
        val testa = listOf(
            Pair("Movies", "div.tab-content[data-name=movies] div.filmlist div.item"),
            Pair("Shows", "div.tab-content[data-name=shows] div.filmlist div.item"),
            Pair("Trending", "div.tab-content[data-name=trending] div.filmlist div.item"),
            Pair(
                "Latest Movies",
                "div.container section.bl:contains(Latest Movies) div.filmlist div.item"
            ),
            Pair(
                "Latest TV-Series",
                "div.container section.bl:contains(Latest TV-Series) div.filmlist div.item"
            ),
        )
        for ((name, element) in testa) try {
            val test = soup.select(element).map {
                val title = it.selectFirst("h3 a")!!.text()
                val link = fixUrl(it.selectFirst("a")!!.attr("href"))
                val qualityInfo = it.selectFirst("div.quality")!!.text()
                val quality = getQualityFromString(qualityInfo)
                TvSeriesSearchResponse(
                    title,
                    link,
                    this.name,
                    if (link.contains("/movie/")) TvType.Movie else TvType.TvSeries,
                    it.selectFirst("a.poster img")!!.attr("src"),
                    null,
                    null,
                    quality = quality
                )
            }
            items.add(HomePageList(name, test))
        } catch (e: Exception) {
            e.printStackTrace()
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse>? {
        val encodedquery = encodeVrf(query, mainKey)
        val url = "$mainUrl/search?keyword=$query&vrf=$encodedquery"
        val html = app.get(url).text
        val document = Jsoup.parse(html)

        return document.select(".filmlist div.item").map {
            val title = it.selectFirst("h3 a")!!.text()
            val href = fixUrl(it.selectFirst("a")!!.attr("href"))
            val image = it.selectFirst("a.poster img")!!.attr("src")
            val isMovie = href.contains("/movie/")
            val qualityInfo = it.selectFirst("div.quality")!!.text()
            val quality = getQualityFromString(qualityInfo)

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null,
                    quality = quality
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null,
                    quality = quality
                )
            }
        }
    }

    data class Response(
        @JsonProperty("html") val html: String
    )

    companion object {
        val mainKey = "OrAimkpzm6phmN3j"
    }

    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url).document
        val movieid = soup.selectFirst("div#watch")!!.attr("data-id")
        val movieidencoded = encodeVrf(movieid, mainKey)
        val title = soup.selectFirst("div.info h1")!!.text()
        val description = soup.selectFirst(".info .desc")?.text()?.trim()
        val poster: String? = try {
            soup.selectFirst("img.poster")!!.attr("src")
        } catch (e: Exception) {
            soup.selectFirst(".info .poster img")!!.attr("src")
        }

        val tags = soup.select("div.info .meta div:contains(Genre) a").map { it.text() }
        val vrfUrl = "$mainUrl/ajax/film/servers?id=$movieid&vrf=$movieidencoded"
        println("VRF___ $vrfUrl")
        val episodes = Jsoup.parse(
            app.get(
                vrfUrl
            ).parsed<Response>().html
        ).select("div.episode").map {
            val a = it.selectFirst("a")
            val href = fixUrl(a!!.attr("href"))
            val extraData = a.attr("data-kname").let { str ->
                str.split("-").mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val isValid = extraData.size == 2
            val episode = if (isValid) extraData.getOrNull(1) else null
            val season = if (isValid) extraData.getOrNull(0) else null

            val eptitle = it.selectFirst(".episode a span.name")!!.text()
            val secondtitle = it.selectFirst(".episode a span")!!.text()
                .replace(Regex("(Episode (\\d+):|Episode (\\d+)-|Episode (\\d+))"), "") ?: ""
            Episode(
                href,
                secondtitle + eptitle,
                season,
                episode,
            )
        }
        val tvType =
            if (url.contains("/movie/") && episodes.size == 1) TvType.Movie else TvType.TvSeries
        val recommendations =
            soup.select("div.bl-2 section.bl div.content div.filmlist div.item")
                .mapNotNull { element ->
                    val recTitle = element.select("h3 a").text() ?: return@mapNotNull null
                    val image = element.select("a.poster img")?.attr("src")
                    val recUrl = fixUrl(element.select("a").attr("href"))
                    MovieSearchResponse(
                        recTitle,
                        recUrl,
                        this.name,
                        if (recUrl.contains("/movie/")) TvType.Movie else TvType.TvSeries,
                        image,
                        year = null
                    )
                }
        val rating = soup.selectFirst(".info span.imdb")?.text()?.toRatingInt()
        val durationdoc = soup.selectFirst("div.info div.meta").toString()
        val durationregex = Regex("((\\d+) min)")
        val yearegex = Regex("<span>(\\d+)</span>")
        val duration = if (durationdoc.contains("na min")) null
        else durationregex.find(durationdoc)?.destructured?.component1()?.replace(" min", "")
            ?.toIntOrNull()
        val year = if (mainUrl == "https://bflix.ru") {
            yearegex.find(durationdoc)?.destructured?.component1()
                ?.replace(Regex("<span>|</span>"), "")
        } else null
        return when (tvType) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    year?.toIntOrNull(),
                    description,
                    null,
                    rating,
                    tags,
                    recommendations = recommendations,
                    duration = duration,
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    year?.toIntOrNull(),
                    description,
                    rating,
                    tags,
                    recommendations = recommendations,
                    duration = duration
                )
            }
            else -> null
        }
    }


    data class Subtitles(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
        @JsonProperty("kind") val kind: String
    )

    data class Links(
        @JsonProperty("url") val url: String
    )

    data class Servers(
        @JsonProperty("28") val mcloud: String?,
        @JsonProperty("35") val mp4upload: String?,
        @JsonProperty("40") val streamtape: String?,
        @JsonProperty("41") val vidstream: String?,
        @JsonProperty("43") val videovard: String?
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val soup = app.get(data).document

        val movieid = encode(soup.selectFirst("div#watch")?.attr("data-id") ?: return false)
        val movieidencoded = encodeVrf(movieid, mainKey)
        Jsoup.parse(
            parseJson<Response>(
                app.get(
                    "$mainUrl/ajax/film/servers?id=$movieid&vrf=$movieidencoded"
                ).text
            ).html
        )
            .select("html body #episodes").map {
                val cleandata = data.replace(mainUrl, "")
                val a = it.select("a").map {
                    it.attr("data-kname")
                }
                val tvType =
                    if (data.contains("movie/") && a.size == 1) TvType.Movie else TvType.TvSeries
                val servers = if (tvType == TvType.Movie) it.select(".episode a").attr("data-ep")
                else
                    it.select(".episode a[href=$cleandata]").attr("data-ep")
                        ?: it.select(".episode a[href=${cleandata.replace("/1-full", "")}]")
                            .attr("data-ep")
                val jsonservers = parseJson<Servers?>(servers) ?: return@map
                listOfNotNull(
                    jsonservers.vidstream,
                    jsonservers.mcloud,
                    jsonservers.mp4upload,
                    jsonservers.streamtape,
                    jsonservers.videovard,
                ).mapNotNull {
                    val epserver = app.get("$mainUrl/ajax/episode/info?id=$it").text
                    (if (epserver.contains("url")) {
                        parseJson<Links>(epserver)
                    } else null)?.url?.let {
                        decodeVrf(it, mainKey)
                    }
                }.apmap { url ->
                    loadExtractor(
                        url, data, subtitleCallback, callback
                    )
                }
                //Apparently any server works, I haven't found any diference
                val sublink =
                    app.get("$mainUrl/ajax/episode/subtitles/${jsonservers.mcloud}").text
                val jsonsub = parseJson<List<Subtitles>>(sublink)
                jsonsub.forEach { subtitle ->
                    subtitleCallback(
                        SubtitleFile(subtitle.label, subtitle.file)
                    )
                }
            }

        return true
    }
}



================================================
FILE: BflixProvider/src/main/kotlin/com/lagradost/BflixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class BflixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(BflixProvider())
    }
}


================================================
FILE: CinecalidadProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: CinecalidadProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: CinecalidadProvider/src/main/kotlin/com/lagradost/CinecalidadProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
// import com.lagradost.cloudstream3.extractors.Cinestart
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class CinecalidadProvider : MainAPI() {
    override var mainUrl = "https://cinecalidad.lol"
    override var name = "Cinecalidad"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override val vpnStatus = VPNStatus.MightBeNeeded //Due to evoload sometimes not loading

    override val mainPage = mainPageOf(
        Pair("$mainUrl/ver-serie/page/", "Series"),
        Pair("$mainUrl/page/", "Peliculas"),
        Pair("$mainUrl/genero-de-la-pelicula/peliculas-en-calidad-4k/page/", "4K UHD"),
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val url = request.data + page

        val soup = app.get(url).document
        val home = soup.select(".item.movies").map {
            val title = it.selectFirst("div.in_title")!!.text()
            val link = it.selectFirst("a")!!.attr("href")
            TvSeriesSearchResponse(
                title,
                link,
                this.name,
                if (link.contains("/ver-pelicula/")) TvType.Movie else TvType.TvSeries,
                it.selectFirst(".poster.custom img")!!.attr("data-src"),
                null,
                null,
            )
        }

        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=${query}"
        val document = app.get(url).document

        return document.select("article").map {
            val title = it.selectFirst("div.in_title")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst(".poster.custom img")!!.attr("data-src")
            val isMovie = href.contains("/ver-pelicula/")

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            }
        }
    }


    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url, timeout = 120).document

        val title = soup.selectFirst(".single_left h1")!!.text()
        val description = soup.selectFirst("div.single_left table tbody tr td p")?.text()?.trim()
        val poster: String? = soup.selectFirst(".alignnone")!!.attr("data-src")
        val episodes = soup.select("div.se-c div.se-a ul.episodios li").map { li ->
            val href = li.selectFirst("a")!!.attr("href")
            val epThumb = li.selectFirst("img.lazy")!!.attr("data-src")
            val name = li.selectFirst(".episodiotitle a")!!.text()
            val seasonid =
                li.selectFirst(".numerando")!!.text().replace(Regex("(S|E)"), "").let { str ->
                    str.split("-").mapNotNull { subStr -> subStr.toIntOrNull() }
                }
            val isValid = seasonid.size == 2
            val episode = if (isValid) seasonid.getOrNull(1) else null
            val season = if (isValid) seasonid.getOrNull(0) else null
            Episode(
                href,
                name,
                season,
                episode,
                if (epThumb.contains("svg")) null else epThumb
            )
        }
        return when (val tvType =
            if (url.contains("/ver-pelicula/")) TvType.Movie else TvType.TvSeries) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    null,
                    description,
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    null,
                    description,
                )
            }
            else -> null
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val datam = app.get(data)
        val doc = datam.document
        val datatext = datam.text

        doc.select(".dooplay_player_option").apmap {
            val url = it.attr("data-option")
//            if (url.startsWith("https://cinestart.net")) {
//                val extractor = Cinestart()
//                extractor.getSafeUrl(url, null, subtitleCallback, callback)
//            } else {
                loadExtractor(url, mainUrl, subtitleCallback, callback)
//            }
            if (url.startsWith("https://cinecalidad.lol")) {
                val cineurlregex =
                    Regex("(https:\\/\\/cinecalidad\\.lol\\/play\\/\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                cineurlregex.findAll(url).map {
                    it.value.replace("/play/", "/play/r.php")
                }.toList().apmap {
                    app.get(
                        it,
                        headers = mapOf(
                            "Host" to "cinecalidad.lol",
                            "User-Agent" to USER_AGENT,
                            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                            "Accept-Language" to "en-US,en;q=0.5",
                            "DNT" to "1",
                            "Connection" to "keep-alive",
                            "Referer" to data,
                            "Upgrade-Insecure-Requests" to "1",
                            "Sec-Fetch-Dest" to "iframe",
                            "Sec-Fetch-Mode" to "navigate",
                            "Sec-Fetch-Site" to "same-origin",
                            "Sec-Fetch-User" to "?1",
                        ),
                        allowRedirects = false
                    ).okhttpResponse.headers.values("location").apmap { extractedurl ->
                        if (extractedurl.contains("cinestart")) {
                            loadExtractor(extractedurl, mainUrl, subtitleCallback, callback)
                        }
                    }
                }
            }
        }
        if (datatext.contains("en castellano")) app.get("$data?ref=es").document.select(".dooplay_player_option")
            .apmap {
                val url = it.attr("data-option")
//                if (url.startsWith("https://cinestart.net")) {
//                    val extractor = Cinestart()
//                    extractor.getSafeUrl(url, null, subtitleCallback, callback)
//                } else {
                    loadExtractor(url, mainUrl, subtitleCallback, callback)
//                }

                if (url.startsWith("https://cinecalidad.lol")) {
                    val cineurlregex =
                        Regex("(https:\\/\\/cinecalidad\\.lol\\/play\\/\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                    cineurlregex.findAll(url).map {
                        it.value.replace("/play/", "/play/r.php")
                    }.toList().apmap {
                        app.get(
                            it,
                            headers = mapOf(
                                "Host" to "cinecalidad.lol",
                                "User-Agent" to USER_AGENT,
                                "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                                "Accept-Language" to "en-US,en;q=0.5",
                                "DNT" to "1",
                                "Connection" to "keep-alive",
                                "Referer" to data,
                                "Upgrade-Insecure-Requests" to "1",
                                "Sec-Fetch-Dest" to "iframe",
                                "Sec-Fetch-Mode" to "navigate",
                                "Sec-Fetch-Site" to "same-origin",
                                "Sec-Fetch-User" to "?1",
                            ),
                            allowRedirects = false
                        ).okhttpResponse.headers.values("location").apmap { extractedurl ->
                            if (extractedurl.contains("cinestart")) {
                                loadExtractor(extractedurl, mainUrl, subtitleCallback, callback)
                            }
                        }
                    }
                }
            }
        if (datatext.contains("Subtítulo LAT") || datatext.contains("Forzados LAT")) {
            doc.select("#panel_descarga.pane a").apmap {
                val link =
                    if (data.contains("serie") || data.contains("episodio")) "${data}${it.attr("href")}"
                    else it.attr("href")
                val docsub = app.get(link)
                val linksub = docsub.document
                val validsub = docsub.text
                if (validsub.contains("Subtítulo") || validsub.contains("Forzados")) {
                    val langregex = Regex("(Subtítulo.*\$|Forzados.*\$)")
                    val langdoc = linksub.selectFirst("div.titulo h3")!!.text()
                    val reallang = langregex.find(langdoc)?.destructured?.component1()
                    linksub.select("a.link").apmap {
                        val sublink =
                            if (data.contains("serie") || data.contains("episodio")) "${data}${
                                it.attr("href")
                            }"
                            else it.attr("href")
                        subtitleCallback(
                            SubtitleFile(reallang!!, sublink)
                        )
                    }
                }
            }
        }
        return true
    }
}



================================================
FILE: CinecalidadProvider/src/main/kotlin/com/lagradost/CinecalidadProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class CinecalidadProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(CinecalidadProvider())
    }
}


================================================
FILE: CuevanaProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: CuevanaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: CuevanaProvider/src/main/kotlin/com/lagradost/CuevanaProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class CuevanaProvider : MainAPI() {
    override var mainUrl = "https://cuevana3.me"
    override var name = "Cuevana"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val urls = listOf(
            Pair(mainUrl, "Recientemente actualizadas"),
            Pair("$mainUrl/estrenos/", "Estrenos"),
        )
        items.add(
            HomePageList(
                "Series",
                app.get("$mainUrl/serie", timeout = 120).document.select("section.home-series li")
                    .map {
                        val title = it.selectFirst("h2.Title")!!.text()
                        val poster = it.selectFirst("img.lazy")!!.attr("data-src")
                        val url = it.selectFirst("a")!!.attr("href")
                        TvSeriesSearchResponse(
                            title,
                            url,
                            this.name,
                            TvType.Anime,
                            poster,
                            null,
                            null,
                        )
                    })
        )
        for ((url, name) in urls) {
            try {
                val soup = app.get(url).document
                val home = soup.select("section li.xxx.TPostMv").map {
                    val title = it.selectFirst("h2.Title")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        if (link.contains("/pelicula/")) TvType.Movie else TvType.TvSeries,
                        it.selectFirst("img.lazy")!!.attr("data-src"),
                        null,
                        null,
                    )
                }

                items.add(HomePageList(name, home))
            } catch (e: Exception) {
                logError(e)
            }
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=${query}"
        val document = app.get(url).document

        return document.select("li.xxx.TPostMv").map {
            val title = it.selectFirst("h2.Title")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst("img.lazy")!!.attr("data-src")
            val isSerie = href.contains("/serie/")

            if (isSerie) {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            } else {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null
                )
            }
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url, timeout = 120).document
        val title = soup.selectFirst("h1.Title")!!.text()
        val description = soup.selectFirst(".Description p")?.text()?.trim()
        val poster: String? = soup.selectFirst(".movtv-info div.Image img")!!.attr("data-src")
        val year1 = soup.selectFirst("footer p.meta").toString()
        val yearRegex = Regex("<span>(\\d+)</span>")
        val yearf =
            yearRegex.find(year1)?.destructured?.component1()?.replace(Regex("<span>|</span>"), "")
        val year = if (yearf.isNullOrBlank()) null else yearf.toIntOrNull()
        val episodes = soup.select(".all-episodes li.TPostMv article").map { li ->
            val href = li.select("a").attr("href")
            val epThumb =
                li.selectFirst("div.Image img")?.attr("data-src") ?: li.selectFirst("img.lazy")!!
                    .attr("data-srcc")
            val seasonid = li.selectFirst("span.Year")!!.text().let { str ->
                str.split("x").mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val isValid = seasonid.size == 2
            val episode = if (isValid) seasonid.getOrNull(1) else null
            val season = if (isValid) seasonid.getOrNull(0) else null
            Episode(
                href,
                null,
                season,
                episode,
                fixUrl(epThumb)
            )
        }
        val tags = soup.select("ul.InfoList li.AAIco-adjust:contains(Genero) a").map { it.text() }
        val tvType = if (episodes.isEmpty()) TvType.Movie else TvType.TvSeries
        val recelement =
            if (tvType == TvType.TvSeries) "main section div.series_listado.series div.xxx"
            else "main section ul.MovieList li"
        val recommendations =
            soup.select(recelement).mapNotNull { element ->
                val recTitle = element.select("h2.Title").text() ?: return@mapNotNull null
                val image = element.select("figure img")?.attr("data-src")
                val recUrl = fixUrl(element.select("a").attr("href"))
                MovieSearchResponse(
                    recTitle,
                    recUrl,
                    this.name,
                    TvType.Movie,
                    image,
                    year = null
                )
            }

        return when (tvType) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    year,
                    description,
                    tags = tags,
                    recommendations = recommendations
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    year,
                    description,
                    tags = tags,
                    recommendations = recommendations
                )
            }
            else -> null
        }
    }

    data class Femcuevana(
        @JsonProperty("url") val url: String,
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("div.TPlayer.embed_div iframe").apmap {
            val iframe = fixUrl(it.attr("data-src"))
            if (iframe.contains("api.cuevana3.me/fembed/")) {
                val femregex =
                    Regex("(https.\\/\\/api\\.cuevana3\\.me\\/fembed\\/\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                femregex.findAll(iframe).map { femreg ->
                    femreg.value
                }.toList().apmap { fem ->
                    val key = fem.replace("https://api.cuevana3.me/fembed/?h=", "")
                    val url = app.post(
                        "https://api.cuevana3.me/fembed/api.php",
                        allowRedirects = false,
                        headers = mapOf(
                            "Host" to "api.cuevana3.me",
                            "User-Agent" to USER_AGENT,
                            "Accept" to "application/json, text/javascript, */*; q=0.01",
                            "Accept-Language" to "en-US,en;q=0.5",
                            "Content-Type" to "application/x-www-form-urlencoded; charset=UTF-8",
                            "X-Requested-With" to "XMLHttpRequest",
                            "Origin" to "https://api.cuevana3.me",
                            "DNT" to "1",
                            "Connection" to "keep-alive",
                            "Sec-Fetch-Dest" to "empty",
                            "Sec-Fetch-Mode" to "cors",
                            "Sec-Fetch-Site" to "same-origin",
                        ),
                        data = mapOf(Pair("h", key))
                    ).text
                    val json = parseJson<Femcuevana>(url)
                    val link = json.url
                    if (link.contains("fembed")) {
                        loadExtractor(link, data, subtitleCallback, callback)
                    }
                }
            }
            if (iframe.contains("tomatomatela")) {
                val tomatoRegex =
                    Regex("(\\/\\/apialfa.tomatomatela.com\\/ir\\/player.php\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                tomatoRegex.findAll(iframe).map { tomreg ->
                    tomreg.value
                }.toList().apmap { tom ->
                    val tomkey = tom.replace("//apialfa.tomatomatela.com/ir/player.php?h=", "")
                    app.post(
                        "https://apialfa.tomatomatela.com/ir/rd.php", allowRedirects = false,
                        headers = mapOf(
                            "Host" to "apialfa.tomatomatela.com",
                            "User-Agent" to USER_AGENT,
                            "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                            "Accept-Language" to "en-US,en;q=0.5",
                            "Content-Type" to "application/x-www-form-urlencoded",
                            "Origin" to "null",
                            "DNT" to "1",
                            "Connection" to "keep-alive",
                            "Upgrade-Insecure-Requests" to "1",
                            "Sec-Fetch-Dest" to "iframe",
                            "Sec-Fetch-Mode" to "navigate",
                            "Sec-Fetch-Site" to "same-origin",
                        ),
                        data = mapOf(Pair("url", tomkey))
                    ).okhttpResponse.headers.values("location").apmap { loc ->
                        if (loc.contains("goto_ddh.php")) {
                            val gotoregex =
                                Regex("(\\/\\/api.cuevana3.me\\/ir\\/goto_ddh.php\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                            gotoregex.findAll(loc).map { goreg ->
                                goreg.value.replace("//api.cuevana3.me/ir/goto_ddh.php?h=", "")
                            }.toList().apmap { gotolink ->
                                app.post(
                                    "https://api.cuevana3.me/ir/redirect_ddh.php",
                                    allowRedirects = false,
                                    headers = mapOf(
                                        "Host" to "api.cuevana3.me",
                                        "User-Agent" to USER_AGENT,
                                        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                                        "Accept-Language" to "en-US,en;q=0.5",
                                        "Content-Type" to "application/x-www-form-urlencoded",
                                        "Origin" to "null",
                                        "DNT" to "1",
                                        "Connection" to "keep-alive",
                                        "Upgrade-Insecure-Requests" to "1",
                                        "Sec-Fetch-Dest" to "iframe",
                                        "Sec-Fetch-Mode" to "navigate",
                                        "Sec-Fetch-Site" to "same-origin",
                                    ),
                                    data = mapOf(Pair("url", gotolink))
                                ).okhttpResponse.headers.values("location").apmap { golink ->
                                    loadExtractor(golink, data, subtitleCallback, callback)
                                }
                            }
                        }
                        if (loc.contains("index.php?h=")) {
                            val indexRegex =
                                Regex("(\\/\\/api.cuevana3.me\\/sc\\/index.php\\?h=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                            indexRegex.findAll(loc).map { indreg ->
                                indreg.value.replace("//api.cuevana3.me/sc/index.php?h=", "")
                            }.toList().apmap { inlink ->
                                app.post(
                                    "https://api.cuevana3.me/sc/r.php", allowRedirects = false,
                                    headers = mapOf(
                                        "Host" to "api.cuevana3.me",
                                        "User-Agent" to USER_AGENT,
                                        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                                        "Accept-Language" to "en-US,en;q=0.5",
                                        "Accept-Encoding" to "gzip, deflate, br",
                                        "Content-Type" to "application/x-www-form-urlencoded",
                                        "Origin" to "null",
                                        "DNT" to "1",
                                        "Connection" to "keep-alive",
                                        "Upgrade-Insecure-Requests" to "1",
                                        "Sec-Fetch-Dest" to "iframe",
                                        "Sec-Fetch-Mode" to "navigate",
                                        "Sec-Fetch-Site" to "same-origin",
                                        "Sec-Fetch-User" to "?1",
                                    ),
                                    data = mapOf(Pair("h", inlink))
                                ).okhttpResponse.headers.values("location").apmap { link ->
                                    loadExtractor(link, data, subtitleCallback, callback)
                                }
                            }
                        }
                    }
                }
            }
        }
        return true
    }
}


================================================
FILE: CuevanaProvider/src/main/kotlin/com/lagradost/CuevanaProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class CuevanaProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(CuevanaProvider())
    }
}


================================================
FILE: DopeboxProvider/build.gradle.kts
================================================
dependencies {
implementation(project(mapOf("path" to ":SflixProvider")))
    //    implementation(project(mapOf("path" to ":SflixProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: DopeboxProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: DopeboxProvider/src/main/kotlin/com/lagradost/DopeboxProvider.kt
================================================
package com.lagradost

class DopeboxProvider : SflixProvider() {
    override var mainUrl = "https://dopebox.to"
    override var name = "Dopebox"
}


================================================
FILE: DopeboxProvider/src/main/kotlin/com/lagradost/DopeboxProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class DopeboxProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DopeboxProvider())
    }
}


================================================
FILE: DoramasYTProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: DoramasYTProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: DoramasYTProvider/src/main/kotlin/com/lagradost/DoramasYTProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
//import com.lagradost.cloudstream3.extractors.FEmbed
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import java.util.*


class DoramasYTProvider : MainAPI() {
    companion object {
        fun getType(t: String): TvType {
            return if (t.contains("OVA") || t.contains("Especial")) TvType.OVA
            else if (t.contains("Pelicula")) TvType.Movie
            else TvType.TvSeries
        }
        fun getDubStatus(title: String): DubStatus {
            return if (title.contains("Latino") || title.contains("Castellano"))
                DubStatus.Dubbed
            else DubStatus.Subbed
        }
    }

    override var mainUrl = "https://doramasyt.com"
    override var name = "DoramasYT"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.AsianDrama,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val urls = listOf(
            Pair("$mainUrl/emision", "En emisión"),
            Pair(
                "$mainUrl/doramas?categoria=pelicula&genero=false&fecha=false&letra=false",
                "Peliculas"
            ),
            Pair("$mainUrl/doramas", "Doramas"),
            Pair(
                "$mainUrl/doramas?categoria=live-action&genero=false&fecha=false&letra=false",
                "Live Action"
            ),
        )

        val items = ArrayList<HomePageList>()

        items.add(
            HomePageList(
                "Capítulos actualizados",
                app.get(mainUrl, timeout = 120).document.select(".col-6").map {
                    val title = it.selectFirst("p")!!.text()
                    val poster = it.selectFirst(".chapter img")!!.attr("src")
                    val epRegex = Regex("episodio-(\\d+)")
                    val url = it.selectFirst("a")!!.attr("href").replace("ver/", "dorama/")
                        .replace(epRegex, "sub-espanol")
                    val epNum = it.selectFirst("h3")!!.text().toIntOrNull()
                    newAnimeSearchResponse(title,url) {
                        this.posterUrl = fixUrl(poster)
                        addDubStatus(getDubStatus(title), epNum)
                    }
                })
        )

        for (i in urls) {
            try {
                val home = app.get(i.first, timeout = 120).document.select(".col-6").map {
                    val title = it.selectFirst(".animedtls p")!!.text()
                    val poster = it.selectFirst(".anithumb img")!!.attr("src")
                    newAnimeSearchResponse(title, fixUrl(it.selectFirst("a")!!.attr("href"))) {
                        this.posterUrl = fixUrl(poster)
                        addDubStatus(getDubStatus(title))
                    }
                }

                items.add(HomePageList(i.second, home))
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        return app.get("$mainUrl/buscar?q=$query", timeout = 120).document.select(".col-6").map {
            val title = it.selectFirst(".animedtls p")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst(".animes img")!!.attr("src")
            AnimeSearchResponse(
                title,
                href,
                this.name,
                TvType.Anime,
                image,
                null,
                if (title.contains("Latino") || title.contains("Castellano")) EnumSet.of(
                    DubStatus.Dubbed
                ) else EnumSet.of(DubStatus.Subbed),
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url, timeout = 120).document
        val poster = doc.selectFirst("div.flimimg img.img1")!!.attr("src")
        val title = doc.selectFirst("h1")!!.text()
        val type = doc.selectFirst("h4")!!.text()
        val description = doc.selectFirst("p.textComplete")!!.text().replace("Ver menos", "")
        val genres = doc.select(".nobel a").map { it.text() }
        val status = when (doc.selectFirst(".state h6")?.text()) {
            "Estreno" -> ShowStatus.Ongoing
            "Finalizado" -> ShowStatus.Completed
            else -> null
        }
        val episodes = doc.select(".heromain .col-item").map {
            val name = it.selectFirst(".dtlsflim p")!!.text()
            val link = it.selectFirst("a")!!.attr("href")
            val epThumb = it.selectFirst(".flimimg img.img1")!!.attr("src")
            Episode(link, name, posterUrl = epThumb)
        }
        return newAnimeLoadResponse(title, url, getType(type)) {
            posterUrl = poster
            addEpisodes(DubStatus.Subbed, episodes)
            showStatus = status
            plot = description
            tags = genres
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("div.playother p").apmap {
            val encodedurl = it.select("p").attr("data-player")
            val urlDecoded = base64Decode(encodedurl)
            val url = (urlDecoded).replace("https://doramasyt.com/reproductor?url=", "")
//            if (url.startsWith("https://www.fembed.com")) {
//                val extractor = FEmbed()
//                extractor.getUrl(url).forEach { link ->
//                    callback.invoke(link)
//                }
//            } else {
                loadExtractor(url, mainUrl, subtitleCallback, callback)
//            }
        }
        return true
    }
}


================================================
FILE: DoramasYTProvider/src/main/kotlin/com/lagradost/DoramasYTProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class DoramasYTProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DoramasYTProvider())
    }
}


================================================
FILE: DramaidProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: DramaidProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: DramaidProvider/src/main/kotlin/com/lagradost/DramaidProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class DramaidProvider : MainAPI() {
    override var mainUrl = "https://185.224.83.103"
    override var name = "DramaId"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val hasChromecastSupport = false
    override val supportedTypes = setOf(TvType.AsianDrama)

    companion object {
        fun getStatus(t: String): ShowStatus {
            return when (t) {
                "Completed" -> ShowStatus.Completed
                "Ongoing" -> ShowStatus.Ongoing
                else -> ShowStatus.Completed
            }
        }
    }

    override val mainPage = mainPageOf(
        "&status=&type=&order=update" to "Drama Terbaru",
        "&order=latest" to "Baru Ditambahkan",
        "&status=&type=&order=popular" to "Drama Popular",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val document = app.get("$mainUrl/series/?page=$page${request.data}").document
        val home = document.select("article[itemscope=itemscope]").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun getProperDramaLink(uri: String): String {
        return if (uri.contains("/series/")) {
            uri
        } else {
            "$mainUrl/series/" + Regex("$mainUrl/(.+)-ep.+").find(uri)?.groupValues?.get(1)
                .toString()
        }
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val href = getProperDramaLink(this.selectFirst("a.tip")!!.attr("href"))
        val title = this.selectFirst("h2[itemprop=headline]")?.text()?.trim() ?: return null
        val posterUrl = fixUrlNull(this.selectFirst(".limit > noscript > img")?.attr("src"))

        return newTvSeriesSearchResponse(title, href, TvType.AsianDrama) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/?s=$query"
        val document = app.get(link).document

        return document.select("article[itemscope=itemscope]").map {
            val title = it.selectFirst("h2[itemprop=headline]")!!.text().trim()
            val poster = it.selectFirst(".limit > noscript > img")!!.attr("src")
            val href = it.selectFirst("a.tip")!!.attr("href")

            newTvSeriesSearchResponse(title, href, TvType.AsianDrama) {
                this.posterUrl = poster
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title = document.selectFirst("h1.entry-title")!!.text().trim()
        val poster = document.select(".thumb > noscript > img").attr("src")
        val tags = document.select(".genxed > a").map { it.text() }

        val year = Regex("\\d, ([0-9]*)").find(
            document.selectFirst(".info-content > .spe > span > time")!!.text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val status = getStatus(
            document.select(".info-content > .spe > span:nth-child(1)")
                .text().trim().replace("Status: ", "")
        )
        val description = document.select(".entry-content > p").text().trim()

        val episodes = document.select(".eplister > ul > li").map {
            val name = it.selectFirst("a > .epl-title")!!.text().trim()
            val link = it.select("a").attr("href")
            val epNum = it.selectFirst("a > .epl-num")!!.text().trim().toIntOrNull()
            newEpisode(link) {
                this.name = name
                this.episode = epNum
            }
        }.reversed()

        val recommendations =
            document.select(".listupd > article[itemscope=itemscope]").map { rec ->
                val epTitle = rec.selectFirst("h2[itemprop=headline]")!!.text().trim()
                val epPoster = rec.selectFirst(".limit > noscript > img")!!.attr("src")
                val epHref = fixUrl(rec.selectFirst("a.tip")!!.attr("href"))

                newTvSeriesSearchResponse(epTitle, epHref, TvType.AsianDrama) {
                    this.posterUrl = epPoster
                }
            }

        if (episodes.size == 1) {
            return newMovieLoadResponse(title, url, TvType.Movie, episodes[0].data) {
                posterUrl = poster
                this.year = year
                plot = description
                this.tags = tags
                this.recommendations = recommendations
            }
        } else {
            return newTvSeriesLoadResponse(title, url, TvType.AsianDrama, episodes = episodes) {
                posterUrl = poster
                this.year = year
                showStatus = status
                plot = description
                this.tags = tags
                this.recommendations = recommendations
            }
        }

    }

    private data class Sources(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
        @JsonProperty("type") val type: String,
        @JsonProperty("default") val default: Boolean?
    )

    private data class Tracks(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
        @JsonProperty("kind") val type: String,
        @JsonProperty("default") val default: Boolean?
    )

    private suspend fun invokeDriveSource(
        url: String,
        name: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val server = app.get(url).document.selectFirst(".picasa")?.nextElementSibling()?.data()

        val source = "[${server!!.substringAfter("sources: [").substringBefore("],")}]".trimIndent()
        val trackers = server.substringAfter("tracks:[").substringBefore("],")
            .replace("//language", "")
            .replace("file", "\"file\"")
            .replace("label", "\"label\"")
            .replace("kind", "\"kind\"").trimIndent()

        tryParseJson<List<Sources>>(source)?.map {
            sourceCallback(
                ExtractorLink(
                    name,
                    "Drive",
                    fixUrl(it.file),
                    referer = "https://motonews.club/",
                    quality = getQualityFromName(it.label)
                )
            )
        }

        tryParseJson<Tracks>(trackers)?.let {
            subCallback.invoke(
                SubtitleFile(
                    if (it.label.contains("Indonesia")) "${it.label}n" else it.label,
                    it.file
                )
            )
        }

    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = app.get(data).document
        val sources = document.select(".mobius > .mirror > option").mapNotNull {
            fixUrl(Jsoup.parse(base64Decode(it.attr("value"))).select("iframe").attr("src"))
        }

        sources.map {
            it.replace("https://ndrama.xyz", "https://www.fembed.com")
        }.apmap {
            when {
                it.contains("motonews.club") -> invokeDriveSource(it, this.name, subtitleCallback, callback)
                else -> loadExtractor(it, data, subtitleCallback, callback)
            }
        }

        return true
    }

}



================================================
FILE: DramaidProvider/src/main/kotlin/com/lagradost/DramaidProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class DramaidProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DramaidProvider())
    }
}


================================================
FILE: DramaSeeProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":VidstreamProviderTemplate")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: DramaSeeProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: DramaSeeProvider/src/main/kotlin/com/lagradost/DramaSeeProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.extractors.Vidstream
//import com.lagradost.cloudstream3.animeproviders.GogoanimeProvider.Companion.extractVidstream
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class DramaSeeProvider : MainAPI() {
    override var mainUrl = "https://dramasee.net"
    override var name = "DramaSee"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = false
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.AsianDrama)

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val headers = mapOf("X-Requested-By" to mainUrl)
        val document = app.get(mainUrl, headers = headers).document
        val mainbody = document.getElementsByTag("body")

        return HomePageResponse(
            mainbody.select("section.block_area.block_area_home")?.map { main ->
                val title = main.select("h2.cat-heading").text() ?: "Main"
                val inner = main.select("div.flw-item") ?: return@map null

                HomePageList(
                    title,
                    inner.mapNotNull {
                        val innerBody = it?.selectFirst("a")
                        // Fetch details
                        val link = fixUrlNull(innerBody?.attr("href")) ?: return@mapNotNull null
                        val image = fixUrlNull(it.select("img").attr("data-src")) ?: ""
                        val name = innerBody?.attr("title") ?: "<Untitled>"
                        //Log.i(this.name, "Result => (innerBody, image) ${innerBody} / ${image}")
                        MovieSearchResponse(
                            name,
                            link,
                            this.name,
                            TvType.AsianDrama,
                            image,
                            year = null,
                            id = null,
                        )
                    }.distinctBy { c -> c.url })
            }?.filterNotNull() ?: listOf()
        )
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search?q=$query"
        val document = app.get(url).document
        val posters = document.select("div.film-poster")


        return posters.mapNotNull {
            val innerA = it.select("a") ?: return@mapNotNull null
            val link = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null
            val title = innerA.attr("title") ?: return@mapNotNull null
            val year =
                Regex(""".*\((\d{4})\)""").find(title)?.groupValues?.getOrNull(1)?.toIntOrNull()
            val imgSrc = it.select("img")?.attr("data-src") ?: return@mapNotNull null
            val image = fixUrlNull(imgSrc)

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                type = TvType.Movie,
                posterUrl = image,
                year = year
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val body = doc.getElementsByTag("body")
        val inner = body?.select("div.anis-content")

        // Video details
        val poster = fixUrlNull(inner?.select("img.film-poster-img")?.attr("src")) ?: ""
        //Log.i(this.name, "Result => (imgLinkCode) ${imgLinkCode}")
        val title = inner?.select("h2.film-name.dynamic-name")?.text() ?: ""
        val year = if (title.length > 5) {
            title.substring(title.length - 5)
                .trim().trimEnd(')').toIntOrNull()
        } else {
            null
        }
        //Log.i(this.name, "Result => (year) ${title.substring(title.length - 5)}")
        val descript = body?.firstOrNull()?.select("div.film-description.m-hide")?.text()
        val tags = inner?.select("div.item.item-list > a")
            ?.mapNotNull { it?.text()?.trim() ?: return@mapNotNull null }
        val recs = body.select("div.flw-item")?.mapNotNull {
            val a = it.select("a") ?: return@mapNotNull null
            val aUrl = fixUrlNull(a.attr("href")) ?: return@mapNotNull null
            val aImg = fixUrlNull(it.select("img")?.attr("data-src"))
            val aName = a.attr("title") ?: return@mapNotNull null
            val aYear = aName.trim().takeLast(5).removeSuffix(")").toIntOrNull()
            MovieSearchResponse(
                url = aUrl,
                name = aName,
                type = TvType.Movie,
                posterUrl = aImg,
                year = aYear,
                apiName = this.name
            )
        }

        // Episodes Links
        val episodeUrl = body.select("a.btn.btn-radius.btn-primary.btn-play").attr("href")
        val episodeDoc = app.get(episodeUrl).document


        val episodeList = episodeDoc.select("div.ss-list.ss-list-min > a").mapNotNull { ep ->
            val episodeNumber = ep.attr("data-number").toIntOrNull()
            val epLink = fixUrlNull(ep.attr("href")) ?: return@mapNotNull null

//            if (epLink.isNotBlank()) {
//                // Fetch video links
//                val epVidLinkEl = app.get(epLink, referer = mainUrl).document
//                val ajaxUrl = epVidLinkEl.select("div#js-player")?.attr("embed")
//                //Log.i(this.name, "Result => (ajaxUrl) ${ajaxUrl}")
//                if (!ajaxUrl.isNullOrEmpty()) {
//                    val innerPage = app.get(fixUrl(ajaxUrl), referer = epLink).document
//                    val listOfLinks = mutableListOf<String>()
//                    innerPage.select("div.player.active > main > div")?.forEach { em ->
//                        val href = fixUrlNull(em.attr("src")) ?: ""
//                        if (href.isNotBlank()) {
//                            listOfLinks.add(href)
//                        }
//                    }
//
//                    //Log.i(this.name, "Result => (listOfLinks) ${listOfLinks.toJson()}")
//
//                }
//            }
            Episode(
                name = null,
                season = null,
                episode = episodeNumber,
                data = epLink,
                posterUrl = null,
                date = null
            )
        }

        //If there's only 1 episode, consider it a movie.
        if (episodeList.size == 1) {
            return MovieLoadResponse(
                name = title,
                url = url,
                apiName = this.name,
                type = TvType.Movie,
                dataUrl = episodeList.first().data,
                posterUrl = poster,
                year = year,
                plot = descript,
                recommendations = recs,
                tags = tags
            )
        }
        return TvSeriesLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.AsianDrama,
            episodes = episodeList,
            posterUrl = poster,
            year = year,
            plot = descript,
            recommendations = recs,
            tags = tags
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        println("DATATATAT $data")

        val document = app.get(data).document
        val iframeUrl = document.select("iframe").attr("src")
        val iframe = app.get(iframeUrl)
        val iframeDoc = iframe.document

        argamap({
            iframeDoc.select(".list-server-items > .linkserver")
                .forEach { element ->
                    val status = element.attr("data-status") ?: return@forEach
                    if (status != "1") return@forEach
                    val extractorData = element.attr("data-video") ?: return@forEach
                    loadExtractor(extractorData, iframe.url, subtitleCallback, callback)
                }
        }, {
            val iv = "9262859232435825"
            val secretKey = "93422192433952489752342908585752"
            val secretDecryptKey = "93422192433952489752342908585752"
            Vidstream.extractVidstream(
                iframe.url,
                this.name,
                callback,
                iv,
                secretKey,
                secretDecryptKey,
                isUsingAdaptiveKeys = false,
                isUsingAdaptiveData = true,
                iframeDocument = iframeDoc
            )
        })
        return true
    }
}



================================================
FILE: DramaSeeProvider/src/main/kotlin/com/lagradost/DramaSeeProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class DramaSeeProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DramaSeeProvider())
    }
}


================================================
FILE: DubokuProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: DubokuProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: DubokuProvider/src/main/kotlin/com/lagradost/DubokuProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import org.jsoup.nodes.Element

class DubokuProvider : MainAPI() {
    override var mainUrl = "https://www.duboku.tv"
    override var name = "Duboku"
    override val hasMainPage = true
    override var lang = "zh"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama,
    )

    override val mainPage = mainPageOf(
        "$mainUrl/vodshow/2--time------" to "连续剧 时间",
        "$mainUrl/vodshow/2--hits------" to "连续剧 人气",
        "$mainUrl/vodshow/13--time------" to "陆剧 时间",
        "$mainUrl/vodshow/13--hits------" to "陆剧 人气",
        "$mainUrl/vodshow/15--time------" to "日韩剧 时间",
        "$mainUrl/vodshow/15--hits------" to "日韩剧 人气",
        "$mainUrl/vodshow/21--time------" to "短剧 时间",
        "$mainUrl/vodshow/21--hits------" to "短剧 人气",
        "$mainUrl/vodshow/16--time------" to "英美剧 时间",
        "$mainUrl/vodshow/16--hits------" to "英美剧 人气",
        "$mainUrl/vodshow/14--time------" to "台泰剧 时间",
        "$mainUrl/vodshow/14--hits------" to "台泰剧 人气",
        "$mainUrl/vodshow/20--time------" to "港剧 时间",
        "$mainUrl/vodshow/20--hits------" to "港剧 人气",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get("${request.data}$page---.html").document
        val home = document.select("ul.myui-vodlist.clearfix li").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h4.title a")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("a")?.attr("data-original"))
        val episode = this.selectFirst("span.pic-text.text-right")?.text()?.filter { it.isDigit() }
            ?.toIntOrNull()

        return newAnimeSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            addSub(episode)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/vodsearch/-------------.html?wd=$query&submit=").document

        return document.select("ul#searchList li").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).document

        val title = document.selectFirst("h1.title")?.text()?.trim() ?: return null
        val tvType = if (document.select("ul.myui-content__list li").size == 1
        ) TvType.Movie else TvType.TvSeries
        val actors = document.select("p.data")[2].select("a").map { it.text() }

        val episodes = document.select("ul.myui-content__list li").map {
            val href = fixUrl(it.select("a").attr("href"))
            val name = it.select("a").text().trim()
            Episode(
                data = href,
                name = name,
            )
        }
        return newTvSeriesLoadResponse(title, url, tvType, episodes) {
            this.posterUrl = fixUrlNull(
                document.selectFirst("a.myui-vodlist__thumb.picture img")?.attr("data-original")
            )
            this.year =
                document.select("p.data")[0].select("a").last()?.text()?.trim()?.toIntOrNull()
            this.plot = document.selectFirst("span.sketch.content")?.text()?.trim()
            this.tags = document.select("p.data")[0].select("a").map { it.text() }
            this.rating = document.select("div#rating span.branch").text().toRatingInt()
            addActors(actors)
        }

    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        app.get(data).document.select("script").map { script ->
            if (script.data().contains("var player_data={")) {
                val dataJson =
                    script.data().substringAfter("var player_data={").substringBefore("}")
                tryParseJson<Sources>("{$dataJson}")?.let { source ->
                    M3u8Helper.generateM3u8(
                        this.name,
                        source.url ?: return@map,
                        referer = "https://w.duboku.io/",
                        headers = mapOf("Origin" to "https://w.duboku.io")
                    ).forEach(callback)
                }
            }
        }


        return true
    }

    data class Sources(
        @JsonProperty("url") val url: String?,
    )


}


================================================
FILE: DubokuProvider/src/main/kotlin/com/lagradost/DubokuProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class DubokuProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(DubokuProvider())
    }
}


================================================
FILE: EgyBestProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: EgyBestProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: EgyBestProvider/src/main/kotlin/com/lagradost/EgyBestProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import org.jsoup.nodes.Element

class EgyBestProvider : MainAPI() {
    override var lang = "ar"
    override var mainUrl = "https://www.egy.best"
    override var name = "EgyBest"
    override val usesWebView = false
    override val hasMainPage = true
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie, TvType.Anime)

    private fun String.getIntFromText(): Int? {
        return Regex("""\d+""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    private fun Element.toSearchResponse(): SearchResponse? {
        val url = this.attr("href") ?: return null
        val posterUrl = select("img")?.attr("src")
        var title = select("span.title").text()
        val year = title.getYearFromTitle()
        val isMovie = Regex(".*/movie/.*|.*/masrahiya/.*").matches(url)
        val tvType = if (isMovie) TvType.Movie else TvType.TvSeries
        title = if (year !== null) title else title.split(" (")[0].trim()
        val quality = select("span.ribbon span").text().replace("-", "")
        // If you need to differentiate use the url.
        return MovieSearchResponse(
            title,
            url,
            this@EgyBestProvider.name,
            tvType,
            posterUrl,
            year,
            null,
            quality = getQualityFromString(quality)
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        // url, title
        val doc = app.get(mainUrl).document
        val pages = arrayListOf<HomePageList>()
        doc.select("#mainLoad div.mbox").apmap {
            val name = it.select(".bdb.pda > strong").text()
            if (it.select(".movie").first()?.attr("href")?.contains("season-(.....)|ep-(.....)".toRegex()) == true) return@apmap
            val list = arrayListOf<SearchResponse>()
            it.select(".movie").map { element ->
                list.add(element.toSearchResponse()!!)
            }
            pages.add(HomePageList(name, list))
        }
        return HomePageResponse(pages)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val q = query.replace(" ","%20")
        val result = arrayListOf<SearchResponse>()
        listOf("$mainUrl/explore/?q=$q").apmap { url ->
            val d = app.get(url).document
            d.select("div.movies a").not("a.auto.load.btn.b").mapNotNull {
                it.toSearchResponse()?.let { it1 -> result.add(it1) }
            }
        }
        return result.distinct().sortedBy { it.name }
    }

    private fun String.getYearFromTitle(): Int? {
        return Regex("""\(\d{4}\)""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val isMovie = Regex(".*/movie/.*|.*/masrahiya/.*").matches(url)
        val posterUrl = doc.select("div.movie_img a img")?.attr("src")
        val year = doc.select("div.movie_title h1 a")?.text()?.toIntOrNull()
        val title = doc.select("div.movie_title h1 span").text()
        val youtubeTrailer = doc.select("div.play")?.attr("url")
        
        val synopsis = doc.select("div.mbox").firstOrNull {
            it.text().contains("القصة")
        }?.text()?.replace("القصة ", "")

        val tags = doc.select("table.movieTable tbody tr").firstOrNull {
            it.text().contains("النوع")
        }?.select("a")?.map { it.text() }

        val actors = doc.select("div.cast_list .cast_item").mapNotNull {
            val name = it.selectFirst("div > a > img")?.attr("alt") ?: return@mapNotNull null
            val image = it.selectFirst("div > a > img")?.attr("src") ?: return@mapNotNull null
            val roleString = it.selectFirst("div > span")!!.text()
            val mainActor = Actor(name, image)
            ActorData(actor = mainActor, roleString = roleString)
        }

        return if (isMovie) {
            val recommendations = doc.select(".movies_small .movie").mapNotNull { element ->
                element.toSearchResponse()
            }

            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = posterUrl
                this.year = year
                this.recommendations = recommendations
                this.plot = synopsis
                this.tags = tags
                this.actors = actors
                addTrailer(youtubeTrailer)
            }
        } else {
            val episodes = ArrayList<Episode>()
            doc.select("#mainLoad > div:nth-child(2) > div.h_scroll > div a").map {
                it.attr("href")
            }.apmap {
                val d = app.get(it).document
                val season = Regex("season-(.....)").find(it)?.groupValues?.getOrNull(1)?.getIntFromText()
                if(d.select("tr.published").isNotEmpty()) {
                    d.select("tr.published").map { element ->
                        val ep = Regex("ep-(.....)").find(element.select(".ep_title a").attr("href"))?.groupValues?.getOrNull(1)?.getIntFromText()
                        episodes.add(
                            Episode(
                                element.select(".ep_title a").attr("href"),
                                name = element.select("td.ep_title").html().replace(".*</span>|</a>".toRegex(), ""),
                                season,
                                ep,
                                rating = element.select("td.tam:not(.date, .ep_len)").text().getIntFromText()
                            )
                        )
                    }
                } else {
                    d.select("#mainLoad > div:nth-child(3) > div.movies_small a").map { eit ->
                        val ep = Regex("ep-(.....)").find(eit.attr("href"))?.groupValues?.getOrNull(1)?.getIntFromText()
                        episodes.add(
                            Episode(
                                eit.attr("href"),
                                eit.select("span.title").text(),
                                season,
                                ep,
                            )
                        )
                    }
                }
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes.distinct().sortedBy { it.episode }) {
                this.posterUrl = posterUrl
                this.tags = tags
                this.year = year
                this.plot = synopsis
                this.actors = actors
                addTrailer(youtubeTrailer)
            }
        }
    }
    data class Sources (
        @JsonProperty("quality") val quality: Int?,
        @JsonProperty("link") val link: String
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        /*val baseURL = data.split("/")[0] + "//" + data.split("/")[2]
        val episodeSoup = app.get(data).document

        val vidstreamURL = fixUrlNull(episodeSoup.selectFirst("iframe.auto-size")?.attr("src") ) ?: throw ErrorLoadingException("No iframe")
        val videoSoup = app.get(vidstreamURL).document
        fixUrlNull( videoSoup.select("source").firstOrNull { it.hasAttr("src") }?.attr("src"))?.let {
            callback.invoke(ExtractorLink(this.name,this.name,it,"",Qualities.Unknown.value,it.contains(".m3u8")))
        } ?: run {
            var jsCode = videoSoup.select("script")[1].data()

            val verificationToken = Regex("{'[0-9a-zA-Z_]*':'ok'}").findAll(jsCode)[0][2:-7]
            val encodedAdLinkVar = Regex("([0-9a-zA-Z_]{2,12}\[Math").findAll(jsCode)[0][1:-5]
            val encodingArraysRegEx = Regex(",[0-9a-zA-Z_]{2,12}=\[\]").findAll(jsCode)
            val firstEncodingArray = encodingArraysRegEx[1][1:-3]
            val secondEncodingArray = encodingArraysRegEx[2][1:-3]

            jsCode = Regex("^<script type=\"text/javascript\">", "", jsCode)
            jsCode = Regex("[;,]\$\('\*'\)(.*)$", ";", jsCode)
            jsCode = Regex(",ismob=(.*)\(navigator\[(.*)\]\)[,;]", ";", jsCode)
            jsCode = Regex("var a0b=function\(\)(.*)a0a\(\);",).findAll( jsCode)
            jsCode += "var link = ''; for (var i = 0; i <= $secondEncodingArray['length']; i++) { link += $firstEncodingArray[$secondEncodingArray[i]] || ''; } return [link, $encodedAdLinkVar[0]] }"

            val jsCodeReturn = executeJS(jsCode)()
            val verificationPath = jsCodeReturn[0]
            val encodedAdPath = jsCodeReturn[1]

            val adLink = baseURL + "/" + str(decode(encodedAdPath + "=" * (-len(encodedAdPath) % 4)), "utf-8")
            val session.get(adLink)

            val verificationLink = baseURL + "/tvc.php?verify=" + verificationPath
            val session.post(verificationLink, data={verificationToken: "ok"})

            val vidstreamResponseText = session.get(vidstreamURL).text
            val videoSoup = BeautifulSoup(vidstreamResponseText, features="html.parser")

            val qualityLinksFileURL = baseURL + videoSoup.body.find("source").get("src")
        }


        return true*/

        val requestJSON = app.get("https://api.zr5.repl.co/egybest?url=$data").text
        // To solve this you need to send a verify request which is pretty hidden, see
        // https://vear.egybest.deals/tvc.php?verify=.......
        val jsonArray = parseJson<List<Sources>>(requestJSON)
        for (i in jsonArray) {
            val quality = i.quality
            val link = i.link
            callback.invoke(
                ExtractorLink(
                    this.name,
                    this.name,
                    link,
                    this.mainUrl,
                    quality!!,
                    true,
                    // Does not work without these headers!
                    headers = mapOf("range" to "bytes=0-"),
                )
            )
        }
        return true
    }
}



================================================
FILE: EgyBestProvider/src/main/kotlin/com/lagradost/EgyBestProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class EgyBestProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(EgyBestProvider())
    }
}


================================================
FILE: ElifilmsProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: ElifilmsProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: ElifilmsProvider/src/main/kotlin/com/lagradost/ElifilmsProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class ElifilmsProvider : MainAPI() {
    override var mainUrl: String = "https://elifilms.net"
    override var name: String = "Elifilms"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val newest = app.get(mainUrl).document.selectFirst("a.fav_link.premiera")?.attr("href")
        val urls = listOf(
            Pair(mainUrl, "Películas recientes"),
            Pair("$mainUrl/4k-peliculas/", "Películas en 4k"),
            Pair(newest, "Últimos estrenos"),
        )
        urls.apmap { (url, name) ->
            val soup = app.get(url ?: "").document
            val home = soup.select("article.shortstory.cf").map {
                val title = it.selectFirst(".short_header")?.text() ?: ""
                val link = it.selectFirst("div a")?.attr("href") ?: ""
                TvSeriesSearchResponse(
                    title,
                    link,
                    this.name,
                    TvType.Movie,
                    it.selectFirst("a.ah-imagge img")?.attr("data-src"),
                    null,
                    null,
                )
            }
            items.add(HomePageList(name, home))
        }
        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val doc = app.get(url).document
        return doc.select("article.cf").map {
            val href = it.selectFirst("div.short_content a")?.attr("href") ?: ""
            val poster = it.selectFirst("a.ah-imagge img")?.attr("data-src")
            val name = it.selectFirst(".short_header")?.text() ?: ""
            (MovieSearchResponse(name, href, this.name, TvType.Movie, poster, null))
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url, timeout = 120).document
        val title = document.selectFirst(".post_title h1")?.text() ?: ""
        val rating = document.select("span.imdb.rki").toString().toIntOrNull()
        val poster = document.selectFirst(".poster img")?.attr("src")
        val desc = document.selectFirst("div.notext .actors p")?.text()
        val tags = document.select("td.notext a")
            .map { it?.text()?.trim().toString() }
        return MovieLoadResponse(
            title,
            url,
            this.name,
            TvType.Movie,
            url,
            poster,
            null,
            desc,
            rating,
            tags
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("li.change-server a").apmap {
            val encodedurl = it.attr("data-id")
            val urlDecoded = base64Decode(encodedurl)
            val url = fixUrl(urlDecoded)
            loadExtractor(url, data, subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: ElifilmsProvider/src/main/kotlin/com/lagradost/ElifilmsProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class ElifilmsProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(ElifilmsProvider())
    }
}


================================================
FILE: EntrepeliculasyseriesProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: EntrepeliculasyseriesProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: EntrepeliculasyseriesProvider/src/main/kotlin/com/lagradost/EntrepeliculasyseriesProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class EntrepeliculasyseriesProvider : MainAPI() {
    override var mainUrl = "https://entrepeliculasyseries.nu"
    override var name = "EntrePeliculasySeries"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override val vpnStatus = VPNStatus.MightBeNeeded //Due to evoload sometimes not loading

    override val mainPage = mainPageOf(
        Pair("$mainUrl/series/page/", "Series"),
        Pair("$mainUrl/peliculas/page/", "Peliculas"),
        Pair("$mainUrl/anime/page/", "Animes"),
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val url = request.data + page

        val soup = app.get(url).document
        val home = soup.select("ul.list-movie li").map {
            val title = it.selectFirst("a.link-title h2")!!.text()
            val link = it.selectFirst("a")!!.attr("href")
            TvSeriesSearchResponse(
                title,
                link,
                this.name,
                if (link.contains("/pelicula/")) TvType.Movie else TvType.TvSeries,
                it.selectFirst("a.poster img")!!.attr("src"),
                null,
                null,
            )
        }

        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=${query}"
        val document = app.get(url).document

        return document.select("li.xxx.TPostMv").map {
            val title = it.selectFirst("h2.Title")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst("img.lazy")!!.attr("data-src")
            val isMovie = href.contains("/pelicula/")

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            }
        }.toList()
    }


    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url, timeout = 120).document

        val title = soup.selectFirst("h1.title-post")!!.text()
        val description = soup.selectFirst("p.text-content:nth-child(3)")?.text()?.trim()
        val poster: String? = soup.selectFirst("article.TPost img.lazy")!!.attr("data-src")
        val episodes = soup.select(".TPostMv article").map { li ->
            val href = (li.select("a") ?: li.select(".C a") ?: li.select("article a")).attr("href")
            val epThumb = li.selectFirst("div.Image img")!!.attr("data-src")
            val seasonid = li.selectFirst("span.Year")!!.text().let { str ->
                str.split("x").mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val isValid = seasonid.size == 2
            val episode = if (isValid) seasonid.getOrNull(1) else null
            val season = if (isValid) seasonid.getOrNull(0) else null
            Episode(
                href,
                null,
                season,
                episode,
                fixUrl(epThumb)
            )
        }
        return when (val tvType =
            if (url.contains("/pelicula/")) TvType.Movie else TvType.TvSeries) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    null,
                    description,
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    null,
                    description,
                )
            }
            else -> null
        }
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select(".video ul.dropdown-menu li").apmap {
            val servers = it.attr("data-link")
            val doc = app.get(servers).document
            doc.select("input").apmap {
                val postkey = it.attr("value")
                app.post(
                    "https://entrepeliculasyseries.nu/r.php",
                    headers = mapOf(
                        "Host" to "entrepeliculasyseries.nu",
                        "User-Agent" to USER_AGENT,
                        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                        "Accept-Language" to "en-US,en;q=0.5",
                        "Content-Type" to "application/x-www-form-urlencoded",
                        "Origin" to "https://entrepeliculasyseries.nu",
                        "DNT" to "1",
                        "Connection" to "keep-alive",
                        "Referer" to servers,
                        "Upgrade-Insecure-Requests" to "1",
                        "Sec-Fetch-Dest" to "document",
                        "Sec-Fetch-Mode" to "navigate",
                        "Sec-Fetch-Site" to "same-origin",
                        "Sec-Fetch-User" to "?1",
                    ),
                    //params = mapOf(Pair("h", postkey)),
                    data = mapOf(Pair("h", postkey)),
                    allowRedirects = false
                ).okhttpResponse.headers.values("location").apmap {
                    loadExtractor(it, data, subtitleCallback, callback)
                }
            }
        }
        return true
    }
}


================================================
FILE: EntrepeliculasyseriesProvider/src/main/kotlin/com/lagradost/EntrepeliculasyseriesProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class EntrepeliculasyseriesProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(EntrepeliculasyseriesProvider())
    }
}


================================================
FILE: EstrenosDoramasProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: EstrenosDoramasProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: EstrenosDoramasProvider/src/main/kotlin/com/lagradost/EstrenosDoramasProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import java.util.*
import kotlin.collections.ArrayList


class EstrenosDoramasProvider : MainAPI() {
    companion object {
        fun getType(t: String): TvType {
            return if (t.contains("OVA") || t.contains("Especial")) TvType.OVA
            else if (t.contains("Pelicula")) TvType.Movie
            else TvType.TvSeries
        }
    }

    override var mainUrl = "https://www23.estrenosdoramas.net"
    override var name = "EstrenosDoramas"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.AsianDrama,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val urls = listOf(
            Pair(mainUrl, "Últimas series"),
            Pair("$mainUrl/category/peliculas", "Películas"),
        )

        val items = ArrayList<HomePageList>()

        urls.apmap { (url, name) ->
            val home = app.get(url, timeout = 120).document.select("div.clearfix").map {
                val title = cleanTitle(it.selectFirst("h3 a")?.text()!!)
                val poster = it.selectFirst("img.cate_thumb")?.attr("src")
                AnimeSearchResponse(
                    title,
                    it.selectFirst("a")?.attr("href")!!,
                    this.name,
                    TvType.AsianDrama,
                    poster,
                    null,
                    if (title.contains("Latino") || title.contains("Castellano")) EnumSet.of(
                        DubStatus.Dubbed
                    ) else EnumSet.of(DubStatus.Subbed),
                )
            }
            items.add(HomePageList(name, home))
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchob = ArrayList<AnimeSearchResponse>()
        val search =
            app.get("$mainUrl/?s=$query", timeout = 120).document.select("div.clearfix").map {
                val title = cleanTitle(it.selectFirst("h3 a")?.text()!!)
                val href = it.selectFirst("a")?.attr("href")
                val image = it.selectFirst("img.cate_thumb")?.attr("src")
                val lists =
                    AnimeSearchResponse(
                        title,
                        href!!,
                        this.name,
                        TvType.AsianDrama,
                        image,
                        null,
                        if (title.contains("Latino") || title.contains("Castellano")) EnumSet.of(
                            DubStatus.Dubbed
                        ) else EnumSet.of(DubStatus.Subbed),
                    )
                if (href.contains("capitulo")) {
                    //nothing
                }
                else {
                    searchob.add(lists)
                }
            }
        return searchob
    }

    override suspend fun load(url: String): LoadResponse? {
        val doc = app.get(url, timeout = 120).document
        val poster = doc.selectFirst("head meta[property]")?.attr("content")
        val title = doc.selectFirst("h1.titulo")?.text()
        val description = try {
            doc.selectFirst("div.post div.highlight div.font")?.text()
        } catch (e:Exception){
            null
        }
        val finaldesc = description?.substringAfter("Sinopsis")?.replace(": ", "")?.trim()
        val epi = ArrayList<Episode>()
        val episodes = doc.select("div.post .lcp_catlist a").map {
            val name = it.selectFirst("a")?.text()
            val link = it.selectFirst("a")?.attr("href")
            val test = Episode(link!!, name)
            if (!link.equals(url)) {
                epi.add(test)
            }
        }.reversed()
        return when (val type = if (episodes.isEmpty()) TvType.Movie else TvType.AsianDrama) {
            TvType.AsianDrama -> {
                return newAnimeLoadResponse(title!!, url, type) {
                    japName = null
                    engName = title.replace(Regex("[Pp]elicula |[Pp]elicula"),"")
                    posterUrl = poster
                    addEpisodes(DubStatus.Subbed, epi.reversed())
                    plot = finaldesc
                }
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    cleanTitle(title!!),
                    url,
                    this.name,
                    TvType.Movie,
                    url,
                    poster,
                    null,
                    finaldesc,
                    null,
                    null,
                )
            }
            else -> null
        }

    }



    data class ReproDoramas (
        @JsonProperty("link") val link: String,
        @JsonProperty("time") val time: Int
    )

    private fun cleanTitle(title: String): String = title.replace(Regex("[Pp]elicula |[Pp]elicula"),"")

    private fun cleanExtractor(
        source: String,
        name: String,
        url: String,
        referer: String,
        m3u8: Boolean,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        callback(
            ExtractorLink(
                source,
                name,
                url,
                referer,
                Qualities.Unknown.value,
                m3u8
            )
        )
        return true
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val headers = mapOf("Host" to "repro3.estrenosdoramas.us",
            "User-Agent" to USER_AGENT,
            "Accept" to "*/*",
            "Accept-Language" to "en-US,en;q=0.5",
            "Content-Type" to "application/x-www-form-urlencoded; charset=UTF-8",
            "X-Requested-With" to "XMLHttpRequest",
            "Origin" to "https://repro3.estrenosdoramas.us",
            "DNT" to "1",
            "Connection" to "keep-alive",
            "Sec-Fetch-Dest" to "empty",
            "Sec-Fetch-Mode" to "cors",
            "Sec-Fetch-Site" to "same-origin",
            "Cache-Control" to "max-age=0",)

        val document = app.get(data).document
        document.select("div.tab_container iframe").apmap { container ->
            val directlink = fixUrl(container.attr("src"))
            loadExtractor(directlink, data, subtitleCallback, callback)

            if (directlink.contains("/repro/amz/")) {
                val amzregex = Regex("https:\\/\\/repro3\\.estrenosdoramas\\.us\\/repro\\/amz\\/examples\\/.*\\.php\\?key=.*\$")
                amzregex.findAll(directlink).map {
                    it.value.replace(Regex("https:\\/\\/repro3\\.estrenosdoramas\\.us\\/repro\\/amz\\/examples\\/.*\\.php\\?key="),"")
                }.toList().apmap { key ->
                    val response = app.post("https://repro3.estrenosdoramas.us/repro/amz/examples/player/api/indexDCA.php",
                        headers = headers,
                        data = mapOf(
                            Pair("key",key),
                            Pair("token","MDAwMDAwMDAwMA=="),
                        ),
                        allowRedirects = false
                    ).text
                    val reprojson = parseJson<ReproDoramas>(response)
                    val decodeurl = base64Decode(reprojson.link)
                    if (decodeurl.contains("m3u8"))

                        cleanExtractor(
                            name,
                            name,
                            decodeurl,
                            "https://repro3.estrenosdoramas.us",
                            decodeurl.contains(".m3u8"),
                            callback
                        )
                }
            }


            if (directlink.contains("reproducir14")) {
                val regex = Regex("(https:\\/\\/repro.\\.estrenosdoramas\\.us\\/repro\\/reproducir14\\.php\\?key=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                regex.findAll(directlink).map {
                    it.value
                }.toList().apmap {
                    val doc = app.get(it).text
                    val videoid = doc.substringAfter("vid=\"").substringBefore("\" n")
                    val token = doc.substringAfter("name=\"").substringBefore("\" s")
                    val acctkn = doc.substringAfter("{ acc: \"").substringBefore("\", id:")
                    val link = app.post("https://repro3.estrenosdoramas.us/repro/proto4.php",
                        headers = headers,
                        data = mapOf(
                            Pair("acc",acctkn),
                            Pair("id",videoid),
                            Pair("tk",token)),
                        allowRedirects = false
                    ).text
                    val extracteklink = link.substringAfter("\"urlremoto\":\"").substringBefore("\"}")
                        .replace("\\/", "/").replace("//ok.ru/","http://ok.ru/")
                    loadExtractor(extracteklink, data, subtitleCallback, callback)
                }
            }

            if (directlink.contains("reproducir120")) {
                val regex = Regex("(https:\\/\\/repro3.estrenosdoramas.us\\/repro\\/reproducir120\\.php\\?\\nkey=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
                regex.findAll(directlink).map {
                    it.value
                }.toList().apmap {
                    val doc = app.get(it).text
                    val videoid = doc.substringAfter("var videoid = '").substringBefore("';")
                    val token = doc.substringAfter("var tokens = '").substringBefore("';")
                    val acctkn = doc.substringAfter("{ acc: \"").substringBefore("\", id:")
                    val link = app.post("https://repro3.estrenosdoramas.us/repro/api3.php",
                        headers = headers,
                        data = mapOf(
                            Pair("acc",acctkn),
                            Pair("id",videoid),
                            Pair("tk",token)),
                        allowRedirects = false
                    ).text
                    val extractedlink = link.substringAfter("\"{file:'").substringBefore("',label:")
                        .replace("\\/", "/")
                    val quality = link.substringAfter(",label:'").substringBefore("',type:")
                    val type = link.substringAfter("type: '").substringBefore("'}\"")
                    if (extractedlink.isNotBlank())
                        if (quality.contains("File not found", ignoreCase = true)) {
                            //Nothing
                        } else {
                            cleanExtractor(
                                "Movil",
                                "Movil $quality",
                                extractedlink,
                                "",
                                !type.contains("mp4"),
                                callback
                            )
                        }
                }
            }
        }

        return true
    }
}



================================================
FILE: EstrenosDoramasProvider/src/main/kotlin/com/lagradost/EstrenosDoramasProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class EstrenosDoramasProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(EstrenosDoramasProvider())
    }
}


================================================
FILE: FaselHDProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: FaselHDProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: FaselHDProvider/src/main/kotlin/com/lagradost/FaselHDProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.nodes.Element

class FaselHDProvider : MainAPI() {
    override var lang = "ar"
    override var mainUrl = "https://faselhd.io"
    override var name = "FaselHD"
    override val usesWebView = false
    override val hasMainPage = true
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie, TvType.AsianDrama, TvType.Anime)

    private fun String.getIntFromText(): Int? {
        return Regex("""\d+""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    private fun Element.toSearchResponse(): SearchResponse? {
        val url = select("div.postDiv a").attr("href") ?: return null
        val posterUrl = select("div.postDiv a div img").attr("data-src") ?:
        select("div.postDiv a div img").attr("src")
        val title = select("div.postDiv a div img").attr("alt")
        val quality = select(".quality").first()?.text()?.replace("1080p |-".toRegex(), "")
        val type = if(title.contains("فيلم")) TvType.Movie else TvType.TvSeries
        return MovieSearchResponse(
            title.replace("الموسم الأول|برنامج|فيلم|مترجم|اون لاين|مسلسل|مشاهدة|انمي|أنمي".toRegex(),""),
            url,
            this@FaselHDProvider.name,
            type,
            posterUrl,
            null,
            null,
            quality = getQualityFromString(quality)
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        // Title, Url
        val moviesUrl = listOf(
            Pair("Movies", "$mainUrl/all-movies/page/"+(0..10).random()),
            Pair("Series", "$mainUrl/series/page/"+(0..10).random()),
            Pair("Top Movies IMDB", "$mainUrl/movies_top_imdb"),
        )
        val pages = moviesUrl.apmap { (title, url) ->
            val doc = app.get(url).document
            val list = doc.select("div[id=\"postList\"] div[class=\"col-xl-2 col-lg-2 col-md-3 col-sm-3\"]")
                .mapNotNull { element ->
                    element.toSearchResponse()
                }
            HomePageList(title, list)
        }
        return HomePageResponse(pages)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val q = query.replace(" ","+")
        val d = app.get("$mainUrl/?s=$q").document
        return d.select("div[id=\"postList\"] div[class=\"col-xl-2 col-lg-2 col-md-3 col-sm-3\"]")
            .mapNotNull {
                it.toSearchResponse()
            }
    }


    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val isMovie = doc.select("div.epAll").isEmpty()
        val posterUrl = doc.select("div.posterImg img").attr("src")
            .ifEmpty { doc.select("div.seasonDiv.active img").attr("data-src") }

        val year = doc.select("div[id=\"singleList\"] div[class=\"col-xl-6 col-lg-6 col-md-6 col-sm-6\"]").firstOrNull {
            it.text().contains("سنة|موعد".toRegex())
        }?.text()?.getIntFromText()

        val title =
            doc.select("title").text().replace(" - فاصل إعلاني", "")
                .replace("الموسم الأول|برنامج|فيلم|مترجم|اون لاين|مسلسل|مشاهدة|انمي|أنمي|$year".toRegex(),"")
        // A bit iffy to parse twice like this, but it'll do.
        val duration = doc.select("div[id=\"singleList\"] div[class=\"col-xl-6 col-lg-6 col-md-6 col-sm-6\"]").firstOrNull {
            it.text().contains("مدة|توقيت".toRegex())
        }?.text()?.getIntFromText()

        val tags = doc.select("div[id=\"singleList\"] div[class=\"col-xl-6 col-lg-6 col-md-6 col-sm-6\"]:contains(تصنيف الفيلم) a").map {
            it.text()
        }
        val recommendations = doc.select("div#postList div.postDiv").mapNotNull {
            it.toSearchResponse()
        }
        val synopsis = doc.select("div.singleDesc p").text()
        return if (isMovie) {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = synopsis
                this.duration = duration
                this.tags = tags
                this.recommendations = recommendations
            }
        } else {
            val episodes = ArrayList<Episode>()
            doc.select("div.epAll a").map {
                episodes.add(
                    Episode(
                        it.attr("href"),
                        it.text(),
                        doc.select("div.seasonDiv.active div.title").text().getIntFromText() ?: 1,
                        it.text().getIntFromText(),
                    )
                )
            }
            doc.select("div[id=\"seasonList\"] div[class=\"col-xl-2 col-lg-3 col-md-6\"] div.seasonDiv")
                .not(".active").apmap { it ->
                    val s = app.get("$mainUrl/?p="+it.attr("data-href")).document
                    s.select("div.epAll a").map {
                        episodes.add(
                            Episode(
                                it.attr("href"),
                                it.text(),
                                s.select("div.seasonDiv.active div.title").text().getIntFromText(),
                                it.text().getIntFromText(),
                            )
                        )
                    }
                }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes.distinct().sortedBy { it.episode }) {
                this.duration = duration
                this.posterUrl = posterUrl
                this.year = year
                this.plot = synopsis
                this.tags = tags
                this.recommendations = recommendations
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val player = app.get(app.get(data).document.select("iframe[name=\"player_iframe\"]").attr("src")).document
        player.select("div.quality_change button.hd_btn").map {
                callback.invoke(
                    ExtractorLink(
                        this.name,
                        this.name,
                        it.attr("data-url"),
                        this.mainUrl,
                        quality = it.text().getIntFromText() ?: 0,
                        isM3u8 = true
                    )
                )
        }
        return true
    }
}


================================================
FILE: FaselHDProvider/src/main/kotlin/com/lagradost/FaselHDProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class FaselHDProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(FaselHDProvider())
    }
}


================================================
FILE: FilmanProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: FilmanProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: FilmanProvider/src/main/kotlin/com/lagradost/FilmanProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.select.Elements

class FilmanProvider : MainAPI() {
    override var mainUrl = "https://filman.cc"
    override var name = "filman.cc"
    override var lang = "pl"
    override val hasMainPage = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val document = app.get(mainUrl).document
        val lists = document.select("#item-list,#series-list")
        val categories = ArrayList<HomePageList>()
        for (l in lists) {
            val title = capitalizeString(l.parent()!!.select("h3").text().lowercase())
            val items = l.select(".poster").map { i ->
                val name = i.select("a[href]").attr("title")
                val href = i.select("a[href]").attr("href")
                val poster = i.select("img[src]").attr("src")
                val year = l.select(".film_year").text().toIntOrNull()
                if (l.hasClass("series-list")) TvSeriesSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.TvSeries,
                    poster,
                    year,
                    null
                ) else MovieSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.Movie,
                    poster,
                    year
                )
            }
            categories.add(HomePageList(title, items))
        }
        return HomePageResponse(categories)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/wyszukiwarka?phrase=$query"
        val document = app.get(url).document
        val lists = document.select("#advanced-search > div")
        val movies = lists[1].select("#item-list > div:not(.clearfix)")
        val series = lists[3].select("#item-list > div:not(.clearfix)")
        if (movies.isEmpty() && series.isEmpty()) return ArrayList()
        fun getVideos(type: TvType, items: Elements): List<SearchResponse> {
            return items.mapNotNull { i ->
                val href = i.selectFirst(".poster > a")?.attr("href") ?: return@mapNotNull null
                val img =
                    i.selectFirst(".poster > a > img")?.attr("src")?.replace("/thumb/", "/big/")
                val name = i.selectFirst(".film_title")?.text() ?: return@mapNotNull null
                val year = i.selectFirst(".film_year")?.text()?.toIntOrNull()
                if (type === TvType.TvSeries) {
                    TvSeriesSearchResponse(
                        name,
                        href,
                        this.name,
                        type,
                        img,
                        year,
                        null
                    )
                } else {
                    MovieSearchResponse(name, href, this.name, type, img, year)
                }
            }
        }
        return getVideos(TvType.Movie, movies) + getVideos(TvType.TvSeries, series)
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document
        val documentTitle = document.select("title").text().trim()

        if (documentTitle.startsWith("Logowanie")) {
            throw RuntimeException("This page seems to be locked behind a login-wall on the website, unable to scrape it. If it is not please report it.")
        }

        var title = document.select("span[itemprop=title]").text()
        val data = document.select("#links").outerHtml()
        val posterUrl = document.select("#single-poster > img").attr("src")
        val year = document.select(".info > ul > li").getOrNull(1)?.text()?.toIntOrNull()
        val plot = document.select(".description").text()
        val episodesElements = document.select("#episode-list a[href]")
        if (episodesElements.isEmpty()) {
            return MovieLoadResponse(title, url, name, TvType.Movie, data, posterUrl, year, plot)
        }
        title = document.selectFirst(".info")?.parent()?.select("h2")?.text() ?: ""
        val episodes = episodesElements.mapNotNull { episode ->
            val e = episode.text()
            val regex = Regex("""\[s(\d{1,3})e(\d{1,3})]""").find(e) ?: return@mapNotNull null
            val eid = regex.groups
            Episode(
                episode.attr("href"),
                e.split("]")[1].trim(),
                eid[1]?.value?.toInt(),
                eid[2]?.value?.toInt(),
            )
        }.toMutableList()

        return TvSeriesLoadResponse(
            title,
            url,
            name,
            TvType.TvSeries,
            episodes,
            posterUrl,
            year,
            plot
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val document = if (data.startsWith("http"))
            app.get(data).document.select("#links").first()
        else Jsoup.parse(data)

        document?.select(".link-to-video")?.apmap { item ->
            val decoded = base64Decode(item.select("a").attr("data-iframe"))
            val link = tryParseJson<LinkElement>(decoded)?.src ?: return@apmap
            loadExtractor(link, subtitleCallback, callback)
        }
        return true
    }
}

data class LinkElement(
    @JsonProperty("src") val src: String
)



================================================
FILE: FilmanProvider/src/main/kotlin/com/lagradost/FilmanProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class FilmanProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(FilmanProvider())
    }
}


================================================
FILE: FilmpertuttiProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: FilmpertuttiProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: FilmpertuttiProvider/src/main/kotlin/com/lagradost/FilmpertuttiProvider.kt
================================================
package com.lagradost

//import androidx.core.text.parseAsHtml
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addRating
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ShortLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element
import com.lagradost.cloudstream3.utils.AppUtils.html


class FilmpertuttiProvider : MainAPI() {
    override var lang = "it"
    override var mainUrl = "https://filmpertutti.photo"
    override var name = "Filmpertutti"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries
    )

    override val mainPage = mainPageOf(
        Pair("$mainUrl/category/film/page/", "Film Popolari"),
        Pair("$mainUrl/category/serie-tv/page/", "Serie Tv Popolari"),
        Pair("$mainUrl/prime-visioni/", "Ultime uscite"),
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = request.data + page

        val soup = app.get(url).document
        val home = soup.select("ul.posts > li").map {
            val title = it.selectFirst("div.title")!!.text().substringBeforeLast("(")
                .substringBeforeLast("[")
            val link = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst("a")!!.attr("data-thumbnail")
            val qualitydata = it.selectFirst("div.hd")
            val quality = if (qualitydata != null) {
                getQualityFromString(qualitydata.text())
            } else {
                null
            }
            newTvSeriesSearchResponse(
                title,
                link
            ) {
                this.posterUrl = image
                this.quality = quality
            }
        }

        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val queryformatted = query.replace(" ", "+")
        val url = "$mainUrl/?s=$queryformatted"
        val doc = app.get(url).document
        return doc.select("ul.posts > li").map {
            val title = it.selectFirst("div.title")!!.text().substringBeforeLast("(")
                .substringBeforeLast("[")
            val link = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst("a")!!.attr("data-thumbnail")
            val quality = getQualityFromString(it.selectFirst("div.hd")?.text())

            MovieSearchResponse(
                title,
                link,
                this.name,
                quality = quality,
                posterUrl = image
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document
        val type =
            if (document.selectFirst("a.taxonomy.category")!!.attr("href").contains("serie-tv")
                    .not()
            ) TvType.Movie else TvType.TvSeries
        val title = document.selectFirst("#content > h1")!!.text().substringBeforeLast("(")
            .substringBeforeLast("[")

        val description =
            document.selectFirst("i.fa.fa-file-text-o.fa-fw")?.parent()?.nextSibling()?.toString()
                ?.html().toString()


        val rating = document.selectFirst("div.rating > div.value")?.text()

        val year =
            document.selectFirst("#content > h1")?.text()?.substringAfterLast("(")
                ?.filter { it.isDigit() }?.toIntOrNull()
                ?: description.substringAfter("trasmessa nel").take(6).filter { it.isDigit() }
                    .toIntOrNull() ?: (document.selectFirst("i.fa.fa-calendar.fa-fw")?.parent()
                    ?.nextSibling() as Element?)?.text()?.substringAfterLast(" ")
                    ?.filter { it.isDigit() }?.toIntOrNull()


        val poster = document.selectFirst("div.meta > div > img")?.attr("data-src")


        val trailerurl =
            document.selectFirst("div.youtube-player")?.attr("data-id")?.let { urldata ->
                "https://www.youtube.com/watch?v=$urldata"
            }

        if (type == TvType.TvSeries) {

            val episodeList = ArrayList<Episode>()
            document.select("div.accordion-item").filter { a ->
                a.selectFirst("#season > ul > li.s_title > span")!!.text().isNotEmpty()
            }.map { element ->
                val season =
                    element.selectFirst("#season > ul > li.s_title > span")!!.text().toInt()
                element.select("div.episode-wrap").map { episode ->
                    val href =
                        episode.select("#links > div > div > table > tbody:nth-child(2) > tr")
                            .map { it.selectFirst("a")!!.attr("href") }.toJson()
                    val epNum = episode.selectFirst("li.season-no")!!.text().substringAfter("x")
                        .filter { it.isDigit() }.toIntOrNull()
                    val epTitle = episode.selectFirst("li.other_link > a")?.text()

                    val posterUrl = episode.selectFirst("figure > img")?.attr("data-src")
                    episodeList.add(
                        Episode(
                            href,
                            epTitle,
                            season,
                            epNum,
                            posterUrl,
                        )
                    )
                }
            }
            return newTvSeriesLoadResponse(
                title,
                url, type, episodeList
            ) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                addRating(rating)
                addTrailer(trailerurl)
            }
        } else {

            val urls0 = document.select("div.embed-player")
            val urls = if (urls0.isNotEmpty()) {
                urls0.map { it.attr("data-id") }.toJson()
            } else {
                document.select("#info > ul > li ").mapNotNull { it.selectFirst("a")?.attr("href") }
                    .toJson()
            }

            return newMovieLoadResponse(
                title,
                url,
                type,
                urls
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year
                this.plot = description
                addRating(rating)
                addTrailer(trailerurl)

            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        tryParseJson<List<String>>(data)?.apmap { id ->
            val link = ShortLink.unshorten(id).trim().replace("/v/", "/e/").replace("/f/", "/e/")
            loadExtractor(link, data, subtitleCallback, callback)
        }
        return true
    }
}


================================================
FILE: FilmpertuttiProvider/src/main/kotlin/com/lagradost/FilmpertuttiProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class FilmpertuttiProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(FilmpertuttiProvider())
    }
}


================================================
FILE: FmoviesToProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: FmoviesToProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: FmoviesToProvider/src/main/kotlin/com/lagradost/FmoviesToProvider.kt
================================================
package com.lagradost

class FmoviesToProvider : BflixProvider() {
    override var mainUrl = "https://fmovies.to"
    override var name = "Fmovies.to"
}


================================================
FILE: FmoviesToProvider/src/main/kotlin/com/lagradost/FmoviesToProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class FmoviesToProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(FmoviesToProvider())
    }
}


================================================
FILE: FrenchStreamProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: FrenchStreamProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: FrenchStreamProvider/src/main/kotlin/com/lagradost/FrenchStreamProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addRating
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.extractorApis


class FrenchStreamProvider : MainAPI() {
    override var mainUrl = "https://french-stream.re"
    override var name = "French Stream"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override var lang = "fr"
    override val supportedTypes = setOf(TvType.AnimeMovie, TvType.TvSeries, TvType.Movie)

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/?do=search&subaction=search&story=$query"
        val soup = app.post(link).document

        return soup.select("div.short-in.nl").map { li ->
            val href = fixUrl(li.selectFirst("a.short-poster")!!.attr("href"))
            val poster = li.selectFirst("img")?.attr("src")
            val title = li.selectFirst("> a.short-poster")!!.text().toString().replace(". ", "")
            val year = li.selectFirst(".date")?.text()?.split("-")?.get(0)?.toIntOrNull()
            if (title.contains(
                    "saison",
                    ignoreCase = true
                )
            ) {  // if saison in title ==> it's a TV serie
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    poster,
                    year,
                    (title.split("Eps ", " ")[1]).split(" ")[0].toIntOrNull()
                )
            } else {  // it's a movie
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    poster,
                    year,
                )
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val soup = app.get(url).document

        val title = soup.selectFirst("h1#s-title")!!.text().toString()
        val isMovie = !title.contains("saison", ignoreCase = true)
        val description =
            soup.selectFirst("div.fdesc")!!.text().toString()
                .split("streaming", ignoreCase = true)[1].replace(" :  ", "")
        var poster = fixUrlNull(soup.selectFirst("div.fposter > img")?.attr("src"))
        val listEpisode = soup.select("div.elink")

        if (isMovie) {
            val tags = soup.select("ul.flist-col > li").getOrNull(1)
            val tagsList = tags?.select("a")
                ?.mapNotNull {   // all the tags like action, thriller ...; unused variable
                    it?.text()
                }
            return newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                addRating(soup.select("div.fr-count > div").text())
                this.year = soup.select("ul.flist-col > li").getOrNull(2)?.text()?.toIntOrNull()
                this.tags = tagsList
                this.plot = description
                addTrailer(soup.selectFirst("div.fleft > span > a")?.attr("href"))
            }
        } else  // a tv serie
        {
            //println(listEpisode)
            //println("listeEpisode:")
            val episodeList = if ("<a" !in (listEpisode[0]).toString()) {  // check if VF is empty
                listEpisode[1]  // no vf, return vostfr
            } else {
                listEpisode[0] // no vostfr, return vf
            }

            //println(url)

            val episodes = episodeList.select("a").map { a ->
                val epNum = a.text().split("Episode")[1].trim().toIntOrNull()
                val epTitle = if (a.text().contains("Episode")) {
                    val type = if ("honey" in a.attr("id")) {
                        "VF"
                    } else {
                        "VOSTFR"
                    }
                    "Episode " + epNum?.toString() + " en " + type
                } else {
                    a.text()
                }
                if (poster == null) {
                    poster = a.selectFirst("div.fposter > img")?.attr("src")
                }
                Episode(
                    fixUrl(url).plus("-episodenumber:$epNum"),
                    epTitle,
                    null,
                    epNum,
                    null,  // episode Thumbnail
                    null // episode date
                )
            }
            return TvSeriesLoadResponse(
                title,
                url,
                this.name,
                TvType.TvSeries,
                episodes,
                poster,
                null,
                description,
                ShowStatus.Ongoing,
            )
        }
    }

    fun translate(
        // the website has weird naming of series for episode 2 and 1 and original version content
        episodeNumber: String,
        is_vf_available: Boolean,
    ): String {
        return if (episodeNumber == "1") {
            if (is_vf_available) {  // 1 translate differently if vf is available or not
                "FGHIJK"
            } else {
                "episode033"
            }
        } else {
            "episode" + (episodeNumber.toInt() + 32).toString()
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val servers =
            if (data.contains("-episodenumber:"))// It's a serie:
            {
                val split =
                    data.split("-episodenumber:")  // the data contains the url and the wanted episode number (a temporary dirty fix that will last forever)
                val url = split[0]
                val wantedEpisode =
                    if (split[1] == "2") { // the episode number 2 has id of ABCDE, don't ask any question
                        "ABCDE"
                    } else {
                        "episode" + split[1]
                    }


                val soup = app.get(fixUrl(url)).document
                val div =
                    if (wantedEpisode == "episode1") {
                        "> div.tabs-sel "  // this element is added when the wanted episode is one (the place changes in the document)
                    } else {
                        ""
                    }
                val serversvf =// French version servers
                    soup.select("div#$wantedEpisode > div.selink > ul.btnss $div> li")
                        .mapNotNull { li ->  // list of all french version servers
                            val serverUrl = fixUrl(li.selectFirst("a")!!.attr("href"))
//                            val litext = li.text()
                            if (serverUrl.isNotBlank()) {
                                if (li.text().replace("&nbsp;", "").replace(" ", "").isNotBlank()) {
                                    Pair(li.text().replace(" ", ""), "vf" + fixUrl(serverUrl))
                                } else {
                                    null
                                }
                            } else {
                                null
                            }
                        }

                val translated = translate(split[1], serversvf.isNotEmpty())
                val serversvo =  // Original version servers
                    soup.select("div#$translated > div.selink > ul.btnss $div> li")
                        .mapNotNull { li ->
                            val serverUrl = fixUrlNull(li.selectFirst("a")?.attr("href"))
                            if (!serverUrl.isNullOrEmpty()) {
                                if (li.text().replace("&nbsp;", "").isNotBlank()) {
                                    Pair(li.text().replace(" ", ""), "vo" + fixUrl(serverUrl))
                                } else {
                                    null
                                }
                            } else {
                                null
                            }
                        }
                serversvf + serversvo
            } else {  // it's a movie
                val movieServers =
                    app.get(fixUrl(data)).document.select("nav#primary_nav_wrap > ul > li > ul > li > a")
                        .mapNotNull { a ->
                            val serverurl = fixUrlNull(a.attr("href")) ?: return@mapNotNull null
                            val parent = a.parents()[2]
                            val element = parent.selectFirst("a")!!.text().plus(" ")
                            if (a.text().replace("&nbsp;", "").isNotBlank()) {
                                Pair(element.plus(a.text()), fixUrl(serverurl))
                            } else {
                                null
                            }
                        }
                movieServers
            }

        servers.apmap {
            for (extractor in extractorApis) {
                if (it.first.contains(extractor.name, ignoreCase = true)) {
                    //                    val name = it.first
                    //                    print("true for $name")
                    extractor.getSafeUrl(it.second, it.second, subtitleCallback, callback)
                    break
                }
            }
        }

        return true
    }


    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse? {
        val document = app.get(mainUrl).document
        val docs = document.select("div.sect")
        val returnList = docs.mapNotNull {
            val epList = it.selectFirst("> div.sect-c.floats.clearfix") ?: return@mapNotNull null
            val title =
                it.selectFirst("> div.sect-t.fx-row.icon-r > div.st-left > a.st-capt")!!.text()
            val list = epList.select("> div.short")
            val isMovieType = title.contains("Films")  // if truen type is Movie
            val currentList = list.map { head ->
                val hrefItem = head.selectFirst("> div.short-in.nl > a")
                val href = fixUrl(hrefItem!!.attr("href"))
                val img = hrefItem.selectFirst("> img")
                val posterUrl = img!!.attr("src")
                val name = img.attr("> div.short-title").toString()
                return@map if (isMovieType) MovieSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.Movie,
                    posterUrl,
                    null
                ) else TvSeriesSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.TvSeries,
                    posterUrl,
                    null, null
                )
            }
            if (currentList.isNotEmpty()) {
                HomePageList(title, currentList)
            } else null
        }
        if (returnList.isEmpty()) return null
        return HomePageResponse(returnList)
    }
}



================================================
FILE: FrenchStreamProvider/src/main/kotlin/com/lagradost/FrenchStreamProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class FrenchStreamProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(FrenchStreamProvider())
    }
}


================================================
FILE: gradle/wrapper/gradle-wrapper.properties
================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists



================================================
FILE: HDMovie5/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: HDMovie5/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: HDMovie5/src/main/kotlin/com/lagradost/HDMovie5.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.httpsify
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class HDMovie5 : MainAPI() {
    override var mainUrl = "https://hdmovie2.click"
    override var name = "HDMovie"
    override var lang = "hi"

    override val hasQuickSearch = true
    override val hasMainPage = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        "$mainUrl/genre/tv-movie/page/" to "TV Movie",
        "$mainUrl/genre/tv-show/page/" to "TV- Show",
        "$mainUrl/genre/hindi-dubbed/page/" to "Hindi Dubbed",
        "$mainUrl/genre/netflix/page/" to "NETFLIX",
    )

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val home = app.get(request.data + page).document.select("article.item").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h3 > a")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")!!.attr("href"))
        val posterUrl = this.selectFirst("img")?.attr("src")
        return newMovieSearchResponse(title, href, TvType.Movie) {
            addPoster(posterUrl)
        }
    }

    private data class QuickSearchResponse(
        val title: String,
        val url: String,
        val img: String,
        val extra: Extra
    ) {
        data class Extra(
            val date: String
        )
    }

    override suspend fun quickSearch(query: String): List<SearchResponse> {
        return app.get("$mainUrl/wp-json/dooplay/search/?keyword=$query&nonce=ddbde04d9c")
            .parsed<Map<String, QuickSearchResponse>>().map {
                val res = it.value
                MovieSearchResponse(
                    res.title,
                    res.url,
                    this.name,
                    TvType.Movie,
                    res.img,
                    res.extra.date.toIntOrNull()
                )
            }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        return app.get("$mainUrl/?s=$query").document.select(".search-page>div.result-item").map {
            val image = it.select(".image")
            MovieSearchResponse(
                image.select("img").attr("alt"),
                image.select("a").attr("href"),
                this.name,
                TvType.Movie,
                image.select("img").attr("src"),
                it.select(".year").text().toIntOrNull()
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val info = doc.select(".sheader")
        val links = doc.select("#playeroptionsul>li")
        val data = links.joinToString(",") { it.attr("data-post") }
        return MovieLoadResponse(
            info.select(".data>h1").text(),
            url,
            this.name,
            TvType.Movie,
            data,
            info.select(".poster>img").attr("src"),
            info.select(".date").text().substringAfter(", ").toIntOrNull(),
            doc.select(".wp-content>p").let { it.getOrNull(it.size - 1)?.text() },
            (doc.select("#repimdb>strong").text().toFloatOrNull()?.times(1000))?.toInt(),
            info.select(".sgeneros>a").map { it.text() },
            info.select(".runtime").text().substringBefore(" Min.").toIntOrNull(),
            mutableListOf(),
            doc.select("#single_relacionados>article>a").map {
                val img = it.select("img")
                MovieSearchResponse(
                    img.attr("alt"),
                    it.attr("href"),
                    this.name,
                    TvType.Movie,
                    img.attr("src")
                )
            },
            doc.select("#cast>.persons>.person").mapNotNull {
                if (it.attr("itemprop") != "director") {
                    ActorData(
                        Actor(
                            it.select("meta").attr("content"),
                            it.select("img").attr("src")
                        )
                    )
                } else null
            },
        )
    }

    private data class PlayerAjaxResponse(
        @JsonProperty("embed_url")
        val embedURL: String? = null
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        return data.split(",").apmapIndexed { index, it ->
            val p = app.post(
                "$mainUrl/wp-admin/admin-ajax.php",
                data = mapOf(
                    "action" to "doo_player_ajax",
                    "post" to it,
                    "nume" to "${index + 1}",
                    "type" to "movie"
                )
            )
            val html = p.parsedSafe<PlayerAjaxResponse>()?.embedURL ?: return@apmapIndexed false
            val doc = Jsoup.parse(html)
            val link = doc.select("iframe").attr("src")
            loadExtractor(httpsify(link), "$mainUrl/", subtitleCallback, callback)
        }.contains(true)
    }
}



================================================
FILE: HDMovie5/src/main/kotlin/com/lagradost/HDMovie5Plugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class HDMovie5Plugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(HDMovie5())
    }
}


================================================
FILE: HDMProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: HDMProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: HDMProvider/src/main/kotlin/com/lagradost/HDMProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.Jsoup

class HDMProvider : MainAPI() {
    override var name = "HD Movies"
    override var mainUrl = "https://hdm.to"
    override val hasMainPage = true

    override val supportedTypes = setOf(
        TvType.Movie,
    )

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search/$query"
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val items = document.select("div.col-md-2 > article > a")
        if (items.isEmpty()) return emptyList()

        return items.map { i ->
            val href = i.attr("href")
            val data = i.selectFirst("> div.item")!!
            val img = data.selectFirst("> img")!!.attr("src")
            val name = data.selectFirst("> div.movie-details")!!.text()
            MovieSearchResponse(name, href, this.name, TvType.Movie, img, null)
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data == "") return false
        val slug = Regex(".*/(.*?)\\.mp4").find(data)?.groupValues?.get(1) ?: return false
        val response = app.get(data).text
        val key = Regex("playlist\\.m3u8(.*?)\"").find(response)?.groupValues?.get(1) ?: return false
        callback.invoke(
            ExtractorLink(
                this.name,
                this.name,
                "https://hls.1o.to/vod/$slug/playlist.m3u8$key",
                "",
                Qualities.P720.value,
                true
            )
        )
        return true
    }

    override suspend fun load(url: String): LoadResponse? {
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val title = document.selectFirst("h2.movieTitle")?.text() ?: throw ErrorLoadingException("No Data Found")
        val poster = document.selectFirst("div.post-thumbnail > img")!!.attr("src")
        val descript = document.selectFirst("div.synopsis > p")!!.text()
        val year = document.select("div.movieInfoAll > div.row > div.col-md-6").getOrNull(1)?.selectFirst("> p > a")?.text()
            ?.toIntOrNull()
        val data = "src/player/\\?v=(.*?)\"".toRegex().find(response)?.groupValues?.get(1) ?: return null

        return MovieLoadResponse(
            title, url, this.name, TvType.Movie,
            "$mainUrl/src/player/?v=$data", poster, year, descript, null
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val html = app.get(mainUrl, timeout = 25).text
        val document = Jsoup.parse(html)
        val all = ArrayList<HomePageList>()

        val mainbody = document.getElementsByTag("body")
            ?.select("div.homeContentOuter > section > div.container > div")
        // Fetch row title
        val inner = mainbody?.select("div.col-md-2.col-sm-2.mrgb")
        val title = mainbody?.select("div > div")?.firstOrNull()?.select("div.title.titleBar")?.text() ?: "Unnamed Row"
        // Fetch list of items and map
        if (inner != null) {
            val elements: List<SearchResponse> = inner.map {

                val aa = it.select("a").firstOrNull()
                val item = aa?.select("div.item")
                val href = aa?.attr("href")
                val link = when (href != null) {
                    true -> fixUrl(href)
                    false -> ""
                }
                val name = item?.select("div.movie-details")?.text() ?: "<No Title>"
                var image = item?.select("img")?.get(1)?.attr("src") ?: ""
                val year = null

                MovieSearchResponse(
                    name,
                    link,
                    this.name,
                    TvType.Movie,
                    image,
                    year,
                    null,
                )
            }

            all.add(
                HomePageList(
                    title, elements
                )
            )
        }
        return HomePageResponse(all)
    }
}


================================================
FILE: HDMProvider/src/main/kotlin/com/lagradost/HDMProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class HDMProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(HDMProvider())
    }
}


================================================
FILE: HDrezkaProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: HDrezkaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: HDrezkaProvider/src/main/kotlin/com/lagradost/HDrezkaProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.mvvm.suspendSafeApiCall
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.util.*

class HDrezkaProvider : MainAPI() {
    override var mainUrl = "https://hdrezka19139.org"
    override var name = "HDrezka"
    override val hasMainPage = true
    override var lang = "ru"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "$mainUrl/films/?filter=watching" to "фильмы",
        "$mainUrl/series/?filter=watching" to "сериалы",
        "$mainUrl/cartoons/?filter=watching" to "мультфильмы",
        "$mainUrl/animation/?filter=watching" to "аниме",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = request.data.split("?")
        val home = app.get("${url.first()}page/$page/?${url.last()}").document.select(
            "div.b-content__inline_items div.b-content__inline_item"
        ).map {
            it.toSearchResult()
        }

        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title =
            this.selectFirst("div.b-content__inline_item-link > a")?.text()?.trim().toString()
        val href = this.selectFirst("a")?.attr("href").toString()
        val posterUrl = this.select("img").attr("src")
        val type = if (this.select("span.info").isNotEmpty()) TvType.TvSeries else TvType.Movie
        return if (type == TvType.Movie) {
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
            }
        } else {
            val episode =
                this.select("span.info").text().substringAfter(",").replace(Regex("[^0-9]"), "")
                    .toIntOrNull()
            newAnimeSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                addDubStatus(
                    dubExist = true,
                    dubEpisodes = episode,
                    subExist = true,
                    subEpisodes = episode
                )
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/search/?do=search&subaction=search&q=$query"
        val document = app.get(link).document

        return document.select("div.b-content__inline_items div.b-content__inline_item").map {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val id = url.split("/").last().split("-").first()
        val title = (document.selectFirst("div.b-post__origtitle")?.text()?.trim()
            ?: document.selectFirst("div.b-post__title h1")?.text()?.trim()).toString()
        val poster = fixUrlNull(document.selectFirst("div.b-sidecover img")?.attr("src"))
        val tags =
            document.select("table.b-post__info > tbody > tr:nth-child(5) span[itemprop=genre]")
                .map { it.text() }
        val year = document.select("div.film-info > div:nth-child(2) a").text().toIntOrNull()
        val tvType = if (document.select("div#simple-episodes-tabs")
                .isNullOrEmpty()
        ) TvType.Movie else TvType.TvSeries
        val description = document.selectFirst("div.b-post__description_text")?.text()?.trim()
        val trailer = app.post(
            "$mainUrl/engine/ajax/gettrailervideo.php",
            data = mapOf("id" to id),
            referer = url
        ).parsedSafe<Trailer>()?.code.let {
            Jsoup.parse(it.toString()).select("iframe").attr("src")
        }
        val rating =
            document.selectFirst("table.b-post__info > tbody > tr:nth-child(1) span.bold")?.text()
                .toRatingInt()
        val actors = document.select("table.b-post__info > tbody > tr:last-child span.item").map {
            Actor(
                it.selectFirst("span[itemprop=name]")?.text().toString(),
                it.selectFirst("span[itemprop=actor]")?.attr("data-photo")
            )
        }

        val recommendations = document.select("div.b-sidelist div.b-content__inline_item").map {
            it.toSearchResult()
        }

        val data = HashMap<String, Any>()
        val server = ArrayList<Map<String, String>>()

        data["id"] = id
        data["favs"] = document.selectFirst("input#ctrl_favs")?.attr("value").toString()
        data["ref"] = url

        return if (tvType == TvType.TvSeries) {
            document.select("ul#translators-list li").map { res ->
                server.add(
                    mapOf(
                        "translator_name" to res.text(),
                        "translator_id" to res.attr("data-translator_id"),
                    )
                )
            }
            val episodes = document.select("div#simple-episodes-tabs ul li").map {
                val season = it.attr("data-season_id").toIntOrNull()
                val episode = it.attr("data-episode_id").toIntOrNull()
                val name = "Episode $episode"

                data["season"] = "$season"
                data["episode"] = "$episode"
                data["server"] = server
                data["action"] = "get_stream"

                Episode(
                    data.toJson(),
                    name,
                    season,
                    episode,
                )
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            document.select("ul#translators-list li").map { res ->
                server.add(
                    mapOf(
                        "translator_name" to res.text(),
                        "translator_id" to res.attr("data-translator_id"),
                        "camrip" to res.attr("data-camrip"),
                        "ads" to res.attr("data-ads"),
                        "director" to res.attr("data-director")
                    )
                )
            }

            data["server"] = server
            data["action"] = "get_movie"

            newMovieLoadResponse(title, url, TvType.Movie, data.toJson()) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    private fun decryptStreamUrl(data: String): String {

        fun getTrash(arr: List<String>, item: Int): List<String> {
            val trash = ArrayList<List<String>>()
            for (i in 1..item) {
                trash.add(arr)
            }
            return trash.reduce { acc, list ->
                val temp = ArrayList<String>()
                acc.forEach { ac ->
                    list.forEach { li ->
                        temp.add(ac.plus(li))
                    }
                }
                return@reduce temp
            }
        }

        val trashList = listOf("@", "#", "!", "^", "$")
        val trashSet = getTrash(trashList, 2) + getTrash(trashList, 3)
        var trashString = data.replace("#h", "").split("//_//").joinToString("")

        trashSet.forEach {
            val temp = base64Encode(it.toByteArray())
            trashString = trashString.replace(temp, "")
        }

        return base64Decode(trashString)

    }

    private fun cleanCallback(
        source: String,
        url: String,
        quality: String,
        isM3u8: Boolean,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        sourceCallback.invoke(
            ExtractorLink(
                source,
                source,
                url,
                "$mainUrl/",
                getQuality(quality),
                isM3u8,
                headers = mapOf(
                    "Origin" to mainUrl
                )
            )
        )
    }

    private fun getLanguage(str: String): String {
        return when (str) {
            "Русский" -> "Russian"
            "Українська" -> "Ukrainian"
            else -> str
        }
    }

    private fun getQuality(str: String): Int {
        return when (str) {
            "360p" -> Qualities.P240.value
            "480p" -> Qualities.P360.value
            "720p" -> Qualities.P480.value
            "1080p" -> Qualities.P720.value
            "1080p Ultra" -> Qualities.P1080.value
            else -> getQualityFromName(str)
        }
    }

    private fun invokeSources(
        source: String,
        url: String,
        subtitle: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        decryptStreamUrl(url).split(",").map { links ->
            val quality =
                Regex("\\[([0-9]*p.*?)]").find(links)?.groupValues?.getOrNull(1)
                    .toString().trim()
            links.replace("[$quality]", "").split("or").map { it.trim() }
                .map { link ->

                    if (link.endsWith(".m3u8")) {
                        cleanCallback(
                            "$source (Main)",
                            link,
                            quality,
                            true,
                            sourceCallback,
                        )
                    } else {
                        cleanCallback(
                            "$source (Backup)",
                            link,
                            quality,
                            false,
                            sourceCallback,
                        )
                    }
                }
        }

        subtitle.split(",").map { sub ->
            val language =
                Regex("\\[(.*)]").find(sub)?.groupValues?.getOrNull(1)
                    .toString()
            val link = sub.replace("[$language]", "").trim()
            subCallback.invoke(
                SubtitleFile(
                    getLanguage(language),
                    link
                )
            )
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        tryParseJson<Data>(data)?.let { res ->
            if (res.server?.isEmpty() == true) {
                val document = app.get(res.ref ?: return@let).document
                document.select("script").map { script ->
                    if (script.data().contains("sof.tv.initCDNMoviesEvents(")) {
                        val dataJson =
                            script.data().substringAfter("false, {").substringBefore("});")
                        tryParseJson<LocalSources>("{$dataJson}")?.let { source ->
                            invokeSources(
                                this.name,
                                source.streams,
                                source.subtitle.toString(),
                                subtitleCallback,
                                callback
                            )
                        }
                    }
                }
            } else {
                res.server?.apmap { server ->
                    suspendSafeApiCall {
                        app.post(
                            url = "$mainUrl/ajax/get_cdn_series/?t=${Date().time}",
                            data = mapOf(
                                "id" to res.id,
                                "translator_id" to server.translator_id,
                                "favs" to res.favs,
                                "is_camrip" to server.camrip,
                                "is_ads" to server.ads,
                                "is_director" to server.director,
                                "season" to res.season,
                                "episode" to res.episode,
                                "action" to res.action,
                            ).filterValues { it != null }.mapValues { it.value as String },
                            referer = res.ref
                        ).parsedSafe<Sources>()?.let { source ->
                            invokeSources(
                                server.translator_name.toString(),
                                source.url,
                                source.subtitle.toString(),
                                subtitleCallback,
                                callback
                            )
                        }
                    }
                }
            }
        }

        return true
    }

    data class LocalSources(
        @JsonProperty("streams") val streams: String,
        @JsonProperty("subtitle") val subtitle: Any?,
    )

    data class Sources(
        @JsonProperty("url") val url: String,
        @JsonProperty("subtitle") val subtitle: Any?,
    )

    data class Server(
        @JsonProperty("translator_name") val translator_name: String?,
        @JsonProperty("translator_id") val translator_id: String?,
        @JsonProperty("camrip") val camrip: String?,
        @JsonProperty("ads") val ads: String?,
        @JsonProperty("director") val director: String?,
    )

    data class Data(
        @JsonProperty("id") val id: String?,
        @JsonProperty("favs") val favs: String?,
        @JsonProperty("server") val server: List<Server>?,
        @JsonProperty("season") val season: String?,
        @JsonProperty("episode") val episode: String?,
        @JsonProperty("action") val action: String?,
        @JsonProperty("ref") val ref: String?,
    )

    data class Trailer(
        @JsonProperty("success") val success: Boolean?,
        @JsonProperty("code") val code: String?,
    )

}


================================================
FILE: HDrezkaProvider/src/main/kotlin/com/lagradost/HDrezkaProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class HDrezkaProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(HDrezkaProvider())
    }
}


================================================
FILE: HDTodayProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: HDTodayProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: HDTodayProvider/src/main/kotlin/com/lagradost/HDTodayProvider.kt
================================================
package com.lagradost

class HDTodayProvider : SflixProvider() {
    override var mainUrl = "https://hdtoday.cc"
    override var name = "HDToday"
}



================================================
FILE: HDTodayProvider/src/main/kotlin/com/lagradost/HDTodayProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class HDTodayProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(HDTodayProvider())
    }
}


================================================
FILE: IdlixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: IdlixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: IdlixProvider/src/main/kotlin/com/lagradost/IdlixProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import org.jsoup.nodes.Element
import java.net.URI

class IdlixProvider : MainAPI() {
    override var mainUrl = "https://94.103.82.88"
    override var name = "Idlix"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        "$mainUrl/trending/page/?get=movies" to "Trending Movies",
        "$mainUrl/trending/page/?get=tv" to "Trending TV Series",
        "$mainUrl/movie/page/" to "Movie Terbaru",
        "$mainUrl/tvseries/page/" to "TV Series Terbaru",
        "$mainUrl/season/page/" to "Season Terbaru",
        "$mainUrl/episode/page/" to "Episode Terbaru",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = request.data.split("?")
        val document = app.get("${url.first()}$page/?${url.lastOrNull()}").document
        val home = document.select("div.items.full article, div#archive-content article").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun getProperLink(uri: String): String {
        return when {
            uri.contains("/episode/") -> {
                var title = uri.substringAfter("$mainUrl/episode/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvseries/$title"
            }
            uri.contains("/season/") -> {
                var title = uri.substringAfter("$mainUrl/season/")
                title = Regex("(.+?)-season").find(title)?.groupValues?.get(1).toString()
                "$mainUrl/tvseries/$title"
            }
            else -> {
                uri
            }
        }
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.selectFirst("h3 > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
        val href = getProperLink(this.selectFirst("h3 > a")!!.attr("href"))
        val posterUrl = this.select("div.poster > img").attr("src").toString()
        val quality = getQualityFromString(this.select("span.quality").text())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            this.quality = quality
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/search/$query"
        val document = app.get(link).document

        return document.select("div.result-item").map {
            val title =
                it.selectFirst("div.title > a")!!.text().replace(Regex("\\(\\d{4}\\)"), "").trim()
            val href = getProperLink(it.selectFirst("div.title > a")!!.attr("href"))
            val posterUrl = it.selectFirst("img")!!.attr("src").toString()
            newMovieSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title =
            document.selectFirst("div.data > h1")?.text()?.replace(Regex("\\(\\d{4}\\)"), "")
                ?.trim().toString()
        val poster = document.select("div.poster > img").attr("src").toString()
        val tags = document.select("div.sgeneros > a").map { it.text() }

        val year = Regex(",\\s?(\\d+)").find(
            document.select("span.date").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (document.select("ul#section > li:nth-child(1)").text().contains("Episodes")
        ) TvType.TvSeries else TvType.Movie
        val description = document.select("div.wp-content > p").text().trim()
        val trailer = document.selectFirst("div.embed iframe")?.attr("src")
        val rating =
            document.selectFirst("span.dt_rating_vgs")?.text()?.toRatingInt()
        val actors = document.select("div.persons > div[itemprop=actor]").map {
            Actor(it.select("meta[itemprop=name]").attr("content"), it.select("img").attr("src"))
        }

        val recommendations = document.select("div.owl-item").map {
            val recName =
                it.selectFirst("a")!!.attr("href").toString().removeSuffix("/").split("/").last()
            val recHref = it.selectFirst("a")!!.attr("href")
            val recPosterUrl = it.selectFirst("img")?.attr("src").toString()
            newTvSeriesSearchResponse(recName, recHref, TvType.TvSeries) {
                this.posterUrl = recPosterUrl
            }
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = document.select("ul.episodios > li").map {
                val href = it.select("a").attr("href")
                val name = fixTitle(it.select("div.episodiotitle > a").text().trim())
                val image = it.select("div.imagen > img").attr("src")
                val episode = it.select("div.numerando").text().replace(" ", "").split("-").last()
                    .toIntOrNull()
                val season = it.select("div.numerando").text().replace(" ", "").split("-").first()
                    .toIntOrNull()
                Episode(
                    href,
                    name,
                    season,
                    episode,
                    image
                )
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    private fun getLanguage(str: String): String {
        return when {
            str.lowercase().contains("indonesia") || str.lowercase()
                .contains("bahasa") -> "Indonesian"
            else -> str
        }
    }

    data class ResponseHash(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("type") val type: String?,
    )

    data class ResponseSource(
        @JsonProperty("hls") val hls: Boolean,
        @JsonProperty("videoSource") val videoSource: String,
        @JsonProperty("securedLink") val securedLink: String?,
    )

    data class Tracks(
        @JsonProperty("kind") val kind: String?,
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String?,
    )

    private suspend fun invokeLokalSource(
        url: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val document = app.get(url, referer = "$mainUrl/").document
        val hash = url.split("/").last().substringAfter("data=")

        val m3uLink = app.post(
            url = "https://jeniusplay.com/player/index.php?data=$hash&do=getVideo",
            data = mapOf("hash" to hash, "r" to "$mainUrl/"),
            referer = url,
            headers = mapOf("X-Requested-With" to "XMLHttpRequest")
        ).parsed<ResponseSource>().videoSource

        M3u8Helper.generateM3u8(
            this.name,
            m3uLink,
            url,
        ).forEach(sourceCallback)


        document.select("script").map { script ->
            if (script.data().contains("eval(function(p,a,c,k,e,d)")) {
                val subData =
                    getAndUnpack(script.data()).substringAfter("\"tracks\":[").substringBefore("],")
                tryParseJson<List<Tracks>>("[$subData]")?.map { subtitle ->
                    subCallback.invoke(
                        SubtitleFile(
                            getLanguage(subtitle.label!!),
                            subtitle.file
                        )
                    )
                }
            }
        }
    }

    data class ResponseLaviolaSource(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String?,
    )

    private suspend fun invokeLaviolaSource(
        url: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val document = app.get(url, referer = "$mainUrl/").document
        val baseName = "Laviola"
        val baseUrl = "https://laviola.live/"
        document.select("script").map { script ->
            if (script.data().contains("var config = {")) {
                val data = script.data().substringAfter("sources: [").substringBefore("],")
                tryParseJson<List<ResponseLaviolaSource>>("[$data]")?.map { m3u ->
                    val m3uData = app.get(m3u.file, referer = baseUrl).text
                    val quality =
                        Regex("\\d{3,4}\\.m3u8").findAll(m3uData).map { it.value }.toList()
                    quality.forEach {
                        sourceCallback.invoke(
                            ExtractorLink(
                                source = baseName,
                                name = baseName,
                                url = m3u.file.replace("video.m3u8", it),
                                referer = baseUrl,
                                quality = getQualityFromName("${it.replace(".m3u8", "")}p"),
                                isM3u8 = true
                            )
                        )
                    }
                }

                val subData = script.data().substringAfter("tracks: [").substringBefore("],")
                tryParseJson<List<Tracks>>("[$subData]")?.map { subtitle ->
                    subCallback.invoke(
                        SubtitleFile(
                            getLanguage(subtitle.label!!),
                            (if (subtitle.kind!!.contains("captions")) subtitle.file else null)!!
                        )
                    )
                }
            }
        }
    }

    private data class Captions(
        @JsonProperty("id") val id: String,
        @JsonProperty("hash") val hash: String,
        @JsonProperty("language") val language: String,
    )

    private data class Data(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
    )

    private data class Player(
        @JsonProperty("poster_file") val poster_file: String,
    )

    private data class ResponseCdn(
        @JsonProperty("success") val success: Boolean,
        @JsonProperty("player") val player: Player,
        @JsonProperty("data") val data: List<Data>?,
        @JsonProperty("captions") val captions: List<Captions>?
    )

    private suspend fun invokeCdnSource(
        url: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val domainUrl = "https://cdnplayer.online"
        val id = url.trimEnd('/').split("/").last()
        val sources = app.post(
            url = "$domainUrl/api/source/$id",
            data = mapOf("r" to mainUrl, "d" to URI(url).host)
        ).parsed<ResponseCdn>()

        sources.data?.map {
            sourceCallback.invoke(
                ExtractorLink(
                    name,
                    "Cdnplayer",
                    fixUrl(it.file),
                    referer = url,
                    quality = getQualityFromName(it.label)
                )
            )
        }
        val userData = sources.player.poster_file.split("/")[2]
        sources.captions?.map { subtitle ->
            subCallback.invoke(
                SubtitleFile(
                    getLanguage(subtitle.language),
                    "$domainUrl/asset/userdata/$userData/caption/${subtitle.hash}/${subtitle.id}.srt"
                )
            )
        }

    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val document = app.get(data).document
        val id = document.select("meta#dooplay-ajax-counter").attr("data-postid")
        val type = if (data.contains("/movie/")) "movie" else "tv"

        document.select("ul#playeroptionsul > li").map {
            it.attr("data-nume")
        }.apmap { nume ->
            safeApiCall {
                var source = app.post(
                    url = "$mainUrl/wp-admin/admin-ajax.php",
                    data = mapOf(
                        "action" to "doo_player_ajax",
                        "post" to id,
                        "nume" to nume,
                        "type" to type
                    )
                ).parsed<ResponseHash>().embed_url

                when {
                    source.startsWith("https://jeniusplay.com") -> invokeLokalSource(
                        source,
                        subtitleCallback,
                        callback
                    )
                    source.startsWith("https://laviola.live") -> invokeLaviolaSource(
                        source,
                        subtitleCallback,
                        callback
                    )
                    source.startsWith("https://cdnplayer.online") -> invokeCdnSource(
                        source,
                        subtitleCallback,
                        callback
                    )
                    else -> {
                        if (source.startsWith("https://uservideo.xyz")) {
                            source = app.get(source).document.select("iframe").attr("src")
                        }
                        loadExtractor(source, data, subtitleCallback, callback)
                    }
                }
            }
        }

        return true
    }


}


================================================
FILE: IdlixProvider/src/main/kotlin/com/lagradost/IdlixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class IdlixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(IdlixProvider())
    }
}


================================================
FILE: IHaveNoTvProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: IHaveNoTvProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: IHaveNoTvProvider/src/main/kotlin/com/lagradost/IHaveNoTvProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import java.net.URLEncoder

class IHaveNoTvProvider : MainAPI() {
    override var mainUrl = "https://ihavenotv.com"
    override var name = "I Have No TV"
    override val hasQuickSearch = false
    override val hasMainPage = true

    override val supportedTypes = setOf(TvType.Documentary)

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        // Uhh, I am too lazy to scrape the "latest documentaries" and "recommended documentaries",
        // so I am just scraping 3 random categories
        val allCategories = listOf(
            "astronomy",
            "brain",
            "creativity",
            "design",
            "economics",
            "environment",
            "health",
            "history",
            "lifehack",
            "math",
            "music",
            "nature",
            "people",
            "physics",
            "science",
            "technology",
            "travel"
        )

        val categories = allCategories.asSequence().shuffled().take(3)
            .toList()  // randomly get 3 categories, because there are too many

        val items = ArrayList<HomePageList>()

        categories.forEach { cat ->
            val link = "$mainUrl/category/$cat"
            val html = app.get(link).text
            val soup = Jsoup.parse(html)

            val searchResults: MutableMap<String, SearchResponse> = mutableMapOf()
            soup.select(".episodesDiv .episode").forEach { res ->
                val poster = res.selectFirst("img")?.attr("src")
                val aTag = if (res.html().contains("/series/")) {
                    res.selectFirst(".episodeMeta > a")
                } else {
                    res.selectFirst("a[href][title]")
                }
                val year = Regex("""•?\s+(\d{4})\s+•""").find(
                    res.selectFirst(".episodeMeta")!!.text()
                )?.destructured?.component1()?.toIntOrNull()

                val title = aTag!!.attr("title")
                val href = fixUrl(aTag.attr("href"))
                searchResults[href] = TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Documentary,//if (href.contains("/series/")) TvType.TvSeries else TvType.Movie,
                    poster,
                    year,
                    null
                )
            }
            items.add(
                HomePageList(
                    capitalizeString(cat),
                    ArrayList(searchResults.values).subList(0, 5)
                )
            ) // just 5 results per category, app crashes when they are too many
        }

        return HomePageResponse(items)
    }

    override suspend fun search(query: String): ArrayList<SearchResponse> {
        val url = """$mainUrl/search/${URLEncoder.encode(query, "UTF-8")}"""
        val response = app.get(url).text
        val soup = Jsoup.parse(response)

        val searchResults: MutableMap<String, SearchResponse> = mutableMapOf()

        soup.select(".episodesDiv .episode").forEach { res ->
            val poster = res.selectFirst("img")?.attr("src")
            val aTag = if (res.html().contains("/series/")) {
                res.selectFirst(".episodeMeta > a")
            } else {
                res.selectFirst("a[href][title]")
            }
            val year =
                Regex("""•?\s+(\d{4})\s+•""").find(
                    res.selectFirst(".episodeMeta")!!.text()
                )?.destructured?.component1()
                    ?.toIntOrNull()

            val title = aTag!!.attr("title")
            val href = fixUrl(aTag.attr("href"))
            searchResults[href] = TvSeriesSearchResponse(
                title,
                href,
                this.name,
                TvType.Documentary, //if (href.contains("/series/")) TvType.TvSeries else TvType.Movie,
                poster,
                year,
                null
            )
        }

        return ArrayList(searchResults.values)
    }

    override suspend fun load(url: String): LoadResponse {
        val isSeries = url.contains("/series/")
        val html = app.get(url).text
        val soup = Jsoup.parse(html)

        val container = soup.selectFirst(".container-fluid h1")?.parent()
        val title = if (isSeries) {
            container?.selectFirst("h1")?.text()?.split("•")?.firstOrNull().toString()
        } else soup.selectFirst(".videoDetails")!!.selectFirst("strong")?.text().toString()
        val description = if (isSeries) {
            container?.selectFirst("p")?.text()
        } else {
            soup.selectFirst(".videoDetails > p")?.text()
        }

        var year: Int? = null
        val categories: MutableSet<String> = mutableSetOf()

        val episodes = if (isSeries) {
            container?.select(".episode")?.map { ep ->
                val thumb = ep.selectFirst("img")!!.attr("src")

                val epLink = fixUrl(ep.selectFirst("a[title]")!!.attr("href"))
                val (season, epNum) = if (ep.selectFirst(".episodeMeta > strong") != null &&
                    ep.selectFirst(".episodeMeta > strong")!!.html().contains("S")
                ) {
                    val split = ep.selectFirst(".episodeMeta > strong")?.text()?.split("E")
                    Pair(
                        split?.firstOrNull()?.replace("S", "")?.toIntOrNull(),
                        split?.get(1)?.toIntOrNull()
                    )
                } else Pair<Int?, Int?>(null, null)

                year = Regex("""•?\s+(\d{4})\s+•""").find(
                    ep.selectFirst(".episodeMeta")!!.text()
                )?.destructured?.component1()?.toIntOrNull()

                categories.addAll(
                    ep.select(".episodeMeta > a[href*=\"/category/\"]").map { it.text().trim() })

                newEpisode(epLink) {
                    this.name = ep.selectFirst("a[title]")!!.attr("title")
                    this.season = season
                    this.episode = epNum
                    this.posterUrl = thumb
                    this.description = ep.selectFirst(".episodeSynopsis")?.text()
                }
            }
        } else {
            listOf(MovieLoadResponse(
                title,
                url,
                this.name,
                TvType.Movie,
                url,
                soup.selectFirst("[rel=\"image_src\"]")!!.attr("href"),
                Regex("""•?\s+(\d{4})\s+•""").find(
                    soup.selectFirst(".videoDetails")!!.text()
                )?.destructured?.component1()?.toIntOrNull(),
                description,
                null,
                soup.selectFirst(".videoDetails")!!.select("a[href*=\"/category/\"]")
                    .map { it.text().trim() }
            ))
        }

        val poster = episodes?.firstOrNull().let {
            if (isSeries && it != null) (it as Episode).posterUrl
            else null
        }

        return if (isSeries) TvSeriesLoadResponse(
            title,
            url,
            this.name,
            TvType.TvSeries,
            episodes!!.map { it as Episode },
            poster,
            year,
            description,
            null,
            null,
            categories.toList()
        ) else (episodes?.first() as MovieLoadResponse)
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val html = app.get(data).text
        val soup = Jsoup.parse(html)

        val iframe = soup.selectFirst("#videoWrap iframe")
        if (iframe != null) {
            loadExtractor(iframe.attr("src"), null, subtitleCallback, callback)
        }
        return true
    }
}



================================================
FILE: IHaveNoTvProvider/src/main/kotlin/com/lagradost/IHaveNoTvProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class IHaveNoTvProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(IHaveNoTvProvider())
    }
}


================================================
FILE: IlGenioDelloStreamingProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: IlGenioDelloStreamingProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: IlGenioDelloStreamingProvider/src/main/kotlin/com/lagradost/IlGenioDelloStreamingProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.LoadResponse.Companion.addRating
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.ShortLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup


class IlGenioDelloStreamingProvider : MainAPI() {
    override var lang = "it"
    override var mainUrl = "https://ilgeniodellostreaming.quest"
    override var name = "IlGenioDelloStreaming"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override val mainPage = mainPageOf(
        Pair("$mainUrl/category/film/page/", "Film Popolari"),
        Pair("$mainUrl/category/serie-tv/page/", "Serie Tv Popolari"),
        Pair("$mainUrl/the-most-voted/page/", "I più votati"),
        Pair("$mainUrl/prime-visioni/page/", "Ultime uscite"),
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val url = request.data + page
        val soup = app.get(url).document
        val home = soup.select("div.items > article.item").map {
            val title = it.selectFirst("div.data > h3 > a")!!.text().substringBeforeLast("(").substringBeforeLast("[")
            val link = it.selectFirst("div.poster > a")!!.attr("href")
            val quality = getQualityFromString(it.selectFirst("span.quality")?.text())
            TvSeriesSearchResponse(
                title,
                link,
                this.name,
                TvType.Movie,
                it.selectFirst("img")!!.attr("data-src-img"),
                null,
                null,
                quality = quality
            )
        }
        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val queryformatted = query.replace(" ", "+")
        val url = "$mainUrl?s=$queryformatted"
        val doc = app.get(url,referer= mainUrl ).document
        return doc.select("div.result-item").map {
            val href = it.selectFirst("div.image > div > a")!!.attr("href")
            val poster = it.selectFirst("div.image > div > a > img")!!.attr("data-src-img")
            val name = it.selectFirst("div.details > div.title > a")!!.text().substringBeforeLast("(").substringBeforeLast("[")
            MovieSearchResponse(
                name,
                href,
                this.name,
                TvType.Movie,
                poster
            )

        }
    }

    override suspend fun load(url: String): LoadResponse {
        val page = app.get(url)
        val document = page.document
        val type = if (document.selectFirst("div.sgeneros")?.text() == "Serie TV"){TvType.TvSeries} else{TvType.Movie}
        val title = document.selectFirst("div.data > h1")!!.text().substringBefore("(").substringBefore("[")
        val description = document.selectFirst("div#info")?.selectFirst("p")?.html()
        val rating = document.select("span.valor").last()?.text()?.split(" ")?.get(0)
        var year = document.selectFirst(" div.data > div.extra > span.date")!!.text().substringAfter(",")
            .filter { it.isDigit() }
        if (year.length > 4) {
            year = year.dropLast(4)
        }

        val poster = document.selectFirst("div.poster > img")!!.attr("data-src-img")

        val recomm = document.select("article.w_item_b").map {
            val href = it.selectFirst("a")!!.attr("href")
            val posterUrl = it.selectFirst("img")!!.attr("data-src-img")
            val name = it.selectFirst("div.data > h3")!!.text().substringBeforeLast("(").substringBeforeLast("[")
            MovieSearchResponse(
                name,
                href,
                this.name,
                TvType.Movie,
                posterUrl
            )

        }


        if (type == TvType.TvSeries) {

            val episodeList = ArrayList<Episode>()
            val seasons = document.selectFirst("div#info")?.select("p")?.map {it.children() }
                ?.filter { it.size > 1 && it.first()!!.hasAttr("href") }
                ?.map{(it.toString().split("<br>"))
                    .map{Jsoup.parse(it).select("a")
                        ?.map { it?.attr("href") }}}
            seasons?.mapIndexed { season, element ->
                element.mapIndexed { index, list ->
                    val urls = list?.toJson()?:url
                    episodeList.add(
                        Episode(
                            data = urls,
                            episode = index + 1,
                            season = season + 1
                        )
                    )
                }
            }
            val seasonnames = document.selectFirst("div#info")?.select("p")?.map {it.children() }
                ?.filter { it.size<3 && it.isNotEmpty()}?.map{it.text()}

            return newTvSeriesLoadResponse(
                title,
                url,
                type,
                episodeList
            ){
                addRating(rating)
                this.plot = description
                this.year = year.toIntOrNull()
                this.posterUrl = poster
                this.recommendations = recomm
                this.seasonNames = seasonnames!!.mapIndexed { index, s -> SeasonData(index, s) }

            }


        } else {
            val actors: List<ActorData> =
                document.select("div.cast_wraper > ul > li").map { actorData ->
                    val actorName = actorData.children()[1].text()
                    val actorImage : String? = actorData.selectFirst("img")?.attr("data-src")
                    val roleActor = actorData.children()[2].text()
                    ActorData(actor = Actor(actorName, image = actorImage), roleString = roleActor )
                }
            return newMovieLoadResponse(
                title,
                url,
                type,
                (document.select("div.embed-player") + document.select("a.link_a")).map { (it.attr("href") + it.attr("data-id")).trim() }.distinct().toJson(),
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year.toIntOrNull()
                this.plot = description
                addRating(rating)
                this.recommendations = recomm
                this.duration = null
                this.actors = actors
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links = tryParseJson<List<String>>(data)
        links?.map { link ->
            val url = ShortLink.unshorten(link).replace("/v/", "/e/").replace("/f/", "/e/")
            loadExtractor(url, data, subtitleCallback, callback)
        }
        return true
    }
}


================================================
FILE: IlGenioDelloStreamingProvider/src/main/kotlin/com/lagradost/IlGenioDelloStreamingProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class IlGenioDelloStreamingProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(IlGenioDelloStreamingProvider())
    }
}


================================================
FILE: KdramaHoodProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":WatchAsianProvider")))
    implementation(project(mapOf("path" to ":WatchAsianProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: KdramaHoodProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: KdramaHoodProvider/src/main/kotlin/com/lagradost/KdramaHoodProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup

class KdramaHoodProvider : MainAPI() {
    override var mainUrl = "https://kdramahood.com"
    override var name = "KDramaHood"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = false
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.AsianDrama)

    private data class ResponseDatas(
        @JsonProperty("label") val label: String,
        @JsonProperty("file") val file: String
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val doc = app.get("$mainUrl/home2").document
        val home = ArrayList<HomePageList>()

        // Hardcoded homepage cause of site implementation
        // Recently added
        val recentlyInner = doc.selectFirst("div.peliculas")
        val recentlyAddedTitle = recentlyInner!!.selectFirst("h1")?.text() ?: "Recently Added"
        val recentlyAdded = recentlyInner.select("div.item_2.items > div.fit.item").mapNotNull {
            val innerA = it.select("div.image > a") ?: return@mapNotNull null
            val link = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null
            val image = fixUrlNull(innerA.select("img").attr("src"))

            val innerData = it.selectFirst("div.data")
            val title = innerData!!.selectFirst("h1")?.text() ?: return@mapNotNull null
            val year = try {
                val yearText = innerData.selectFirst("span.titulo_o")
                    ?.text()?.takeLast(11)?.trim()?.take(4) ?: ""
                //Log.i(this.name, "Result => (yearText) $yearText")
                val rex = Regex("\\((\\d+)")
                //Log.i(this.name, "Result => (rex value) ${rex.find(yearText)?.value}")
                rex.find(yearText)?.value?.toIntOrNull()
            } catch (e: Exception) {
                null
            }

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                type = TvType.TvSeries,
                posterUrl = image,
                year = year
            )
        }.distinctBy { it.url } ?: listOf()
        home.add(HomePageList(recentlyAddedTitle, recentlyAdded))
        return HomePageResponse(home.filter { it.list.isNotEmpty() })
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val html = app.get(url).document
        val document = html.getElementsByTag("body")
            .select("div.item_1.items > div.item") ?: return listOf()

        return document.mapNotNull {
            if (it == null) {
                return@mapNotNull null
            }
            val innerA = it.selectFirst("div.boxinfo > a") ?: return@mapNotNull null
            val link = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null
            val title = innerA.select("span.tt")?.text() ?: return@mapNotNull null

            val year = it.selectFirst("span.year")?.text()?.toIntOrNull()
            val image = fixUrlNull(it.selectFirst("div.image > img")?.attr("src"))

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                type = TvType.Movie,
                posterUrl = image,
                year = year
            )
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val inner = doc.selectFirst("div.central")

        // Video details
        val title = inner?.selectFirst("h1")?.text() ?: ""
        val poster = fixUrlNull(doc.selectFirst("meta[property=og:image]")?.attr("content")) ?: ""
        //Log.i(this.name, "Result => (poster) ${poster}")
        val info = inner!!.selectFirst("div#info")
        val descript = inner.selectFirst("div.contenidotv > div > p")?.text()
        val year = try {
            val startLink = "https://kdramahood.com/drama-release-year/"
            var res: Int? = null
            info?.select("div.metadatac")?.forEach {
                if (res != null) {
                    return@forEach
                }
                if (it == null) {
                    return@forEach
                }
                val yearLink = it.select("a").attr("href") ?: return@forEach
                if (yearLink.startsWith(startLink)) {
                    res = yearLink.substring(startLink.length).replace("/", "").toIntOrNull()
                }
            }
            res
        } catch (e: Exception) {
            null
        }

        val recs = doc.select("div.sidebartv > div.tvitemrel").mapNotNull {
            val a = it?.select("a") ?: return@mapNotNull null
            val aUrl = fixUrlNull(a.attr("href")) ?: return@mapNotNull null
            val aImg = a.select("img")
            val aCover = fixUrlNull(aImg.attr("src")) ?: fixUrlNull(aImg.attr("data-src"))
            val aNameYear = a.select("div.datatvrel") ?: return@mapNotNull null
            val aName = aNameYear.select("h4").text() ?: aImg.attr("alt") ?: return@mapNotNull null
            val aYear = aName.trim().takeLast(5).removeSuffix(")").toIntOrNull()
            MovieSearchResponse(
                url = aUrl,
                name = aName,
                type = TvType.Movie,
                posterUrl = aCover,
                year = aYear,
                apiName = this.name
            )
        }

        // Episodes Links
        val episodeList = inner.select("ul.episodios > li")?.mapNotNull { ep ->
            //Log.i(this.name, "Result => (ep) ${ep}")
            val listOfLinks = mutableListOf<String>()
            val count = ep.select("div.numerando")?.text()?.toIntOrNull() ?: 0
            val innerA = ep.select("div.episodiotitle > a") ?: return@mapNotNull null
            //Log.i(this.name, "Result => (innerA) ${innerA}")
            val epLink = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null
            //Log.i(this.name, "Result => (epLink) ${epLink}")
            if (epLink.isNotBlank()) {
                // Fetch video links
                val epVidLinkEl = app.get(epLink, referer = mainUrl).document
                val epLinksContent = epVidLinkEl.selectFirst("div.player_nav > script")?.html()
                    ?.replace("ifr_target.src =", "<div>")
                    ?.replace("';", "</div>")
                //Log.i(this.name, "Result => (epLinksContent) $epLinksContent")
                if (!epLinksContent.isNullOrEmpty()) {
                    //Log.i(this.name, "Result => (epLinksContent) ${Jsoup.parse(epLinksContent)?.select("div")}")
                    Jsoup.parse(epLinksContent)?.select("div")?.forEach { em ->
                        val href = em?.html()?.trim()?.removePrefix("'") ?: return@forEach
                        //Log.i(this.name, "Result => (ep#$count link) $href")
                        if (href.isNotBlank()) {
                            listOfLinks.add(fixUrl(href))
                        }
                    }
                }
                //Fetch default source and subtitles
                epVidLinkEl.select("div.embed2")?.forEach { defsrc ->
                    if (defsrc == null) {
                        return@forEach
                    }
                    val scriptstring = defsrc.toString()
                    if (scriptstring.contains("sources: [{")) {
                        "(?<=playerInstance2.setup\\()([\\s\\S]*?)(?=\\);)".toRegex()
                            .find(scriptstring)?.value?.let { itemjs ->
                            listOfLinks.add("$mainUrl$itemjs")
                        }
                    }
                }
            }
            Episode(
                name = null,
                season = null,
                episode = count,
                data = listOfLinks.distinct().toJson(),
                posterUrl = poster,
                date = null
            )
        }

        //If there's only 1 episode, consider it a movie.
        if (episodeList?.size == 1) {
            return MovieLoadResponse(
                name = title,
                url = url,
                apiName = this.name,
                type = TvType.Movie,
                dataUrl = episodeList[0].data,
                posterUrl = poster,
                year = year,
                plot = descript,
                recommendations = recs
            )
        }
        return TvSeriesLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.AsianDrama,
            episodes = episodeList?.reversed() ?: emptyList(),
            posterUrl = poster,
            year = year,
            plot = descript,
            recommendations = recs
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        var count = 0
        parseJson<List<String>>(data).apmap { item ->
            if (item.isNotBlank()) {
                count++
                if (item.startsWith(mainUrl)) {
                    val text = item.substring(mainUrl.length)
                    //Log.i(this.name, "Result => (text) $text")
                    //Find video files
                    try {
                        "(?<=sources: )([\\s\\S]*?)(?<=])".toRegex().find(text)?.value?.let { vid ->
                            parseJson<List<ResponseDatas>>(vid).forEach { src ->
                                //Log.i(this.name, "Result => (src) ${src.toJson()}")
                                callback(
                                    ExtractorLink(
                                        name = name,
                                        url = src.file,
                                        quality = getQualityFromName(src.label),
                                        referer = mainUrl,
                                        source = name
                                    )
                                )
                            }
                        }
                    } catch (e: Exception) {
                        logError(e)
                    }
                    //Find subtitles
                    try {
                        "(?<=tracks: )([\\s\\S]*?)(?<=])".toRegex().find(text)?.value?.let { sub ->
                            val subtext = sub.replace("file:", "\"file\":")
                                .replace("label:", "\"label\":")
                                .replace("kind:", "\"kind\":")
                            parseJson<List<ResponseDatas>>(subtext).forEach { src ->
                                //Log.i(this.name, "Result => (sub) ${src.toJson()}")
                                subtitleCallback(
                                    SubtitleFile(
                                        lang = src.label,
                                        url = src.file
                                    )
                                )
                            }
                        }
                    } catch (e: Exception) {
                        logError(e)
                    }

                } else {
                    val url = fixUrl(item.trim())
                    //Log.i(this.name, "Result => (url) $url")
                    when {
                        url.startsWith("https://asianembed.io") -> {
                            AsianEmbedHelper.getUrls(url, subtitleCallback, callback)
                        }
                        url.startsWith("https://embedsito.com") -> {
                            val extractor = XStreamCdn()
                            extractor.domainUrl = "embedsito.com"
                            extractor.getUrl(url).forEach { link ->
                                callback.invoke(link)
                            }
                        }
                        else -> {
                            loadExtractor(url, mainUrl, subtitleCallback, callback)
                        }
                    }
                }
            }
        }
        return count > 0
    }
}


================================================
FILE: KdramaHoodProvider/src/main/kotlin/com/lagradost/KdramaHoodProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class KdramaHoodProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(KdramaHoodProvider())
    }
}


================================================
FILE: KisskhProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: KisskhProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: KisskhProvider/src/main/kotlin/com/lagradost/KisskhProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.loadExtractor
import java.util.ArrayList

class KisskhProvider : MainAPI() {
    override var mainUrl = "https://kisskh.me"
    override var name = "Kisskh"
    override val hasMainPage = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.AsianDrama,
        TvType.Anime
    )

    override val mainPage = mainPageOf(
        "&type=2&sub=0&country=2&status=0&order=1" to "Movie Pupular",
        "&type=2&sub=0&country=2&status=0&order=2" to "Movie Last Update",
        "&type=1&sub=0&country=2&status=0&order=1" to "TVSeries Popular",
        "&type=1&sub=0&country=2&status=0&order=2" to "TVSeries Last Update",
        "&type=3&sub=0&country=0&status=0&order=1" to "Anime Popular",
        "&type=3&sub=0&country=0&status=0&order=2" to "Anime Last Update",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val home = app.get("$mainUrl/api/DramaList/List?page=$page${request.data}")
            .parsedSafe<Responses>()?.data
            ?.mapNotNull { media ->
                media.toSearchResponse()
            } ?: throw ErrorLoadingException("Invalid Json reponse")
        return newHomePageResponse(request.name, home)
    }

    private fun Media.toSearchResponse(): SearchResponse? {

        return newAnimeSearchResponse(
            title ?: return null,
            "$title/$id",
            TvType.TvSeries,
        ) {
            this.posterUrl = thumbnail
            addSub(episodesCount)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val searchResponse =
            app.get("$mainUrl/api/DramaList/Search?q=$query&type=0", referer = "$mainUrl/").text
        return tryParseJson<ArrayList<Media>>(searchResponse)?.mapNotNull { media ->
            media.toSearchResponse()
        } ?: throw ErrorLoadingException("Invalid Json reponse")
    }

    private fun getTitle(str: String): String {
        return str.replace(Regex("[^a-zA-Z0-9]"), "-")
    }

    override suspend fun load(url: String): LoadResponse? {
        val id = url.split("/")
        val res = app.get(
            "$mainUrl/api/DramaList/Drama/${id.last()}?isq=false",
            referer = "$mainUrl/Drama/${
                getTitle(id.first())
            }?id=${id.last()}"
        ).parsedSafe<MediaDetail>()
            ?: throw ErrorLoadingException("Invalid Json reponse")

        val episodes = res.episodes?.map { eps ->
            Episode(
                data = Data(res.title, eps.number, res.id, eps.id).toJson(),
                episode = eps.number
            )
        } ?: throw ErrorLoadingException("No Episode")

        return newTvSeriesLoadResponse(
            res.title ?: return null,
            url,
            if (res.type == "Movie" || episodes.size == 1) TvType.Movie else TvType.TvSeries,
            episodes
        ) {
            this.posterUrl = res.thumbnail
            this.year = res.releaseDate?.split("-")?.first()?.toIntOrNull()
            this.plot = res.description
            this.tags = listOf("${res.country}", "${res.status}", "${res.type}")
            this.showStatus = when (res.status) {
                "Completed" -> ShowStatus.Completed
                "Ongoing" -> ShowStatus.Ongoing
                else -> null
            }
        }

    }

    private fun getLanguage(str: String): String {
        return when (str) {
            "Indonesia" -> "Indonesian"
            else -> str
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val loadData = parseJson<Data>(data)

        app.get(
            "$mainUrl/api/DramaList/Episode/${loadData.epsId}.png?err=false&ts=&time=",
            referer = "$mainUrl/Drama/${getTitle("${loadData.title}")}/Episode-${loadData.eps}?id=${loadData.id}&ep=${loadData.epsId}&page=0&pageSize=100"
        ).parsedSafe<Sources>()?.let { source ->
            listOf(source.video, source.thirdParty).apmap { link ->
                safeApiCall {
                    if (link?.contains(".m3u8") == true) {
                        M3u8Helper.generateM3u8(
                            this.name,
                            link,
                            referer = "$mainUrl/",
                            headers = mapOf("Origin" to mainUrl)
                        ).forEach(callback)
                    } else {
                        loadExtractor(
                            link?.substringBefore("=http") ?: return@safeApiCall,
                            "$mainUrl/",
                            subtitleCallback,
                            callback
                        )
                    }
                }
            }
        }

        // parsedSafe doesn't work in <List<Object>>
        app.get("$mainUrl/api/Sub/${loadData.epsId}").text.let { res ->
            tryParseJson<List<Subtitle>>(res)?.map { sub ->
                subtitleCallback.invoke(
                    SubtitleFile(
                        getLanguage(sub.label ?: return@map),
                        sub.src ?: return@map
                    )
                )
            }
        }

        return true

    }

    data class Data(
        val title: String?,
        val eps: Int?,
        val id: Int?,
        val epsId: Int?,
    )

    data class Sources(
        @JsonProperty("Video") val video: String?,
        @JsonProperty("ThirdParty") val thirdParty: String?,
    )

    data class Subtitle(
        @JsonProperty("src") val src: String?,
        @JsonProperty("label") val label: String?,
    )

    data class Responses(
        @JsonProperty("data") val data: ArrayList<Media>? = arrayListOf(),
    )

    data class Media(
        @JsonProperty("episodesCount") val episodesCount: Int?,
        @JsonProperty("thumbnail") val thumbnail: String?,
        @JsonProperty("id") val id: Int?,
        @JsonProperty("title") val title: String?,
    )

    data class Episodes(
        @JsonProperty("id") val id: Int?,
        @JsonProperty("number") val number: Int?,
        @JsonProperty("sub") val sub: Int?,
    )

    data class MediaDetail(
        @JsonProperty("description") val description: String?,
        @JsonProperty("releaseDate") val releaseDate: String?,
        @JsonProperty("status") val status: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("country") val country: String?,
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf(),
        @JsonProperty("thumbnail") val thumbnail: String?,
        @JsonProperty("id") val id: Int?,
        @JsonProperty("title") val title: String?,
    )

}


================================================
FILE: KisskhProvider/src/main/kotlin/com/lagradost/KisskhProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class KisskhProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(KisskhProvider())
    }
}


================================================
FILE: LayarKacaProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: LayarKacaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: LayarKacaProvider/src/main/kotlin/com/lagradost/LayarKacaProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class LayarKacaProvider : MainAPI() {
    override var mainUrl = "https://lk21.xn--6frz82g"
    override var name = "LayarKaca"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "$mainUrl/populer/page/" to "Film Terplopuler",
        "$mainUrl/latest-series/page/" to "Series Terbaru",
        "$mainUrl/series/asian/page/" to "Film Asian Terbaru",
        "$mainUrl/latest/page/" to "Film Upload Terbaru",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).document
        val home = document.select("article.mega-item").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h1.grid-title > a")?.ownText()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("h1.grid-title > a")!!.attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst(".grid-poster > a > img")?.attr("src"))
        val quality = this.select("div.quality").text().trim()
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
            addQuality(quality)
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/?s=$query"
        val document = app.get(link).document

        return document.select("div.search-item").map {
            val title = it.selectFirst("h2 > a")!!.text().trim()
            val href = it.selectFirst("h2 > a")!!.attr("href")
            val posterUrl = fixUrl(it.selectFirst("img.img-thumbnail")?.attr("src").toString())
            newTvSeriesSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title = document.selectFirst("li.last > span[itemprop=name]")?.text()?.trim().toString()
        val poster = fixUrl(document.select("img.img-thumbnail").attr("src").toString())
        val tags = document.select("div.content > div:nth-child(5) > h3 > a").map { it.text() }

        val year = Regex("\\d, (\\d+)").find(
            document.select("div.content > div:nth-child(7) > h3").text().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (document.select("div.serial-wrapper")
                .isNotEmpty()
        ) TvType.TvSeries else TvType.Movie
        val description = document.select("div.content > blockquote").text().trim()
        val trailer = document.selectFirst("div.action-player li > a.fancybox")?.attr("href")
        val rating =
            document.selectFirst("div.content > div:nth-child(6) > h3")?.text()?.toRatingInt()
        val actors =
            document.select("div.col-xs-9.content > div:nth-child(3) > h3 > a").map { it.text() }

        val recommendations = document.select("div.row.item-media").map {
            val recName = it.selectFirst("h3")?.text()?.trim().toString()
            val recHref = it.selectFirst(".content-media > a")!!.attr("href")
            val recPosterUrl =
                fixUrl(it.selectFirst(".poster-media > a > img")?.attr("src").toString())
            newTvSeriesSearchResponse(recName, recHref, TvType.TvSeries) {
                this.posterUrl = recPosterUrl
            }
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = document.select("div.episode-list > a:matches(\\d+)").map {
                val href = fixUrl(it.attr("href"))
                val episode = it.text().toIntOrNull()
                val season =
                    it.attr("href").substringAfter("season-").substringBefore("-").toIntOrNull()
                Episode(
                    href,
                    "Episode $episode",
                    season,
                    episode,
                )
            }.reversed()
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val document = app.get(data).document

//        maybe will need this in future
//        val sources = if (data.contains("-episode-")) {
//            document.select("script").mapNotNull { script ->
//                if (script.data().contains("var data =")) {
//                    val scriptData =
//                        script.toString().substringAfter("var data = '").substringBefore("';")
//                    Jsoup.parse(scriptData).select("li").map {
//                        fixUrl(it.select("a").attr("href"))
//                    }
//                } else {
//                    null
//                }
//            }[0]
//        } else {
//            document.select("ul#loadProviders > li").map {
//                fixUrl(it.select("a").attr("href"))
//            }
//        }

        document.select("ul#loadProviders > li").map {
            fixUrl(it.select("a").attr("href"))
        }.apmap {
            val link = if (it.startsWith("https://layarkacaxxi.icu")) {
                it.substringBeforeLast("/")
            } else {
                it
            }
            loadExtractor(link, data, subtitleCallback, callback)
        }

        return true
    }


}


================================================
FILE: LayarKacaProvider/src/main/kotlin/com/lagradost/LayarKacaProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class LayarKacaProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(LayarKacaProvider())
    }
}


================================================
FILE: MeloMovieProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: MeloMovieProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: MeloMovieProvider/src/main/kotlin/com/lagradost/MeloMovieProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.module.kotlin.readValue
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbUrl
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class MeloMovieProvider : MainAPI() {
    override var name = "MeloMovie"
    override var mainUrl = "https://melomovie.com"
    override val instantLinkLoading = true
    override val hasQuickSearch = true
    override val hasChromecastSupport = false // MKV FILES CANT BE PLAYED ON A CHROMECAST

    data class MeloMovieSearchResult(
        @JsonProperty("id") val id: Int,
        @JsonProperty("imdb_code") val imdbId: String,
        @JsonProperty("title") val title: String,
        @JsonProperty("type") val type: Int, // 1 = MOVIE, 2 = TV-SERIES
        @JsonProperty("year") val year: Int?, // 1 = MOVIE, 2 = TV-SERIES
        //"mppa" for tags
    )

    data class MeloMovieLink(
        @JsonProperty("name") val name: String,
        @JsonProperty("link") val link: String
    )

    override suspend fun quickSearch(query: String): List<SearchResponse> {
        return search(query)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/movie/search/?name=$query"
        val returnValue: ArrayList<SearchResponse> = ArrayList()
        val response = app.get(url).text
        val mapped = response.let { mapper.readValue<List<MeloMovieSearchResult>>(it) }
        if (mapped.isEmpty()) return returnValue

        for (i in mapped) {
            val currentUrl = "$mainUrl/movie/${i.id}"
            val currentPoster = "$mainUrl/assets/images/poster/${i.imdbId}.jpg"
            if (i.type == 2) { // TV-SERIES
                returnValue.add(
                    TvSeriesSearchResponse(
                        i.title,
                        currentUrl,
                        this.name,
                        TvType.TvSeries,
                        currentPoster,
                        i.year,
                        null
                    )
                )
            } else if (i.type == 1) { // MOVIE
                returnValue.add(
                    MovieSearchResponse(
                        i.title,
                        currentUrl,
                        this.name,
                        TvType.Movie,
                        currentUrl,
                        i.year
                    )
                )
            }
        }
        return returnValue
    }

    // http not https, the links are not https!
    private fun fixUrl(url: String): String {
        if (url.isEmpty()) return ""

        if (url.startsWith("//")) {
            return "http:$url"
        }
        if (!url.startsWith("http")) {
            return "http://$url"
        }
        return url
    }

    private fun serializeData(element: Element): List<MeloMovieProvider.MeloMovieLink> {
        val eps = element.select("> tbody > tr")
        val parsed = eps.mapNotNull {
            try {
                val tds = it.select("> td")
                val name = tds[if (tds.size == 5) 1 else 0].text()
                val url = fixUrl(tds.last()!!.selectFirst("> a")!!.attr("data-lnk").replace(" ", "%20"))
                MeloMovieLink(name, url)
            } catch (e: Exception) {
                MeloMovieLink("", "")
            }
        }.filter { it.link != "" && it.name != "" }
        return parsed
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links = parseJson<List<MeloMovieLink>>(data)
        for (link in links) {
            callback.invoke(
                ExtractorLink(
                    this.name,
                    link.name,
                    link.link,
                    "",
                    getQualityFromName(link.name),
                    false
                )
            )
        }
        return true
    }

    override suspend fun load(url: String): LoadResponse? {
        val response = app.get(url).text

        //backdrop = imgurl
        fun findUsingRegex(src: String): String? {
            return src.toRegex().find(response)?.groups?.get(1)?.value ?: return null
        }

        val imdbUrl = findUsingRegex("var imdb = \"(.*?)\"")
        val document = Jsoup.parse(response)
        val poster = document.selectFirst("img.img-fluid")!!.attr("src")
        val type = findUsingRegex("var posttype = ([0-9]*)")?.toInt() ?: return null
        val titleInfo = document.selectFirst("div.movie_detail_title > div > div > h1")
        val title = titleInfo!!.ownText()
        val year =
            titleInfo.selectFirst("> a")?.text()?.replace("(", "")?.replace(")", "")?.toIntOrNull()
        val plot = document.selectFirst("div.col-lg-12 > p")!!.text()

        if (type == 1) { // MOVIE
            val serialize = document.selectFirst("table.accordion__list")
                ?: throw ErrorLoadingException("No links found")
            return newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                serializeData(serialize)
            ) {
                this.posterUrl = poster
                this.year = year
                this.plot = plot
                addImdbUrl(imdbUrl)
            }
        } else if (type == 2) {
            val episodes = ArrayList<Episode>()
            val seasons = document.select("div.accordion__card")
                ?: throw ErrorLoadingException("No episodes found")
            for (s in seasons) {
                val season =
                    s.selectFirst("> div.card-header > button > span")!!.text()
                        .replace("Season: ", "").toIntOrNull()
                val localEpisodes = s.select("> div.collapse > div > div > div.accordion__card")
                for (e in localEpisodes) {
                    val episode =
                        e.selectFirst("> div.card-header > button > span")!!.text()
                            .replace("Episode: ", "").toIntOrNull()
                    val links =
                        e.selectFirst("> div.collapse > div > table.accordion__list") ?: continue
                    val data = serializeData(links)
                    episodes.add(newEpisode(data) {
                        this.season = season
                        this.episode = episode
                    })
                }
            }
            episodes.reverse()
            return newTvSeriesLoadResponse(
                title,
                url,
                TvType.TvSeries,
                episodes
            ) {
                this.posterUrl = poster
                this.year = year
                this.plot = plot
                addImdbUrl(imdbUrl)
            }
        }
        return null
    }
}


================================================
FILE: MeloMovieProvider/src/main/kotlin/com/lagradost/MeloMovieProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class MeloMovieProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MeloMovieProvider())
    }
}


================================================
FILE: MultiplexProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: MultiplexProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: MultiplexProvider/src/main/kotlin/com/lagradost/MultiplexProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.jsoup.nodes.Element

class MultiplexProvider : MainAPI() {
    override var mainUrl = "https://146.19.24.137"
    override var name = "Multiplex"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "$mainUrl/genre/top-popular-movies/page/" to "Top Popolar Movies",
        "$mainUrl/genre/series-ongoing/page/" to "Series Ongoing",
        "$mainUrl/genre/series-barat/page/" to "Series Barat",
        "$mainUrl/genre/series-korea/page/" to "Series Korea",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).document
        val home = document.select("article.item").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h2.entry-title > a")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")!!.attr("href"))
        val posterUrl = fixUrlNull(this.selectFirst("a > img")?.attr("data-src"))
        val quality = this.select("div.gmr-quality-item > a").text().trim()
        return if (quality.isEmpty()) {
            val episode = this.select("div.gmr-numbeps > span").text().toIntOrNull()
            newAnimeSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                addSub(episode)
            }
        } else {
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                addQuality(quality)
            }
        }
    }

    private fun Element.toBottomSearchResult(): SearchResponse? {
        val title = this.selectFirst("a > span.idmuvi-rp-title")?.text()?.trim() ?: return null
        val href = this.selectFirst("a")!!.attr("href")
        val posterUrl = fixUrl(this.selectFirst("a > img")?.attr("data-src").toString())
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/?s=$query&post_type[]=post&post_type[]=tv"
        val document = app.get(link).document
        return document.select("article.item").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title =
            document.selectFirst("h1.entry-title")?.text()?.substringBefore("Season")?.trim()
                .toString()
        val poster =
            fixUrl(document.selectFirst("figure.pull-left > img")?.attr("data-src").toString())
        val tags = document.select("span.gmr-movie-genre:contains(Genre:) > a").map { it.text() }

        val year =
            document.select("span.gmr-movie-genre:contains(Year:) > a").text().trim().toIntOrNull()
        val tvType = if (url.contains("/tv/")) TvType.TvSeries else TvType.Movie
        val description = document.selectFirst("div[itemprop=description] > p")?.text()?.trim()
        val trailer = document.selectFirst("ul.gmr-player-nav li a.gmr-trailer-popup")?.attr("href")
        val rating =
            document.selectFirst("div.gmr-meta-rating > span[itemprop=ratingValue]")?.text()
                ?.toRatingInt()
        val actors = document.select("div.gmr-moviedata").last()?.select("span[itemprop=actors]")
            ?.map { it.select("a").text() }

        val recommendations = document.select("div.idmuvi-rp ul li").mapNotNull {
            it.toBottomSearchResult()
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = document.select("div.gmr-listseries > a").map {
                val href = fixUrl(it.attr("href"))
                val episode = it.text().split(" ").last().toIntOrNull()
                val season = it.text().split(" ").first().substringAfter("S").toIntOrNull()
                Episode(
                    href,
                    "Episode $episode",
                    season,
                    episode,
                )
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    private data class ResponseSource(
        @JsonProperty("file") val file: String,
        @JsonProperty("type") val type: String?,
        @JsonProperty("label") val label: String?
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val document = app.get(data).document

        val id = document.selectFirst("div#muvipro_player_content_id")!!.attr("data-id")
        val server = app.post(
            "$mainUrl/wp-admin/admin-ajax.php",
            data = mapOf("action" to "muvipro_player_content", "tab" to "player1", "post_id" to id)
        ).document.select("iframe").attr("src")

        app.get(server, referer = "$mainUrl/").document.select("script").map { script ->
            if (script.data().contains("var config = {")) {
                val source = script.data().substringAfter("sources: [").substringBefore("],")
                tryParseJson<List<ResponseSource>>("[$source]")?.map { m3u ->
                    val m3uData = app.get(m3u.file, referer = "https://gdriveplayer.link/").text
                    val quality =
                        Regex("\\d{3,4}\\.m3u8").findAll(m3uData).map { it.value }.toList()
                    quality.forEach {
                        callback.invoke(
                            ExtractorLink(
                                source = name,
                                name = name,
                                url = m3u.file.replace("video.m3u8", it),
                                referer = "https://gdriveplayer.link/",
                                quality = getQualityFromName("${it.replace(".m3u8", "")}p"),
                                isM3u8 = true
                            )
                        )
                    }
                }
            }
        }

        return true

    }


}


================================================
FILE: MultiplexProvider/src/main/kotlin/com/lagradost/MultiplexProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class MultiplexProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MultiplexProvider())
    }
}


================================================
FILE: MyCimaProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: MyCimaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: MyCimaProvider/src/main/kotlin/com/lagradost/MyCimaProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import org.jsoup.Jsoup
import org.jsoup.nodes.Element

class MyCimaProvider : MainAPI() {
    override var lang = "ar"
    override var mainUrl = "https://mycima.tv"
    override var name = "MyCima"
    override val usesWebView = false
    override val hasMainPage = true
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie, TvType.Anime)

    private fun String.getImageURL(): String? {
        return this.replace("--im(age|g):url\\(|\\);".toRegex(), "")
    }

    private fun String.getIntFromText(): Int? {
        return Regex("""\d+""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    private fun Element.toSearchResponse(): SearchResponse? {
        val url = select("div.Thumb--GridItem a")
        val posterUrl = select("span.BG--GridItem")?.attr("data-lazy-style")
            ?.getImageURL()
        val year = select("div.GridItem span.year")?.text()
        val title = select("div.Thumb--GridItem strong").text()
            .replace("$year", "")
            .replace("مشاهدة|فيلم|مسلسل|مترجم".toRegex(), "")
            .replace("( نسخة مدبلجة )", " ( نسخة مدبلجة ) ")
        // If you need to differentiate use the url.
        return MovieSearchResponse(
            title,
            url.attr("href"),
            this@MyCimaProvider.name,
            if(url.attr("title").contains("فيلم")) TvType.Movie else TvType.TvSeries,
            posterUrl,
            year?.getIntFromText(),
            null,
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        // Title, Url
        val moviesUrl = listOf(
            "Movies" to "$mainUrl/movies/page/" + (0..25).random(),
            "Series" to "$mainUrl/seriestv/new/page/" + (0..25).random()
        )
        val pages = moviesUrl.apmap {
            val doc = app.get(it.second).document
            val list = doc.select("div.Grid--MycimaPosts div.GridItem").mapNotNull { element ->
                element.toSearchResponse()
            }
            HomePageList(it.first, list)
        }.sortedBy { it.name }
        return HomePageResponse(pages)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val q = query.replace(" ", "%20")
        val result = arrayListOf<SearchResponse>()
        listOf(
            "$mainUrl/search/$q",
            "$mainUrl/search/$q/list/series/",
            "$mainUrl/search/$q/list/anime/"
        ).apmap { url ->
            val d = app.get(url).document
            d.select("div.Grid--MycimaPosts div.GridItem").mapNotNull {
                if (it.text().contains("اعلان")) return@mapNotNull null
                it.toSearchResponse()?.let { it1 -> result.add(it1) }
            }
        }
        return result.distinct().sortedBy { it.name }
    }

    data class MoreEPS(
        val output: String
    )

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val isMovie = doc.select("ol li:nth-child(3)").text().contains("افلام")
        val posterUrl =
            doc.select("mycima.separated--top")?.attr("data-lazy-style")?.getImageURL()
                ?.ifEmpty { doc.select("meta[itemprop=\"thumbnailUrl\"]")?.attr("content") }
                ?.ifEmpty { doc.select("mycima.separated--top")?.attr("style")?.getImageURL() }
        val year =
            doc.select("div.Title--Content--Single-begin h1 a.unline")?.text()?.getIntFromText()
        val title = doc.select("div.Title--Content--Single-begin h1").text()
            .replace("($year)", "")
            .replace("مشاهدة|فيلم|مسلسل|مترجم|انمي".toRegex(), "")
        // A bit iffy to parse twice like this, but it'll do.
        val duration =
            doc.select("ul.Terms--Content--Single-begin li").firstOrNull {
                it.text().contains("المدة")
            }?.text()?.getIntFromText()

        val synopsis = doc.select("div.StoryMovieContent").text()
            .ifEmpty { doc.select("div.PostItemContent").text() }

        val tags = doc.select("li:nth-child(3) > p > a").map { it.text() }

        val actors = doc.select("div.List--Teamwork > ul.Inner--List--Teamwork > li")?.mapNotNull {
            val name = it?.selectFirst("a > div.ActorName > span")?.text() ?: return@mapNotNull null
            val image = it.attr("style")
                ?.getImageURL()
                ?: return@mapNotNull null
            Actor(name, image)
        }
        val recommendations =
            doc.select("div.Grid--MycimaPosts div.GridItem")?.mapNotNull { element ->
                element.toSearchResponse()
            }

        return if (isMovie) {
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                url
            ) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = synopsis
                this.tags = tags
                this.duration = duration
                this.recommendations = recommendations
                addActors(actors)
            }
        } else {
            val episodes = ArrayList<Episode>()
            val seasons = doc.select("div.List--Seasons--Episodes a").not(".selected").map {
                it.attr("href")
            }
            val moreButton = doc.select("div.MoreEpisodes--Button")
            val season =
                doc.select("div.List--Seasons--Episodes a.selected").text().getIntFromText()
            doc.select("div.Seasons--Episodes div.Episodes--Seasons--Episodes a")
                .apmap {
                    episodes.add(
                        Episode(
                            it.attr("href"),
                            it.text(),
                            season,
                            it.text().getIntFromText(),
                        )
                    )
                }
            if (moreButton.isNotEmpty()) {
                val n = doc.select("div.Seasons--Episodes div.Episodes--Seasons--Episodes a").size
                val totals =
                    doc.select("div.Episodes--Seasons--Episodes a").first()!!.text().getIntFromText()
                val mEPS = arrayListOf(
                    n,
                    n + 40,
                    n + 80,
                    n + 120,
                    n + 160,
                    n + 200,
                    n + 240,
                    n + 280,
                    n + 320,
                    n + 360,
                    n + 400,
                    n + 440,
                    n + 480,
                    n + 520,
                    n + 660,
                    n + 700,
                    n + 740,
                    n + 780,
                    n + 820,
                    n + 860,
                    n + 900,
                    n + 940,
                    n + 980,
                    n + 1020,
                    n + 1060,
                    n + 1100,
                    n + 1140,
                    n + 1180,
                    n + 1220,
                    totals
                )
                mEPS.apmap { it ->
                    if (it != null) {
                        if (it > totals!!) return@apmap
                        val ajaxURL =
                            "$mainUrl/AjaxCenter/MoreEpisodes/${moreButton.attr("data-term")}/$it"
                        val jsonResponse = app.get(ajaxURL)
                        val json = parseJson<MoreEPS>(jsonResponse.text)
                        val document = Jsoup.parse(json.output?.replace("""\""", ""))
                        document.select("a").map {
                            episodes.add(
                                Episode(
                                    it.attr("href"),
                                    it.text(),
                                    season,
                                    it.text().getIntFromText(),
                                )
                            )
                        }
                    }
                }
            }
            if (seasons.isNotEmpty()) {
                seasons.apmap { surl ->
                    if (surl.contains("%d9%85%d8%af%d8%a8%d9%84%d8%ac")) return@apmap
                    val seasonsite = app.get(surl).document
                    val fmoreButton = seasonsite.select("div.MoreEpisodes--Button")
                    val fseason = seasonsite.select("div.List--Seasons--Episodes a.selected").text()
                        .getIntFromText() ?: 1
                    seasonsite.select("div.Seasons--Episodes div.Episodes--Seasons--Episodes a")
                        .map {
                            episodes.add(
                                Episode(
                                    it.attr("href"),
                                    it.text(),
                                    fseason,
                                    it.text().getIntFromText(),
                                )
                            )
                        }
                    if (fmoreButton.isNotEmpty()) {
                        val n =
                            seasonsite.select("div.Seasons--Episodes div.Episodes--Seasons--Episodes a").size
                        val totals =
                            seasonsite.select("div.Episodes--Seasons--Episodes a").first()!!.text()
                                .getIntFromText()
                        val mEPS = arrayListOf(
                            n,
                            n + 40,
                            n + 80,
                            n + 120,
                            n + 160,
                            n + 200,
                            n + 240,
                            n + 280,
                            n + 320,
                            n + 360,
                            n + 400,
                            n + 440,
                            n + 480,
                            n + 520,
                            n + 660,
                            n + 700,
                            n + 740,
                            n + 780,
                            n + 820,
                            n + 860,
                            n + 900,
                            n + 940,
                            n + 980,
                            n + 1020,
                            n + 1060,
                            n + 1100,
                            n + 1140,
                            n + 1180,
                            n + 1220,
                            totals
                        )
                        mEPS.apmap { it ->
                            if (it != null) {
                                if (it > totals!!) return@apmap
                                val ajaxURL =
                                    "$mainUrl/AjaxCenter/MoreEpisodes/${fmoreButton.attr("data-term")}/$it"
                                val jsonResponse = app.get(ajaxURL)
                                val json = parseJson<MoreEPS>(jsonResponse.text)
                                val document = Jsoup.parse(json.output?.replace("""\""", ""))
                                document.select("a").map {
                                    episodes.add(
                                        Episode(
                                            it.attr("href"),
                                            it.text(),
                                            fseason,
                                            it.text().getIntFromText(),
                                        )
                                    )
                                }
                            }
                        }
                    } else return@apmap
                }
            }
            newTvSeriesLoadResponse(
                title,
                url,
                TvType.TvSeries,
                episodes.distinct().sortedBy { it.episode }) {
                this.duration = duration
                this.posterUrl = posterUrl
                this.tags = tags
                this.year = year
                this.plot = synopsis
                this.recommendations = recommendations
                addActors(actors)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document
            .select("ul.List--Download--Mycima--Single:nth-child(2) li").map {
                it.select("a").map { linkElement ->
                    callback.invoke(
                        ExtractorLink(
                            this.name,
                            this.name,
                            linkElement.attr("href"),
                            this.mainUrl,
                            quality = linkElement.select("resolution").text().getIntFromText() ?: 0
                        )
                    )
                }
            }.flatten()
        return true
    }
}



================================================
FILE: MyCimaProvider/src/main/kotlin/com/lagradost/MyCimaProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class MyCimaProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(MyCimaProvider())
    }
}


================================================
FILE: NginxProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: NginxProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: NginxProvider/src/main/kotlin/com/lagradost/NginxProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities

class NginxProvider : MainAPI() {
    override var name = "Nginx"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val supportedTypes = setOf(TvType.AnimeMovie, TvType.TvSeries, TvType.Movie)

    companion object {
        var loginCredentials: String? = null
        var overrideUrl: String? = null
        const val ERROR_STRING = "No nginx url specified in the settings"
    }

    private fun getAuthHeader(): Map<String, String> {
        val url = overrideUrl ?: throw ErrorLoadingException(ERROR_STRING)
        mainUrl = url
        println("OVERRIDING URL TO $overrideUrl")
        if (mainUrl == "NONE" || mainUrl.isBlank()) {
            throw ErrorLoadingException(ERROR_STRING)
        }

        val localCredentials = loginCredentials
        if (localCredentials == null || localCredentials.trim() == ":") {
            return mapOf("Authorization" to "Basic ")  // no Authorization headers
        }

        val basicAuthToken =
            base64Encode(localCredentials.toByteArray())  // will this be loaded when not using the provider ??? can increase load

        return mapOf("Authorization" to "Basic $basicAuthToken")
    }

    override suspend fun load(url: String): LoadResponse {
        val authHeader =
            getAuthHeader()  // call again because it isn't reloaded if in main class and storedCredentials loads after
        // url can be tvshow.nfo for series or mediaRootUrl for movies

        val mainRootDocument = app.get(url, authHeader).document

        val nfoUrl = url + mainRootDocument.getElementsByAttributeValueContaining("href", ".nfo")
            .attr("href")  // metadata url file

        val metadataDocument = app.get(nfoUrl, authHeader).document  // get the metadata nfo file

        val isMovie = !nfoUrl.contains("tvshow.nfo")

        val title = metadataDocument.selectFirst("title")!!.text()

        val description = metadataDocument.selectFirst("plot")!!.text()

        if (isMovie) {
            val poster = metadataDocument.selectFirst("thumb")!!.text()
            val trailer = metadataDocument.select("trailer").mapNotNull {
                it?.text()?.replace(
                    "plugin://plugin.video.youtube/play/?video_id=",
                    "https://www.youtube.com/watch?v="
                )
            }
            val partialUrl =
                mainRootDocument.getElementsByAttributeValueContaining("href", ".nfo").attr("href")
                    .replace(".nfo", ".")
            val date = metadataDocument.selectFirst("year")?.text()?.toIntOrNull()
            val ratingAverage = metadataDocument.selectFirst("value")?.text()?.toIntOrNull()
            val tagsList = metadataDocument.select("genre")
                .mapNotNull {   // all the tags like action, thriller ...
                    it?.text()

                }


            val dataList =
                mainRootDocument.getElementsByAttributeValueContaining(  // list of all urls of the webpage
                    "href",
                    partialUrl
                )

            val data = url + dataList.firstNotNullOf { item ->
                item.takeIf {
                    (!it.attr("href").contains(".nfo") && !it.attr("href").contains(".jpg"))
                }
            }.attr("href").toString()  // exclude poster and nfo (metadata) file

            return newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                data
            ) {
                this.year = date
                this.plot = description
                this.rating = ratingAverage
                this.tags = tagsList
                addTrailer(trailer)
                addPoster(poster, authHeader)
            }
        } else  // a tv serie
        {
            val list = ArrayList<Pair<Int, String>>()
            val mediaRootUrl = url.replace("tvshow.nfo", "")
            val posterUrl = mediaRootUrl + "poster.jpg"
            val mediaRootDocument = app.get(mediaRootUrl, authHeader).document
            val seasons =
                mediaRootDocument.getElementsByAttributeValueContaining("href", "Season%20")


            val tagsList = metadataDocument.select("genre")
                .mapNotNull {   // all the tags like action, thriller ...; unused variable
                    it?.text()
                }

            //val actorsList = document.select("actor")
            //    ?.mapNotNull {   // all the tags like action, thriller ...; unused variable
            //        it?.text()
            //    }

            seasons.forEach { element ->
                val season =
                    element.attr("href").replace("Season%20", "").replace("/", "").toIntOrNull()
                val href = mediaRootUrl + element.attr("href")
                if (season != null && season > 0 && href.isNotBlank()) {
                    list.add(Pair(season, href))
                }
            }

            if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            val episodeList = ArrayList<Episode>()


            list.apmap { (seasonInt, seasonString) ->
                val seasonDocument = app.get(seasonString, authHeader).document
                val episodes = seasonDocument.getElementsByAttributeValueContaining(
                    "href",
                    ".nfo"
                ) // get metadata
                episodes.forEach { episode ->
                    val nfoDocument = app.get(
                        seasonString + episode.attr("href"),
                        authHeader
                    ).document // get episode metadata file
                    val epNum = nfoDocument.selectFirst("episode")?.text()?.toIntOrNull()
                    val poster =
                        seasonString + episode.attr("href").replace(".nfo", "-thumb.jpg")
                    val name = nfoDocument.selectFirst("title")!!.text()
                    // val seasonInt = nfoDocument.selectFirst("season").text().toIntOrNull()
                    val date = nfoDocument.selectFirst("aired")?.text()
                    val plot = nfoDocument.selectFirst("plot")?.text()

                    val dataList = seasonDocument.getElementsByAttributeValueContaining(
                        "href",
                        episode.attr("href").replace(".nfo", "")
                    )
                    val data = seasonString + dataList.firstNotNullOf { item ->
                        item.takeIf {
                            (!it.attr("href").contains(".nfo") && !it.attr("href").contains(".jpg"))
                        }
                    }.attr("href").toString()  // exclude poster and nfo (metadata) file

                    episodeList.add(
                        newEpisode(data) {
                            this.name = name
                            this.season = seasonInt
                            this.episode = epNum
                            this.posterUrl = poster  // will require headers too
                            this.description = plot
                            addDate(date)
                        }
                    )
                }
            }
            return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodeList) {
                this.name = title
                this.url = url
                this.episodes = episodeList
                this.plot = description
                this.tags = tagsList
                addPoster(posterUrl, authHeader)
            }
        }

    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        // loadExtractor(data, null) { callback(it.copy(headers=authHeader)) }
        val authHeader =
            getAuthHeader()  // call again because it isn't reloaded if in main class and storedCredentials loads after
        callback.invoke(
            ExtractorLink(
                name,
                name,
                data,
                data,  // referer not needed
                Qualities.Unknown.value,
                false,
                authHeader,
            )
        )

        return true
    }


    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val authHeader =
            getAuthHeader()  // call again because it isn't reloaded if in main class and storedCredentials loads after

        val document = app.get(mainUrl, authHeader).document
        val categories = document.select("a")
        val returnList = categories.mapNotNull {
            val categoryTitle = it.text()  // get the category title like Movies or Series
            if (categoryTitle != "../" && categoryTitle != "Music/") {  // exclude parent dir and Music dir
                val href = it?.attr("href")
                val categoryPath = fixUrlNull(href?.trim())
                    ?: return@mapNotNull null // get the url of the category; like http://192.168.1.10/media/Movies/

                val categoryDocument = app.get(
                    categoryPath,
                    authHeader
                ).document // queries the page http://192.168.1.10/media/Movies/
                val contentLinks = categoryDocument.select("a")
                val currentList = contentLinks.mapNotNull { head ->
                    if (head.attr("href") != "../") {
                        try {
                            val mediaRootUrl =
                                categoryPath + head.attr("href")// like http://192.168.1.10/media/Series/Chernobyl/
                            val mediaDocument = app.get(mediaRootUrl, authHeader).document
                            val nfoFilename = mediaDocument.getElementsByAttributeValueContaining(
                                "href",
                                ".nfo"
                            )[0].attr("href")
                            val isMovieType = nfoFilename != "tvshow.nfo"
                            val nfoPath =
                                mediaRootUrl + nfoFilename // must exist or will raise errors, only the first one is taken
                            val nfoContent =
                                app.get(nfoPath, authHeader).document  // all the metadata

                            if (isMovieType) {
                                val movieName = nfoContent.select("title").text()
                                val posterUrl = mediaRootUrl + "poster.jpg"
                                return@mapNotNull newMovieSearchResponse(
                                    movieName,
                                    mediaRootUrl,
                                    TvType.Movie,
                                ) {
                                    addPoster(posterUrl, authHeader)
                                }
                            } else {  // tv serie
                                val serieName = nfoContent.select("title").text()

                                val posterUrl = mediaRootUrl + "poster.jpg"

                                newTvSeriesSearchResponse(
                                    serieName,
                                    nfoPath,
                                    TvType.TvSeries,
                                ) {
                                    addPoster(posterUrl, authHeader)
                                }
                            }
                        } catch (e: Exception) {  // can cause issues invisible errors
                            null
                            //logError(e) // not working because it changes the return type of currentList to Any
                        }
                    } else null
                }
                if (currentList.isNotEmpty() && categoryTitle != "../") {  // exclude upper dir
                    HomePageList(categoryTitle, currentList)
                } else null
            } else null  // the path is ../ which is parent directory
        }
        // if (returnList.isEmpty()) return null // maybe doing nothing idk
        return HomePageResponse(returnList)
    }
}



================================================
FILE: NginxProvider/src/main/kotlin/com/lagradost/NginxProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class NginxProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(NginxProvider())
    }
}


================================================
FILE: OlgplyProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: OlgplyProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: OlgplyProvider/src/main/kotlin/com/lagradost/OlgplyProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.nicehttp.requestCreator
import org.mozilla.javascript.Context
import org.mozilla.javascript.Scriptable
import org.mozilla.javascript.ScriptableObject

class OlgplyProvider : TmdbProvider() {
    override var mainUrl = "https://olgply.com"
    override val apiName = "Olgply"
    override var name = "Olgply"
    override val instantLinkLoading = true
    override val useMetaLoadResponse = true
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie)

    private suspend fun loadLinksWithWebView(
        url: String,
//        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ) {
        val foundVideo = WebViewResolver(
            Regex("""movies4discord""")
        ).resolveUsingWebView(
            requestCreator("GET", url)
        ).first ?: return

        callback.invoke(
            ExtractorLink(
                this.name,
                "Movies4Discord",
                foundVideo.url.toString(),
                "",
                Qualities.Unknown.value
            )
        )
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mappedData = parseJson<TmdbLink>(data)
        val tmdbId = mappedData.tmdbID ?: return false
        val jsRegex = Regex("""eval\(.*\);""")

        val apiUrl =
            "https://olgply.xyz/${tmdbId}${mappedData.season?.let { "/$it" } ?: ""}${mappedData.episode?.let { "/$it" } ?: ""}"
        val html =
            app.get(apiUrl).text
        val rhino = Context.enter()
        rhino.optimizationLevel = -1
        val scope: Scriptable = rhino.initSafeStandardObjects()
        val documentJs = """
            Plyr = function(){};
            
            hlsPrototype = {
                loadSource(url) {
                    this.url = url;
                }
            };

            function Hls() {};
            Hls.isSupported = function(){return true};
            
            Hls.prototype = hlsPrototype;
            Hls.prototype.constructor = Hls;

            document = {
                "querySelector" : function() {}
            };
        """.trimIndent()

        val foundJs = jsRegex.find(html)?.groupValues?.getOrNull(0) ?: return false
        try {
            rhino.evaluateString(scope, documentJs + foundJs, "JavaScript", 1, null)
        } catch (e: Exception) {
        }

        val hls = scope.get("hls", scope) as? ScriptableObject

        if (hls != null) {
            callback.invoke(
                ExtractorLink(
                    this.name,
                    this.name,
                    hls["url"].toString(),
                    this.mainUrl + "/",
                    Qualities.Unknown.value,
                    headers = mapOf("range" to "bytes=0-"),
                    isM3u8 = true
                )
            )
        } else {
            // Disgraceful fallback, but the js for Movies4Discord refuses to work correctly :(
            loadLinksWithWebView(apiUrl, callback)
        }
        return true
    }
}


================================================
FILE: OlgplyProvider/src/main/kotlin/com/lagradost/OlgplyProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class OlgplyProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(OlgplyProvider())
    }
}


================================================
FILE: OpenVidsProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":VidstreamProviderTemplate")))
    implementation(project(mapOf("path" to ":VidEmbedProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: OpenVidsProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: OpenVidsProvider/src/main/kotlin/com/lagradost/OpenVidsProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.extractors.Vidstream
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import java.time.ZonedDateTime
import java.time.format.DateTimeFormatter

class OpenVidsProvider:TmdbProvider() {
    override val apiName = "OpenVids"
    override var name = "OpenVids"
    override var mainUrl = "https://openvids.io"
    override val useMetaLoadResponse = true
    override val instantLinkLoading = false
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    data class  OpenvidsMain(
        @JsonProperty("ok"      ) val ok      : Boolean? = null,
        @JsonProperty("servers" ) val servers : OpenvidServers? = OpenvidServers()
    )

    data class OpenvidServers (
        @JsonProperty("streamsb" ) val streamsb : OpenvidServersData? = OpenvidServersData(),
        @JsonProperty("voxzer"   ) val voxzer   : OpenvidServersData?   = OpenvidServersData(),
        @JsonProperty("mixdrop"   ) val mixdrop   : OpenvidServersData?   = OpenvidServersData(),
        @JsonProperty("doodstream"   ) val doodstream   : OpenvidServersData?   = OpenvidServersData(),
        @JsonProperty("voe"   ) val voe   : OpenvidServersData?   = OpenvidServersData(),
        @JsonProperty("vidcloud" ) val vidcloud : OpenvidServersData? = OpenvidServersData()
    )
    data class OpenvidServersData (
        @JsonProperty("code"      ) val code      : String?  = null,
        @JsonProperty("updatedAt" ) val updatedAt : String?  = null,
        @JsonProperty("encoded"   ) val encoded   : Boolean? = null
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mappedData = parseJson<TmdbLink>(data)
        val (id, site) = if (mappedData.imdbID != null) listOf(
            mappedData.imdbID,
            "imdb"
        ) else listOf(mappedData.tmdbID.toString(), "tmdb")
        val isMovie = mappedData.episode == null && mappedData.season == null
        val embedUrl = if (isMovie) {
            if(site == "imdb") "$mainUrl/movie/$id" else
                "$mainUrl/tmdb/movie/$id"
        } else {
            val suffix = "$id-${mappedData.season ?: 1}-${mappedData.episode ?: 1}"
            if (site == "imdb") "$mainUrl/episode/$suffix" else
                "$mainUrl/tmdb/episode/$suffix"
        }
        val zonedatetime = ZonedDateTime.now()
        val timeformated = DateTimeFormatter.ISO_INSTANT.format(zonedatetime)
        val headers = if (isMovie) {
            mapOf(
                "Host" to "openvids.io",
                "User-Agent" to USER_AGENT,
                "Accept" to "*/*",
                "Accept-Language" to "en-US,en;q=0.5",
                "Referer" to embedUrl,
                "updatedAt" to timeformated,
                "title" to "${mappedData.movieName}",
                "year" to "2016",
                "DNT" to "1",
                "Alt-Used" to "openvids.io",
                "Connection" to "keep-alive",
                "Sec-Fetch-Dest" to "empty",
                "Sec-Fetch-Mode" to "cors",
                "Sec-Fetch-Site" to "same-origin",
            )
        } else {
            mapOf(
                "Host" to "openvids.io",
                "User-Agent" to USER_AGENT,
                "Accept" to "*/*",
                "Accept-Language" to "en-US,en;q=0.5",
                "Referer" to embedUrl,
                "updatedAt" to timeformated,
                "title" to "${mappedData.movieName} - season 1",
                "year" to "2021",
                "e" to "${mappedData.episode}",
                "s" to "${mappedData.season}",
                "DNT" to "1",
                "Alt-Used" to "openvids.io",
                "Connection" to "keep-alive",
                "Sec-Fetch-Dest" to "empty",
                "Sec-Fetch-Mode" to "cors",
                "Sec-Fetch-Site" to "same-origin",
            )
        }
        val json = app.get("$mainUrl/api/servers.json?imdb=${mappedData.imdbID}", headers = headers).parsedSafe<OpenvidsMain>()

        val listservers = listOf(
            "https://streamsb.net/e/" to json?.servers?.streamsb?.code,
            "https://player.voxzer.org/view/" to json?.servers?.voxzer?.code,
            "https://mixdrop.co/e/" to json?.servers?.mixdrop?.code,
            "https://dood.pm/e/" to json?.servers?.doodstream?.code,
            "https://voe.sx/e/" to json?.servers?.voe?.code,
            "https://membed.net/streaming.php?id=" to json?.servers?.vidcloud?.code
        ).mapNotNull { (url, id) -> if(id==null) return@mapNotNull null else "$url$id" }

        if (json?.ok != true) return false
        listservers.apmap { links ->
            if (links.contains("membed")) {
                val membed = VidEmbedProvider()
                Vidstream.extractVidstream(
                    links,
                    this.name,
                    callback,
                    membed.iv,
                    membed.secretKey,
                    membed.secretDecryptKey,
                    membed.isUsingAdaptiveKeys,
                    membed.isUsingAdaptiveData)
            } else
                loadExtractor(links, data, subtitleCallback, callback)
        }
        return true
    }

}


================================================
FILE: OpenVidsProvider/src/main/kotlin/com/lagradost/OpenVidsProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class OpenVidsProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(OpenVidsProvider())
    }
}


================================================
FILE: PelisflixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PelisflixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PelisflixProvider/src/main/kotlin/com/lagradost/PelisflixProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addDuration
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class PelisflixProvider : MainAPI() {
    override var mainUrl = "https://pelisflix.li"
    override var name = "Pelisflix"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val urls = listOf(
            Pair("$mainUrl/ver-peliculas-online-gratis-fullhdc3/", "Películas"),
            Pair("$mainUrl/ver-series-online-gratis/", "Series"),
        )
        for (i in urls) {
            try {
                val soup = app.get(i.first).document
                val home = soup.select("article.TPost.B").map {
                    val title = it.selectFirst("h2.title")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        TvType.Movie,
                        it.selectFirst("figure img")!!.attr("data-src"),
                        null,
                        null,
                    )
                }

                items.add(HomePageList(i.second, home))
            } catch (e: Exception) {
                logError(e)
            }
        }
        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val doc = app.get(url).document
        return doc.select("article.TPost.B").map {
            val href = it.selectFirst("a")!!.attr("href")
            val poster = it.selectFirst("figure img")!!.attr("data-src")
            val name = it.selectFirst("h2.title")!!.text()
            val isMovie = href.contains("/pelicula/")
            if (isMovie) {
                MovieSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.Movie,
                    poster,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.TvSeries,
                    poster,
                    null,
                    null
                )
            }
        }.toList()
    }

    override suspend fun load(url: String): LoadResponse? {
        val type = if (url.contains("/pelicula/")) TvType.Movie else TvType.TvSeries

        val document = app.get(url).document

        val title = document.selectFirst("h1.Title")!!.text()
        val descRegex = Regex("(.Recuerda.*Pelisflix.+)")
        val descRegex2 = Regex("(Actualmente.*.)")
        val descRegex3 = Regex("(.*Director:.*)")
        val descRegex4 = Regex("(.*Actores:.*)")
        val descRegex5 = Regex("(Ver.*(\\)|)((\\d+).))")
        val descipt = document.selectFirst("div.Description")!!.text().replace(descRegex, "")
            .replace(descRegex2, "").replace(descRegex3, "")
            .replace(descRegex4, "").replace(descRegex5, "")
        val desc2Regex = Regex("(G(e|é)nero:.*..)")
        val descipt2 = document.selectFirst("div.Description")!!.text().replace(desc2Regex, "")
        val rating =
            document.selectFirst("div.rating-content button.like-mov span.vot_cl")?.text()
                ?.toFloatOrNull()
                ?.times(0)?.toInt()
        val year = document.selectFirst("span.Date")?.text()
        val duration =
            if (type == TvType.Movie) document.selectFirst(".Container .Container  span.Time")!!
                .text() else null
        val postercss = document.selectFirst("head").toString()
        val posterRegex =
            Regex("(\"og:image\" content=\"https:\\/\\/seriesflix.video\\/wp-content\\/uploads\\/(\\d+)\\/(\\d+)\\/?.*.jpg)")
        val poster = try {
            posterRegex.findAll(postercss).map {
                it.value.replace("\"og:image\" content=\"", "")
            }.toList().first()
        } catch (e: Exception) {
            document.select(".TPostBg").attr("src")
        }
        if (type == TvType.TvSeries) {
            val list = ArrayList<Pair<Int, String>>()

            document.select("main > section.SeasonBx > div > div.Title > a").forEach { element ->
                val season = element.selectFirst("> span")?.text()?.toIntOrNull()
                val href = element.attr("href")
                if (season != null && season > 0 && !href.isNullOrBlank()) {
                    list.add(Pair(season, fixUrl(href)))
                }
            }
            if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            val episodeList = ArrayList<Episode>()

            for ((seasonInt, seasonUrl) in list) {
                val seasonDocument = app.get(seasonUrl).document
                val episodes = seasonDocument.select("table > tbody > tr")
                if (episodes.isNotEmpty()) {
                    episodes.forEach { episode ->
                        val epNum = episode.selectFirst("> td > span.Num")?.text()?.toIntOrNull()
                        val epthumb = episode.selectFirst("img")?.attr("src")
                        val aName = episode.selectFirst("> td.MvTbTtl > a")
                        val name = aName!!.text()
                        val href = aName.attr("href")
                        val date = episode.selectFirst("> td.MvTbTtl > span")?.text()
                        episodeList.add(
                            newEpisode(href) {
                                this.name = name
                                this.season = seasonInt
                                this.episode =  epNum
                                this.posterUrl = fixUrlNull(epthumb)
                                addDate(date)
                            }
                        )
                    }
                }
            }
            return TvSeriesLoadResponse(
                title,
                url,
                this.name,
                type,
                episodeList,
                fixUrlNull(poster),
                year?.toIntOrNull(),
                descipt2,
                null,
                rating
            )
        } else {
            return newMovieLoadResponse(
                title,
                url,
                type,
                url
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year?.toIntOrNull()
                this.plot = descipt
                this.rating = rating
                addDuration(duration)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("li button.Button.sgty").forEach {
            val movieID = it.attr("data-id")
            val serverID = it.attr("data-key")
            val type = if (data.contains("pelicula")) 1 else 2
            val url =
                "$mainUrl/?trembed=$serverID&trid=$movieID&trtype=$type" //This is to get the POST key value
            val doc1 = app.get(url).document
            doc1.select("div.Video iframe").apmap {
                val iframe = it.attr("src")
                val postkey = iframe.replace("/stream/index.php?h=", "") // this obtains
                // djNIdHNCR2lKTGpnc3YwK3pyRCs3L2xkQmljSUZ4ai9ibTcza0JRODNMcmFIZ0hPejdlYW0yanJIL2prQ1JCZA POST KEY
                app.post(
                    "https://pelisflix.li/stream/r.php",
                    headers = mapOf(
                        "Host" to "pelisflix.li",
                        "User-Agent" to USER_AGENT,
                        "Accept" to "ext/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                        "Accept-Language" to "en-US,en;q=0.5",
                        "Content-Type" to "application/x-www-form-urlencoded",
                        "Origin" to "null",
                        "DNT" to "1",
                        "Connection" to "keep-alive",
                        "Upgrade-Insecure-Requests" to "1",
                        "Sec-Fetch-Dest" to "iframe",
                        "Sec-Fetch-Mode" to "navigate",
                        "Sec-Fetch-Site" to "same-origin",
                        "Sec-Fetch-User" to "?1",
                        "Pragma" to "no-cache",
                        "Cache-Control" to "no-cache",
                        "TE" to "trailers"
                    ),
                    params = mapOf(Pair("h", postkey)),
                    data = mapOf(Pair("h", postkey)),
                    allowRedirects = false
                ).okhttpResponse.headers.values("location").apmap { link ->
                    val url1 = link.replace("#bu", "")
                    loadExtractor(url1, data, subtitleCallback, callback)
                }
            }
        }
        return true
    }
}


================================================
FILE: PelisflixProvider/src/main/kotlin/com/lagradost/PelisflixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PelisflixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PelisflixProvider())
    }
}


================================================
FILE: PeliSmartProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PeliSmartProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PeliSmartProvider/src/main/kotlin/com/lagradost/PeliSmartProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class PeliSmartProvider: MainAPI() {
    override var mainUrl = "https://pelismart.com"
    override var name = "PeliSmart"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override val vpnStatus = VPNStatus.MightBeNeeded //Due to evoload sometimes not loading

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val urls = listOf(
            Pair("$mainUrl/peliculas/", "Peliculas"),
            Pair("$mainUrl/series/", "Series"),
            Pair("$mainUrl/documentales/", "Documentales"),
        )

        // has no inf loading
        urls.apmap { (url, name) ->
            try {
                val soup = app.get(url).document
                val home = soup.select(".description-off").map {
                    val title = it.selectFirst("h3.entry-title a")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        if (link.contains("pelicula")) TvType.Movie else TvType.TvSeries,
                        it.selectFirst("div img")!!.attr("src"),
                        null,
                        null,
                    )
                }

                items.add(HomePageList(name, home))
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl?s=${query}&post_type=post"
        val document = app.get(url).document

        return document.select(".description-off").map {
            val title = it.selectFirst("h3.entry-title a")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst("div img")!!.attr("src")
            val isMovie = href.contains("pelicula")

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            }
        }
    }


    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url, timeout = 120).document
        val title = soup.selectFirst(".wpb_wrapper h1")!!.text()
        val description = soup.selectFirst("div.wpb_wrapper p")?.text()?.trim()
        val poster: String? = soup.selectFirst(".vc_single_image-img")!!.attr("src")
        val episodes = soup.select("div.vc_tta-panel-body div a").map { li ->
            val href = li.selectFirst("a")!!.attr("href")
            val preregex = Regex("(\\d+)\\. ")
            val name = li.selectFirst("a")!!.text().replace(preregex,"")
            val regextest = Regex("(temporada-(\\d+)-capitulo-(\\d+)|temporada-(\\d+)-episodio-(\\d+))")
            val test = regextest.find(href)?.destructured?.component1()?.replace(Regex("(temporada-|-)"),"")
            val seasonid = test.let { str ->
                str?.split("episodio","capitulo")?.mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val isValid = seasonid?.size == 2
            val episode = if (isValid) seasonid?.getOrNull(1) else null
            val season = if (isValid) seasonid?.getOrNull(0) else null
                Episode(
                    href,
                    name,
                    season,
                    episode,
                )
        }
        return when (val tvType = if (episodes.isEmpty()) TvType.Movie else TvType.TvSeries) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    null,
                    description,
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    null,
                    description,
                )
            }
            else -> null
        }
    }
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val soup = app.get(data).text
         fetchUrls(soup).apmap {
             val urlc = it.replace("https://pelismart.com/p/1.php?v=","https://evoload.io/e/")
             .replace("https://pelismart.com/p/2.php?v=","https://streamtape.com/e/")
             .replace("https://pelismart.com/p/4.php?v=","https://dood.to/e/")
             .replace("https://pelismarthd.com/p/1.php?v=","https://evoload.io/e/")
             .replace("https://pelismarthd.com/p/2.php?v=","https://streamtape.com/e/")
             .replace("https://pelismarthd.com/p/4.php?v=","https://dood.to/e/")
             loadExtractor(urlc, data, subtitleCallback, callback)
         }
        return true
    }
}


================================================
FILE: PeliSmartProvider/src/main/kotlin/com/lagradost/PeliSmartProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PeliSmartProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PeliSmartProvider())
    }
}


================================================
FILE: PelisplusHDProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PelisplusHDProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PelisplusHDProvider/src/main/kotlin/com/lagradost/PelisplusHDProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class PelisplusHDProvider:MainAPI() {
    override var mainUrl = "https://pelisplushd.net"
    override var name = "PelisplusHD"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val document = app.get(mainUrl).document
        val map = mapOf(
            "Películas" to "#default-tab-1",
            "Series" to "#default-tab-2",
            "Anime" to "#default-tab-3",
            "Doramas" to "#default-tab-4",
        )
        map.forEach {
            items.add(HomePageList(
                it.key,
                document.select(it.value).select("a.Posters-link").map { element ->
                    element.toSearchResult()
                }
            ))
        }
        return HomePageResponse(items)
    }
    private fun Element.toSearchResult(): SearchResponse {
        val title = this.select(".listing-content p").text()
        val href = this.select("a").attr("href")
        val posterUrl = this.select(".Posters-img").attr("src")
        val isMovie = href.contains("/pelicula/")
        return if (isMovie) {
            MovieSearchResponse(
                title,
                href,
                name,
                TvType.Movie,
                posterUrl,
                null
            )
        } else {
            TvSeriesSearchResponse(
                title,
                href,
                name,
                TvType.Movie,
                posterUrl,
                null,
                null
            )
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "https://pelisplushd.net/search?s=${query}"
        val document = app.get(url).document

        return document.select("a.Posters-link").map {
            val title = it.selectFirst(".listing-content p")!!.text()
            val href = it.selectFirst("a")!!.attr("href")
            val image = it.selectFirst(".Posters-img")!!.attr("src")
            val isMovie = href.contains("/pelicula/")

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            }
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url, timeout = 120).document

        val title = soup.selectFirst(".m-b-5")!!.text()
        val description = soup.selectFirst("div.text-large")?.text()?.trim()
        val poster: String? = soup.selectFirst(".img-fluid")!!.attr("src")
        val episodes = soup.select("div.tab-pane .btn").map { li ->
            val href = li.selectFirst("a")!!.attr("href")
            val name = li.selectFirst(".btn-primary.btn-block")!!.text()
            val seasonid = href.replace("/capitulo/","-")
                .replace(Regex("$mainUrl/.*/.*/temporada/"),"").let { str ->
                    str.split("-").mapNotNull { subStr -> subStr.toIntOrNull() }
                }
            val isValid = seasonid.size == 2
            val episode = if (isValid) seasonid.getOrNull(1) else null
            val season = if (isValid) seasonid.getOrNull(0) else null
            Episode(
                href,
                name,
                season,
                episode,
            )
        }

        val year = soup.selectFirst(".p-r-15 .text-semibold")!!.text().toIntOrNull()
        val tvType = if (url.contains("/pelicula/")) TvType.Movie else TvType.TvSeries
        val tags = soup.select(".p-h-15.text-center a span.font-size-18.text-info.text-semibold")
            .map { it?.text()?.trim().toString().replace(", ","") }

        return when (tvType) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    year,
                    description,
                    null,
                    null,
                    tags,
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    poster,
                    year,
                    description,
                    null,
                    tags,
                )
            }
            else -> null
        }
    }
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("div.player > script").map { script ->
            fetchUrls(script.data().replace("https://pelisplushd.net/fembed.php?url=","https://www.fembed.com/v/")).apmap {
                loadExtractor(it, data, subtitleCallback, callback)
            }
        }
        return true
    }
}



================================================
FILE: PelisplusHDProvider/src/main/kotlin/com/lagradost/PelisplusHDProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PelisplusHDProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PelisplusHDProvider())
    }
}


================================================
FILE: PelisplusProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":PelisplusProviderTemplate")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PelisplusProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PelisplusProvider/src/main/kotlin/com/lagradost/PelisplusProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.TvType

/** Needs to inherit from MainAPI() to
 * make the app know what functions to call
 */ 
class PelisplusProvider : PelisplusProviderTemplate() {
    // mainUrl is good to have as a holder for the url to make future changes easier.
    override var mainUrl = "https://pelisplus.icu"

    // name is for how the provider will be named which is visible in the UI, no real rules for this.
    override var name = "Pelisplus"

    override val homePageUrlList = listOf(
        mainUrl,
        "$mainUrl/movies",
        "$mainUrl/series",
        "$mainUrl/new-season",
        "$mainUrl/popular"
    )

    // This is just extra metadata about what type of movies the provider has.
    // Needed for search functionality.
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie)
}



================================================
FILE: PelisplusProvider/src/main/kotlin/com/lagradost/PelisplusProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PelisplusProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PelisplusProvider())
    }
}


================================================
FILE: PelisplusProviderTemplate/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PelisplusProviderTemplate/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PelisplusProviderTemplate/src/main/kotlin/com/lagradost/PelisplusProviderTemplate.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.Jsoup


/** Needs to inherit from MainAPI() to
 * make the app know what functions to call
 */

open class PelisplusProviderTemplate : MainAPI() {
    override var lang = "es"
    open val homePageUrlList = listOf<String>()

//    // mainUrl is good to have as a holder for the url to make future changes easier.
//    override val mainUrl: String
//        get() = "https://vidembed.cc"
//
//    // name is for how the provider will be named which is visible in the UI, no real rules for this.
//    override val name: String
//        get() = "VidEmbed"

    // hasQuickSearch defines if quickSearch() should be called, this is only when typing the searchbar
    // gives results on the site instead of bringing you to another page.
    // if hasQuickSearch is true and quickSearch() hasn't been overridden you will get errors.
    // VidEmbed actually has quick search on their site, but the function wasn't implemented.
    override val hasQuickSearch = false

    // If getMainPage() is functional, used to display the homepage in app, an optional, but highly encouraged endevour.
    override val hasMainPage = true

    // Searching returns a SearchResponse, which can be one of the following: AnimeSearchResponse, MovieSearchResponse, TorrentSearchResponse, TvSeriesSearchResponse
    // Each of the classes requires some different data, but always has some critical things like name, poster and url.

    override suspend fun search(query: String): ArrayList<SearchResponse> {
        // Simply looking at devtools network is enough to spot a request like:
        // https://vidembed.cc/search.html?keyword=neverland where neverland is the query, can be written as below.
        val link = "$mainUrl/search.html?keyword=$query"
        val html = app.get(link).text
        val soup = Jsoup.parse(html)

        return ArrayList(soup.select(".listing.items > .video-block").map { li ->
            // Selects the href in <a href="...">
            val href = fixUrl(li.selectFirst("a")!!.attr("href"))
            val poster = fixUrl(li.selectFirst("img")!!.attr("src"))

            // .text() selects all the text in the element, be careful about doing this while too high up in the html hierarchy
            val title = cleanName(li.selectFirst(".name")!!.text())
            // Use get(0) and toIntOrNull() to prevent any possible crashes, [0] or toInt() will error the search on unexpected values.
            val year = li.selectFirst(".date")?.text()?.split("-")?.get(0)?.toIntOrNull()

            TvSeriesSearchResponse(
                // .trim() removes unwanted spaces in the start and end.
                if (!title.contains("Episode")) title else title.split("Episode")[0].trim(),
                href,
                this.name,
                TvType.TvSeries,
                poster, year,
                // You can't get the episodes from the search bar.
                null
            )
        })
    }


    // Load, like the name suggests loads the info page, where all the episodes and data usually is.
    // Like search you should return either of: AnimeLoadResponse, MovieLoadResponse, TorrentLoadResponse, TvSeriesLoadResponse.
    override suspend fun load(url: String): LoadResponse? {
        // Gets the url returned from searching.
        val html = app.get(url).text
        val soup = Jsoup.parse(html)

        val title = cleanName(soup.selectFirst("h1,h2,h3")!!.text())
        val description = soup.selectFirst(".post-entry")?.text()?.trim()
        val poster = soup.selectFirst("head meta[property=og:image]")!!.attr("content")

        var year : Int? = null
        val episodes = soup.select(".listing.items.lists > .video-block").map { li ->
            val href = fixUrl(li.selectFirst("a")!!.attr("href"))
            val regexseason = Regex("(-[Tt]emporada-(\\d+)-[Cc]apitulo-(\\d+))")
            val aaa = regexseason.find(href)?.destructured?.component1()?.replace(Regex("(-[Tt]emporada-|[Cc]apitulo-)"),"")
            val seasonid = aaa.let { str ->
                str?.split("-")?.mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val isValid = seasonid?.size == 2
            val episode = if (isValid) seasonid?.getOrNull(1) else null
            val season = if (isValid) seasonid?.getOrNull(0) else null
            val epThumb = fixUrl(li.selectFirst("img")!!.attr("src"))
            val epDate = li.selectFirst(".meta > .date")!!.text()

            if(year == null) {
                year = epDate?.split("-")?.get(0)?.toIntOrNull()
            }

            newEpisode(li.selectFirst("a")!!.attr("href")) {
                this.season = season
                this.episode = episode
                this.posterUrl = epThumb
                addDate(epDate)
            }
        }.reversed()

        // Make sure to get the type right to display the correct UI.
        val tvType = if (episodes.size == 1 && episodes[0].name == title) TvType.Movie else TvType.TvSeries

        return when (tvType) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    fixUrl(poster),
                    year,
                    description,
                    null,
                    null,
                    null
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes[0].data,
                    fixUrl(poster),
                    year,
                    description,
                    null,
                    null
                )
            }
            else -> null
        }
    }

    // This loads the homepage, which is basically a collection of search results with labels.
    // Optional function, but make sure to enable hasMainPage if you program this.
    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val urls = homePageUrlList
        val homePageList = ArrayList<HomePageList>()
        // .pmap {} is used to fetch the different pages in parallel
        urls.apmap { url ->
            val response = app.get(url, timeout = 20).text
            val document = Jsoup.parse(response)
            document.select("div.main-inner")?.forEach { inner ->
                // Always trim your text unless you want the risk of spaces at the start or end.
                val title = cleanName(inner.select(".widget-title").text())
                val elements = inner.select(".video-block").map {
                    val link = fixUrl(it.select("a").attr("href"))
                    val image = it.select(".picture > img").attr("src").replace("//img", "https://img")
                    val name = cleanName(it.select("div.name").text())
                    val isSeries = (name.contains("Temporada") || name.contains("Capítulo"))

                    if (isSeries) {
                        TvSeriesSearchResponse(
                            name,
                            link,
                            this.name,
                            TvType.TvSeries,
                            image,
                            null,
                            null,
                        )
                    } else {
                        MovieSearchResponse(
                            name,
                            link,
                            this.name,
                            TvType.Movie,
                            image,
                            null,
                            null,
                        )
                    }
                }

                homePageList.add(
                    HomePageList(
                        title, elements
                    )
                )

            }

        }
        return HomePageResponse(homePageList)
    }


    private fun cleanName(input: String): String = input.replace(Regex("([Tt]emporada (\\d+)|[Cc]apítulo (\\d+))|[Tt]emporada|[Cc]apítulo"),"").trim()


    private suspend fun getPelisStream(
        link: String,
        callback: (ExtractorLink) -> Unit) : Boolean {
        val soup = app.get(link).text
        val m3u8regex = Regex("((https:|http:)\\/\\/.*m3u8.*expiry=(\\d+))")
        val m3u8 = m3u8regex.find(soup)?.value ?: return false

        M3u8Helper.generateM3u8(
            name,
            m3u8,
            mainUrl,
            headers = mapOf("Referer" to mainUrl)
        ).forEach (callback)

        return true
    }

    // loadLinks gets the raw .mp4 or .m3u8 urls from the data parameter in the episodes class generated in load()
    // See Episode(...) in this provider.
    // The data are usually links, but can be any other string to help aid loading the links.
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        // These callbacks are functions you should call when you get a link to a subtitle file or media file.
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document
        val info = doc.select("div.tabs-video li").text()
        if (info.contains("Latino")) {
            doc.select(".server-item-1 li").apmap {
                val serverid = fixUrl(it.attr("data-video")).replace("streaming.php","play")
                loadExtractor(serverid, data, subtitleCallback, callback)
                if (serverid.contains("pelisplus.icu")) {
                    getPelisStream(serverid, callback)
                }
            }
        }

        if (info.contains("Subtitulado")) {
            doc.select(".server-item-0 li").apmap {
                val serverid = fixUrl(it.attr("data-video")).replace("streaming.php","play")
                loadExtractor(serverid, data, subtitleCallback, callback)
                if (serverid.contains("pelisplus.icu")) {
                    getPelisStream(serverid, callback)
                }
            }
        }

        if (info.contains("Castellano")) {
            doc.select(".server-item-2 li").apmap {
                val serverid = fixUrl(it.attr("data-video")).replace("streaming.php","play")
                loadExtractor(serverid, data, subtitleCallback, callback)
                if (serverid.contains("pelisplus.icu")) {
                    getPelisStream(serverid, callback)
                }
            }
        }
        return true
    }
}



================================================
FILE: PelisplusProviderTemplate/src/main/kotlin/com/lagradost/PelisplusProviderTemplatePlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PelisplusProviderTemplatePlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PelisplusProviderTemplate())
    }
}


================================================
FILE: PhimmoichillProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PhimmoichillProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PhimmoichillProvider/src/main/kotlin/com/lagradost/PhimmoichillProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.*
import org.jsoup.nodes.Element
import java.net.URLDecoder
import java.util.ArrayList

class PhimmoichillProvider : MainAPI() {
    override var mainUrl = "https://phimmoichill.net"
    override var name = "Phimmoichill"
    override val hasMainPage = true
    override var lang = "vi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AsianDrama
    )

    override val mainPage = mainPageOf(
        "$mainUrl/genre/phim-chieu-rap/page-" to "Phim Chiếu Rạp",
        "$mainUrl/list/phim-le/page-" to "Phim Lẻ",
        "$mainUrl/list/phim-bo/page-" to "Phim Bộ",
        "$mainUrl/genre/phim-hoat-hinh/page-" to "Phim Hoạt Hình",
        "$mainUrl/country/phim-han-quoc/page-" to "Phim Hàn Quốc",
        "$mainUrl/country/phim-trung-quoc/page-" to "Phim Trung Quốc",
        "$mainUrl/country/phim-thai-lan/page-" to "Phim Thái Lan",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).document
        val home = document.select("li.item").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun decode(input: String): String? = URLDecoder.decode(input, "utf-8")

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.selectFirst("p,h3")?.text()?.trim().toString()
        val href = fixUrl(this.selectFirst("a")!!.attr("href"))
        val posterUrl = decode(this.selectFirst("img")!!.attr("src").substringAfter("url="))
        val temp = this.select("span.label").text()
        return if (temp.contains(Regex("\\d"))) {
            val episode = Regex("(\\((\\d+))|(\\s(\\d+))").find(temp)?.groupValues?.map { num ->
                num.replace(Regex("\\(|\\s"), "")
            }?.distinct()?.firstOrNull()?.toIntOrNull()
            newAnimeSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                addSub(episode)
            }
        } else {
            val quality =
                temp.replace(Regex("(-.*)|(\\|.*)|(?i)(VietSub.*)|(?i)(Thuyết.*)"), "").trim()
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                addQuality(quality)
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/tim-kiem/$query"
        val document = app.get(link).document

        return document.select("ul.list-film li").map {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title = document.selectFirst("h1[itemprop=name]")?.text()?.trim().toString()
        val link = document.select("ul.list-button li:last-child a").attr("href")
        val poster = document.selectFirst("div.image img[itemprop=image]")?.attr("src")
        val tags = document.select("ul.entry-meta.block-film li:nth-child(4) a").map { it.text() }
        val year = document.select("ul.entry-meta.block-film li:nth-child(2) a").text().trim()
            .toIntOrNull()
        val tvType = if (document.select("div.latest-episode").isNotEmpty()
        ) TvType.TvSeries else TvType.Movie
        val description = document.select("div#film-content-wrapper").text().trim()
        val trailer =
            document.select("div#trailer script").last()?.data()?.substringAfter("file: \"")
                ?.substringBefore("\",")
        val rating =
            document.select("ul.entry-meta.block-film li:nth-child(7) span").text().toRatingInt()
        val actors = document.select("ul.entry-meta.block-film li:last-child a").map { it.text() }
        val recommendations = document.select("ul#list-film-realted li.item").map {
            it.toSearchResult()
        }

        return if (tvType == TvType.TvSeries) {
            val docEpisodes = app.get(link).document
            val episodes = docEpisodes.select("ul#list_episodes > li").map {
                val href = it.select("a").attr("href")
                val episode =
                    it.select("a").text().replace(Regex("[^0-9]"), "").trim().toIntOrNull()
                val name = "Episode $episode"
                Episode(
                    data = href,
                    name = name,
                    episode = episode,
                )
            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, link) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val document = app.get(data).document

        val key = document.select("div#content script").mapNotNull { script ->
            if (script.data().contains("filmInfo.episodeID =")) {
                val id = script.data().substringAfter("filmInfo.episodeID = parseInt('")
                    .substringBefore("');")
                app.post(
                    url = "$mainUrl/pmplayer.php",
                    data = mapOf("qcao" to id),
                    referer = data,
                    headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                ).text.substringAfterLast("iniPlayers(\"").substringBefore("\",")
            } else {
                null
            }
        }.first()

        listOf(
            Pair("https://so-trym.topphimmoi.org/hlspm/$key", "PMFAST"),
            Pair("https://dash.megacdn.xyz/hlspm/$key", "PMHLS"),
            Pair("https://dash.megacdn.xyz/dast/$key/index.m3u8", "PMBK")
        ).apmap { (link, source) ->
            safeApiCall {
                if (source == "PMBK") {
                    callback.invoke(
                        ExtractorLink(
                            source,
                            source,
                            link,
                            referer = "$mainUrl/",
                            quality = Qualities.P1080.value,
                            isM3u8 = true
                        )
                    )
                } else {
                    val playList = app.get(link, referer = "$mainUrl/")
                        .parsedSafe<ResponseM3u>()?.main?.segments?.map { segment ->
                            PlayListItem(
                                segment.link,
                                (segment.du.toFloat() * 1_000_000).toLong()
                            )
                        }

                    callback.invoke(
                        ExtractorLinkPlayList(
                            source,
                            source,
                            playList ?: return@safeApiCall,
                            referer = "$mainUrl/",
                            quality = Qualities.P1080.value,
                            headers = mapOf(
//                                "If-None-Match" to "*",
                                "Origin" to mainUrl,
                            )
                        )
                    )
                }
            }
        }
        return true
    }

    data class Segment(
        @JsonProperty("du") val du: String,
        @JsonProperty("link") val link: String,
    )

    data class DataM3u(
        @JsonProperty("segments") val segments: List<Segment>?,
    )

    data class ResponseM3u(
        @JsonProperty("2048p") val main: DataM3u?,
    )

}


================================================
FILE: PhimmoichillProvider/src/main/kotlin/com/lagradost/PhimmoichillProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PhimmoichillProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PhimmoichillProvider())
    }
}


================================================
FILE: PinoyHDXyzProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PinoyHDXyzProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PinoyHDXyzProvider/src/main/kotlin/com/lagradost/PinoyHDXyzProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class PinoyHDXyzProvider : MainAPI() {
    override var name = "Pinoy-HD"
    override var mainUrl = "https://www.pinoy-hd.xyz"
    override var lang = "tl"
    override val supportedTypes = setOf(TvType.AsianDrama)
    override val hasDownloadSupport = true
    override val hasMainPage = true
    override val hasQuickSearch = false

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val all = ArrayList<HomePageList>()
        val document = app.get(mainUrl, referer = mainUrl).document
        val mainbody = document.getElementsByTag("body")

        mainbody.select("div.section-cotent.col-md-12.bordert").forEach { row ->
            val title = row?.select("div.title-section.tt")?.text() ?: "<Row>"
            val elements = row?.select("li.img_frame.preview-tumb7")?.mapNotNull {
                // Get inner div from article
                val innerBody = it?.selectFirst("a") ?: return@mapNotNull null
                // Fetch details
                val name = it.text().trim()
                if (name.isBlank()) {
                    return@mapNotNull null
                }

                val link = innerBody.attr("href") ?: return@mapNotNull null
                val image = fixUrlNull(innerBody.select("img").attr("src"))
                //Log.i(this.name, "Result => (innerBody, image) ${innerBody} / ${image}")
                // Get Year from Link
                val rex = Regex("_(\\d+)_")
                val year = rex.find(link)?.value?.replace("_", "")?.toIntOrNull()
                //Log.i(this.name, "Result => (yearRes, year) ${yearRes} / ${year}")
                MovieSearchResponse(
                    name = name,
                    url = link,
                    apiName = this.name,
                    type = TvType.Movie,
                    posterUrl = image,
                    year = year
                )
            }?.distinctBy { c -> c.url } ?: listOf()
            // Add to Homepage
            if (elements.isNotEmpty()) {
                all.add(
                    HomePageList(
                        title, elements
                    )
                )
            }
        }
        return HomePageResponse(all)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search/?q=${query.replace(" ", "+")}"
        val document = app.get(url).document.select("div.portfolio-thumb")
        return document.mapNotNull {
            if (it == null) {
                return@mapNotNull null
            }
            val link = it.selectFirst("a")?.attr("href") ?: return@mapNotNull null
            val title = it.text() ?: ""
            val year = null
            val image = null // site provides no image on search page

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                type = TvType.Movie,
                posterUrl = image,
                year = year
            )
        }.distinctBy { c -> c.url }
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val body = doc.getElementsByTag("body")
        val inner = body.select("div.info")

        // Video links
        val listOfLinks: MutableList<String> = mutableListOf()

        // Video details
        var title = ""
        var year: Int? = null
        var tags: List<String>? = null
        val poster = fixUrlNull(inner.select("div.portfolio-tumb.ph-link > img").attr("src"))
        //Log.i(this.name, "Result => (imgLinkCode) ${imgLinkCode}")
        inner.select("table").select("tr").forEach {
            val td = it?.select("td") ?: return@forEach
            val caption = td[0].text().lowercase()
            //Log.i(this.name, "Result => (caption) $caption")
            when (caption) {
                "name" -> {
                    title = td[1].text()
                }
                "year" -> {
                    var yearRes = td[1].toString()
                    year = if (yearRes.isNotBlank()) {
                        if (yearRes.contains("var year =")) {
                            yearRes =
                                yearRes.substring(yearRes.indexOf("var year =") + "var year =".length)
                            //Log.i(this.name, "Result => (yearRes) $yearRes")
                            yearRes = yearRes.substring(0, yearRes.indexOf(';'))
                                .trim().removeSurrounding("'")
                        }
                        yearRes.toIntOrNull()
                    } else {
                        null
                    }
                }
                "genre" -> {
                    tags = td[1].select("a").mapNotNull { tag ->
                        tag?.text()?.trim() ?: return@mapNotNull null
                    }.filter { a -> a.isNotBlank() }
                }
            }
        }

        var descript = body.select("div.eText").text()
        if (!descript.isNullOrEmpty()) {
            try {
                descript = "(undefined_x_Polus+[.\\d+])".toRegex().replace(descript, "")
                descript = "(_x_Polus+[.\\d+])".toRegex().replace(descript, "")
                descript = descript.trim().removeSuffix("undefined").trim()
            } catch (e: java.lang.Exception) {
            }
        }
        // Add links hidden in description
        listOfLinks.addAll(fetchUrls(descript))
        listOfLinks.forEach { link ->
            //Log.i(this.name, "Result => (hidden link) $link")
            descript = descript.replace(link, "")
        }

        // Try looking for episodes, for series
        val episodeList = ArrayList<Episode>()
        val bodyText = body.select("div.section-cotent1.col-md-12").select("section")
            .select("script").toString()
        //Log.i(this.name, "Result => (bodyText) ${bodyText}")

        "(?<=ses=\\(')(.*)(?='\\).split)".toRegex().find(bodyText)?.groupValues?.get(0).let {
            if (!it.isNullOrEmpty()) {
                var count = 0
                it.split(", ").forEach { ep ->
                    count++
                    val listEpStream = listOf(ep.trim()).toJson()
                    //Log.i(this.name, "Result => (ep $count) $listEpStream")
                    episodeList.add(
                        Episode(
                            name = null,
                            season = null,
                            episode = count,
                            data = listEpStream,
                            posterUrl = null,
                            date = null
                        )
                    )
                }
            }
        }
        if (episodeList.size > 0) {
            return TvSeriesLoadResponse(
                name = title,
                url = url,
                apiName = this.name,
                type = TvType.AsianDrama,
                episodes = episodeList,
                posterUrl = poster,
                year = year,
                plot = descript,
                tags = tags
            )
        }

        // Video links for Movie
        body.select("div.tabcontent > iframe").forEach {
            val linkMain = it?.attr("src")
            if (!linkMain.isNullOrEmpty()) {
                listOfLinks.add(linkMain)
                //Log.i(this.name, "Result => (linkMain) $linkMain")
            }
        }
        body.select("div.tabcontent.hide > iframe").forEach {
            val linkMain = it?.attr("src")
            if (!linkMain.isNullOrEmpty()) {
                listOfLinks.add(linkMain)
                //Log.i(this.name, "Result => (linkMain hide) $linkMain")
            }
        }

        val extraLinks = body.select("div.tabcontent.hide").text()
        listOfLinks.addAll(fetchUrls(extraLinks))

        val streamLinks = listOfLinks.distinct().toJson()
        //Log.i(this.name, "Result => (streamLinks) streamLinks")
        return MovieLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.Movie,
            dataUrl = streamLinks,
            posterUrl = poster,
            year = year,
            plot = descript,
            tags = tags
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        var count = 0
        parseJson<List<String>>(data).forEach { item ->
            val url = item.trim()
            if (url.isNotBlank()) {
                if (loadExtractor(url, mainUrl, subtitleCallback, callback)) {
                    count++
                }
            }
        }
        return count > 0
    }
}


================================================
FILE: PinoyHDXyzProvider/src/main/kotlin/com/lagradost/PinoyHDXyzProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PinoyHDXyzProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PinoyHDXyzProvider())
    }
}


================================================
FILE: PinoyMoviePediaProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":WatchAsianProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PinoyMoviePediaProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PinoyMoviePediaProvider/src/main/kotlin/com/lagradost/PinoyMoviePediaProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
//import com.lagradost.cloudstream3.extractors.FEmbed
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class PinoyMoviePediaProvider : MainAPI() {
    override var name = "Pinoy Moviepedia"
    override var mainUrl = "https://pinoymoviepedia.ru"
    override var lang = "tl"
    override val supportedTypes = setOf(TvType.AsianDrama)
    override val hasDownloadSupport = true
    override val hasMainPage = true
    override val hasQuickSearch = false

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val all = ArrayList<HomePageList>()
        val document = app.get(mainUrl).document
        val mainbody = document.getElementsByTag("body")
        // All rows will be hardcoded bc of the nature of the site
        val rows: List<Pair<String, String>> = listOf(
            Pair("Latest Movies", "featured-titles"),
            Pair("Movies", "dt-movies"),
            Pair("Digitally Restored", "genre_digitally-restored"),
            Pair("Action", "genre_action"),
            Pair("Romance", "genre_romance"),
            Pair("Comedy", "genre_comedy"),
            Pair("Family", "genre_family")
            //Pair("Adult +18", "genre_pinay-sexy-movies")
        )
        rows.forEach { item ->
            val title = item.first
            val inner = mainbody?.select("div#${item.second} > article")

            val elements: List<SearchResponse> = inner?.mapNotNull {
                if (it == null) { return@mapNotNull null }

                // Get inner div from article
                val urlTitle = it.select("div.data") ?: return@mapNotNull null
                // Fetch details
                val link = fixUrlNull(urlTitle.select("a")?.attr("href")) ?: return@mapNotNull null
                val image = it.select("div.poster > img")?.attr("src")

                // Get Title and Year
                val titleYear = it.select("div.data.dfeatur")
                var name = titleYear?.select("h3")?.text() ?: ""
                var year = titleYear?.select("span")?.text()?.toIntOrNull()

                if (name.isEmpty()) {
                    name = urlTitle.select("h3")?.text() ?: ""
                    year = titleYear?.select("span")?.text()?.takeLast(4)?.toIntOrNull()
                }
                // Get year from name
                if (year == null) {
                    val rex = Regex("\\((\\d+)")
                    year = rex.find(name)?.value?.replace("(", "")?.toIntOrNull()
                }
                //Get quality
                val qual = getQualityFromString(it.selectFirst("span.quality")?.text())

                MovieSearchResponse(
                    name = name,
                    url = link,
                    apiName = this.name,
                    TvType.Movie,
                    posterUrl = image,
                    year = year,
                    quality = qual
                )
            }?.distinctBy { c -> c.url } ?: listOf()
            // Add
            all.add(
                HomePageList(
                    title, elements
                )
            )
        }
        return HomePageResponse(all.filter { a -> a.list.isNotEmpty() })
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=${query}"
        val document = app.get(url).document.selectFirst("div.search-page")
            ?.select("div.result-item")

        return document?.mapNotNull {
            val inner = it.select("article") ?: return@mapNotNull null
            val details = inner.select("div.details") ?: return@mapNotNull null
            val link = fixUrlNull(details.select("div.title > a")?.attr("href")) ?: return@mapNotNull null

            val title = details.select("div.title")?.text() ?: ""
            val year = details.select("div.meta > span.year")?.text()?.toIntOrNull()
            val image = inner.select("div.image > div > a > img")?.attr("src")
            val qual = getQualityFromString(it.selectFirst("span.quality")?.text())

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                TvType.Movie,
                posterUrl = image,
                year = year,
                quality = qual
            )
        }?.distinctBy { c -> c.url } ?: listOf()
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val body = doc.getElementsByTag("body")
        val inner = body?.select("div.sheader")
        // Identify if movie or series
        val isTvSeries = doc.select("title")?.text()?.lowercase()?.contains("full episode -") ?: false

        // Video details
        val data = inner?.select("div.data")
        val poster = inner?.select("div.poster > img")?.attr("src")
        val title = data?.select("h1")?.firstOrNull()?.text()?.trim() ?: ""
        val descript = body?.select("div#info > div.wp-content p")?.firstOrNull()?.text()
        val rex = Regex("\\((\\d+)")
        val yearRes = rex.find(title)?.value ?: ""
        //Log.i(this.name, "Result => (yearRes) ${yearRes}")
        val year = yearRes.replace("(", "").toIntOrNull()
        val tags = data?.select("div.sgeneros > a")?.mapNotNull { tag ->
            tag?.text()?.trim() ?: return@mapNotNull null
        }?.toList()
        val recList = body?.select("div#single_relacionados > article")?.mapNotNull {
            val a = it.select("a") ?: return@mapNotNull null
            val aUrl = a.attr("href") ?: return@mapNotNull null
            val aImg = a.select("img")?.attr("src")
            val aName = a.select("img")?.attr("alt") ?: return@mapNotNull null
            val aYear = try {
                aName.trim().takeLast(5).removeSuffix(")").toIntOrNull()
            } catch (e: Exception) { null }

            MovieSearchResponse(
                url = aUrl,
                name = aName,
                type = TvType.Movie,
                posterUrl = aImg,
                year = aYear,
                apiName = this.name
            )
        }

        // Video links
        val playcontainer = body?.select("div#playcontainer")
        val listOfLinks: MutableList<String> = mutableListOf()
        playcontainer?.select("iframe")?.forEach { item ->
            val lnk = item?.attr("src")?.trim() ?: ""
            //Log.i(this.name, "Result => (lnk) $lnk")
            if (lnk.isNotEmpty()) {
                listOfLinks.add(lnk)
            }
        }

        // Parse episodes if series
        if (isTvSeries) {
            val episodeList = ArrayList<Episode>()
            val epLinks = playcontainer?.select("div > div > div.source-box")
            //Log.i(this.name, "Result => (epList) ${epList}")
            body?.select("div#playeroptions > ul > li")?.forEach { ep ->
                val epTitle = ep.select("span.title")?.text()
                if (!epTitle.isNullOrEmpty()) {
                    val epNum = epTitle.lowercase().replace("episode", "").trim().toIntOrNull()
                    //Log.i(this.name, "Result => (epNum) ${epNum}")
                    val href = when (epNum != null && !epLinks.isNullOrEmpty()) {
                        true -> epLinks.select("div#source-player-$epNum")
                            ?.select("iframe")?.attr("src") ?: ""
                        false -> ""
                    }
                    val streamEpLink = listOf(href.trim()).toJson()
                    //Log.i(this.name, "Result => (streamEpLink $epNum) $streamEpLink")
                    episodeList.add(
                        Episode(
                            name = null,
                            season = null,
                            episode = epNum,
                            data = streamEpLink,
                            posterUrl = poster,
                            date = null
                        )
                    )
                }
            }
            return TvSeriesLoadResponse(
                name = title,
                url = url,
                apiName = this.name,
                type = TvType.AsianDrama,
                episodes = episodeList,
                posterUrl = poster,
                year = year,
                plot = descript,
                tags = tags,
                recommendations = recList
            )
        }
        val streamlinks = listOfLinks.distinct().toJson()
        return MovieLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.Movie,
            dataUrl = streamlinks,
            posterUrl = poster,
            year = year,
            plot = descript,
            tags = tags,
            recommendations = recList
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        // parse movie servers
        var count = 0
        tryParseJson<List<String>>(data)?.apmap { link ->
            count++
            if (link.contains("fembed.com")) {
                val extractor = FEmbed()
                extractor.domainUrl = "diasfem.com"
                extractor.getUrl(data).forEach {
                    callback.invoke(it)
                }
            } else {
                loadExtractor(link, mainUrl, subtitleCallback, callback)
            }
        }
        return count > 0
    }
}


================================================
FILE: PinoyMoviePediaProvider/src/main/kotlin/com/lagradost/PinoyMoviePediaProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PinoyMoviePediaProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PinoyMoviePediaProvider())
    }
}


================================================
FILE: PinoyMoviesEsProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":WatchAsianProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: PinoyMoviesEsProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: PinoyMoviesEsProvider/src/main/kotlin/com/lagradost/PinoyMoviesEsProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
//import com.lagradost.cloudstream3.extractors.FEmbed
//import com.lagradost.cloudstream3.extractors.helper.VstreamhubHelper
import com.lagradost.cloudstream3.network.DdosGuardKiller
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.select.Elements

class PinoyMoviesEsProvider : MainAPI() {
    override var name = "Pinoy Movies"
    override var mainUrl = "https://pinoymovies.es"
    override var lang = "tl"
    override val supportedTypes = setOf(TvType.AsianDrama)
    override val hasDownloadSupport = false
    override val hasMainPage = true
    override val hasQuickSearch = false

    data class EmbedUrl(
        @JsonProperty("embed_url") val embed_url: String,
        @JsonProperty("type") val type: String
    )

    private fun getRowElements(
        mainbody: Elements,
        rows: List<Pair<String, String>>,
        sep: String
    ): MutableList<HomePageList> {
        val all = mutableListOf<HomePageList>()
        for (item in rows) {
            val title = item.first
            val elements = mainbody.select("div${sep}${item.second} > article")?.mapNotNull {
                // Get inner div from article
                var urlTitle = it?.select("div.data.dfeatur")
                if (urlTitle.isNullOrEmpty()) {
                    urlTitle = it?.select("div.data")
                }
                if (urlTitle.isNullOrEmpty()) {
                    return@mapNotNull null
                }
                // Fetch details
                val link = fixUrlNull(urlTitle.select("a")?.attr("href"))
                if (link.isNullOrBlank()) {
                    return@mapNotNull null
                }

                val image = it?.select("div.poster > img")?.attr("data-src")

                // Get Title and Year
                val name = urlTitle.select("h3")?.text()
                    ?: urlTitle.select("h2")?.text()
                    ?: urlTitle.select("h1")?.text()
                if (name.isNullOrBlank()) {
                    return@mapNotNull null
                }

                var year = urlTitle.select("span")?.text()?.toIntOrNull()

                if (year == null) {
                    // Get year from name
                    val rex = Regex("\\((\\d+)")
                    year = rex.find(name)?.value?.replace("(", "")?.toIntOrNull()
                }
                //Log.i(this.name, "ApiError -> ${it.selectFirst("span.quality")?.text()}")
                val searchQual = getQualityFromString(it.selectFirst("span.quality")?.text())

                MovieSearchResponse(
                    name = name,
                    url = link,
                    apiName = this.name,
                    type = TvType.Movie,
                    posterUrl = image,
                    year = year,
                    quality = searchQual
                )
            }?.distinctBy { c -> c.url } ?: listOf()
            //Add to list of homepages
            if (!elements.isNullOrEmpty()) {
                all.add(
                    HomePageList(
                        title, elements
                    )
                )
            }
        }
        return all
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val all = ArrayList<HomePageList>()
        val document = app.get(mainUrl).document
        val mainbody = document.getElementsByTag("body")
        if (mainbody != null) {
            // All rows will be hardcoded bc of the nature of the site
            val homepage1 = getRowElements(
                mainbody, listOf(
                    Pair("Suggestion", "items.featured"),
                    Pair("All Movies", "items.full")
                ), "."
            )
            if (homepage1.isNotEmpty()) {
                all.addAll(homepage1)
            }
            //2nd rows
            val homepage2 = getRowElements(
                mainbody, listOf(
                    Pair("Action", "genre_action"),
                    Pair("Comedy", "genre_comedy"),
                    Pair("Romance", "genre_romance"),
                    Pair("Horror", "genre_horror")
                    //Pair("Rated-R", "genre_rated-r")
                ), "#"
            )
            if (homepage2.isNotEmpty()) {
                all.addAll(homepage2)
            }
        }
        return HomePageResponse(all)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=${query.replace(" ", "+")}"
        val document = app.get(url, interceptor = DdosGuardKiller(true))
            .document.select("div#archive-content > article")

        return document?.mapNotNull {
            // Fetch details
            val urlTitle = it?.select("div.data") ?: return@mapNotNull null
            val link = urlTitle.select("a")?.attr("href") ?: return@mapNotNull null
            val title = urlTitle.text()?.trim() ?: "<No Title>"
            val year = urlTitle.select("span.year")?.text()?.toIntOrNull()
            val image = it.select("div.poster > img")?.attr("src")
            val searchQual = getQualityFromString(it.selectFirst("span.quality")?.text())

            MovieSearchResponse(
                name = title,
                url = link,
                apiName = this.name,
                type = TvType.Movie,
                posterUrl = image,
                year = year,
                quality = searchQual
            )
        }?.distinctBy { it.url } ?: listOf()
    }

    override suspend fun load(url: String): LoadResponse {
        val doc = app.get(url).document
        val body = doc.getElementsByTag("body")
        val inner = body?.select("div.sheader")

        // Video details
        val data = inner?.select("div.sheader > div.data")
        val title = data?.select("h1")?.firstOrNull()?.text() ?: "<Untitled>"
        val year = data?.select("span.date")?.text()?.takeLast(4)?.toIntOrNull()

        val descript = body?.select("div#info > div.wp-content")?.text()
        val poster = body?.select("div.poster > img")?.attr("src")
        val tags = data?.select("div.sgeneros > a")?.mapNotNull { tag ->
            tag?.text() ?: return@mapNotNull null
        }?.toList()
        val recList = body?.select("div#single_relacionados > article")?.mapNotNull {
            val a = it.select("a") ?: return@mapNotNull null
            val aUrl = a.attr("href") ?: return@mapNotNull null
            val aImg = a.select("img")?.attr("data-src")
            val aName = a.select("img")?.attr("alt") ?: return@mapNotNull null
            val aYear = try {
                aName.trim().takeLast(5).removeSuffix(")").toIntOrNull()
            } catch (e: Exception) {
                null
            }
            MovieSearchResponse(
                url = aUrl,
                name = aName,
                type = TvType.Movie,
                posterUrl = aImg,
                year = aYear,
                apiName = this.name
            )
        }

        // Video links
        val listOfLinks: MutableList<String> = mutableListOf()
        val postlist = body?.select("div#playeroptions > ul > li")?.mapNotNull {
            it?.attr("data-post") ?: return@mapNotNull null
        }?.filter { it.isNotBlank() }?.distinct() ?: listOf()

        postlist.apmap { datapost ->
            //Log.i(this.name, "Result => (datapost) ${datapost}")
            val content = mapOf(
                Pair("action", "doo_player_ajax"),
                Pair("post", datapost),
                Pair("nume", "1"),
                Pair("type", "movie")
            )
            val innerPage = app.post(
                "https://pinoymovies.es/wp-admin/admin-ajax.php ",
                referer = url, data = content
            ).document.select("body")?.text()?.trim()
            if (!innerPage.isNullOrBlank()) {
                tryParseJson<EmbedUrl>(innerPage)?.let {
                    listOfLinks.add(it.embed_url)
                }
            }
        }
        return MovieLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.Movie,
            dataUrl = listOfLinks.toJson(),
            posterUrl = poster,
            year = year,
            plot = descript,
            tags = tags,
            recommendations = recList
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        // parse movie servers
        var count = 0
        tryParseJson<List<String>>(data)?.forEach { link ->
            //Log.i(this.name, "Result => (link) $link")
            if (link.startsWith("https://vstreamhub.com")) {
                VstreamhubHelper.getUrls(link, subtitleCallback, callback)
                count++
            } else if (link.contains("fembed.com")) {
                val extractor = FEmbed()
                extractor.domainUrl = "diasfem.com"
                extractor.getUrl(data).forEach {
                    callback.invoke(it)
                    count++
                }
            } else {
                if (loadExtractor(link, mainUrl, subtitleCallback, callback)) {
                    count++
                }
            }
        }
        return count > 0
    }
}



================================================
FILE: PinoyMoviesEsProvider/src/main/kotlin/com/lagradost/PinoyMoviesEsProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class PinoyMoviesEsProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(PinoyMoviesEsProvider())
    }
}


================================================
FILE: PinoyMoviesEsProvider/src/main/kotlin/com/lagradost/VstreamhubHelper.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.loadExtractor

class VstreamhubHelper {
    companion object {
        private val baseUrl: String = "https://vstreamhub.com"
        private val baseName: String = "Vstreamhub"

        suspend fun getUrls(
            url: String,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            if (url.startsWith(baseUrl)) {
                // Fetch links
                val doc = app.get(url).document.select("script")
                doc?.forEach {
                    val innerText = it?.toString()
                    if (!innerText.isNullOrEmpty()) {
                        if (innerText.contains("file:")) {
                            val startString = "file: "
                            val aa = innerText.substring(innerText.indexOf(startString))
                            val linkUrl =
                                aa.substring(startString.length + 1, aa.indexOf("\",")).trim()
                            //Log.i(baseName, "Result => (linkUrl) ${linkUrl}")
                            val exlink = ExtractorLink(
                                name = "$baseName m3u8",
                                source = baseName,
                                url = linkUrl,
                                quality = Qualities.Unknown.value,
                                referer = url,
                                isM3u8 = true
                            )
                            callback.invoke(exlink)
                        }
                        if (innerText.contains("playerInstance")) {
                            val aa =
                                innerText.substring(innerText.indexOf("playerInstance.addButton"))
                            val startString = "window.open(["
                            val bb = aa.substring(aa.indexOf(startString))
                            val datavid = bb.substring(startString.length, bb.indexOf("]"))
                                .removeSurrounding("\"")
                            if (datavid.isNotBlank()) {
                                loadExtractor(datavid, url, subtitleCallback, callback)
                                //Log.i(baseName, "Result => (datavid) ${datavid}")
                            }
                        }
                    }
                }
            }
        }
    }
}


================================================
FILE: RebahinProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: RebahinProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: RebahinProvider/src/main/kotlin/com/lagradost/RebahinProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.network.WebViewResolver
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element
import java.net.URI

class RebahinProvider : MainAPI() {
    override var mainUrl = "http://104.237.198.194"
    override var name = "Rebahin"
    override val hasMainPage = true
    override var lang = "id"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AsianDrama
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val urls = listOf(
            Pair("Featured", "xtab1"),
            Pair("Film Terbaru", "xtab2"),
            Pair("Romance", "xtab3"),
            Pair("Drama", "xtab4"),
            Pair("Action", "xtab5"),
            Pair("Scifi", "xtab6"),
            Pair("Tv Series Terbaru", "stab1"),
            Pair("Anime Series", "stab2"),
            Pair("Drakor Series", "stab3"),
            Pair("West Series", "stab4"),
            Pair("China Series", "stab5"),
            Pair("Japan Series", "stab6"),
        )

        val items = ArrayList<HomePageList>()

        for ((header, tab) in urls) {
            try {
                val home =
                    app.get("$mainUrl/wp-content/themes/indoxxi/ajax-top-$tab.php").document.select(
                        "div.ml-item"
                    ).map {
                        it.toSearchResult()
                    }
                items.add(HomePageList(header, home))
            } catch (e: Exception) {
                logError(e)
            }
        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    private fun Element.toSearchResult(): SearchResponse {
        val title = this.selectFirst("span.mli-info > h2")!!.text().trim()
        val href = this.selectFirst("a")!!.attr("href")
        val type =
            if (this.select("span.mli-quality").isNotEmpty()) TvType.Movie else TvType.TvSeries
        return if (type == TvType.Movie) {
            val posterUrl = this.select("img").attr("src")
            val quality = getQualityFromString(this.select("span.mli-quality").text().trim())
            newMovieSearchResponse(title, href, TvType.Movie) {
                this.posterUrl = posterUrl
                this.quality = quality
            }
        } else {
            val posterUrl =
                this.select("img").attr("src").ifEmpty { this.select("img").attr("data-original") }
            val episode =
                this.select("div.mli-eps > span").text().replace(Regex("[^0-9]"), "").toIntOrNull()
            newAnimeSearchResponse(title, href, TvType.TvSeries) {
                this.posterUrl = posterUrl
                addSub(episode)
            }
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val link = "$mainUrl/?s=$query"
        val document = app.get(link).document

        return document.select("div.ml-item").map {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title = document.selectFirst("h3[itemprop=name]")!!.ownText().trim()
        val poster = document.select(".mvic-desc > div.thumb.mvic-thumb").attr("style")
            .substringAfter("url(").substringBeforeLast(")")
        val tags = document.select("span[itemprop=genre]").map { it.text() }

        val year = Regex("([0-9]{4}?)-").find(
            document.selectFirst(".mvici-right > p:nth-child(3)")!!.ownText().trim()
        )?.groupValues?.get(1).toString().toIntOrNull()
        val tvType = if (url.contains("/series/")) TvType.TvSeries else TvType.Movie
        val description = document.select("span[itemprop=reviewBody] > p").text().trim()
        val trailer = fixUrlNull(document.selectFirst("div.modal-body-trailer iframe")?.attr("src"))
        val rating = document.selectFirst("span[itemprop=ratingValue]")?.text()?.toRatingInt()
        val duration = document.selectFirst(".mvici-right > p:nth-child(1)")!!
            .ownText().replace(Regex("[^0-9]"), "").toIntOrNull()
        val actors = document.select("span[itemprop=actor] > a").map { it.select("span").text() }

        val baseLink = fixUrl(document.select("div#mv-info > a").attr("href").toString())

        return if (tvType == TvType.TvSeries) {
            val episodes = app.get(baseLink).document.select("div#list-eps > a").map {
                Pair(it.text(), it.attr("data-iframe"))
            }.groupBy { it.first }.map { eps ->
                Episode(
                    data = eps.value.map { fixUrl(base64Decode(it.second)) }.toString(),
                    name = eps.key,
                    episode = eps.key.filter { it.isDigit() }.toIntOrNull()
                )

            }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                this.duration = duration
                addActors(actors)
                addTrailer(trailer)
            }
        } else {
            val links =
                app.get(baseLink).document.select("div#server-list div.server-wrapper div[id*=episode]")
                    .map {
                        fixUrl(base64Decode(it.attr("data-iframe")))
                    }.toString()
            newMovieLoadResponse(title, url, TvType.Movie, links) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                this.duration = duration
                addActors(actors)
                addTrailer(trailer)
            }
        }
    }

    private suspend fun invokeLokalSource(
        url: String,
        name: String,
        ref: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val document = app.get(
            url,
            allowRedirects = false,
            referer = mainUrl,
            headers = mapOf("Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8")
        ).document

        document.select("script").map { script ->
            if (script.data().contains("sources: [")) {
                val source = tryParseJson<ResponseLocal>(
                    script.data().substringAfter("sources: [").substringBefore("],")
                )
                val m3uData = app.get(source!!.file, referer = ref).text
                val quality = Regex("\\d{3,4}\\.m3u8").findAll(m3uData).map { it.value }.toList()

                quality.forEach {
                    sourceCallback.invoke(
                        ExtractorLink(
                            source = name,
                            name = name,
                            url = source.file.replace("video.m3u8", it),
                            referer = ref,
                            quality = getQualityFromName("${it.replace(".m3u8", "")}p"),
                            isM3u8 = true
                        )
                    )
                }

                val trackJson = script.data().substringAfter("tracks: [").substringBefore("],")
                val track = tryParseJson<List<Tracks>>("[$trackJson]")
                track?.map {
                    subCallback.invoke(
                        SubtitleFile(
                            "Indonesian",
                            (if (it.file.contains(".srt")) it.file else null)!!
                        )
                    )
                }
            }
        }
    }

    private suspend fun invokeKotakAjairSource(
        url: String,
        subCallback: (SubtitleFile) -> Unit,
        sourceCallback: (ExtractorLink) -> Unit
    ) {
        val domainUrl = "https://kotakajair.xyz"
        val id = url.trimEnd('/').split("/").last()
        val sources = app.post(
            url = "$domainUrl/api/source/$id",
            data = mapOf("r" to mainUrl, "d" to URI(url).host)
        ).parsed<ResponseKotakAjair>()

        sources.data?.map {
            sourceCallback.invoke(
                ExtractorLink(
                    name,
                    "KotakAjair",
                    fixUrl(it.file),
                    referer = url,
                    quality = getQualityFromName(it.label)
                )
            )
        }
        val userData = sources.player.poster_file.split("/")[2]
        sources.captions?.map {
            subCallback.invoke(
                SubtitleFile(
                    if (it.language.lowercase().contains("eng")) it.language else "Indonesian",
                    "$domainUrl/asset/userdata/$userData/caption/${it.hash}/${it.id}.srt"
                )
            )
        }

    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        data.removeSurrounding("[", "]").split(",").map { it.trim() }.apmap { link ->
            safeApiCall {
                when {
                    link.startsWith("http://172.96.161.72") -> invokeLokalSource(
                        link,
                        this.name,
                        "http://172.96.161.72/",
                        subtitleCallback,
                        callback
                    )
                    link.startsWith("https://kotakajair.xyz") -> invokeKotakAjairSource(
                        link,
                        subtitleCallback,
                        callback
                    )
                    else -> {
                        loadExtractor(link, "$mainUrl/", subtitleCallback, callback)
                        if (link.startsWith("https://sbfull.com")) {
                            val response = app.get(
                                link, interceptor = WebViewResolver(
                                    Regex("""\.srt""")
                                )
                            )
                            subtitleCallback.invoke(
                                SubtitleFile(
                                    "Indonesian",
                                    response.url
                                )
                            )
                        }
                    }
                }
            }
        }

        return true
    }

    private data class ResponseLocal(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
        @JsonProperty("type") val type: String?
    )

    private data class Tracks(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String?,
        @JsonProperty("kind") val kind: String?
    )

    private data class Captions(
        @JsonProperty("id") val id: String,
        @JsonProperty("hash") val hash: String,
        @JsonProperty("language") val language: String,
    )

    private data class Data(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
    )

    private data class Player(
        @JsonProperty("poster_file") val poster_file: String,
    )

    private data class ResponseKotakAjair(
        @JsonProperty("success") val success: Boolean,
        @JsonProperty("player") val player: Player,
        @JsonProperty("data") val data: List<Data>?,
        @JsonProperty("captions") val captions: List<Captions>?
    )

}




================================================
FILE: RebahinProvider/src/main/kotlin/com/lagradost/RebahinProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class RebahinProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(RebahinProvider())
    }
}


================================================
FILE: SeriesflixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SeriesflixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SeriesflixProvider/src/main/kotlin/com/lagradost/SeriesflixProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addDuration
import com.lagradost.cloudstream3.mvvm.logError
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class SeriesflixProvider : MainAPI() {
    override var mainUrl = "https://seriesflix.video"
    override var name = "Seriesflix"
    override var lang = "es"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val urls = listOf(
            Pair("$mainUrl/ver-series-online/", "Series"),
            Pair("$mainUrl/genero/accion/", "Acción"),
            Pair("$mainUrl/genero/ciencia-ficcion/", "Ciencia ficción"),
        )
        for (i in urls) {
            try {
                val soup = app.get(i.first).document
                val home = soup.select("article.TPost.B").map {
                    val title = it.selectFirst("h2.title")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        TvType.Movie,
                        it.selectFirst("figure img")!!.attr("src"),
                        null,
                        null,
                    )
                }

                items.add(HomePageList(i.second, home))
            } catch (e: Exception) {
                logError(e)
            }
        }
        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val doc = app.get(url).document
        return doc.select("article.TPost.B").map {
            val href = it.selectFirst("a")!!.attr("href")
            val poster = it.selectFirst("figure img")!!.attr("src")
            val name = it.selectFirst("h2.title")!!.text()
            val isMovie = href.contains("/movies/")
            if (isMovie) {
                MovieSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.Movie,
                    poster,
                    null
                )
            } else {
                TvSeriesSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.TvSeries,
                    poster,
                    null,
                    null
                )
            }
        }.toList()
    }


    override suspend fun load(url: String): LoadResponse {
        val type = if (url.contains("/movies/")) TvType.Movie else TvType.TvSeries

        val document = app.get(url).document

        val title = document.selectFirst("h1.Title")!!.text()
        val descRegex = Regex("(Recuerda.*Seriesflix.)")
        val descipt = document.selectFirst("div.Description > p")!!.text().replace(descRegex, "")
        val rating =
            document.selectFirst("div.Vote > div.post-ratings > span")?.text()?.toRatingInt()
        val year = document.selectFirst("span.Date")?.text()
        // ?: does not work
        val duration = try {
            document.selectFirst("span.Time")!!.text()
        } catch (e: Exception) {
            null
        }
        val postercss = document.selectFirst("head").toString()
        val posterRegex =
            Regex("(\"og:image\" content=\"https://seriesflix.video/wp-content/uploads/(\\d+)/(\\d+)/?.*.jpg)")
        val poster = try {
            posterRegex.findAll(postercss).map {
                it.value.replace("\"og:image\" content=\"", "")
            }.toList().first()
        } catch (e: Exception) {
            document.select(".TPostBg").attr("src")
        }

        if (type == TvType.TvSeries) {
            val list = ArrayList<Pair<Int, String>>()

            document.select("main > section.SeasonBx > div > div.Title > a").forEach { element ->
                val season = element.selectFirst("> span")?.text()?.toIntOrNull()
                val href = element.attr("href")
                if (season != null && season > 0 && !href.isNullOrBlank()) {
                    list.add(Pair(season, fixUrl(href)))
                }
            }
            if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            val episodeList = ArrayList<Episode>()

            for (season in list) {
                val seasonDocument = app.get(season.second).document
                val episodes = seasonDocument.select("table > tbody > tr")
                if (episodes.isNotEmpty()) {
                    episodes.forEach { episode ->
                        val epNum = episode.selectFirst("> td > span.Num")?.text()?.toIntOrNull()
                        val epthumb = episode.selectFirst("img")?.attr("src")
                        val aName = episode.selectFirst("> td.MvTbTtl > a")
                        val name = aName!!.text()
                        val href = aName!!.attr("href")
                        val date = episode.selectFirst("> td.MvTbTtl > span")?.text()
                        episodeList.add(
                            newEpisode(href) {
                                this.name = name
                                this.season = season.first
                                this.episode = epNum
                                this.posterUrl = fixUrlNull(epthumb)
                                addDate(date)
                            }
                        )
                    }
                }
            }
            return TvSeriesLoadResponse(
                title,
                url,
                this.name,
                type,
                episodeList,
                fixUrlNull(poster),
                year?.toIntOrNull(),
                descipt,
                null,
                rating
            )
        } else {
            return newMovieLoadResponse(
                title,
                url,
                type,
                url
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year?.toIntOrNull()
                this.plot = descipt
                this.rating = rating
                addDuration(duration)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        app.get(data).document.select("ul.ListOptions li").forEach {
            val movieID = it.attr("data-id")
            val serverID = it.attr("data-key")
            val type = if (data.contains("movies")) 1 else 2
            val url =
                "$mainUrl/?trembed=$serverID&trid=$movieID&trtype=$type" //This is to get the POST key value
            val doc1 = app.get(url).document
            doc1.select("div.Video iframe").apmap {
                val iframe = it.attr("src")
                val postkey =
                    iframe.replace("https://sc.seriesflix.video/index.php?h=", "") // this obtains
                // djNIdHNCR2lKTGpnc3YwK3pyRCs3L2xkQmljSUZ4ai9ibTcza0JRODNMcmFIZ0hPejdlYW0yanJIL2prQ1JCZA POST KEY
                app.post(
                    "https://sc.seriesflix.video/r.php",
                    headers = mapOf(
                        "Host" to "sc.seriesflix.video",
                        "User-Agent" to USER_AGENT,
                        "Accept" to "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
                        "Accept-Language" to "en-US,en;q=0.5",
                        "Content-Type" to "application/x-www-form-urlencoded",
                        "Origin" to "null",
                        "DNT" to "1",
                        "Alt-Used" to "sc.seriesflix.video",
                        "Connection" to "keep-alive",
                        "Upgrade-Insecure-Requests" to "1",
                        "Sec-Fetch-Dest" to "iframe",
                        "Sec-Fetch-Mode" to "navigate",
                        "Sec-Fetch-Site" to "same-origin",
                        "Sec-Fetch-User" to "?1",
                    ),
                    params = mapOf(Pair("h", postkey)),
                    data = mapOf(Pair("h", postkey)),
                    allowRedirects = false
                ).okhttpResponse.headers.values("location").apmap { link ->
                    val url1 = link.replace("#bu", "")
                    loadExtractor(url1, data, subtitleCallback, callback)
                }
            }
        }
        return true
    }
}



================================================
FILE: SeriesflixProvider/src/main/kotlin/com/lagradost/SeriesflixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SeriesflixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SeriesflixProvider())
    }
}


================================================
FILE: SflixProProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SflixProProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SflixProProvider/src/main/kotlin/com/lagradost/SflixProProvider.kt
================================================
package com.lagradost

class SflixProProvider : BflixProvider() {
    override var mainUrl = "https://sflix.pro"
    override var name = "Sflix.pro"
}


================================================
FILE: SflixProProvider/src/main/kotlin/com/lagradost/SflixProProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SflixProProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SflixProProvider())
    }
}


================================================
FILE: SflixProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SflixProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SflixProvider/src/main/kotlin/com/lagradost/SflixProvider.kt
================================================
package com.lagradost

import android.util.Log
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.APIHolder.getCaptchaToken
import com.lagradost.cloudstream3.APIHolder.unixTimeMS
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addDuration
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
//import com.lagradost.cloudstream3.animeproviders.ZoroProvider
import com.lagradost.cloudstream3.mvvm.suspendSafeApiCall
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.tryParseJson
import com.lagradost.cloudstream3.utils.Coroutines.ioSafe
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.cloudstream3.utils.loadExtractor
import com.lagradost.nicehttp.NiceResponse
import kotlinx.coroutines.delay
import okhttp3.RequestBody.Companion.toRequestBody
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.net.URI
import java.util.*
import kotlin.system.measureTimeMillis

open class SflixProvider : MainAPI() {
    override var mainUrl = "https://sflix.to"
    override var name = "Sflix.to"

    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val usesWebView = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )
    override val vpnStatus = VPNStatus.None

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val html = app.get("$mainUrl/home").text
        val document = Jsoup.parse(html)

        val all = ArrayList<HomePageList>()

        val map = mapOf(
            "Trending Movies" to "div#trending-movies",
            "Trending TV Shows" to "div#trending-tv",
        )
        map.forEach {
            all.add(HomePageList(
                it.key,
                document.select(it.value).select("div.flw-item").map { element ->
                    element.toSearchResult()
                }
            ))
        }

        document.select("section.block_area.block_area_home.section-id-02").forEach {
            val title = it.select("h2.cat-heading").text().trim()
            val elements = it.select("div.flw-item").map { element ->
                element.toSearchResult()
            }
            all.add(HomePageList(title, elements))
        }

        return HomePageResponse(all)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search/${query.replace(" ", "-")}"
        val html = app.get(url).text
        val document = Jsoup.parse(html)

        return document.select("div.flw-item").map {
            val title = it.select("h2.film-name").text()
            val href = fixUrl(it.select("a").attr("href"))
            val year = it.select("span.fdi-item").text().toIntOrNull()
            val image = it.select("img").attr("data-src")
            val isMovie = href.contains("/movie/")

            val metaInfo = it.select("div.fd-infor > span.fdi-item")
            // val rating = metaInfo[0].text()
            val quality = getQualityFromString(metaInfo.getOrNull(1)?.text())

            if (isMovie) {
                MovieSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.Movie,
                    image,
                    year,
                    quality = quality
                )
            } else {
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    year,
                    null,
                    quality = quality
                )
            }
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val details = document.select("div.detail_page-watch")
        val img = details.select("img.film-poster-img")
        val posterUrl = img.attr("src")
        val title = img.attr("title") ?: throw ErrorLoadingException("No Title")

        /*
        val year = Regex("""[Rr]eleased:\s*(\d{4})""").find(
            document.select("div.elements").text()
        )?.groupValues?.get(1)?.toIntOrNull()
        val duration = Regex("""[Dd]uration:\s*(\d*)""").find(
            document.select("div.elements").text()
        )?.groupValues?.get(1)?.trim()?.plus(" min")*/
        var duration = document.selectFirst(".fs-item > .duration")?.text()?.trim()
        var year: Int? = null
        var tags: List<String>? = null
        var cast: List<String>? = null
        val youtubeTrailer = document.selectFirst("iframe#iframe-trailer")?.attr("data-src")
        val rating = document.selectFirst(".fs-item > .imdb")?.text()?.trim()
            ?.removePrefix("IMDB:")?.toRatingInt()

        document.select("div.elements > .row > div > .row-line").forEach { element ->
            val type = element?.select(".type")?.text() ?: return@forEach
            when {
                type.contains("Released") -> {
                    year = Regex("\\d+").find(
                        element.ownText() ?: return@forEach
                    )?.groupValues?.firstOrNull()?.toIntOrNull()
                }
                type.contains("Genre") -> {
                    tags = element.select("a").mapNotNull { it.text() }
                }
                type.contains("Cast") -> {
                    cast = element.select("a").mapNotNull { it.text() }
                }
                type.contains("Duration") -> {
                    duration = duration ?: element.ownText().trim()
                }
            }
        }
        val plot = details.select("div.description").text().replace("Overview:", "").trim()

        val isMovie = url.contains("/movie/")

        // https://sflix.to/movie/free-never-say-never-again-hd-18317 -> 18317
        val idRegex = Regex(""".*-(\d+)""")
        val dataId = details.attr("data-id")
        val id = if (dataId.isNullOrEmpty())
            idRegex.find(url)?.groupValues?.get(1)
                ?: throw ErrorLoadingException("Unable to get id from '$url'")
        else dataId

        val recommendations =
            document.select("div.film_list-wrap > div.flw-item").mapNotNull { element ->
                val titleHeader =
                    element.select("div.film-detail > .film-name > a") ?: return@mapNotNull null
                val recUrl = fixUrlNull(titleHeader.attr("href")) ?: return@mapNotNull null
                val recTitle = titleHeader.text() ?: return@mapNotNull null
                val poster = element.select("div.film-poster > img").attr("data-src")
                MovieSearchResponse(
                    recTitle,
                    recUrl,
                    this.name,
                    if (recUrl.contains("/movie/")) TvType.Movie else TvType.TvSeries,
                    poster,
                    year = null
                )
            }

        if (isMovie) {
            // Movies
            val episodesUrl = "$mainUrl/ajax/movie/episodes/$id"
            val episodes = app.get(episodesUrl).text

            // Supported streams, they're identical
            val sourceIds = Jsoup.parse(episodes).select("a").mapNotNull { element ->
                var sourceId = element.attr("data-id")
                if (sourceId.isNullOrEmpty())
                    sourceId = element.attr("data-linkid")

                if (element.select("span").text().trim().isValidServer()) {
                    if (sourceId.isNullOrEmpty()) {
                        fixUrlNull(element.attr("href"))
                    } else {
                        "$url.$sourceId".replace("/movie/", "/watch-movie/")
                    }
                } else {
                    null
                }
            }

            val comingSoon = sourceIds.isEmpty()

            return newMovieLoadResponse(title, url, TvType.Movie, sourceIds) {
                this.year = year
                this.posterUrl = posterUrl
                this.plot = plot
                addDuration(duration)
                addActors(cast)
                this.tags = tags
                this.recommendations = recommendations
                this.comingSoon = comingSoon
                addTrailer(youtubeTrailer)
                this.rating = rating
            }
        } else {
            val seasonsDocument = app.get("$mainUrl/ajax/v2/tv/seasons/$id").document
            val episodes = arrayListOf<Episode>()
            var seasonItems = seasonsDocument.select("div.dropdown-menu.dropdown-menu-model > a")
            if (seasonItems.isNullOrEmpty())
                seasonItems = seasonsDocument.select("div.dropdown-menu > a.dropdown-item")
            seasonItems.apmapIndexed { season, element ->
                val seasonId = element.attr("data-id")
                if (seasonId.isNullOrBlank()) return@apmapIndexed

                var episode = 0
                val seasonEpisodes = app.get("$mainUrl/ajax/v2/season/episodes/$seasonId").document
                var seasonEpisodesItems =
                    seasonEpisodes.select("div.flw-item.film_single-item.episode-item.eps-item")
                if (seasonEpisodesItems.isNullOrEmpty()) {
                    seasonEpisodesItems =
                        seasonEpisodes.select("ul > li > a")
                }
                seasonEpisodesItems.forEach {
                    val episodeImg = it?.select("img")
                    val episodeTitle = episodeImg?.attr("title") ?: it.ownText()
                    val episodePosterUrl = episodeImg?.attr("src")
                    val episodeData = it.attr("data-id") ?: return@forEach

                    episode++

                    val episodeNum =
                        (it.select("div.episode-number").text()
                            ?: episodeTitle).let { str ->
                            Regex("""\d+""").find(str)?.groupValues?.firstOrNull()
                                ?.toIntOrNull()
                        } ?: episode

                    episodes.add(
                        newEpisode(Pair(url, episodeData)) {
                            this.posterUrl = fixUrlNull(episodePosterUrl)
                            this.name = episodeTitle?.removePrefix("Episode $episodeNum: ")
                            this.season = season + 1
                            this.episode = episodeNum
                        }
                    )
                }
            }

            return newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = posterUrl
                this.year = year
                this.plot = plot
                addDuration(duration)
                addActors(cast)
                this.tags = tags
                this.recommendations = recommendations
                addTrailer(youtubeTrailer)
                this.rating = rating
            }
        }
    }

    data class Tracks(
        @JsonProperty("file") val file: String?,
        @JsonProperty("label") val label: String?,
        @JsonProperty("kind") val kind: String?
    )

    data class Sources(
        @JsonProperty("file") val file: String?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("label") val label: String?
    )

    data class SourceObject(
        @JsonProperty("sources") val sources: List<Sources?>?,
        @JsonProperty("sources_1") val sources1: List<Sources?>?,
        @JsonProperty("sources_2") val sources2: List<Sources?>?,
        @JsonProperty("sourcesBackup") val sourcesBackup: List<Sources?>?,
        @JsonProperty("tracks") val tracks: List<Tracks?>?
    )

    data class IframeJson(
//        @JsonProperty("type") val type: String? = null,
        @JsonProperty("link") val link: String? = null,
//        @JsonProperty("sources") val sources: ArrayList<String> = arrayListOf(),
//        @JsonProperty("tracks") val tracks: ArrayList<String> = arrayListOf(),
//        @JsonProperty("title") val title: String? = null
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val urls = (tryParseJson<Pair<String, String>>(data)?.let { (prefix, server) ->
            val episodesUrl = "$mainUrl/ajax/v2/episode/servers/$server"

            // Supported streams, they're identical
            app.get(episodesUrl).document.select("a").mapNotNull { element ->
                val id = element?.attr("data-id") ?: return@mapNotNull null
                if (element.select("span").text().trim().isValidServer()) {
                    "$prefix.$id".replace("/tv/", "/watch-tv/")
                } else {
                    null
                }
            }
        } ?: tryParseJson<List<String>>(data))?.distinct()

        urls?.apmap { url ->
            suspendSafeApiCall {
                // Possible without token

//                val response = app.get(url)
//                val key =
//                    response.document.select("script[src*=https://www.google.com/recaptcha/api.js?render=]")
//                        .attr("src").substringAfter("render=")
//                val token = getCaptchaToken(mainUrl, key) ?: return@suspendSafeApiCall

                val serverId = url.substringAfterLast(".")
                val iframeLink =
                    app.get("${this.mainUrl}/ajax/get_link/$serverId").parsed<IframeJson>().link
                        ?: return@suspendSafeApiCall

                // Some smarter ws11 or w10 selection might be required in the future.
                val extractorData =
                    "https://ws11.rabbitstream.net/socket.io/?EIO=4&transport=polling"

                if (iframeLink.contains("streamlare", ignoreCase = true)) {
                    loadExtractor(iframeLink, null, subtitleCallback, callback)
                } else {
                    extractRabbitStream(iframeLink, subtitleCallback, callback, false) { it }
                }
            }
        }

        return !urls.isNullOrEmpty()
    }

    override suspend fun extractorVerifierJob(extractorData: String?) {
        runSflixExtractorVerifierJob(this, extractorData, "https://rabbitstream.net/")
    }

    private fun Element.toSearchResult(): SearchResponse {
        val inner = this.selectFirst("div.film-poster")
        val img = inner!!.select("img")
        val title = img.attr("title")
        val posterUrl = img.attr("data-src") ?: img.attr("src")
        val href = fixUrl(inner.select("a").attr("href"))
        val isMovie = href.contains("/movie/")
        val otherInfo =
            this.selectFirst("div.film-detail > div.fd-infor")?.select("span")?.toList() ?: listOf()
        //var rating: Int? = null
        var year: Int? = null
        var quality: SearchQuality? = null
        when (otherInfo.size) {
            1 -> {
                year = otherInfo[0]?.text()?.trim()?.toIntOrNull()
            }
            2 -> {
                year = otherInfo[0]?.text()?.trim()?.toIntOrNull()
            }
            3 -> {
                //rating = otherInfo[0]?.text()?.toRatingInt()
                quality = getQualityFromString(otherInfo[1]?.text())
                year = otherInfo[2]?.text()?.trim()?.toIntOrNull()
            }
        }

        return if (isMovie) {
            MovieSearchResponse(
                title,
                href,
                this@SflixProvider.name,
                TvType.Movie,
                posterUrl = posterUrl,
                year = year,
                quality = quality,
            )
        } else {
            TvSeriesSearchResponse(
                title,
                href,
                this@SflixProvider.name,
                TvType.Movie,
                posterUrl,
                year = year,
                episodes = null,
                quality = quality,
            )
        }
    }

    companion object {
        data class PollingData(
            @JsonProperty("sid") val sid: String? = null,
            @JsonProperty("upgrades") val upgrades: ArrayList<String> = arrayListOf(),
            @JsonProperty("pingInterval") val pingInterval: Int? = null,
            @JsonProperty("pingTimeout") val pingTimeout: Int? = null
        )

        /*
        # python code to figure out the time offset based on code if necessary
        chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_"
        code = "Nxa_-bM"
        total = 0
        for i, char in enumerate(code[::-1]):
            index = chars.index(char)
            value = index * 64**i
            total += value
        print(f"total {total}")
        */
        private fun generateTimeStamp(): String {
            val chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_"
            var code = ""
            var time = unixTimeMS
            while (time > 0) {
                code += chars[(time % (chars.length)).toInt()]
                time /= chars.length
            }
            return code.reversed()
        }


        /**
         * Generates a session
         * 1 Get request.
         * */
        private suspend fun negotiateNewSid(baseUrl: String): PollingData? {
            // Tries multiple times
            for (i in 1..5) {
                val jsonText =
                    app.get("$baseUrl&t=${generateTimeStamp()}").text.replaceBefore("{", "")
//            println("Negotiated sid $jsonText")
                parseJson<PollingData?>(jsonText)?.let { return it }
                delay(1000L * i)
            }
            return null
        }

        /**
         * Generates a new session if the request fails
         * @return the data and if it is new.
         * */
        private suspend fun getUpdatedData(
            response: NiceResponse,
            data: PollingData,
            baseUrl: String
        ): Pair<PollingData, Boolean> {
            if (!response.okhttpResponse.isSuccessful) {
                return negotiateNewSid(baseUrl)?.let {
                    it to true
                } ?: data to false
            }
            return data to false
        }


        private suspend fun initPolling(
            extractorData: String,
            referer: String
        ): Pair<PollingData?, String?> {
            val headers = mapOf(
                "Referer" to referer // "https://rabbitstream.net/"
            )

            val data = negotiateNewSid(extractorData) ?: return null to null
            app.post(
                "$extractorData&t=${generateTimeStamp()}&sid=${data.sid}",
                requestBody = "40".toRequestBody(),
                headers = headers
            )

            // This makes the second get request work, and re-connect work.
            val reconnectSid =
                parseJson<PollingData>(
                    app.get(
                        "$extractorData&t=${generateTimeStamp()}&sid=${data.sid}",
                        headers = headers
                    )
//                    .also { println("First get ${it.text}") }
                        .text.replaceBefore("{", "")
                ).sid

            // This response is used in the post requests. Same contents in all it seems.
            val authInt =
                app.get(
                    "$extractorData&t=${generateTimeStamp()}&sid=${data.sid}",
                    timeout = 60,
                    headers = headers
                ).text
                    //.also { println("Second get ${it}") }
                    // Dunno if it's actually generated like this, just guessing.
                    .toIntOrNull()?.plus(1) ?: 3

            return data to reconnectSid
        }

        suspend fun runSflixExtractorVerifierJob(
            api: MainAPI,
            extractorData: String?,
            referer: String
        ) {
            if (extractorData == null) return
            val headers = mapOf(
                "Referer" to referer // "https://rabbitstream.net/"
            )

            lateinit var data: PollingData
            var reconnectSid = ""

            initPolling(extractorData, referer)
                .also {
                    data = it.first ?: throw RuntimeException("Data Null")
                    reconnectSid = it.second ?: throw RuntimeException("ReconnectSid Null")
                }

            // Prevents them from fucking us over with doing a while(true){} loop
            val interval = maxOf(data.pingInterval?.toLong()?.plus(2000) ?: return, 10000L)
            var reconnect = false
            var newAuth = false


            while (true) {
                val authData =
                    when {
                        newAuth -> "40"
                        reconnect -> """42["_reconnect", "$reconnectSid"]"""
                        else -> "3"
                    }

                val url = "${extractorData}&t=${generateTimeStamp()}&sid=${data.sid}"

                getUpdatedData(
                    app.post(url, json = authData, headers = headers),
                    data,
                    extractorData
                ).also {
                    newAuth = it.second
                    data = it.first
                }

                //.also { println("Sflix post job ${it.text}") }
                Log.d(api.name, "Running ${api.name} job $url")

                val time = measureTimeMillis {
                    // This acts as a timeout
                    val getResponse = app.get(
                        url,
                        timeout = interval / 1000,
                        headers = headers
                    )
//                    .also { println("Sflix get job ${it.text}") }
                    reconnect = getResponse.text.contains("sid")
                }
                // Always waits even if the get response is instant, to prevent a while true loop.
                if (time < interval - 4000)
                    delay(4000)
            }
        }

        // Only scrape servers with these names
        fun String?.isValidServer(): Boolean {
            val list = listOf("upcloud", "vidcloud", "streamlare")
            return list.contains(this?.lowercase(Locale.ROOT))
        }

        // For re-use in Zoro
        private suspend fun Sources.toExtractorLink(
            caller: MainAPI,
            name: String,
            extractorData: String? = null,
        ): List<ExtractorLink>? {
            return this.file?.let { file ->
                //println("FILE::: $file")
                val isM3u8 = URI(this.file).path.endsWith(".m3u8") || this.type.equals(
                    "hls",
                    ignoreCase = true
                )
                return if (isM3u8) {
                    suspendSafeApiCall {
                        M3u8Helper().m3u8Generation(
                            M3u8Helper.M3u8Stream(
                                this.file,
                                null,
                                mapOf("Referer" to "https://mzzcloud.life/")
                            ), false
                        )
                            .map { stream ->
                                ExtractorLink(
                                    caller.name,
                                    "${caller.name} $name",
                                    stream.streamUrl,
                                    caller.mainUrl,
                                    getQualityFromName(stream.quality?.toString()),
                                    true,
                                    extractorData = extractorData
                                )
                            }
                    } ?: listOf(
                        // Fallback if m3u8 extractor fails
                        ExtractorLink(
                            caller.name,
                            "${caller.name} $name",
                            this.file,
                            caller.mainUrl,
                            getQualityFromName(this.label),
                            isM3u8,
                            extractorData = extractorData
                        )
                    )
                } else {
                    listOf(
                        ExtractorLink(
                            caller.name,
                            caller.name,
                            file,
                            caller.mainUrl,
                            getQualityFromName(this.label),
                            false,
                            extractorData = extractorData
                        )
                    )
                }
            }
        }

        private fun Tracks.toSubtitleFile(): SubtitleFile? {
            return this.file?.let {
                SubtitleFile(
                    this.label ?: "Unknown",
                    it
                )
            }
        }

        suspend fun MainAPI.extractRabbitStream(
            url: String,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit,
            useSidAuthentication: Boolean,
            /** Used for extractorLink name, input: Source name */
            extractorData: String? = null,
            nameTransformer: (String) -> String,
        ) = suspendSafeApiCall {
            // https://rapid-cloud.ru/embed-6/dcPOVRE57YOT?z= -> https://rapid-cloud.ru/embed-6
            val mainIframeUrl =
                url.substringBeforeLast("/")
            val mainIframeId = url.substringAfterLast("/")
                .substringBefore("?") // https://rapid-cloud.ru/embed-6/dcPOVRE57YOT?z= -> dcPOVRE57YOT
            val iframe = app.get(url, referer = mainUrl)
            val iframeKey =
                iframe.document.select("script[src*=https://www.google.com/recaptcha/api.js?render=]")
                    .attr("src").substringAfter("render=")
            val iframeToken = getCaptchaToken(url, iframeKey)
            val number =
                Regex("""recaptchaNumber = '(.*?)'""").find(iframe.text)?.groupValues?.get(1)

            var sid: String? = null
            if (useSidAuthentication && extractorData != null) {
                negotiateNewSid(extractorData)?.also { pollingData ->
                    app.post(
                        "$extractorData&t=${generateTimeStamp()}&sid=${pollingData.sid}",
                        requestBody = "40".toRequestBody(),
                        timeout = 60
                    )
                    val text = app.get(
                        "$extractorData&t=${generateTimeStamp()}&sid=${pollingData.sid}",
                        timeout = 60
                    ).text.replaceBefore("{", "")

                    sid = parseJson<PollingData>(text).sid
                    ioSafe { app.get("$extractorData&t=${generateTimeStamp()}&sid=${pollingData.sid}") }
                }
            }

            val mapped = app.get(
                "${
                    mainIframeUrl.replace(
                        "/embed",
                        "/ajax/embed"
                    )
                }/getSources?id=$mainIframeId&_token=$iframeToken&_number=$number${sid?.let { "$&sId=$it" } ?: ""}",
                referer = mainUrl,
                headers = mapOf(
                    "X-Requested-With" to "XMLHttpRequest",
                    "Accept" to "*/*",
                    "Accept-Language" to "en-US,en;q=0.5",
//                        "Cache-Control" to "no-cache",
                    "Connection" to "keep-alive",
//                        "Sec-Fetch-Dest" to "empty",
//                        "Sec-Fetch-Mode" to "no-cors",
//                        "Sec-Fetch-Site" to "cross-site",
//                        "Pragma" to "no-cache",
//                        "Cache-Control" to "no-cache",
                    "TE" to "trailers"
                )
            ).parsed<SourceObject>()

            mapped.tracks?.forEach { track ->
                track?.toSubtitleFile()?.let { subtitleFile ->
                    subtitleCallback.invoke(subtitleFile)
                }
            }

            val list = listOf(
                mapped.sources to "source 1",
                mapped.sources1 to "source 2",
                mapped.sources2 to "source 3",
                mapped.sourcesBackup to "source backup"
            )
            list.forEach { subList ->
                subList.first?.forEach { source ->
                    source?.toExtractorLink(
                        this,
                        nameTransformer(subList.second),
                        extractorData,
                    )
                        ?.forEach {
                            // Sets Zoro SID used for video loading
//                            (this as? ZoroProvider)?.sid?.set(it.url.hashCode(), sid)
                            callback(it)
                        }
                }
            }
        }
    }
}




================================================
FILE: SflixProvider/src/main/kotlin/com/lagradost/SflixProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SflixProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SflixProvider())
    }
}


================================================
FILE: SoaptwoDayProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SoaptwoDayProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SoaptwoDayProvider/src/main/kotlin/com/lagradost/SoaptwoDayProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.Jsoup

class SoaptwoDayProvider : MainAPI() {
    override var mainUrl = "https://secretlink.xyz" //Probably a rip off, but it has no captcha
    override var name = "Soap2Day"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        Pair("$mainUrl/movielist?page=", "Movies"),
        Pair("$mainUrl/tvlist?page=", "TV Series"),
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val url = request.data + page

        val soup = app.get(url).document
        val home =
            soup.select("div.container div.row div.col-sm-12.col-lg-12 div.row div.col-sm-12.col-lg-12 .col-xs-6")
                .map {
                    val title = it.selectFirst("h5 a")!!.text()
                    val link = it.selectFirst("a")!!.attr("href")
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        TvType.TvSeries,
                        fixUrl(it.selectFirst("img")!!.attr("src")),
                        null,
                        null,
                    )
                }
        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val doc = app.get("$mainUrl/search/keyword/$query").document
        return doc.select("div.container div.row div.col-sm-12.col-lg-12 div.row div.col-sm-12.col-lg-12 .col-xs-6")
            .map {
                val title = it.selectFirst("h5 a")!!.text()
                val image = fixUrl(it.selectFirst("img")!!.attr("src"))
                val href = fixUrl(it.selectFirst("a")!!.attr("href"))
                TvSeriesSearchResponse(
                    title,
                    href,
                    this.name,
                    TvType.TvSeries,
                    image,
                    null,
                    null
                )
            }
    }

    override suspend fun load(url: String): LoadResponse? {
        val soup = app.get(url).document
        val title = soup.selectFirst(".hidden-lg > div:nth-child(1) > h4")?.text() ?: ""
        val description = soup.selectFirst("p#wrap")?.text()?.trim()
        val poster =
            soup.selectFirst(".col-md-5 > div:nth-child(1) > div:nth-child(1) > img")?.attr("src")
        val episodes = mutableListOf<Episode>()
        soup.select("div.alert").forEach {
            val season = it?.selectFirst("h4")?.text()?.filter { c -> c.isDigit() }?.toIntOrNull()
            it?.select("div > div > a")?.forEach { entry ->
                val link = fixUrlNull(entry?.attr("href")) ?: return@forEach
                val text = entry?.text() ?: ""
                val name = text.replace(Regex("(^(\\d+)\\.)"), "")
                val epNum = text.substring(0, text.indexOf(".")).toIntOrNull()
                episodes.add(
                    Episode(
                        name = name,
                        data = link,
                        season = season,
                        episode = epNum
                    )
                )
            }
        }
        val otherInfoBody = soup.select("div.col-sm-8 div.panel-body").toString()
        //Fetch casts
        val casts = otherInfoBody.substringAfter("Stars : ")
            .substringBefore("Genre : ").let {
                Jsoup.parse(it).select("a")
            }.mapNotNull {
                val castName = it?.text() ?: return@mapNotNull null
                ActorData(
                    Actor(
                        name = castName
                    )
                )
            }
        //Fetch year
        val year = otherInfoBody.substringAfter("<h4>Release : </h4>")
            .substringBefore("<div").let {
                //Log.i(this.name, "Result => year string: $it")
                Jsoup.parse(it).select("p")[1]
            }?.text()?.take(4)?.toIntOrNull()
        //Fetch genres
        val genre = otherInfoBody.substringAfter("<h4>Genre : </h4>")
            .substringBefore("<h4>Release : </h4>").let {
                //Log.i(this.name, "Result => genre string: $it")
                Jsoup.parse(it).select("a")
            }.mapNotNull { it?.text()?.trim() ?: return@mapNotNull null }

        return when (val tvType = if (episodes.isEmpty()) TvType.Movie else TvType.TvSeries) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes.reversed(),
                    fixUrlNull(poster),
                    year = year,
                    description,
                    actors = casts,
                    tags = genre
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    url,
                    fixUrlNull(poster),
                    year = year,
                    description,
                    actors = casts,
                    tags = genre
                )
            }
            else -> null
        }
    }

    data class ServerJson(
        @JsonProperty("0") val zero: String?,
        @JsonProperty("key") val key: Boolean?,
        @JsonProperty("val") val stream: String?,
        @JsonProperty("val_bak") val streambackup: String?,
        @JsonProperty("pos") val pos: Int?,
        @JsonProperty("type") val type: String?,
        @JsonProperty("subs") val subs: List<Subs>?,
        @JsonProperty("prev_epi_title") val prevEpiTitle: String?,
        @JsonProperty("prev_epi_url") val prevEpiUrl: String?,
        @JsonProperty("next_epi_title") val nextEpiTitle: String?,
        @JsonProperty("next_epi_url") val nextEpiUrl: String?
    )

    data class Subs(
        @JsonProperty("id") val id: Int?,
        @JsonProperty("movieId") val movieId: Int?,
        @JsonProperty("tvId") val tvId: Int?,
        @JsonProperty("episodeId") val episodeId: Int?,
        @JsonProperty("default") val default: Int?,
        @JsonProperty("IsShow") val IsShow: Int?,
        @JsonProperty("name") val name: String,
        @JsonProperty("path") val path: String?,
        @JsonProperty("downlink") val downlink: String?,
        @JsonProperty("source_file_name") val sourceFileName: String?,
        @JsonProperty("createtime") val createtime: Int?
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document
        val idplayer = doc.selectFirst("#divU")?.text()
        val idplayer2 = doc.selectFirst("#divP")?.text()
        val movieid = doc.selectFirst("div.row input#hId")!!.attr("value")
        val tvType = try {
            doc.selectFirst(".col-md-5 > div:nth-child(1) > div:nth-child(1) > img")!!.attr("src")
                ?: ""
        } catch (e: Exception) {
            ""
        }
        val ajaxlink =
            if (tvType.contains("movie")) "$mainUrl/home/index/GetMInfoAjax" else "$mainUrl/home/index/GetEInfoAjax"
        listOf(
            idplayer,
            idplayer2,
        ).mapNotNull { playerID ->
            val url = app.post(
                ajaxlink,
                headers = mapOf(
                    "Host" to "secretlink.xyz",
                    "User-Agent" to USER_AGENT,
                    "Accept" to "application/json, text/javascript, */*; q=0.01",
                    "Accept-Language" to "en-US,en;q=0.5",
                    "Content-Type" to "application/x-www-form-urlencoded; charset=UTF-8",
                    "X-Requested-With" to "XMLHttpRequest",
                    "Origin" to "https://secretlink.xyz",
                    "DNT" to "1",
                    "Connection" to "keep-alive",
                    "Referer" to data,
                    "Sec-Fetch-Dest" to "empty",
                    "Sec-Fetch-Mode" to "cors",
                    "Sec-Fetch-Site" to "same-origin",
                ),
                data = mapOf(
                    Pair("pass", movieid),
                    Pair("param", playerID ?: ""),
                )
            ).text.replace("\\\"", "\"").replace("\"{", "{").replace("}\"", "}")
                .replace("\\\\\\/", "\\/")
            val json = parseJson<ServerJson>(url)
            listOfNotNull(
                json.stream,
                json.streambackup
            ).apmap { stream ->
                val cleanstreamurl = stream.replace("\\/", "/").replace("\\\\\\", "")
                if (cleanstreamurl.isNotBlank()) {
                    callback(
                        ExtractorLink(
                            "Soap2Day",
                            "Soap2Day",
                            cleanstreamurl,
                            "https://soap2day.ac",
                            Qualities.Unknown.value,
                            isM3u8 = false
                        )
                    )
                }
            }
            json.subs?.forEach { subtitle ->
                val sublink = mainUrl + subtitle.path
                listOf(
                    sublink,
                    subtitle.downlink
                ).mapNotNull { subs ->
                    if (subs != null) {
                        if (subs.isNotBlank()) {
                            subtitleCallback(
                                SubtitleFile(subtitle.name, subs)
                            )
                        }
                    }
                }
            }
        }
        return true
    }
}



================================================
FILE: SoaptwoDayProvider/src/main/kotlin/com/lagradost/SoaptwoDayProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SoaptwoDayProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SoaptwoDayProvider())
    }
}


================================================
FILE: SolarmovieProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":SflixProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SolarmovieProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SolarmovieProvider/src/main/kotlin/com/lagradost/SolarmovieProvider.kt
================================================
package com.lagradost

class SolarmovieProvider : SflixProvider() {
    override var mainUrl = "https://solarmovie.pe"
    override var name = "Solarmovie"
}


================================================
FILE: SolarmovieProvider/src/main/kotlin/com/lagradost/SolarmovieProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SolarmovieProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SolarmovieProvider())
    }
}


================================================
FILE: StreamingcommunityProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: StreamingcommunityProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: StreamingcommunityProvider/src/main/kotlin/com/lagradost/StreamingcommunityProvider.kt
================================================
package com.lagradost

import android.text.Html
import com.fasterxml.jackson.annotation.*
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.*
import org.json.JSONObject
import java.net.URI
import java.security.MessageDigest

data class Moviedata(
    @JsonProperty("id") val id: Long,
    @JsonProperty("name") val name: String,
    @JsonProperty("type") val type: String,
    @JsonProperty("release_date") val releaseDate: String,
    @JsonProperty("seasons_count") val seasonsCount: Long? = null,
    @JsonProperty("genres") val genres: List<Genre>,
    @JsonProperty("votes") val votes: List<Vote>,
    @JsonProperty("runtime") val runtime: Long? = null
)

data class Genre(
    @JsonProperty("name") val name: String,
    @JsonProperty("pivot") val pivot: Pivot,
)

data class Pivot(
    @JsonProperty("titleID") val titleID: Long,
    @JsonProperty("genreID") val genreID: Long,
)

data class Vote(
    @JsonProperty("title_id") val title_id: Long,
    @JsonProperty("average") val average: String,
    @JsonProperty("count") val count: Long,
    @JsonProperty("type") val type: String,
)

data class VideoElement(
    @JsonProperty("id") val id: Long,
    @JsonProperty("slug") val slug: String,
    @JsonProperty("images") val images: List<Image>,
)

data class Image(
    @JsonProperty("imageable_id") val imageableID: Long,
    @JsonProperty("imageable_type") val imageableType: String,
    @JsonProperty("server_id") val serverID: Long,
    @JsonProperty("proxy_id") val proxyID: Long,
    @JsonProperty("url") val url: String,
    @JsonProperty("type") val type: String,
//    @JsonProperty("sc_url") val scURL: String,
//    @JsonProperty("proxy") val proxy: Proxy,
//    @JsonProperty("server") val server: Proxy
)

// Proxy is not used and crashes otherwise

//data class Proxy(
//    @JsonProperty("id") val id: Long,
//    @JsonProperty("type") val type: String,
//    @JsonProperty("ip") val ip: String,
//    @JsonProperty("number") val number: Long,
//    @JsonProperty("storage") val storage: Long,
//    @JsonProperty("max_storage") val maxStorage: Long,
//    @JsonProperty("max_conversions") val maxConversions: Any? = null,
//    @JsonProperty("max_publications") val maxPublications: Any? = null,
//    @JsonProperty("created_at") val createdAt: String,
//    @JsonProperty("updated_at") val updatedAt: String,
//    @JsonProperty("upload_bandwidth") val uploadBandwidth: Any? = null,
//    @JsonProperty("upload_bandwidth_limit") val uploadBandwidthLimit: Any? = null
//)

data class Season(
    @JsonProperty("id") val id: Long,
    @JsonProperty("name") val name: String? = "",
    @JsonProperty("plot") val plot: String? = "",
    @JsonProperty("date") val date: String? = "",
    @JsonProperty("number") val number: Long,
    @JsonProperty("title_id") val title_id: Long,
    @JsonProperty("createdAt") val createdAt: String? = "",
    @JsonProperty("updated_at") val updatedAt: String? = "",
    @JsonProperty("episodes") val episodes: List<Episodejson>
)

data class Episodejson(
    @JsonProperty("id") val id: Long,
    @JsonProperty("number") val number: Long,
    @JsonProperty("name") val name: String? = "",
    @JsonProperty("plot") val plot: String? = "",
    @JsonProperty("season_id") val seasonID: Long,
    @JsonProperty("images") val images: List<ImageSeason>
)

data class ImageSeason(
    @JsonProperty("imageable_id") val imageableID: Long,
    @JsonProperty("imageable_type") val imageableType: String,
    @JsonProperty("server_id") val serverID: Long,
    @JsonProperty("proxy_id") val proxyID: Long,
    @JsonProperty("url") val url: String,
    @JsonProperty("type") val type: String,
    @JsonProperty("original_url") val originalURL: String
)

data class TrailerElement(
    @JsonProperty("id") val id: Long? = null,
    @JsonProperty("url") val url: String? = null,
    @JsonProperty("host") val host: String? = null,
    @JsonProperty("videoable_id") val videoableID: Long? = null,
    @JsonProperty("videoable_type") val videoableType: String? = null,
    @JsonProperty("created_at") val createdAt: String? = null,
    @JsonProperty("updated_at") val updatedAt: String? = null,
    @JsonProperty("size") val size: String? = null,
    @JsonProperty("created_by") val createdBy: String? = null,
    @JsonProperty("server_id") val serverID: Long? = null,
    @JsonProperty("name") val name: String? = null,
    @JsonProperty("quality") val quality: String? = null,
    @JsonProperty("original_name") val originalName: Any? = null,
    @JsonProperty("views") val views: Long? = null,
    @JsonProperty("public") val public: Long? = null,
    @JsonProperty("proxy_id") val proxyID: Any? = null,
    @JsonProperty("proxy_default_id") val proxyDefaultID: Any? = null,
    @JsonProperty("scws_id") val scwsID: Any? = null
)


class StreamingcommunityProvider : MainAPI() {
    override var lang = "it"
    override var mainUrl = "https://streamingcommunity.best"
    override var name = "Streamingcommunity"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    private fun translatenumber(num: Int): Int? {
        return when (num) {
            67 -> 1
            71 -> 2
            72 -> 3
            73 -> 4
            74 -> 5
            75 -> 6
            76 -> 7
            77 -> 8
            78 -> 9
            79 -> 10
            133 -> 11
            else -> null
        }
    }

    private fun translateip(num: Int): String? {
        return when (num) {
            16 -> "sc-b1-01.scws-content.net"
            17 -> "sc-b1-02.scws-content.net"
            18 -> "sc-b1-03.scws-content.net"
            85 -> "sc-b1-04.scws-content.net"
            95 -> "sc-b1-05.scws-content.net"
            117 -> "sc-b1-06.scws-content.net"
            141 -> "sc-b1-07.scws-content.net"
            142 -> "sc-b1-08.scws-content.net"
            143 -> "sc-b1-09.scws-content.net"
            144 -> "sc-b1-10.scws-content.net"
            else -> null
        }
    }

    companion object {
        val posterMap = hashMapOf<String, String>()
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val document = app.get(mainUrl).document
        document.select("slider-title").subList(0, 3).map { it ->
            if (it.attr("slider-name") != "In arrivo") {
                val films = it.attr("titles-json")
                val lista = mutableListOf<MovieSearchResponse>()
                val videoData = parseJson<List<VideoElement>>(films)

                videoData.subList(0, 12).map { searchr ->
                    val id = searchr.id
                    val name = searchr.slug
                    val img = searchr.images[0].url
                    val number = translatenumber(searchr.images[0].serverID.toInt())
                    val ip = translateip(searchr.images[0].proxyID.toInt())
                    val posterurl = "https://$ip/images/$number/$img"
                    val videourl = "$mainUrl/titles/$id-$name"
                    posterMap[videourl] = posterurl
                    val data = app.post("$mainUrl/api/titles/preview/$id", referer = mainUrl).text
                    val datajs = parseJson<Moviedata>(data)
                    val type: TvType = if (datajs.type == "movie") {
                        TvType.Movie
                    } else {
                        TvType.TvSeries
                    }

                    lista.add(
                        MovieSearchResponse(
                            datajs.name,
                            videourl,
                            this.name,
                            type,
                            posterurl,
                            datajs.releaseDate.substringBefore("-").filter { it.isDigit() }
                                .toIntOrNull(),
                            null,
                        )
                    )
                }
                items.add(HomePageList(it.attr("slider-name"), lista))
            }
        }
        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val queryformatted = query.replace(" ", "%20")
        val url = "$mainUrl/search?q=$queryformatted"
        val document = app.get(url).document

        val films =
            document.selectFirst("the-search-page")!!.attr("records-json").replace("&quot;", """"""")

        val searchresults = parseJson<List<VideoElement>>(films)
        return searchresults.map { result ->
            val id = result.id
            val name = result.slug
            val img = result.images[0].url
            val number = translatenumber(result.images[0].serverID.toInt())
            val ip = translateip(result.images[0].proxyID.toInt())
            val data = app.post("$mainUrl/api/titles/preview/$id", referer = mainUrl).text
            val datajs = parseJson<Moviedata>(data)
            val posterurl = "https://$ip/images/$number/$img"
            val videourl = "$mainUrl/titles/$id-$name"
            posterMap[videourl] = posterurl
            if (datajs.type == "movie") {
                val type = TvType.Movie
                MovieSearchResponse(
                    datajs.name,
                    videourl,
                    this.name,
                    type,
                    posterurl,
                    datajs.releaseDate.substringBefore("-").filter { it.isDigit() }.toIntOrNull(),
                    null,
                )
            } else {
                val type = TvType.TvSeries
                TvSeriesSearchResponse(
                    datajs.name,
                    videourl,
                    this.name,
                    type,
                    posterurl,
                    datajs.releaseDate.substringBefore("-").filter { it.isDigit() }.toIntOrNull(),
                    null,
                )
            }

        }

    }

    override suspend fun load(url: String): LoadResponse {

        val document = app.get(url).document
        val poster = posterMap[url]
        val id = url.substringBefore("-").filter { it.isDigit() }
        val data = app.post("$mainUrl/api/titles/preview/$id", referer = mainUrl).text

        val datajs = parseJson<Moviedata>(data)
        val type: TvType = if (datajs.type == "movie") {
            TvType.Movie
        } else {
            TvType.TvSeries
        }
        val trailerinfojs = document.select("slider-trailer").attr("videos")
        val trailerinfo = parseJson<List<TrailerElement>>(trailerinfojs)
        val trailerurl: String? = if (trailerinfo.isNotEmpty()) {
            "https://www.youtube.com/watch?v=${trailerinfo[0].url}"
        } else {
            null
        }

        val year = datajs.releaseDate.substringBefore("-")

        val correlatijs = document.selectFirst("slider-title")!!.attr("titles-json")
        val listacorr = mutableListOf<MovieSearchResponse>()
        val correlatidata = parseJson<List<VideoElement>>(correlatijs)
        val number : Int = if (correlatidata.size<=15) {correlatidata.size} else correlatidata.size-15

        correlatidata.take(number).map { searchr ->
            val idcorr = searchr.id
            val name = searchr.slug
            val img = searchr.images[0].url
            val number = translatenumber(searchr.images[0].serverID.toInt())
            val ip = translateip(searchr.images[0].proxyID.toInt())
            val datacorrel = app.post("$mainUrl/api/titles/preview/$idcorr", referer = mainUrl).text
            val datajscorrel = parseJson<Moviedata>(datacorrel)
            val videourl = "$mainUrl/titles/$idcorr-$name"
            val posterurl = "https://$ip/images/$number/$img"

            posterMap[videourl] = posterurl
            val typecorr: TvType = if (datajscorrel.type == "movie") {
                TvType.Movie
            } else {
                TvType.TvSeries
            }

            listacorr.add(
                MovieSearchResponse(
                    datajscorrel.name,
                    videourl,
                    this.name,
                    typecorr,
                    posterurl,
                    datajscorrel.releaseDate.substringBefore("-").filter { it.isDigit() }
                        .toIntOrNull(),
                    null,
                )
            )
        }

        if (type == TvType.TvSeries) {

            val name = datajs.name
            val episodeList = arrayListOf<Episode>()

            val episodes =
                Html.fromHtml(document.selectFirst("season-select")!!.attr("seasons")).toString()
            val jsonEpisodes = parseJson<List<Season>>(episodes)

            jsonEpisodes.map { seasons ->
                val stagione = seasons.number.toInt()
                val sid = seasons.title_id
                val episodio = seasons.episodes
                episodio.map { ep ->
                    val href = "$mainUrl/watch/$sid?e=${ep.id}"
                    val postimage = if (ep.images.isNotEmpty()) {
                        ep.images.first().originalURL
                    } else {
                        ""
                    }
                    episodeList.add(

                        newEpisode(href) {
                            this.name = ep.name
                            this.season = stagione
                            this.episode = ep.number.toInt()
                            this.description = ep.plot
                            this.posterUrl = postimage
                        }
                    )
                }
            }


            if (episodeList.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            return newTvSeriesLoadResponse(name, url, type, episodeList) {
                this.posterUrl = poster
                this.year = year.filter { it.isDigit() }.toInt()
                this.plot = document.selectFirst("div.plot-wrap > p")!!.text()
                this.duration = datajs.runtime?.toInt()
                this.rating = (datajs.votes[0].average.toFloatOrNull()?.times(1000))?.toInt()
                this.tags = datajs.genres.map { it.name }
                addTrailer(trailerurl)
                this.recommendations = listacorr
            }


        } else {

            return newMovieLoadResponse(
                document.selectFirst("div > div > h1")!!.text(),
                document.select("a.play-hitzone").attr("href"),
                type,
                document.select("a.play-hitzone").attr("href")
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year.filter { it.isDigit() }.toInt()
                this.plot = document.selectFirst("p.plot")!!.text()
                this.rating = datajs.votes[0].average.toFloatOrNull()?.times(1000)?.toInt()
                this.tags = datajs.genres.map { it.name }
                this.duration = datajs.runtime?.toInt()
                addTrailer(trailerurl)
                this.recommendations = listacorr
            }

        }
    }


    private suspend fun getM3u8Qualities(
        m3u8Link: String,
        referer: String,
        qualityName: String,
    ): List<ExtractorLink> {
        return M3u8Helper.generateM3u8(
            this.name,
            m3u8Link,
            referer,
            name = "${this.name} - $qualityName"
        )
    }


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val ip = app.get("https://api.ipify.org/").text
        val videors = app.get(data).document
        val scwsidjs = videors.select("video-player").attr("response").replace("&quot;", """"""")
        val jsn = JSONObject(scwsidjs)
        val scwsid = jsn.getString("scws_id")
        val expire = (System.currentTimeMillis() / 1000 + 172800).toString()

        val uno = "$expire$ip Yc8U6r8KjAKAepEA".toByteArray()
        val due = MessageDigest.getInstance("MD5").digest(uno)
        val tre = base64Encode(due)
        val token = tre.replace("=", "").replace("+", "-").replace("/", "_")


        val link = "https://scws.xyz/master/$scwsid?token=$token&expires=$expire&n=1&n=1"
        getM3u8Qualities(link, data, URI(link).host).forEach(callback)
        return true
    }
}



================================================
FILE: StreamingcommunityProvider/src/main/kotlin/com/lagradost/StreamingcommunityProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class StreamingcommunityProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(StreamingcommunityProvider())
    }
}


================================================
FILE: SuperStream/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: SuperStream/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: SuperStream/src/main/kotlin/com/lagradost/SuperStream.kt
================================================
package com.lagradost

import android.util.Base64
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.SuperStream.CipherUtils.getVerify
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.APIHolder.capitalize
import com.lagradost.cloudstream3.APIHolder.unixTime
import com.lagradost.cloudstream3.LoadResponse.Companion.addImdbId
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import com.lagradost.nicehttp.NiceResponse
import java.nio.charset.StandardCharsets
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec
import kotlin.math.roundToInt

const val TYPE_SERIES = 2
const val TYPE_MOVIES = 1

class SuperStream : MainAPI() {
    override var name = "SuperStream"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime,
        TvType.AnimeMovie,
    )

    // 0 to get nsfw
    private val hideNsfw = 1

    override val instantLinkLoading = true

    val headers = mapOf(
        "Platform" to "android",
        "Accept" to "charset=utf-8",
    )

    // Random 32 length string
    private fun randomToken(): String {
        return (0..31).joinToString("") {
            (('0'..'9') + ('a'..'f')).random().toString()
        }
    }

    private val token = randomToken()

    private object CipherUtils {
        private const val ALGORITHM = "DESede"
        private const val TRANSFORMATION = "DESede/CBC/PKCS5Padding"
        fun encrypt(str: String, key: String, iv: String): String? {
            return try {
                val cipher: Cipher = Cipher.getInstance(TRANSFORMATION)
                val bArr = ByteArray(24)
                val bytes: ByteArray = key.toByteArray()
                var length = if (bytes.size <= 24) bytes.size else 24
                System.arraycopy(bytes, 0, bArr, 0, length)
                while (length < 24) {
                    bArr[length] = 0
                    length++
                }
                cipher.init(
                    1,
                    SecretKeySpec(bArr, ALGORITHM),
                    IvParameterSpec(iv.toByteArray())
                )

                String(Base64.encode(cipher.doFinal(str.toByteArray()), 2), StandardCharsets.UTF_8)
            } catch (e: Exception) {
                e.printStackTrace()
                null
            }
        }

        fun md5(str: String): String? {
            return MD5Util.md5(str)?.let { HexDump.toHexString(it).lowercase() }
        }

        fun getVerify(str: String?, str2: String, str3: String): String? {
            if (str != null) {
                return md5(md5(str2) + str3 + str)
            }
            return null
        }
    }

    private object HexDump {
        private val HEX_DIGITS = charArrayOf(
            '0',
            '1',
            '2',
            '3',
            '4',
            '5',
            '6',
            '7',
            '8',
            '9',
            'A',
            'B',
            'C',
            'D',
            'E',
            'F'
        )

        @JvmOverloads
        fun toHexString(bArr: ByteArray, i: Int = 0, i2: Int = bArr.size): String {
            val cArr = CharArray(i2 * 2)
            var i3 = 0
            for (i4 in i until i + i2) {
                val b = bArr[i4].toInt()
                val i5 = i3 + 1
                val cArr2 = HEX_DIGITS
                cArr[i3] = cArr2[b ushr 4 and 15]
                i3 = i5 + 1
                cArr[i5] = cArr2[b and 15]
            }
            return String(cArr)
        }
    }

    private object MD5Util {
        fun md5(str: String): ByteArray? {
            return this.md5(str.toByteArray())
        }

        fun md5(bArr: ByteArray?): ByteArray? {
            return try {
                val digest = MessageDigest.getInstance("MD5")
                digest.update(bArr ?: return null)
                digest.digest()
            } catch (e: NoSuchAlgorithmException) {
                e.printStackTrace()
                null
            }
        }
    }

    private suspend fun queryApi(query: String): NiceResponse {
        val encryptedQuery = CipherUtils.encrypt(query, key, iv)!!
        val appKeyHash = CipherUtils.md5(appKey)!!
        val newBody =
            """{"app_key":"$appKeyHash","verify":"${
                getVerify(
                    encryptedQuery,
                    appKey,
                    key
                )
            }","encrypt_data":"$encryptedQuery"}"""
        val base64Body = String(Base64.encode(newBody.toByteArray(), Base64.DEFAULT))

        val data = mapOf(
            "data" to base64Body,
            "appid" to "27",
            "platform" to "android",
            "version" to "129",
            // Probably best to randomize this
            "medium" to "Website&token$token"
        )

        return app.post(apiUrl, headers = headers, data = data)
    }

    private suspend inline fun <reified T : Any> queryApiParsed(query: String): T {
        return queryApi(query).parsed()
    }

    private fun getExpiryDate(): Long {
        // Current time + 12 hours
        return unixTime + 60 * 60 * 12
    }

    private data class PostJSON(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("poster") val poster: String? = null,
        @JsonProperty("poster_2") val poster2: String? = null,
        @JsonProperty("box_type") val boxType: Int? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("quality_tag") val quality_tag: String? = null,
    )

    private data class ListJSON(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("type") val type: String? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("box_type") val boxType: Int? = null,
        @JsonProperty("list") val list: ArrayList<PostJSON> = arrayListOf(),
    )

    private data class DataJSON(
        @JsonProperty("data") val data: ArrayList<ListJSON> = arrayListOf()
    )

    // We do not want content scanners to notice this scraping going on so we've hidden all constants
    // The source has its origins in China so I added some extra security with banned words
    // Mayhaps a tiny bit unethical, but this source is just too good :)
    // If you are copying this code please use precautions so they do not change their api.

    // Free Tibet, The Tienanmen Square protests of 1989
    private val iv = base64Decode("d0VpcGhUbiE=")
    private val key = base64Decode("MTIzZDZjZWRmNjI2ZHk1NDIzM2FhMXc2")
    private val ip = base64Decode("aHR0cHM6Ly8xNTIuMzIuMTQ5LjE2MA==")
    private val apiUrl =
        "$ip${base64Decode("L2FwaS9hcGlfY2xpZW50L2luZGV4Lw==")}"
    private val appKey = base64Decode("bW92aWVib3g=")
    private val appId = base64Decode("Y29tLnRkby5zaG93Ym94")

    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val json = queryApi(
            """{"childmode":"$hideNsfw","app_version":"11.5","appid":"$appId","module":"Home_list_type_v2","channel":"Website","page":"$page","lang":"en","type":"all","pagelimit":"10","expired_date":"${getExpiryDate()}","platform":"android"}
            """.trimIndent()
        ).text

        // Cut off the first row (featured)
        val pages = parseJson<DataJSON>(json).data.let { it.subList(minOf(it.size, 1), it.size) }
            .mapNotNull {
                var name = it.name
                if (name.isNullOrEmpty()) name = "Featured"
                val postList = it.list.mapNotNull second@{ post ->
                    val type = if (post.boxType == 1) TvType.Movie else TvType.TvSeries
                    newMovieSearchResponse(
                        name = post.title ?: return@second null,
                        url = LoadData(post.id ?: return@mapNotNull null, post.boxType).toJson(),
                        type = type,
                        fix = false
                    ) {
                        posterUrl = post.poster ?: post.poster2
                        quality = getQualityFromString(post.quality_tag ?: "")
                    }
                }
                if (postList.isEmpty()) return@mapNotNull null
                HomePageList(name, postList)
            }
        return HomePageResponse(pages, hasNext = !pages.any { it.list.isEmpty() })
    }

    private data class Data(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("box_type") val boxType: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("poster_org") val posterOrg: String? = null,
        @JsonProperty("poster") val poster: String? = null,
        @JsonProperty("cats") val cats: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("quality_tag") val qualityTag: String? = null,
    )

    private data class MainData(
        @JsonProperty("data") val data: ArrayList<Data> = arrayListOf()
    )

    override suspend fun search(query: String): List<SearchResponse> {

        val apiQuery =
            // Originally 8 pagelimit
            """{"childmode":"$hideNsfw","app_version":"11.5","appid":"$appId","module":"Search3","channel":"Website","page":"1","lang":"en","type":"all","keyword":"$query","pagelimit":"20","expired_date":"${getExpiryDate()}","platform":"android"}"""
        val searchResponse = parseJson<MainData>(queryApi(apiQuery).text).data.mapNotNull {
            val type = if (it.boxType == 1) TvType.Movie else TvType.TvSeries
            newMovieSearchResponse(
                name = it.title ?: return@mapNotNull null,
                url = LoadData(it.id ?: return@mapNotNull null, it.boxType).toJson(),
                type = type,
                fix = false
            ) {
                posterUrl = it.posterOrg ?: it.poster
                year = it.year
                quality = getQualityFromString(it.qualityTag?.replace("-", "") ?: "")
            }
        }
        return searchResponse
    }

    private data class LoadData(
        val id: Int,
        val type: Int?
    )

    private data class MovieData(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("director") val director: String? = null,
        @JsonProperty("writer") val writer: String? = null,
        @JsonProperty("actors") val actors: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("poster") val poster: String? = null,
        @JsonProperty("description") val description: String? = null,
        @JsonProperty("cats") val cats: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("trailer") val trailer: String? = null,
        @JsonProperty("released") val released: String? = null,
        @JsonProperty("content_rating") val contentRating: String? = null,
        @JsonProperty("tmdb_id") val tmdbId: Int? = null,
        @JsonProperty("tomato_meter") val tomatoMeter: Int? = null,
        @JsonProperty("poster_org") val posterOrg: String? = null,
        @JsonProperty("trailer_url") val trailerUrl: String? = null,
        @JsonProperty("imdb_link") val imdbLink: String? = null,
        @JsonProperty("box_type") val boxType: Int? = null,
    )

    private data class MovieDataProp(
        @JsonProperty("data") val data: MovieData? = MovieData()
    )


    private data class SeriesDataProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: SeriesData? = SeriesData()
    )

    private data class SeriesSeasonProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: ArrayList<SeriesEpisode>? = arrayListOf()
    )
//    data class PlayProgress (
//
//  @JsonProperty("over"      ) val over     : Int? = null,
//  @JsonProperty("seconds"   ) val seconds  : Int? = null,
//  @JsonProperty("mp4_id"    ) val mp4Id    : Int? = null,
//  @JsonProperty("last_time" ) val lastTime : Int? = null
//
//)

    private data class SeriesEpisode(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("tid") val tid: Int? = null,
        @JsonProperty("mb_id") val mbId: Int? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("imdb_id_status") val imdbIdStatus: Int? = null,
        @JsonProperty("srt_status") val srtStatus: Int? = null,
        @JsonProperty("season") val season: Int? = null,
        @JsonProperty("episode") val episode: Int? = null,
        @JsonProperty("state") val state: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("thumbs") val thumbs: String? = null,
        @JsonProperty("thumbs_bak") val thumbsBak: String? = null,
        @JsonProperty("thumbs_original") val thumbsOriginal: String? = null,
        @JsonProperty("poster_imdb") val posterImdb: Int? = null,
        @JsonProperty("synopsis") val synopsis: String? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("view") val view: Int? = null,
        @JsonProperty("download") val download: Int? = null,
        @JsonProperty("source_file") val sourceFile: Int? = null,
        @JsonProperty("code_file") val codeFile: Int? = null,
        @JsonProperty("add_time") val addTime: Int? = null,
        @JsonProperty("update_time") val updateTime: Int? = null,
        @JsonProperty("released") val released: String? = null,
        @JsonProperty("released_timestamp") val releasedTimestamp: Long? = null,
        @JsonProperty("audio_lang") val audioLang: String? = null,
        @JsonProperty("quality_tag") val qualityTag: String? = null,
        @JsonProperty("3d") val _3d: Int? = null,
        @JsonProperty("remark") val remark: String? = null,
        @JsonProperty("pending") val pending: String? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("display") val display: Int? = null,
        @JsonProperty("sync") val sync: Int? = null,
        @JsonProperty("tomato_meter") val tomatoMeter: Int? = null,
        @JsonProperty("tomato_meter_count") val tomatoMeterCount: Int? = null,
        @JsonProperty("tomato_audience") val tomatoAudience: Int? = null,
        @JsonProperty("tomato_audience_count") val tomatoAudienceCount: Int? = null,
        @JsonProperty("thumbs_min") val thumbsMin: String? = null,
        @JsonProperty("thumbs_org") val thumbsOrg: String? = null,
        @JsonProperty("imdb_link") val imdbLink: String? = null,
//        @JsonProperty("quality_tags") val qualityTags: ArrayList<String> = arrayListOf(),
//  @JsonProperty("play_progress"         ) val playProgress        : PlayProgress?     = PlayProgress()

    )

    private data class SeriesLanguage(
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("lang") val lang: String? = null
    )

    private data class SeriesData(
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("mb_id") val mbId: Int? = null,
        @JsonProperty("title") val title: String? = null,
        @JsonProperty("display") val display: Int? = null,
        @JsonProperty("state") val state: Int? = null,
        @JsonProperty("vip_only") val vipOnly: Int? = null,
        @JsonProperty("code_file") val codeFile: Int? = null,
        @JsonProperty("director") val director: String? = null,
        @JsonProperty("writer") val writer: String? = null,
        @JsonProperty("actors") val actors: String? = null,
        @JsonProperty("add_time") val addTime: Int? = null,
        @JsonProperty("poster") val poster: String? = null,
        @JsonProperty("poster_imdb") val posterImdb: Int? = null,
        @JsonProperty("banner_mini") val bannerMini: String? = null,
        @JsonProperty("description") val description: String? = null,
        @JsonProperty("imdb_id") val imdbId: String? = null,
        @JsonProperty("cats") val cats: String? = null,
        @JsonProperty("year") val year: Int? = null,
        @JsonProperty("collect") val collect: Int? = null,
        @JsonProperty("view") val view: Int? = null,
        @JsonProperty("download") val download: Int? = null,
        @JsonProperty("update_time") val updateTime: String? = null,
        @JsonProperty("released") val released: String? = null,
        @JsonProperty("released_timestamp") val releasedTimestamp: Int? = null,
        @JsonProperty("episode_released") val episodeReleased: String? = null,
        @JsonProperty("episode_released_timestamp") val episodeReleasedTimestamp: Int? = null,
        @JsonProperty("max_season") val maxSeason: Int? = null,
        @JsonProperty("max_episode") val maxEpisode: Int? = null,
        @JsonProperty("remark") val remark: String? = null,
        @JsonProperty("imdb_rating") val imdbRating: String? = null,
        @JsonProperty("content_rating") val contentRating: String? = null,
        @JsonProperty("tmdb_id") val tmdbId: Int? = null,
        @JsonProperty("tomato_url") val tomatoUrl: String? = null,
        @JsonProperty("tomato_meter") val tomatoMeter: Int? = null,
        @JsonProperty("tomato_meter_count") val tomatoMeterCount: Int? = null,
        @JsonProperty("tomato_meter_state") val tomatoMeterState: String? = null,
        @JsonProperty("reelgood_url") val reelgoodUrl: String? = null,
        @JsonProperty("audience_score") val audienceScore: Int? = null,
        @JsonProperty("audience_score_count") val audienceScoreCount: Int? = null,
        @JsonProperty("no_tomato_url") val noTomatoUrl: Int? = null,
        @JsonProperty("order_year") val orderYear: Int? = null,
        @JsonProperty("episodate_id") val episodateId: String? = null,
        @JsonProperty("weights_day") val weightsDay: Double? = null,
        @JsonProperty("poster_min") val posterMin: String? = null,
        @JsonProperty("poster_org") val posterOrg: String? = null,
        @JsonProperty("banner_mini_min") val bannerMiniMin: String? = null,
        @JsonProperty("banner_mini_org") val bannerMiniOrg: String? = null,
        @JsonProperty("trailer_url") val trailerUrl: String? = null,
        @JsonProperty("years") val years: ArrayList<Int> = arrayListOf(),
        @JsonProperty("season") val season: ArrayList<Int> = arrayListOf(),
        @JsonProperty("history") val history: ArrayList<String> = arrayListOf(),
        @JsonProperty("imdb_link") val imdbLink: String? = null,
        @JsonProperty("episode") val episode: ArrayList<SeriesEpisode> = arrayListOf(),
//        @JsonProperty("is_collect") val isCollect: Int? = null,
        @JsonProperty("language") val language: ArrayList<SeriesLanguage> = arrayListOf(),
        @JsonProperty("box_type") val boxType: Int? = null,
        @JsonProperty("year_year") val yearYear: String? = null,
        @JsonProperty("season_episode") val seasonEpisode: String? = null
    )


    override suspend fun load(url: String): LoadResponse {
        val loadData = parseJson<LoadData>(url)
        // val module = if(type === "TvType.Movie") "Movie_detail" else "*tv series module*"

        val isMovie = loadData.type == TYPE_MOVIES

        if (isMovie) { // 1 = Movie
            val apiQuery =
                """{"childmode":"$hideNsfw","uid":"","app_version":"11.5","appid":"$appId","module":"Movie_detail","channel":"Website","mid":"${loadData.id}","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","oss":"","group":""}"""
            val data = (queryApiParsed<MovieDataProp>(apiQuery)).data
                ?: throw RuntimeException("API error")

            return newMovieLoadResponse(
                data.title ?: "",
                url,
                TvType.Movie,
                LinkData(
                    data.id ?: throw RuntimeException("No movie ID"),
                    TYPE_MOVIES,
                    null,
                    null
                ),
            ) {
                this.posterUrl = data.posterOrg ?: data.poster
                this.year = data.year
                this.plot = data.description
                this.tags = data.cats?.split(",")?.map { it.capitalize() }
                this.rating = data.imdbRating?.split("/")?.get(0)?.toIntOrNull()
                addTrailer(data.trailerUrl)
                this.addImdbId(data.imdbId)
            }
        } else { // 2 Series
            val apiQuery =
                """{"childmode":"$hideNsfw","uid":"","app_version":"11.5","appid":"$appId","module":"TV_detail_1","display_all":"1","channel":"Website","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","tid":"${loadData.id}"}"""
            val data = (queryApiParsed<SeriesDataProp>(apiQuery)).data
                ?: throw RuntimeException("API error")

            val episodes = data.season.mapNotNull {
                val seasonQuery =
                    """{"childmode":"$hideNsfw","app_version":"11.5","year":"0","appid":"$appId","module":"TV_episode","display_all":"1","channel":"Website","season":"$it","lang":"en","expired_date":"${getExpiryDate()}","platform":"android","tid":"${loadData.id}"}"""
                (queryApiParsed<SeriesSeasonProp>(seasonQuery)).data
            }.flatten()

            return newTvSeriesLoadResponse(
                data.title ?: "",
                url,
                TvType.TvSeries,
                episodes.mapNotNull {
                    Episode(
                        LinkData(
                            it.tid ?: it.id ?: return@mapNotNull null,
                            TYPE_SERIES,
                            it.season,
                            it.episode
                        ).toJson(),
                        it.title,
                        it.season,
                        it.episode,
                        it.thumbs ?: it.thumbsBak ?: it.thumbsMin ?: it.thumbsOriginal
                        ?: it.thumbsOrg,
                        it.imdbRating?.toDoubleOrNull()?.times(10)?.roundToInt(),
                        it.synopsis,
                        it.releasedTimestamp
                    )
                }
            ) {
                this.year = data.year
                this.plot = data.description
                this.posterUrl = data.posterOrg ?: data.poster
                this.rating = data.imdbRating?.split("/")?.get(0)?.toIntOrNull()
                this.tags = data.cats?.split(",")?.map { it.capitalize() }
                this.addImdbId(data.imdbId)
            }
        }
    }


    private data class LinkData(
        val id: Int,
        val type: Int,
        val season: Int?,
        val episode: Int?
    )


    private data class LinkDataProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: ParsedLinkData? = ParsedLinkData()
    )

    private data class LinkList(
        @JsonProperty("path") val path: String? = null,
        @JsonProperty("quality") val quality: String? = null,
        @JsonProperty("real_quality") val realQuality: String? = null,
        @JsonProperty("format") val format: String? = null,
        @JsonProperty("size") val size: String? = null,
        @JsonProperty("size_bytes") val sizeBytes: Long? = null,
        @JsonProperty("count") val count: Int? = null,
        @JsonProperty("dateline") val dateline: Long? = null,
        @JsonProperty("fid") val fid: Int? = null,
        @JsonProperty("mmfid") val mmfid: Int? = null,
        @JsonProperty("h265") val h265: Int? = null,
        @JsonProperty("hdr") val hdr: Int? = null,
        @JsonProperty("filename") val filename: String? = null,
        @JsonProperty("original") val original: Int? = null,
        @JsonProperty("colorbit") val colorbit: Int? = null,
        @JsonProperty("success") val success: Int? = null,
        @JsonProperty("timeout") val timeout: Int? = null,
        @JsonProperty("vip_link") val vipLink: Int? = null,
        @JsonProperty("fps") val fps: Int? = null,
        @JsonProperty("bitstream") val bitstream: String? = null,
        @JsonProperty("width") val width: Int? = null,
        @JsonProperty("height") val height: Int? = null
    )

    private data class ParsedLinkData(
        @JsonProperty("seconds") val seconds: Int? = null,
        @JsonProperty("quality") val quality: ArrayList<String> = arrayListOf(),
        @JsonProperty("list") val list: ArrayList<LinkList> = arrayListOf()
    )

    private data class SubtitleDataProp(
        @JsonProperty("code") val code: Int? = null,
        @JsonProperty("msg") val msg: String? = null,
        @JsonProperty("data") val data: PrivateSubtitleData? = PrivateSubtitleData()
    )

    private data class Subtitles(
        @JsonProperty("sid") val sid: Int? = null,
        @JsonProperty("mid") val mid: String? = null,
        @JsonProperty("file_path") val filePath: String? = null,
        @JsonProperty("lang") val lang: String? = null,
        @JsonProperty("language") val language: String? = null,
        @JsonProperty("delay") val delay: Int? = null,
        @JsonProperty("point") val point: String? = null,
        @JsonProperty("order") val order: Int? = null,
        @JsonProperty("admin_order") val adminOrder: Int? = null,
        @JsonProperty("myselect") val myselect: Int? = null,
        @JsonProperty("add_time") val addTime: Long? = null,
        @JsonProperty("count") val count: Int? = null
    )

    private data class SubtitleList(

        @JsonProperty("language") val language: String? = null,
        @JsonProperty("subtitles") val subtitles: ArrayList<Subtitles> = arrayListOf()

    )

    private data class PrivateSubtitleData(
        @JsonProperty("select") val select: ArrayList<String> = arrayListOf(),
        @JsonProperty("list") val list: ArrayList<SubtitleList> = arrayListOf()
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        fun LinkList.toExtractorLink(): ExtractorLink? {
            return ExtractorLink(
                this@SuperStream.name,
                this.filename ?: "",
                this.path?.replace("\\/", "") ?: return null,
                "",
                getQualityFromName(this.quality),
            )
        }

        fun Subtitles.toSubtitleFile(): SubtitleFile? {
            return SubtitleFile(
                this.language ?: this.lang ?: "",
                this.filePath ?: return null
            )
        }

        val parsed = parseJson<LinkData>(data)

        // No childmode when getting links
        val query = if (parsed.type == TYPE_MOVIES) {
            """{"childmode":"0","uid":"","app_version":"11.5","appid":"$appId","module":"Movie_downloadurl_v3","channel":"Website","mid":"${parsed.id}","lang":"","expired_date":"${getExpiryDate()}","platform":"android","oss":"1","group":""}"""
        } else {
            val episode = parsed.episode ?: throw RuntimeException("No episode number!")
            val season = parsed.season ?: throw RuntimeException("No season number!")
            """{"childmode":"0","app_version":"11.5","module":"TV_downloadurl_v3","channel":"Website","episode":"$episode","expired_date":"${getExpiryDate()}","platform":"android","tid":"${parsed.id}","oss":"1","uid":"","appid":"$appId","season":"$season","lang":"en","group":""}"""
        }

        val linkData = queryApiParsed<LinkDataProp>(query)
        linkData.data?.list?.forEach {
            callback.invoke(it.toExtractorLink() ?: return@forEach)
        }

        // Should really run this query for every link :(
        val fid = linkData.data?.list?.firstOrNull { it.fid != null }?.fid

        val subtitleQuery = if (parsed.type == TYPE_MOVIES) {
            """{"childmode":"0","fid":"$fid","uid":"","app_version":"11.5","appid":"$appId","module":"Movie_srt_list_v2","channel":"Website","mid":"${parsed.id}","lang":"en","expired_date":"${getExpiryDate()}","platform":"android"}"""
        } else {
            """{"childmode":"0","fid":"$fid","app_version":"11.5","module":"TV_srt_list_v2","channel":"Website","episode":"${parsed.episode}","expired_date":"${getExpiryDate()}","platform":"android","tid":"${parsed.id}","uid":"","appid":"$appId","season":"${parsed.season}","lang":"en"}"""
        }

        val subtitles = queryApiParsed<SubtitleDataProp>(subtitleQuery).data
        subtitles?.list?.forEach {
            it.subtitles.forEach second@{ sub ->
                subtitleCallback.invoke(sub.toSubtitleFile() ?: return@second)
            }
        }

        return true
    }
}


================================================
FILE: SuperStream/src/main/kotlin/com/lagradost/SuperStreamPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class SuperStreamPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(SuperStream())
    }
}


================================================
FILE: TantiFilmProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: TantiFilmProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: TantiFilmProvider/src/main/kotlin/com/lagradost/TantiFilmProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor


class TantifilmProvider : MainAPI() {
    override var lang = "it"
    override var mainUrl = "https://tantifilm.autos"
    override var name = "Tantifilm"
    override val hasMainPage = true
    override val hasChromecastSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        Pair("$mainUrl/watch-genre/al-cinema/page/", "Ultimi Film"),
        Pair("$mainUrl/serie-tv/page/", "Ultime Serie Tv"),
        Pair("$mainUrl/watch-genre/film-aggiornati/page/", "Ultimi Film Aggiornati"),
    )

    override suspend fun getMainPage(
        page: Int,
        request : MainPageRequest
    ): HomePageResponse {
        val url = request.data + page
        val soup = app.get(url).document
        val home = soup.select("div.media3").map {
            val title = it.selectFirst("p")!!.text().substringBefore("(")
            val link = it.selectFirst("a")!!.attr("href")
            TvSeriesSearchResponse(
                title,
                link,
                this.name,
                TvType.Movie,
                it.selectFirst("img")!!.attr("src"),
                null,
                null,
            )
        }
        return newHomePageResponse(request.name, home)
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val queryformatted = query.replace(" ", "+")
        val url = "$mainUrl/search/$queryformatted"
        val doc = app.get(url).document
        return doc.select("div.film.film-2").map {
            val href = it.selectFirst("a")!!.attr("href")
            val poster = it.selectFirst("img")!!.attr("src")
            val name = it.selectFirst("a > p")!!.text().substringBeforeLast("(")
            MovieSearchResponse(
                name,
                href,
                this.name,
                TvType.Movie,
                poster,
                null
            )

        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document
        val type = if (document.selectFirst("div.category-film")!!.text().contains("Serie")
                .not()
        ) TvType.Movie else TvType.TvSeries
        val title = document.selectFirst("div.title-film-left")!!.text().substringBefore("(")
        val descipt = document.select("div.content-left-film > p").map { it.text() }
        val rating =
            document.selectFirst("div.star-rating.star-rating-f > span > span")!!
                .attr("data-rateit-value").toFloatOrNull()
                ?.times(2857)?.toInt()?.let { minOf(it, 10000) }

        var year = document.selectFirst("div.title-film-left")!!.text().substringAfter("(")
            .filter { it.isDigit() }
        year = if (year.length > 4) {
            year.dropLast(4)
        } else {
            year
        }
        // ?: does not wor
        val poster = document.selectFirst("div.image-right-film > img")!!.attr("src")

        val recomm = document.select("div.mediaWrap.mediaWrapAlt.recomended_videos").map {
            val href = it.selectFirst("a")!!.attr("href")
            val poster = it.selectFirst("img")!!.attr("src")
            val name = it.selectFirst("a > p")!!.text().substringBeforeLast("(")
            MovieSearchResponse(
                name,
                href,
                this.name,
                TvType.Movie,
                poster,
                null
            )

        }

        val trailerurl = document.selectFirst("#trailer_mob > iframe")!!.attr("src")

        if (type == TvType.TvSeries) {
            val list = ArrayList<Pair<Int, String>>()
            val urlvideocontainer = document.selectFirst("iframe")!!.attr("src")
            val videocontainer = app.get(urlvideocontainer).document
            videocontainer.select("nav.nav1 > select > option").forEach { element ->
                val season = element.text().toIntOrNull()
                val href = element.attr("value")
                if (season != null && season > 0 && !href.isNullOrBlank()) {
                    list.add(Pair(season, fixUrl(href)))
                }
            }
            if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

            val episodeList = ArrayList<Episode>()

            for ((season, seasonurl) in list) {
                val seasonDocument = app.get(seasonurl).document
                val episodes = seasonDocument.select("nav.second_nav > select > option")
                if (episodes.isNotEmpty()) {
                    episodes.forEach { episode ->
                        val href = episode.attr("value")
                        val epNum = episode.text().toIntOrNull()
                        episodeList.add(
                            Episode(
                                href,
                                title,
                                season,
                                epNum,
                            )
                        )
                    }
                }
            }
            return newTvSeriesLoadResponse(
                title,
                url,
                type,
                episodeList
            ) {
                this.posterUrl = fixUrlNull(poster)
                this.year = year.toIntOrNull()
                this.plot = descipt[0]
                this.rating = rating
                this.recommendations = recomm
                addTrailer(trailerurl)
            }
        } else {
            val url2 = document.selectFirst("iframe")!!.attr("src")
            val actorpagelink =
                document.select("div.content-left-film > p:nth-child(2) > a").attr("href")
            val actorpagelink2 = document.select("div.content-left-film > p > a").attr("href")
            val Linkactor: String = actorpagelink.ifEmpty {
                actorpagelink2
            }

            val actors: List<ActorData>? = if (Linkactor.isNotEmpty()) {
                val actorpage = app.get(Linkactor + "cast/").document
                actorpage.select("article.membro-cast").filter {
                    it -> it.selectFirst("img")
                        ?.attr("src") != "https://www.filmtv.it/imgbank/DUMMY/no_portrait.jpg"
                }.mapNotNull {
                    val name = it.selectFirst("div.info > h3")!!.text()
                    val image = it.selectFirst("img")?.attr("src")
                    val roleString: String = if (it.selectFirst("h2")?.text() == "Regia") {
                        "Regia"
                    } else {
                        "Attore"
                    }
                    val mainActor = Actor(name, image)
                    ActorData(actor = mainActor, roleString = roleString)
                }
            } else {
                null
            }


            val duratio: Int? = if (descipt.size == 2) {
                descipt[0].filter { it.isDigit() }.toInt()
            } else {
                null
            }
            val tags: List<String>? = if (descipt.size == 2) {
                mutableListOf(descipt[0].substringBefore(" "))
            } else {
                null
            }
            val plot: String = if (descipt.size == 2) {
                descipt[1]
            } else {
                descipt[0]
            }
            return newMovieLoadResponse(
                title,
                url2,
                type,
                url2
            ) {
                posterUrl = fixUrlNull(poster)
                this.year = year.toIntOrNull()
                this.plot = plot
                this.rating = rating
                this.recommendations = recomm
                this.tags = tags
                this.duration = duratio
                this.actors = actors
                addTrailer(trailerurl)

            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val doc = app.get(data).document
        val iframe =
            doc.select("option").map { fixUrl(it.attr("value")) }.filter { it.contains("label") }
        iframe.forEach { id ->
            val doc2 = app.get(id).document
            val id2 = app.get(doc2.selectFirst("iframe")!!.attr("src")).url
            loadExtractor(id2, data, subtitleCallback, callback)
        }
        return true
    }
}


================================================
FILE: TantiFilmProvider/src/main/kotlin/com/lagradost/TantiFilmProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class TantiFilmProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TantifilmProvider())
    }
}


================================================
FILE: TheFlixToProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: TheFlixToProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: TheFlixToProvider/src/main/kotlin/com/lagradost/TheFlixToProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.network.cookies
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName


class TheFlixToProvider : MainAPI() {
    companion object {
        var latestCookies: Map<String, String> = emptyMap()
    }

    override var name = "TheFlix.to"
    override var mainUrl = "https://theflix.to"
    override val instantLinkLoading = false
    override val hasMainPage = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )



    data class HomeJson(
        @JsonProperty("props") val props: HomeProps = HomeProps(),
    )

    data class HomeProps(
        @JsonProperty("pageProps") val pageProps: PageProps = PageProps(),
    )

    data class PageProps(
        @JsonProperty("moviesListTrending") val moviesListTrending: MoviesListTrending = MoviesListTrending(),
        @JsonProperty("moviesListNewArrivals") val moviesListNewArrivals: MoviesListNewArrivals = MoviesListNewArrivals(),
        @JsonProperty("tvsListTrending") val tvsListTrending: TvsListTrending = TvsListTrending(),
        @JsonProperty("tvsListNewEpisodes") val tvsListNewEpisodes: TvsListNewEpisodes = TvsListNewEpisodes(),
    )


    data class MoviesListTrending(
        @JsonProperty("docs") val docs: ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total") val total: Int? = null,
        @JsonProperty("page") val page: Int? = null,
        @JsonProperty("limit") val limit: Int? = null,
        @JsonProperty("pages") val pages: Int? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class MoviesListNewArrivals(
        @JsonProperty("docs") val docs: ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total") val total: Int? = null,
        @JsonProperty("page") val page: Int? = null,
        @JsonProperty("limit") val limit: Int? = null,
        @JsonProperty("pages") val pages: Int? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class TvsListTrending(
        @JsonProperty("docs") val docs: ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total") val total: Int? = null,
        @JsonProperty("page") val page: Int? = null,
        @JsonProperty("limit") val limit: Int? = null,
        @JsonProperty("pages") val pages: Int? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class TvsListNewEpisodes(
        @JsonProperty("docs") val docs: ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total") val total: Int? = null,
        @JsonProperty("page") val page: Int? = null,
        @JsonProperty("limit") val limit: Int? = null,
        @JsonProperty("pages") val pages: Int? = null,
        @JsonProperty("type") val type: String? = null,
    )

    data class Docs(
        @JsonProperty("name") val name: String = String(),
        @JsonProperty("originalLanguage") val originalLanguage: String? = null,
        @JsonProperty("popularity") val popularity: Double? = null,
        @JsonProperty("runtime") val runtime: Int? = null,
        @JsonProperty("status") val status: String? = null,
        @JsonProperty("voteAverage") val voteAverage: Double? = null,
        @JsonProperty("voteCount") val voteCount: Int? = null,
        @JsonProperty("cast") val cast: String? = null,
        @JsonProperty("director") val director: String? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("posterUrl") val posterUrl: String? = null,
        @JsonProperty("releaseDate") val releaseDate: String? = null,
        @JsonProperty("createdAt") val createdAt: String? = null,
        @JsonProperty("updatedAt") val updatedAt: String? = null,
        @JsonProperty("conversionDate") val conversionDate: String? = null,
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("available") val available: Boolean? = null,
        @JsonProperty("videos"           ) val videos           : ArrayList<String>? = arrayListOf(),
    )


    private suspend fun getCookies(): Map<String, String> {
        //  val cookieResponse = app.post(
        //      "https://theflix.to:5679/authorization/session/continue?contentUsageType=Viewing",
        //    headers = mapOf(
        //          "Host" to "theflix.to:5679",
        //          "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0",
        //          "Accept" to "application/json, text/plain,"
        //          "Accept-Language" to "en-US,en;q=0.5",
        //          "Content-Type" to "application/json;charset=utf-8",
        //          "Content-Length" to "35",
        //          "Origin" to "https://theflix.to",
        //          "DNT" to "1",
        //          "Connection" to "keep-alive",
        //          "Referer" to "https://theflix.to/",
        //          "Sec-Fetch-Dest" to "empty",
        //          "Sec-Fetch-Mode" to "cors",
        //          "Sec-Fetch-Site" to "same-site",)).okhttpResponse.headers.values("Set-Cookie")

        val cookies = app.post(
            "$mainUrl:5679/authorization/session/continue?contentUsageType=Viewing",
            headers = mapOf(
                "Host" to "theflix.to:5679",
                "User-Agent" to USER_AGENT,
                "Accept" to "application/json, text/plain, */*",
                "Accept-Language" to "en-US,en;q=0.5",
                "Content-Type" to "application/json;charset=utf-8",
                "Content-Length" to "35",
                "Origin" to mainUrl,
                "DNT" to "1",
                "Connection" to "keep-alive",
                "Referer" to mainUrl,
                "Sec-Fetch-Dest" to "empty",
                "Sec-Fetch-Mode" to "cors",
                "Sec-Fetch-Site" to "same-site",)
        ).cookies
        /* val cookieRegex = Regex("(theflix\\..*?id\\=[a-zA-Z0-9]{0,8}[a-zA-Z0-9_-]+)")
       val findcookie = cookieRegex.findAll(cookieResponse.toString()).map { it.value }.toList()
       val cookiesstring = findcookie.toString().replace(", ","; ").replace("[","").replace("]","")
       val cookiesmap = mapOf("Cookie" to cookiesstring) */
        latestCookies = cookies
        return latestCookies
    }


    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val items = ArrayList<HomePageList>()
        val doc = app.get(mainUrl).document
        val scriptText = doc.selectFirst("script[type=application/json]")!!.data()
        if (scriptText.contains("moviesListTrending")) {
            val json = parseJson<HomeJson>(scriptText)
            val homePageProps = json.props.pageProps
            listOf(
                Triple(
                    homePageProps.moviesListNewArrivals.docs,
                    homePageProps.moviesListNewArrivals.type,
                    "New Movie arrivals"
                ),
                Triple(
                    homePageProps.moviesListTrending.docs,
                    homePageProps.moviesListTrending.type,
                    "Trending Movies"
                ),
                Triple(
                    homePageProps.tvsListTrending.docs,
                    homePageProps.tvsListTrending.type,
                    "Trending TV Series"
                ),
                Triple(
                    homePageProps.tvsListNewEpisodes.docs,
                    homePageProps.tvsListNewEpisodes.type,
                    "New Episodes"
                )
            ).map { (docs, type, homename) ->
                val home = docs.map { info ->
                    val title = info.name
                    val poster = info.posterUrl
                    val typeinfo =
                        if (type?.contains("TV") == true) TvType.TvSeries else TvType.Movie
                    val link =
                        if (typeinfo == TvType.Movie) "$mainUrl/movie/${info.id}-${cleanTitle(title)}"
                        else "$mainUrl/tv-show/${info.id}-${cleanTitle(title).replace("?","")}/season-1/episode-1"
                    TvSeriesSearchResponse(
                        title,
                        link,
                        this.name,
                        typeinfo,
                        poster,
                        null,
                        null,
                    )
                }
                items.add(HomePageList(homename, home))
            }

        }

        if (items.size <= 0) throw ErrorLoadingException()
        return HomePageResponse(items)
    }

    data class SearchJson(
        @JsonProperty("props") val props: SearchProps = SearchProps(),
    )

    data class SearchProps(
        @JsonProperty("pageProps") val pageProps: SearchPageProps = SearchPageProps(),
    )

    data class SearchPageProps(
        @JsonProperty("mainList") val mainList: SearchMainList = SearchMainList(),
    )

    data class SearchMainList(
        @JsonProperty("docs") val docs: ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total") val total: Int? = null,
        @JsonProperty("page") val page: Int? = null,
        @JsonProperty("limit") val limit: Int? = null,
        @JsonProperty("pages") val pages: Int? = null,
        @JsonProperty("type") val type: String? = null,
    )


    override suspend fun search(query: String): List<SearchResponse> {
        val search = ArrayList<SearchResponse>()
        val urls = listOf(
            "$mainUrl/movies/trending?search=$query",
            "$mainUrl/tv-shows/trending?search=$query"
        )
        urls.apmap { url ->
            val doc = app.get(url).document
            val scriptText = doc.selectFirst("script[type=application/json]")!!.data()
            if (scriptText.contains("pageProps")) {
                val json = parseJson<SearchJson>(scriptText)
                val searchPageProps = json.props.pageProps.mainList
                val pair = listOf(Pair(searchPageProps.docs, searchPageProps.type))
                pair.map { (docs, type) ->
                    docs.map { info ->
                        val title = info.name
                        val poster = info.posterUrl
                        val typeinfo =
                            if (type?.contains("TV") == true) TvType.TvSeries else TvType.Movie
                        val link = if (typeinfo == TvType.Movie) "$mainUrl/movie/${info.id}-${
                            cleanTitle(title)
                        }"
                        else "$mainUrl/tv-show/${info.id}-${cleanTitle(title)}/season-1/episode-1"
                        if (typeinfo == TvType.Movie) {
                            search.add(
                                MovieSearchResponse(
                                    title,
                                    link,
                                    this.name,
                                    TvType.Movie,
                                    poster,
                                    null
                                )
                            )
                        } else {
                            search.add(
                                TvSeriesSearchResponse(
                                    title,
                                    link,
                                    this.name,
                                    TvType.TvSeries,
                                    poster,
                                    null,
                                    null
                                )
                            )
                        }
                    }
                }
            }
        }
        return search
    }
    data class LoadMain (
        @JsonProperty("props"         ) val props         : LoadProps?         = LoadProps(),
        @JsonProperty("page"          ) val page          : String?        = null,
        @JsonProperty("buildId"       ) val buildId       : String?        = null,
        @JsonProperty("runtimeConfig" ) val runtimeConfig : RuntimeConfig? = RuntimeConfig(),
        @JsonProperty("isFallback"    ) val isFallback    : Boolean?       = null,
        @JsonProperty("gssp"          ) val gssp          : Boolean?       = null,
        @JsonProperty("customServer"  ) val customServer  : Boolean?       = null,
        @JsonProperty("appGip"        ) val appGip        : Boolean?       = null
    )

    data class LoadProps (
        @JsonProperty("pageProps" ) val pageProps : LoadPageProps? = LoadPageProps(),
        @JsonProperty("__N_SSP"   ) val _NSSP     : Boolean?   = null
    )

    data class LoadPageProps (
        @JsonProperty("selectedTv"          ) val selectedTv          : TheFlixMetadata?          = TheFlixMetadata(),
        @JsonProperty("movie") val movie: TheFlixMetadata? = TheFlixMetadata(),
        @JsonProperty("recommendationsList" ) val recommendationsList : RecommendationsList? = RecommendationsList(),
        @JsonProperty("basePageSegments"    ) val basePageSegments    : ArrayList<String>?    = arrayListOf()
    )

    data class TheFlixMetadata (
        @JsonProperty("episodeRuntime"   ) val episodeRuntime   : Int?               = null,
        @JsonProperty("name"             ) val name             : String?            = null,
        @JsonProperty("numberOfSeasons"  ) val numberOfSeasons  : Int?               = null,
        @JsonProperty("numberOfEpisodes" ) val numberOfEpisodes : Int?               = null,
        @JsonProperty("originalLanguage" ) val originalLanguage : String?            = null,
        @JsonProperty("popularity"       ) val popularity       : Double?            = null,
        @JsonProperty("status"           ) val status           : String?            = null,
        @JsonProperty("voteAverage"      ) val voteAverage      : Double?            = null,
        @JsonProperty("voteCount"        ) val voteCount        : Int?               = null,
        @JsonProperty("cast"             ) val cast             : String?            = null,
        @JsonProperty("director"         ) val director         : String?            = null,
        @JsonProperty("overview"         ) val overview         : String?            = null,
        @JsonProperty("posterUrl"        ) val posterUrl        : String?            = null,
        @JsonProperty("releaseDate"      ) val releaseDate      : String?            = null,
        @JsonProperty("createdAt"        ) val createdAt        : String?            = null,
        @JsonProperty("updatedAt"        ) val updatedAt        : String?            = null,
        @JsonProperty("id"               ) val id               : Int?               = null,
        @JsonProperty("available"        ) val available        : Boolean?           = null,
        @JsonProperty("genres"           ) val genres           : ArrayList<Genres>?  = arrayListOf(),
        @JsonProperty("seasons"          ) val seasons          : ArrayList<Seasons>? = arrayListOf(),
        @JsonProperty("videos"           ) val videos           : ArrayList<String>? = arrayListOf(),
        @JsonProperty("runtime"          ) val runtime          : Int?              = null,
    )
    data class Seasons(
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("numberOfEpisodes") val numberOfEpisodes: Int? = null,
        @JsonProperty("seasonNumber") val seasonNumber: Int? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("posterUrl") val posterUrl: String? = null,
        @JsonProperty("releaseDate") val releaseDate: String? = null,
        @JsonProperty("createdAt") val createdAt: String? = null,
        @JsonProperty("updatedAt") val updatedAt: String? = null,
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("episodes") val episodes: ArrayList<Episodes>? = arrayListOf()
    )

    data class Episodes(
        @JsonProperty("episodeNumber") val episodeNumber: Int? = null,
        @JsonProperty("name") val name: String? = null,
        @JsonProperty("seasonNumber") val seasonNumber: Int? = null,
        @JsonProperty("voteAverage") val voteAverage: Double? = null,
        @JsonProperty("voteCount") val voteCount: Int? = null,
        @JsonProperty("overview") val overview: String? = null,
        @JsonProperty("releaseDate") val releaseDate: String? = null,
        @JsonProperty("createdAt") val createdAt: String? = null,
        @JsonProperty("updatedAt") val updatedAt: String? = null,
        @JsonProperty("id") val id: Int? = null,
        @JsonProperty("videos") val videos: ArrayList<String>? = arrayListOf()
    )


    data class Genres (
        @JsonProperty("name" ) val name : String? = null,
        @JsonProperty("id"   ) val id   : Int?    = null
    )

    data class RuntimeConfig (
        @JsonProperty("AddThisService" ) val AddThisService : RuntimeConfigData? = RuntimeConfigData(),
        @JsonProperty("Application"    ) val Application    : RuntimeConfigData?    = RuntimeConfigData(),
        @JsonProperty("GtmService"     ) val GtmService     : RuntimeConfigData?     = RuntimeConfigData(),
        @JsonProperty("Services"       ) val Services       : RuntimeConfigData?       = RuntimeConfigData(),
    )

    data class RuntimeConfigData(
        @JsonProperty("PublicId" ) val PublicId : String? = null,
        @JsonProperty("ContentUsageType"              ) val ContentUsageType              : String?  = null,
        @JsonProperty("IsDevelopmentMode"             ) val IsDevelopmentMode             : Boolean? = null,
        @JsonProperty("IsDevelopmentOrProductionMode" ) val IsDevelopmentOrProductionMode : Boolean? = null,
        @JsonProperty("IsProductionMode"              ) val IsProductionMode              : Boolean? = null,
        @JsonProperty("IsStagingMode"                 ) val IsStagingMode                 : Boolean? = null,
        @JsonProperty("IsTestMode"                    ) val IsTestMode                    : Boolean? = null,
        @JsonProperty("Mode"                          ) val Mode                          : String?  = null,
        @JsonProperty("Name"                          ) val Name                          : String?  = null,
        @JsonProperty("Url"                           ) val Url                           : String?  = null,
        @JsonProperty("UseFilterInfoInUrl"            ) val UseFilterInfoInUrl            : Boolean? = null,
        @JsonProperty("TrackingId" ) val TrackingId : String? = null,
        @JsonProperty("Server"     ) val Server     : Server?     = Server(),
        @JsonProperty("TmdbServer" ) val TmdbServer : TmdbServer? = TmdbServer(),
    )

    data class TmdbServer (
        @JsonProperty("Url" ) val Url : String? = null
    )


    data class Server (
        @JsonProperty("Url" ) val Url : String? = null
    )

    data class RecommendationsList (
        @JsonProperty("docs"  ) val docs  : ArrayList<Docs> = arrayListOf(),
        @JsonProperty("total" ) val total : Int?            = null,
        @JsonProperty("page"  ) val page  : Int?            = null,
        @JsonProperty("limit" ) val limit : Int?            = null,
        @JsonProperty("pages" ) val pages : Int?            = null,
        @JsonProperty("type"  ) val type  : String?         = null,
    )

    private fun cleanTitle(title: String): String {
        val dotTitle = title.substringBefore("/season")
        if (dotTitle.contains(Regex("\\..\\."))) { //For titles containing more than two dots (S.W.A.T.)
            return (dotTitle.removeSuffix(".")
                .replace(" - ", "-")
                .replace(".", "-").replace(" ", "-")
                .replace("-&", "")
                .replace(Regex("(:|-&)"), "")
                .replace("'", "-")).lowercase()
        }
        return (title
            .replace(" - ", "-")
            .replace(" ", "-")
            .replace("-&", "")
            .replace("/", "-")
            .replace(Regex("(:|-&|\\.)"), "")
            .replace("'", "-")).lowercase()
    }

    private suspend fun getLoadMan(url: String): LoadMain {
        getCookies()
        val og = app.get(url, headers = latestCookies)
        val soup = og.document
        val script = soup.selectFirst("script[type=application/json]")!!.data()
        return parseJson(script)
    }

    override suspend fun load(url: String): LoadResponse? {
        val tvtype = if (url.contains("movie")) TvType.Movie else TvType.TvSeries
        val json = getLoadMan(url)
        val episodes = ArrayList<Episode>()
        val isMovie = tvtype == TvType.Movie
        val pageMain = json.props?.pageProps

        val metadata: TheFlixMetadata? = if (isMovie) pageMain?.movie else pageMain?.selectedTv

        val available = metadata?.available

        val comingsoon = !available!!

        val movieId = metadata.id

        val movietitle = metadata.name

        val poster = metadata.posterUrl

        val description = metadata.overview

        if (!isMovie) {
            metadata.seasons?.map { seasons ->
                val seasonPoster = seasons.posterUrl ?: metadata.posterUrl
                seasons.episodes?.forEach { epi ->
                    val episodenu = epi.episodeNumber
                    val seasonum = epi.seasonNumber
                    val title = epi.name
                    val epDesc = epi.overview
                    val test = epi.videos
                    val ratinginfo = (epi.voteAverage)?.times(10)?.toInt()
                    val rating = if (ratinginfo?.equals(0) == true) null else ratinginfo
                    val eps = Episode(
                        "$mainUrl/tv-show/$movieId-${cleanTitle(movietitle!!)}/season-$seasonum/episode-$episodenu",
                        title,
                        seasonum,
                        episodenu,
                        description = epDesc!!,
                        posterUrl = seasonPoster,
                        rating = rating,
                    )
                    if (test!!.isNotEmpty()) {
                        episodes.add(eps)
                    } else {
                        //Nothing, will prevent seasons/episodes with no videos to be added
                    }
                }
            }
        }
        val rating = metadata.voteAverage?.toFloat()?.times(1000)?.toInt()

        val tags = metadata.genres?.mapNotNull { it.name }

        val recommendationsitem = pageMain?.recommendationsList?.docs?.map { loadDocs ->
            val title = loadDocs.name
            val posterrec = loadDocs.posterUrl
            val link = if (isMovie) "$mainUrl/movie/${loadDocs.id}-${cleanTitle(title)}"
            else "$mainUrl/tv-show/${loadDocs.id}-${cleanTitle(title)}/season-1/episode-1"
            MovieSearchResponse(
                title,
                link,
                this.name,
                tvtype,
                posterrec,
                year = null
            )
        }

        val year = metadata.releaseDate?.substringBefore("-")

        val runtime = metadata.runtime?.div(60) ?: metadata.episodeRuntime?.div(60)
        val cast = metadata.cast?.split(",")

        return when (tvtype) {
            TvType.TvSeries -> {
                return newTvSeriesLoadResponse(movietitle!!, url, TvType.TvSeries, episodes) {
                    this.posterUrl = poster
                    this.year = year?.toIntOrNull()
                    this.plot = description
                    this.duration = runtime
                    addActors(cast)
                    this.tags = tags
                    this.recommendations = recommendationsitem
                    this.comingSoon = comingsoon
                    this.rating = rating
                }
            }
            TvType.Movie -> {
                newMovieLoadResponse(movietitle!!, url, TvType.Movie, url) {
                    this.year = year?.toIntOrNull()
                    this.posterUrl = poster
                    this.plot = description
                    this.duration = runtime
                    addActors(cast)
                    this.tags = tags
                    this.recommendations = recommendationsitem
                    this.comingSoon = comingsoon
                    this.rating = rating
                }
            }
            else -> null
        }
    }


    data class VideoData (
        @JsonProperty("url"           ) val url           : String?        = null,
        @JsonProperty("id"            ) val id            : String?        = null,
        @JsonProperty("type"          ) val type          : String?        = null,
    )


    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val json = getLoadMan(data)
        val authhost = json.runtimeConfig?.Services?.Server?.Url
        val isMovie = data.contains("/movie/")
        val qualityReg = Regex("(\\d+p)")
        if (isMovie){
            json.props?.pageProps?.movie?.videos?.apmap { id ->
                val jsonmovie = app.get("$authhost/movies/videos/$id/request-access?contentUsageType=Viewing",
                    headers = latestCookies).parsedSafe<VideoData>() ?: return@apmap false
                val extractedlink = jsonmovie.url
                if (!extractedlink.isNullOrEmpty()) {
                    val quality = qualityReg.find(extractedlink)?.value ?: ""
                    callback(
                        ExtractorLink(
                            name,
                            name,
                            extractedlink,
                            "",
                            getQualityFromName(quality),
                            false
                        )
                    )
                } else null
            }
        }
        else
        {
            val dataRegex = Regex("(season-(\\d+)\\/episode-(\\d+))")
            val cleandatainfo = dataRegex.find(data)?.value?.replace(Regex("(season-|episode-)"),"")?.replace("/","x")
            val tesatt = cleandatainfo.let { str ->
                str?.split("x")?.mapNotNull { subStr -> subStr.toIntOrNull() }
            }
            val epID = tesatt?.getOrNull(1)
            val seasonid = tesatt?.getOrNull(0)
            json.props?.pageProps?.selectedTv?.seasons?.map {
                it.episodes?.map {
                    val epsInfo = Triple(it.seasonNumber, it.episodeNumber, it.videos)
                    if (epsInfo.first == seasonid && epsInfo.second == epID) {
                        epsInfo.third?.apmap { id ->
                            val jsonserie = app.get("$authhost/tv/videos/$id/request-access?contentUsageType=Viewing", headers = latestCookies).parsedSafe<VideoData>() ?: return@apmap false
                            val extractedlink = jsonserie.url
                            if (!extractedlink.isNullOrEmpty()) {
                                val quality = qualityReg.find(extractedlink)?.value ?: ""
                                callback(
                                    ExtractorLink(
                                        name,
                                        name,
                                        extractedlink,
                                        "",
                                        getQualityFromName(quality),
                                        false
                                    )
                                )
                            } else null
                        }
                    }
                }
            }
        }
        return true
    }
}



================================================
FILE: TheFlixToProvider/src/main/kotlin/com/lagradost/TheFlixToProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class TheFlixToProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TheFlixToProvider())
    }
}


================================================
FILE: TrailersTwoProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: TrailersTwoProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: TrailersTwoProvider/src/main/kotlin/com/lagradost/TrailersTwoProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.SubtitleHelper

class TrailersTwoProvider : TmdbProvider() {
    val user = "cloudstream"
    override val apiName = "Trailers.to"
    override var name = "Trailers.to"
    override var mainUrl = "https://trailers.to"
    override val useMetaLoadResponse = true
    override val instantLinkLoading = true

    data class TrailersEpisode(
        // val tvShowItemID: Long?,
        //val tvShow: String,
        //val tvShowIMDB: String?,
        //val tvShowTMDB: Long?,
        @JsonProperty("ItemID")
        val itemID: Int,
        //val title: String,
        //@JsonProperty("IMDb")
        @JsonProperty("IMDb")
        val imdb: String?,
        //@JsonProperty("TMDb")
        @JsonProperty("TMDb")
        val tmdb: Int?,
        //val releaseDate: String,
        //val entryDate: String
    )

    data class TrailersMovie(
        @JsonProperty("ItemID")
        val itemID: Int,
        @JsonProperty("IMDb")
        val imdb: String?,
        @JsonProperty("TMDb")
        val tmdb: Int?,
        //@JsonProperty("Title")
        //val title: String?,
    )

    /*companion object {
        private var tmdbToIdMovies: HashMap<Int, Int> = hashMapOf()
        private var imdbToIdMovies: HashMap<String, Int> = hashMapOf()
        private var tmdbToIdTvSeries: HashMap<Int, Int> = hashMapOf()
        private var imdbToIdTvSeries: HashMap<String, Int> = hashMapOf()

        private const val startDate = 1900
        private const val endDate = 9999

        fun getEpisode(tmdb: Int?, imdb: String?): Int? {
            var currentId: Int? = null
            if (tmdb != null) {
                currentId = tmdbToIdTvSeries[tmdb]
            }
            if (imdb != null && currentId == null) {
                currentId = imdbToIdTvSeries[imdb]
            }
            return currentId
        }

        fun getMovie(tmdb: Int?, imdb: String?): Int? {
            var currentId: Int? = null
            if (tmdb != null) {
                currentId = tmdbToIdMovies[tmdb]
            }
            if (imdb != null && currentId == null) {
                currentId = imdbToIdMovies[imdb]
            }
            return currentId
        }

        suspend fun fillData(isMovie: Boolean) {
            if (isMovie) {
                if (tmdbToIdMovies.isNotEmpty() || imdbToIdMovies.isNotEmpty()) {
                    return
                }
                parseJson<List<TrailersMovie>>(
                    app.get(
                        "https://trailers.to/movies?from=$startDate-01-01&to=$endDate",
                        timeout = 30
                    ).text
                ).forEach { movie ->
                    movie.imdb?.let {
                        imdbToIdTvSeries[it] = movie.itemID
                    }
                    movie.tmdb?.let {
                        tmdbToIdTvSeries[it] = movie.itemID
                    }
                }
            } else {
                if (tmdbToIdTvSeries.isNotEmpty() || imdbToIdTvSeries.isNotEmpty()) {
                    return
                }
                parseJson<List<TrailersEpisode>>(
                    app.get(
                        "https://trailers.to/episodes?from=$startDate-01-01&to=$endDate",
                        timeout = 30
                    ).text
                ).forEach { episode ->
                    episode.imdb?.let {
                        imdbToIdTvSeries[it] = episode.itemID
                    }
                    episode.tmdb?.let {
                        tmdbToIdTvSeries[it] = episode.itemID
                    }
                }
            }
        }
    }*/

    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        //TvType.AnimeMovie,
        //TvType.Anime,
        //TvType.Cartoon
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mappedData = parseJson<TmdbLink>(data)
        val (id, site) = if (mappedData.imdbID != null) listOf(
            mappedData.imdbID,
            "imdb"
        ) else listOf(mappedData.tmdbID.toString(), "tmdb")

        val isMovie = mappedData.episode == null && mappedData.season == null
        val (videoUrl, subtitleUrl) = if (isMovie) {
            val suffix = "$user/$site/$id"
            Pair(
                "https://trailers.to/video/$suffix",
                "https://trailers.to/subtitles/$suffix"
            )
        } else {
            val suffix = "$user/$site/$id/S${mappedData.season ?: 1}E${mappedData.episode ?: 1}"
            Pair(
                "https://trailers.to/video/$suffix",
                "https://trailers.to/subtitles/$suffix"
            )
        }

        callback.invoke(
            ExtractorLink(
                this.name,
                this.name,
                videoUrl,
                "https://trailers.to",
                Qualities.Unknown.value,
                false,
            )
        )

        argamap(
            {
                val subtitles =
                    app.get(subtitleUrl).text
                val subtitlesMapped = parseJson<List<TrailersSubtitleFile>>(subtitles)
                subtitlesMapped.forEach {
                    subtitleCallback.invoke(
                        SubtitleFile(
                            SubtitleHelper.fromTwoLettersToLanguage(it.LanguageCode ?: "en")
                                ?: "English",
                            "https://trailers.to/subtitles/${it.ContentHash ?: return@forEach}/${it.LanguageCode ?: return@forEach}.vtt" // ${it.MetaInfo?.SubFormat ?: "srt"}"
                        )
                    )
                }
            }, {
                //https://trailers.to/en/quick-search?q=iron man
                val name = mappedData.movieName
                if (name != null && isMovie) {
                    app.get("https://trailers.to/en/quick-search?q=${name}").document.select("a.post-minimal")
                        .mapNotNull {
                            it?.attr("href")
                        }.map { Regex("""/movie/(\d+)/""").find(it)?.groupValues?.getOrNull(1) }
                        .firstOrNull()?.let { movieId ->
                            val correctUrl = app.get(videoUrl).url
                            callback.invoke(
                                ExtractorLink(
                                    this.name,
                                    "${this.name} Backup",
                                    correctUrl.replace("/$user/0/", "/$user/$movieId/"),
                                    "https://trailers.to",
                                    Qualities.Unknown.value,
                                    false,
                                )
                            )
                        }
                }
            }
        )

        /*
        // the problem with this code is that it tages ages and the json file is 50mb or so for movies
        fillData(isMovie)
        val movieId = if (isMovie) {
            getMovie(mappedData.tmdbID, mappedData.imdbID)
        } else {
            getEpisode(mappedData.tmdbID, mappedData.imdbID)
        } ?: return@argamap
        val request = app.get(data)
        val endUrl = request.url
        callback.invoke(
            ExtractorLink(
                this.name,
                "${this.name} Backup",
                endUrl.replace("/cloudstream/0/", "/cloudstream/$movieId/"),
                "https://trailers.to",
                Qualities.Unknown.value,
                false,
            )
        )
         */

        return true
    }
}

// Auto generated
data class TrailersSubtitleFile(
    @JsonProperty("SubtitleID") val SubtitleID: Int?,
    @JsonProperty("ItemID") val ItemID: Int?,
    @JsonProperty("ContentText") val ContentText: String?,
    @JsonProperty("ContentHash") val ContentHash: String?,
    @JsonProperty("LanguageCode") val LanguageCode: String?,
    @JsonProperty("MetaInfo") val MetaInfo: MetaInfo?,
    @JsonProperty("EntryDate") val EntryDate: String?,
    @JsonProperty("ItemSubtitleAdaptations") val ItemSubtitleAdaptations: List<ItemSubtitleAdaptations>?,
    @JsonProperty("ReleaseNames") val ReleaseNames: List<String>?,
    @JsonProperty("SubFileNames") val SubFileNames: List<String>?,
    @JsonProperty("Framerates") val Framerates: List<Int>?,
    @JsonProperty("IsRelevant") val IsRelevant: Boolean?
)

data class QueryParameters(
    @JsonProperty("imdbid") val imdbid: String?
)

data class MetaInfo(
    @JsonProperty("MatchedBy") val MatchedBy: String?,
    @JsonProperty("IDSubMovieFile") val IDSubMovieFile: String?,
    @JsonProperty("MovieHash") val MovieHash: String?,
    @JsonProperty("MovieByteSize") val MovieByteSize: String?,
    @JsonProperty("MovieTimeMS") val MovieTimeMS: String?,
    @JsonProperty("IDSubtitleFile") val IDSubtitleFile: String?,
    @JsonProperty("SubFileName") val SubFileName: String?,
    @JsonProperty("SubActualCD") val SubActualCD: String?,
    @JsonProperty("SubSize") val SubSize: String?,
    @JsonProperty("SubHash") val SubHash: String?,
    @JsonProperty("SubLastTS") val SubLastTS: String?,
    @JsonProperty("SubTSGroup") val SubTSGroup: String?,
    @JsonProperty("InfoReleaseGroup") val InfoReleaseGroup: String?,
    @JsonProperty("InfoFormat") val InfoFormat: String?,
    @JsonProperty("InfoOther") val InfoOther: String?,
    @JsonProperty("IDSubtitle") val IDSubtitle: String?,
    @JsonProperty("UserID") val UserID: String?,
    @JsonProperty("SubLanguageID") val SubLanguageID: String?,
    @JsonProperty("SubFormat") val SubFormat: String?,
    @JsonProperty("SubSumCD") val SubSumCD: String?,
    @JsonProperty("SubAuthorComment") val SubAuthorComment: String?,
    @JsonProperty("SubAddDate") val SubAddDate: String?,
    @JsonProperty("SubBad") val SubBad: String?,
    @JsonProperty("SubRating") val SubRating: String?,
    @JsonProperty("SubSumVotes") val SubSumVotes: String?,
    @JsonProperty("SubDownloadsCnt") val SubDownloadsCnt: String?,
    @JsonProperty("MovieReleaseName") val MovieReleaseName: String?,
    @JsonProperty("MovieFPS") val MovieFPS: String?,
    @JsonProperty("IDMovie") val IDMovie: String?,
    @JsonProperty("IDMovieImdb") val IDMovieImdb: String?,
    @JsonProperty("MovieName") val MovieName: String?,
    @JsonProperty("MovieNameEng") val MovieNameEng: String?,
    @JsonProperty("MovieYear") val MovieYear: String?,
    @JsonProperty("MovieImdbRating") val MovieImdbRating: String?,
    @JsonProperty("SubFeatured") val SubFeatured: String?,
    @JsonProperty("UserNickName") val UserNickName: String?,
    @JsonProperty("SubTranslator") val SubTranslator: String?,
    @JsonProperty("ISO639") val ISO639: String?,
    @JsonProperty("LanguageName") val LanguageName: String?,
    @JsonProperty("SubComments") val SubComments: String?,
    @JsonProperty("SubHearingImpaired") val SubHearingImpaired: String?,
    @JsonProperty("UserRank") val UserRank: String?,
    @JsonProperty("SeriesSeason") val SeriesSeason: String?,
    @JsonProperty("SeriesEpisode") val SeriesEpisode: String?,
    @JsonProperty("MovieKind") val MovieKind: String?,
    @JsonProperty("SubHD") val SubHD: String?,
    @JsonProperty("SeriesIMDBParent") val SeriesIMDBParent: String?,
    @JsonProperty("SubEncoding") val SubEncoding: String?,
    @JsonProperty("SubAutoTranslation") val SubAutoTranslation: String?,
    @JsonProperty("SubForeignPartsOnly") val SubForeignPartsOnly: String?,
    @JsonProperty("SubFromTrusted") val SubFromTrusted: String?,
    @JsonProperty("QueryCached") val QueryCached: Int?,
    @JsonProperty("SubTSGroupHash") val SubTSGroupHash: String?,
    @JsonProperty("SubDownloadLink") val SubDownloadLink: String?,
    @JsonProperty("ZipDownloadLink") val ZipDownloadLink: String?,
    @JsonProperty("SubtitlesLink") val SubtitlesLink: String?,
    @JsonProperty("QueryNumber") val QueryNumber: String?,
    @JsonProperty("QueryParameters") val QueryParameters: QueryParameters?,
    @JsonProperty("Score") val Score: Double?
)

data class ItemSubtitleAdaptations(
    @JsonProperty("ContentHash") val ContentHash: String?,
    @JsonProperty("OffsetMs") val OffsetMs: Int?,
    @JsonProperty("Framerate") val Framerate: Int?,
    @JsonProperty("Views") val Views: Int?,
    @JsonProperty("EntryDate") val EntryDate: String?,
    @JsonProperty("Subtitle") val Subtitle: String?
)


================================================
FILE: TrailersTwoProvider/src/main/kotlin/com/lagradost/TrailersTwoProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class TrailersTwoProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TrailersTwoProvider())
    }
}


================================================
FILE: TwoEmbedProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":SflixProvider")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: TwoEmbedProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: TwoEmbedProvider/src/main/kotlin/com/lagradost/TwoEmbedProvider.kt
================================================
package com.lagradost

import android.util.Log
import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.SflixProvider.Companion.extractRabbitStream
import com.lagradost.SflixProvider.Companion.runSflixExtractorVerifierJob
import com.lagradost.cloudstream3.APIHolder.getCaptchaToken
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
import com.lagradost.cloudstream3.apmap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class TwoEmbedProvider : TmdbProvider() {
    override val apiName = "2Embed"
    override var name = "2Embed"
    override var mainUrl = "https://www.2embed.to"
    override val useMetaLoadResponse = true
    override val instantLinkLoading = false
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    data class EmbedJson (
        @JsonProperty("type") val type: String?,
        @JsonProperty("link") val link: String,
        @JsonProperty("sources") val sources: List<String?>,
        @JsonProperty("tracks") val tracks: List<String>?
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mappedData = parseJson<TmdbLink>(data)
        val (id, site) = if (mappedData.imdbID != null) listOf(
            mappedData.imdbID,
            "imdb"
        ) else listOf(mappedData.tmdbID.toString(), "tmdb")
        val isMovie = mappedData.episode == null && mappedData.season == null
        val embedUrl = if (isMovie) {
            "$mainUrl/embed/$site/movie?id=$id"
        } else {
            val suffix = "$id&s=${mappedData.season ?: 1}&e=${mappedData.episode ?: 1}"
            "$mainUrl/embed/$site/tv?id=$suffix"
        }

        val document = app.get(embedUrl).document
        val captchaKey =
            document.select("script[src*=https://www.google.com/recaptcha/api.js?render=]")
                .attr("src").substringAfter("render=")

        val servers =  document.select(".dropdown-menu a[data-id]").map { it.attr("data-id") }
        servers.apmap { serverID ->
            val token = getCaptchaToken(embedUrl, captchaKey)
            val ajax = app.get("$mainUrl/ajax/embed/play?id=$serverID&_token=$token", referer = embedUrl).text
            val mappedservers = parseJson<EmbedJson>(ajax)
            val iframeLink = mappedservers.link
            if (iframeLink.contains("rabbitstream")) {
                extractRabbitStream(iframeLink, subtitleCallback, callback, false) { it }
            } else {
                loadExtractor(iframeLink, embedUrl, subtitleCallback, callback)
            }
        }
        return true
    }

    override suspend fun extractorVerifierJob(extractorData: String?) {
        Log.d(this.name, "Starting ${this.name} job!")
        runSflixExtractorVerifierJob(this, extractorData, "https://rabbitstream.net/")
    }
}



================================================
FILE: TwoEmbedProvider/src/main/kotlin/com/lagradost/TwoEmbedProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class TwoEmbedProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(TwoEmbedProvider())
    }
}


================================================
FILE: UakinoProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: UakinoProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: UakinoProvider/src/main/kotlin/com/lagradost/UakinoProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.M3u8Helper
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import java.util.*

class UakinoProvider : MainAPI() {
    override var mainUrl = "https://uakino.club"
    override var name = "Uakino"
    override val hasMainPage = true
    override var lang = "uk"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
        TvType.Anime
    )

    override val mainPage = mainPageOf(
        "$mainUrl/filmy/page/" to "Фільми",
        "$mainUrl/seriesss/page/" to "Серіали",
        "$mainUrl/seriesss/doramy/page/" to "Дорами",
        "$mainUrl/animeukr/page/" to "Аніме",
        "$mainUrl/cartoon/page/" to "Мультфільми",
        "$mainUrl/cartoon/cartoonseries/page/" to "Мультсеріали",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).document
        val home = document.select("div.owl-item, div.movie-item").map {
            it.toSearchResponse()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResponse(): SearchResponse {
        val title = this.selectFirst("a.movie-title")?.text()?.trim().toString()
        val href = this.selectFirst("a.movie-title")?.attr("href").toString()
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("src"))
        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }

    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.post(
            url = mainUrl,
            data = mapOf(
                "do" to "search",
                "subaction" to "search",
                "story" to query.replace(" ", "+")
            )
        ).document
        return document.select("div.movie-item.short-item").map {
            it.toSearchResponse()
        }
    }

    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document

        val title = document.selectFirst("h1 span.solototle")?.text()?.trim().toString()
        val poster = fixUrl(document.selectFirst("div.film-poster img")?.attr("src").toString())
        val tags = document.select("div.film-info > div:nth-child(4) a").map { it.text() }
        val year = document.select("div.film-info > div:nth-child(2) a").text().toIntOrNull()
        val tvType =
            if (url.contains(Regex("(/anime-series)|(/seriesss)|(/cartoonseries)"))) TvType.TvSeries else TvType.Movie
        val description = document.selectFirst("div[itemprop=description]")?.text()?.trim()
        val trailer = document.selectFirst("iframe#pre")?.attr("data-src")
        val rating = document.selectFirst("div.film-info > div:nth-child(8) div.fi-desc")?.text()
            ?.substringBefore("/").toRatingInt()
        val actors = document.select("div.film-info > div:nth-child(6) a").map { it.text() }

        val recommendations = document.select("div#full-slides div.owl-item").map {
            it.toSearchResponse()
        }

        return if (tvType == TvType.TvSeries) {
            val id = url.split("/").last().split("-").first()
            val episodes =
                app.get("$mainUrl/engine/ajax/playlists.php?news_id=$id&xfield=playlist&time=${Date().time}")
                    .parsedSafe<Responses>()?.response.let {
                        Jsoup.parse(it.toString()).select("ul > li").mapNotNull { eps ->
                            val href = fixUrl(eps.attr("data-file"))
                            val name = eps.text().trim()
                            if (href.isNotEmpty()) {
                                Episode(
                                    href,
                                    name,
                                )
                            } else {
                                null
                            }
                        }
                    }
            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val links = ArrayList<String>()

        if (data.startsWith("https://ashdi.vip")) {
            links.add(data)
        } else {
            val iframeUrl = app.get(data).document.selectFirst("iframe#pre")?.attr("src")
            if (iframeUrl.isNullOrEmpty()) {
                val id = data.split("/").last().split("-").first()
                app.get("$mainUrl/engine/ajax/playlists.php?news_id=$id&xfield=playlist&time=${Date().time}")
                    .parsedSafe<Responses>()?.response.let {
                        Jsoup.parse(it.toString()).select("ul > li").mapNotNull { mirror ->
                            links.add(fixUrl(mirror.attr("data-file")))
                        }
                    }
            } else {
                links.add(iframeUrl)
            }
        }

        links.apmap { link ->
            safeApiCall {
                app.get(link, referer = "$mainUrl/").document.select("script").map { script ->
                    if (script.data().contains("var player = new Playerjs({")) {
                        val m3uLink =
                            script.data().substringAfterLast("file:\"").substringBefore("\",")
                        M3u8Helper.generateM3u8(
                            source = this.name,
                            streamUrl = m3uLink,
                            referer = "https://ashdi.vip/"
                        ).forEach(callback)
                    }
                }
            }
        }

        return true
    }

    data class Responses(
        @JsonProperty("success") val success: Boolean?,
        @JsonProperty("response") val response: String,
    )

}


================================================
FILE: UakinoProvider/src/main/kotlin/com/lagradost/UakinoProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class UakinoProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(UakinoProvider())
    }
}


================================================
FILE: VfFilmProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VfFilmProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VfFilmProvider/src/main/kotlin/com/lagradost/VfFilmProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.Jsoup

// referer = https://vf-film.org, USERAGENT ALSO REQUIRED
class VfFilmProvider : MainAPI() {
    override var mainUrl = "https://vf-film.me"
    override var name = "vf-film.me"
    override var lang = "fr"
    override val hasQuickSearch = false
    override val hasMainPage = false
    override val hasChromecastSupport = false

    override val supportedTypes = setOf(TvType.Movie)

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val items = document.select("ul.MovieList > li > article > a")
        if (items.isNullOrEmpty()) return ArrayList()

        val returnValue = ArrayList<SearchResponse>()
        for (item in items) {
            val href = item.attr("href")

            val poster = item.selectFirst("> div.Image > figure > img")!!.attr("src")
                .replace("//image", "https://image")

            val name = item.selectFirst("> h3.Title")!!.text()

            val year = item.selectFirst("> span.Year")!!.text().toIntOrNull()

            returnValue.add(MovieSearchResponse(name, href, this.name, TvType.Movie, poster, year))
        }
        return returnValue
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data.length <= 4) return false
        callback.invoke(
            ExtractorLink(
                this.name,
                this.name,
                data,
                "",
                Qualities.P720.value,
                false
            )
        )
        return true
    }

    private suspend fun getDirect(original: String): String {  // original data, https://vf-film.org/?trembed=1&trid=55313&trtype=1 for example
        val response = app.get(original).text
        val url = "iframe .*src=\"(.*?)\"".toRegex().find(response)?.groupValues?.get(1)
            .toString()  // https://vudeo.net/embed-uweno86lzx8f.html for example
        val vudoResponse = app.get(url).text
        val document = Jsoup.parse(vudoResponse)
        val vudoUrl = Regex("sources: \\[\"(.*?)\"]").find(document.html())?.groupValues?.get(1)
            .toString()  // direct mp4 link, https://m11.vudeo.net/2vp3ukyw2avjdohilpebtzuct42q5jwvpmpsez3xjs6d7fbs65dpuey2rbra/v.mp4 for exemple
        return vudoUrl
    }

    override suspend fun load(url: String): LoadResponse {
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val title = document.selectFirst("div.SubTitle")?.text()
            ?: throw ErrorLoadingException("Service might be unavailable")

        val year = document.select("span.Date").text().toIntOrNull()

//        val rating = document.select("span.AAIco-star").text()

        val duration = document.select("span.Time").text().toIntOrNull()

        val poster = document.selectFirst("div.Image > figure > img")!!.attr("src")
            .replace("//image", "https://image")

        val descript = document.selectFirst("div.Description > p")!!.text()

        val players = document.select("ul.TPlayerNv > li")
        var number_player = 0
        var found = false
        for (player in players) {
            if (player.selectFirst("> span")!!.text() == "Vudeo") {
                found = true
                break
            } else {
                number_player += 1
            }
        }
        if (!found) {
            number_player = 0
        }
        val i = number_player.toString()
        val trid = Regex("iframe .*trid=(.*?)&").find(document.html())?.groupValues?.get(1)

        val data = getDirect("$mainUrl/?trembed=$i&trid=$trid&trtype=1")

        return newMovieLoadResponse(
            title,
            url,
            TvType.Movie,
            data
        ) {
            this.posterUrl = poster
            this.year = year
            this.plot = descript
            //this.rating = rating
            this.duration = duration
        }
    }
}



================================================
FILE: VfFilmProvider/src/main/kotlin/com/lagradost/VfFilmProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class VfFilmProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(VfFilmProvider())
    }
}


================================================
FILE: VfSerieProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VfSerieProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VfSerieProvider/src/main/kotlin/com/lagradost/VfSerieProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.Jsoup

// referer = https://vf-serie.org, USERAGENT ALSO REQUIRED
class VfSerieProvider : MainAPI() {
    override var mainUrl = "https://vf-serie.org"
    override var name = "vf-serie.org"
    override var lang = "fr"

    override val hasQuickSearch = false
    override val hasMainPage = false
    override val hasChromecastSupport = false

    override val supportedTypes = setOf(TvType.TvSeries)

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val items = document.select("ul.MovieList > li > article > a")
        if (items.isNullOrEmpty()) return ArrayList()

        val returnValue = ArrayList<SearchResponse>()
        for (item in items) {
            val href = item.attr("href")

            val poster = item.selectFirst("> div.Image > figure > img")!!.attr("src")
                .replace("//image", "https://image")

            if (poster == "$mainUrl/wp-content/themes/toroplay/img/cnt/noimg-thumbnail.png") {  // if the poster is missing (the item is just a redirect to something like https://vf-serie.org/series-tv/)
                continue
            }
            val name = item.selectFirst("> h3.Title")!!.text()

            val year = item.selectFirst("> span.Year")!!.text().toIntOrNull()

            returnValue.add(
                TvSeriesSearchResponse(
                    name,
                    href,
                    this.name,
                    TvType.TvSeries,
                    poster,
                    year,
                    null
                )
            )
        }
        return returnValue
    }

    private suspend fun getDirect(original: String): String {  // original data, https://vf-serie.org/?trembed=1&trid=80467&trtype=2 for example
        val response = app.get(original).text
        val url = "iframe .*src=\"(.*?)\"".toRegex().find(response)?.groupValues?.get(1)
            .toString()  // https://vudeo.net/embed-7jdb1t5b2mvo.html for example
        val vudoResponse = app.get(url).text
        val document = Jsoup.parse(vudoResponse)
        return Regex("sources: \\[\"(.*?)\"]").find(document.html())?.groupValues?.get(1)
            .toString()  // direct mp4 link, https://m5.vudeo.net/2vp3xgpw2avjdohilpfbtyuxzzrqzuh4z5yxvztral5k3rjnba6f4byj3saa/v.mp4 for exemple
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        if (data == "") return false

        val response = app.get(data).text
        val document = Jsoup.parse(response)
        val players = document.select("ul.TPlayerNv > li")
        val trembedUrl = document.selectFirst("div.TPlayerTb > iframe")!!.attr("src")
        var numberPlayer = Regex(".*trembed=(.*?)&").find(trembedUrl)?.groupValues?.get(1)!!
            .toInt()  // the starting trembed number of the first player website, some start at 0 other at 1
        var found = false
        for (player in players) {
            if (player.selectFirst("> span")!!.text() == "Vudeo") {
                found = true
                break
            } else {
                numberPlayer += 1
            }
        }
        if (!found) {
            numberPlayer = 1
        }
        val i = numberPlayer.toString()
        val trid = Regex("iframe .*trid=(.*?)&").find(document.html())?.groupValues?.get(1)

        val directData = getDirect("$mainUrl/?trembed=$i&trid=$trid&trtype=2")
        callback.invoke(
            ExtractorLink(
                this.name,
                this.name,
                directData,
                "",
                Qualities.P720.value,
                false
            )
        )
        return true
    }

    override suspend fun load(url: String): LoadResponse {
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val title =
            document.selectFirst(".Title")?.text()?.replace("Regarder Serie ", "")
                ?.replace(" En Streaming", "")
                ?: throw ErrorLoadingException("Service might be unavailable")


        val year = document.select("span.Date").text().toIntOrNull()
        val rating = document.select("span.AAIco-star").text().toIntOrNull()

        //val duration = document.select("span.Time").text()?.toIntOrNull()

        val backgroundPoster =
            document.selectFirst("div.Image > figure > img")!!.attr("src")
                .replace("//image", "https://image")

        val descript = document.selectFirst("div.Description > p")!!.text()

        val list = ArrayList<Int>()

        // episode begin
        document.select(".Wdgt").forEach { element ->
            val season = element.selectFirst("> .AA-Season > span")?.text()?.toIntOrNull()
            if (season != null && season > 0) {
                list.add(season)
            }
        }
        if (list.isEmpty()) throw ErrorLoadingException("No Seasons Found")

        val episodeList = ArrayList<Episode>()

        for (season in list) {
            val episodes = document.select("table > tbody > tr")
            if (episodes.isNotEmpty()) {
                episodes.forEach { episode ->
                    val epNum = episode.selectFirst("> span.Num")?.text()?.toIntOrNull()
                    val poster =
                        episode.selectFirst("> td.MvTbImg > a > img")?.attr("src")
                            ?.replace("//image", "https://image")
                    val aName = episode.selectFirst("> td.MvTbTtl > a")
                    val date = episode.selectFirst("> td.MvTbTtl > span")?.text()?.toString()
                    val name = aName!!.text()
                    val href = aName.attr("href")
                    episodeList.add(
                        newEpisode(href) {
                            this.name = name
                            this.season = season
                            this.episode = epNum
                            this.posterUrl = poster
                            addDate(date)
                        }
                    )
                }
            }
        }
        return TvSeriesLoadResponse(
            title,
            url,
            this.name,
            TvType.TvSeries,
            episodeList,
            backgroundPoster,
            year,
            descript,
            null,
            rating
        )
    }
}



================================================
FILE: VfSerieProvider/src/main/kotlin/com/lagradost/VfSerieProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class VfSerieProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(VfSerieProvider())
    }
}


================================================
FILE: VidEmbedProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":VidstreamProviderTemplate")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VidEmbedProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VidEmbedProvider/src/main/kotlin/com/lagradost/VidEmbedProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.TvType

/** Needs to inherit from MainAPI() to
 * make the app know what functions to call
 */
class VidEmbedProvider : VidstreamProviderTemplate() {
    // mainUrl is good to have as a holder for the url to make future changes easier.
    override var mainUrl = "https://membed.net"

    // name is for how the provider will be named which is visible in the UI, no real rules for this.
    override var name = "VidEmbed"

    override val homePageUrlList: List<String> = listOf(
        mainUrl,
        "$mainUrl/movies",
        "$mainUrl/series",
        "$mainUrl/recommended-series",
        "$mainUrl/cinema-movies"
    )

    override val iv = "9225679083961858"
    override val secretKey = "25742532592138496744665879883281"
    override val secretDecryptKey = secretKey

    // This is just extra metadata about what type of movies the provider has.
    // Needed for search functionality.
    override val supportedTypes = setOf(TvType.TvSeries, TvType.Movie)
}



================================================
FILE: VidEmbedProvider/src/main/kotlin/com/lagradost/VidEmbedProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class VidEmbedProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(VidEmbedProvider())
    }
}


================================================
FILE: VidSrcProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VidSrcProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VidSrcProvider/src/main/kotlin/com/lagradost/VidSrcProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.TvType
//import com.lagradost.cloudstream3.extractors.VidSrcExtractor
import com.lagradost.cloudstream3.metaproviders.TmdbLink
import com.lagradost.cloudstream3.metaproviders.TmdbProvider
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class VidSrcProvider : TmdbProvider() {
    override val apiName = "VidSrc"
    override var name = "VidSrc"
    override var mainUrl = "https://v2.vidsrc.me"
    override val useMetaLoadResponse = true
    override val instantLinkLoading = false
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

//    companion object {
//        val extractor = VidSrcExtractor()
//    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val mappedData = parseJson<TmdbLink>(data)
        val (id, site) = if (mappedData.imdbID != null) listOf(
            mappedData.imdbID,
            "imdb"
        ) else listOf(mappedData.tmdbID.toString(), "tmdb")
        val isMovie = mappedData.episode == null && mappedData.season == null
        val embedUrl = if (isMovie) {
            if (site == "imdb") "$mainUrl/embed/$id" else
                "$mainUrl/embed/$id"
        } else {
            val suffix = "$id/${mappedData.season ?: 1}-${mappedData.episode ?: 1}"
            if (site == "imdb") "$mainUrl/embed/$suffix" else
                "$mainUrl/embed/$suffix"
        }

        loadExtractor(embedUrl, null, subtitleCallback, callback)
//        extractor.getSafeUrl(embedUrl, null, subtitleCallback, callback)

        return true
    }
}


================================================
FILE: VidSrcProvider/src/main/kotlin/com/lagradost/VidSrcProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class VidSrcProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(VidSrcProvider())
    }
}


================================================
FILE: VidstreamProviderTemplate/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VidstreamProviderTemplate/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VidstreamProviderTemplate/src/main/kotlin/com/lagradost/MultiQuality.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import com.lagradost.cloudstream3.utils.getQualityFromName
import java.net.URI

class MultiQuality : ExtractorApi() {
    override var name = "MultiQuality"
    override var mainUrl = "https://gogo-play.net"
    private val sourceRegex = Regex("""file:\s*['"](.*?)['"],label:\s*['"](.*?)['"]""")
    private val m3u8Regex = Regex(""".*?(\d*).m3u8""")
    private val urlRegex = Regex("""(.*?)([^/]+$)""")
    override val requiresReferer = false

    override fun getExtractorUrl(id: String): String {
        return "$mainUrl/loadserver.php?id=$id"
    }

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {
        val extractedLinksList: MutableList<ExtractorLink> = mutableListOf()
        with(app.get(url)) {
            sourceRegex.findAll(this.text).forEach { sourceMatch ->
                val extractedUrl = sourceMatch.groupValues[1]
                // Trusting this isn't mp4, may fuck up stuff
                if (URI(extractedUrl).path.endsWith(".m3u8")) {
                    with(app.get(extractedUrl)) {
                        m3u8Regex.findAll(this.text).forEach { match ->
                            extractedLinksList.add(
                                ExtractorLink(
                                    name,
                                    name = name,
                                    urlRegex.find(this.url)!!.groupValues[1] + match.groupValues[0],
                                    url,
                                    getQualityFromName(match.groupValues[1]),
                                    isM3u8 = true
                                )
                            )
                        }

                    }
                } else if (extractedUrl.endsWith(".mp4")) {
                    extractedLinksList.add(
                        ExtractorLink(
                            name,
                            "$name ${sourceMatch.groupValues[2]}",
                            extractedUrl,
                            url.replace(" ", "%20"),
                            Qualities.Unknown.value,
                        )
                    )
                }
            }
            return extractedLinksList
        }
    }
}


================================================
FILE: VidstreamProviderTemplate/src/main/kotlin/com/lagradost/Vidstream.kt
================================================
package com.lagradost.cloudstream3.extractors

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.MultiQuality
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.AcraApplication.Companion.getKey
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.*
import org.jsoup.Jsoup
import org.jsoup.nodes.Document
import java.net.URI
import javax.crypto.Cipher
import javax.crypto.spec.IvParameterSpec
import javax.crypto.spec.SecretKeySpec

/**
 * overrideMainUrl is necessary for for other vidstream clones like vidembed.cc
 * If they diverge it'd be better to make them separate.
 * */
class Vidstream(val mainUrl: String) {
    val name: String = "Vidstream"

    companion object {
        data class GogoSources(
            @JsonProperty("source") val source: List<GogoSource>?,
            @JsonProperty("sourceBk") val sourceBk: List<GogoSource>?,
            //val track: List<Any?>,
            //val advertising: List<Any?>,
            //val linkiframe: String
        )

        data class GogoSource(
            @JsonProperty("file") val file: String,
            @JsonProperty("label") val label: String?,
            @JsonProperty("type") val type: String?,
            @JsonProperty("default") val default: String? = null
        )

        // https://github.com/saikou-app/saikou/blob/3e756bd8e876ad7a9318b17110526880525a5cd3/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt#L60
        // No Licence on the function
        private fun cryptoHandler(
            string: String,
            iv: String,
            secretKeyString: String,
            encrypt: Boolean = true
        ): String {
            //println("IV: $iv, Key: $secretKeyString, encrypt: $encrypt, Message: $string")
            val ivParameterSpec = IvParameterSpec(iv.toByteArray())
            val secretKey = SecretKeySpec(secretKeyString.toByteArray(), "AES")
            val cipher = Cipher.getInstance("AES/CBC/PKCS5Padding")
            return if (!encrypt) {
                cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParameterSpec)
                String(cipher.doFinal(base64DecodeArray(string)))
            } else {
                cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec)
                base64Encode(cipher.doFinal(string.toByteArray()))
            }
        }

        /**
         * @param iframeUrl something like https://gogoplay4.com/streaming.php?id=XXXXXX
         * @param mainApiName used for ExtractorLink names and source
         * @param iv secret iv from site, required non-null if isUsingAdaptiveKeys is off
         * @param secretKey secret key for decryption from site, required non-null if isUsingAdaptiveKeys is off
         * @param secretDecryptKey secret key to decrypt the response json, required non-null if isUsingAdaptiveKeys is off
         * @param isUsingAdaptiveKeys generates keys from IV and ID, see getKey()
         * @param isUsingAdaptiveData generate encrypt-ajax data based on $("script[data-name='episode']")[0].dataset.value
         * */
        suspend fun extractVidstream(
            iframeUrl: String,
            mainApiName: String,
            callback: (ExtractorLink) -> Unit,
            iv: String?,
            secretKey: String?,
            secretDecryptKey: String?,
            // This could be removed, but i prefer it verbose
            isUsingAdaptiveKeys: Boolean,
            isUsingAdaptiveData: Boolean,
            // If you don't want to re-fetch the document
            iframeDocument: Document? = null
        ) = safeApiCall {
            // https://github.com/saikou-app/saikou/blob/3e756bd8e876ad7a9318b17110526880525a5cd3/app/src/main/java/ani/saikou/anime/source/extractors/GogoCDN.kt
            // No Licence on the following code
            // Also modified of https://github.com/jmir1/aniyomi-extensions/blob/master/src/en/gogoanime/src/eu/kanade/tachiyomi/animeextension/en/gogoanime/extractors/GogoCdnExtractor.kt
            // License on the code above  https://github.com/jmir1/aniyomi-extensions/blob/master/LICENSE

            if ((iv == null || secretKey == null || secretDecryptKey == null) && !isUsingAdaptiveKeys)
                return@safeApiCall

            val id = Regex("id=([^&]+)").find(iframeUrl)!!.value.removePrefix("id=")

            var document: Document? = iframeDocument
            val foundIv =
                iv ?: (document ?: app.get(iframeUrl).document.also { document = it })
                    .select("""div.wrapper[class*=container]""")
                    .attr("class").split("-").lastOrNull() ?: return@safeApiCall
            val foundKey = secretKey ?: getKey(base64Decode(id) + foundIv) ?: return@safeApiCall
            val foundDecryptKey = secretDecryptKey ?: foundKey

            val uri = URI(iframeUrl)
            val mainUrl = "https://" + uri.host

            val encryptedId = cryptoHandler(id, foundIv, foundKey)
            val encryptRequestData = if (isUsingAdaptiveData) {
                // Only fetch the document if necessary
                val realDocument = document ?: app.get(iframeUrl).document
                val dataEncrypted =
                    realDocument.select("script[data-name='episode']").attr("data-value")
                val headers = cryptoHandler(dataEncrypted, foundIv, foundKey, false)
                "id=$encryptedId&alias=$id&" + headers.substringAfter("&")
            } else {
                "id=$encryptedId&alias=$id"
            }

            val jsonResponse =
                app.get(
                    "$mainUrl/encrypt-ajax.php?$encryptRequestData",
                    headers = mapOf("X-Requested-With" to "XMLHttpRequest")
                )
            val dataencrypted =
                jsonResponse.text.substringAfter("{\"data\":\"").substringBefore("\"}")
            val datadecrypted = cryptoHandler(dataencrypted, foundIv, foundDecryptKey, false)
            val sources = AppUtils.parseJson<GogoSources>(datadecrypted)

            fun invokeGogoSource(
                source: GogoSource,
                sourceCallback: (ExtractorLink) -> Unit
            ) {
                sourceCallback.invoke(
                    ExtractorLink(
                        mainApiName,
                        mainApiName,
                        source.file,
                        mainUrl,
                        getQualityFromName(source.label),
                        isM3u8 = source.type == "hls" || source.label?.contains(
                            "auto",
                            ignoreCase = true
                        ) == true
                    )
                )
            }

            sources.source?.forEach {
                invokeGogoSource(it, callback)
            }
            sources.sourceBk?.forEach {
                invokeGogoSource(it, callback)
            }
        }
    }


    private fun getExtractorUrl(id: String): String {
        return "$mainUrl/streaming.php?id=$id"
    }

    private fun getDownloadUrl(id: String): String {
        return "$mainUrl/download?id=$id"
    }

    private val normalApis = arrayListOf(MultiQuality())

    // https://gogo-stream.com/streaming.php?id=MTE3NDg5
    suspend fun getUrl(
        id: String,
        isCasting: Boolean = false,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit,
    ): Boolean {
        val extractorUrl = getExtractorUrl(id)
        argamap(
            {
                normalApis.apmap { api ->
                    val url = api.getExtractorUrl(id)
                    api.getSafeUrl(
                        url,
                        callback = callback,
                        subtitleCallback = subtitleCallback
                    )
                }
            }, {
                /** Stolen from GogoanimeProvider.kt extractor */
                val link = getDownloadUrl(id)
                println("Generated vidstream download link: $link")
                val page = app.get(link, referer = extractorUrl)

                val pageDoc = Jsoup.parse(page.text)
                val qualityRegex = Regex("(\\d+)P")

                //a[download]
                pageDoc.select(".dowload > a")?.apmap { element ->
                    val href = element.attr("href") ?: return@apmap
                    val qual = if (element.text()
                            .contains("HDP")
                    ) "1080" else qualityRegex.find(element.text())?.destructured?.component1()
                        .toString()

                    if (!loadExtractor(href, link, subtitleCallback, callback)) {
                        callback.invoke(
                            ExtractorLink(
                                this.name,
                                name = this.name,
                                href,
                                page.url,
                                getQualityFromName(qual),
                                element.attr("href").contains(".m3u8")
                            )
                        )
                    }
                }
            }, {
                with(app.get(extractorUrl)) {
                    val document = Jsoup.parse(this.text)
                    val primaryLinks = document.select("ul.list-server-items > li.linkserver")
                    //val extractedLinksList: MutableList<ExtractorLink> = mutableListOf()

                    // All vidstream links passed to extractors
                    primaryLinks.distinctBy { it.attr("data-video") }.forEach { element ->
                        val link = element.attr("data-video")
                        //val name = element.text()

                        // Matches vidstream links with extractors
                        extractorApis.filter { !it.requiresReferer || !isCasting }.apmap { api ->
                            if (link.startsWith(api.mainUrl)) {
                                api.getSafeUrl(link, extractorUrl, subtitleCallback, callback)
                            }
                        }
                    }
                }
            }
        )
        return true
    }
}


================================================
FILE: VidstreamProviderTemplate/src/main/kotlin/com/lagradost/VidstreamProviderTemplate.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.extractors.Vidstream
//import com.lagradost.cloudstream3.animeproviders.GogoanimeProvider.Companion.extractVidstream
//import com.lagradost.cloudstream3.extractors.Vidstream
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.jsoup.Jsoup
import java.net.URI

/** Needs to inherit from MainAPI() to
 * make the app know what functions to call
 */
open class VidstreamProviderTemplate : MainAPI() {
    open val homePageUrlList = listOf<String>()
    open val vidstreamExtractorUrl: String? = null

    /**
     *  Used to generate encrypted video links.
     *  Try keys from other providers before cracking
     *  one yourself.
     * */
    // Userscript to get the keys:

    /*
    // ==UserScript==
    // @name        Easy keys
    // @namespace   Violentmonkey Scripts
    // @match       https://*/streaming.php*
    // @grant       none
    // @version     1.0
    // @author      LagradOst
    // @description 4/16/2022, 2:05:31 PM
    // ==/UserScript==

    let encrypt = CryptoJS.AES.encrypt;
    CryptoJS.AES.encrypt = (message, key, cfg) => {
        let realKey = CryptoJS.enc.Utf8.stringify(key);
        let realIv = CryptoJS.enc.Utf8.stringify(cfg.iv);

        var result = encrypt(message, key, cfg);
        let realResult = CryptoJS.enc.Utf8.stringify(result);

        popup = "Encrypt key: " + realKey + "\n\nIV: " + realIv + "\n\nMessage: " + message + "\n\nResult: " + realResult;
        alert(popup);

        return result;
    };

    let decrypt = CryptoJS.AES.decrypt;
    CryptoJS.AES.decrypt = (message, key, cfg) => {
        let realKey = CryptoJS.enc.Utf8.stringify(key);
        let realIv = CryptoJS.enc.Utf8.stringify(cfg.iv);

        let result = decrypt(message, key, cfg);
        let realResult = CryptoJS.enc.Utf8.stringify(result);

        popup = "Decrypt key: " + realKey + "\n\nIV: " + realIv + "\n\nMessage: " + message + "\n\nResult: " + realResult;
        alert(popup);

        return result;
    };

     */
     */

    open val iv: String? = null
    open val secretKey: String? = null
    open val secretDecryptKey: String? = null

    /** Generated the key from IV and ID */
    open val isUsingAdaptiveKeys: Boolean = false

    /**
     * Generate data for the encrypt-ajax automatically (only on supported sites)
     * See $("script[data-name='episode']")[0].dataset.value
     * */
    open val isUsingAdaptiveData: Boolean = false


//    // mainUrl is good to have as a holder for the url to make future changes easier.
//    override val mainUrl: String
//        get() = "https://vidembed.cc"
//
//    // name is for how the provider will be named which is visible in the UI, no real rules for this.
//    override val name: String
//        get() = "VidEmbed"

    // hasQuickSearch defines if quickSearch() should be called, this is only when typing the searchbar
    // gives results on the site instead of bringing you to another page.
    // if hasQuickSearch is true and quickSearch() hasn't been overridden you will get errors.
    // VidEmbed actually has quick search on their site, but the function wasn't implemented.
    override val hasQuickSearch = false

    // If getMainPage() is functional, used to display the homepage in app, an optional, but highly encouraged endevour.
    override val hasMainPage = true

    // Searching returns a SearchResponse, which can be one of the following: AnimeSearchResponse, MovieSearchResponse, TorrentSearchResponse, TvSeriesSearchResponse
    // Each of the classes requires some different data, but always has some critical things like name, poster and url.
    override suspend fun search(query: String): ArrayList<SearchResponse> {
        // Simply looking at devtools network is enough to spot a request like:
        // https://vidembed.cc/search.html?keyword=neverland where neverland is the query, can be written as below.
        val link = "$mainUrl/search.html?keyword=$query"
        val html = app.get(link).text
        val soup = Jsoup.parse(html)

        return ArrayList(soup.select(".listing.items > .video-block").map { li ->
            // Selects the href in <a href="...">
            val href = fixUrl(li.selectFirst("a")!!.attr("href"))
            val poster = li.selectFirst("img")?.attr("src")

            // .text() selects all the text in the element, be careful about doing this while too high up in the html hierarchy
            val title = li.selectFirst(".name")!!.text()
            // Use get(0) and toIntOrNull() to prevent any possible crashes, [0] or toInt() will error the search on unexpected values.
            val year = li.selectFirst(".date")?.text()?.split("-")?.get(0)?.toIntOrNull()

            TvSeriesSearchResponse(
                // .trim() removes unwanted spaces in the start and end.
                if (!title.contains("Episode")) title else title.split("Episode")[0].trim(),
                href,
                this.name,
                TvType.TvSeries,
                poster, year,
                // You can't get the episodes from the search bar.
                null
            )
        })
    }


    // Load, like the name suggests loads the info page, where all the episodes and data usually is.
    // Like search you should return either of: AnimeLoadResponse, MovieLoadResponse, TorrentLoadResponse, TvSeriesLoadResponse.
    override suspend fun load(url: String): LoadResponse? {
        // Gets the url returned from searching.
        val html = app.get(url).text
        val soup = Jsoup.parse(html)

        var title = soup.selectFirst("h1,h2,h3")!!.text()
        title = if (!title.contains("Episode")) title else title.split("Episode")[0].trim()

        val description = soup.selectFirst(".post-entry")?.text()?.trim()
        var poster: String? = null
        var year: Int? = null

        val episodes =
            soup.select(".listing.items.lists > .video-block").withIndex().map { (_, li) ->
                val epTitle = if (li.selectFirst(".name") != null)
                    if (li.selectFirst(".name")!!.text().contains("Episode"))
                        "Episode " + li.selectFirst(".name")!!.text().split("Episode")[1].trim()
                    else
                        li.selectFirst(".name")!!.text()
                else ""
                val epThumb = li.selectFirst("img")?.attr("src")
                val epDate = li.selectFirst(".meta > .date")!!.text()

                if (poster == null) {
                    poster = li.selectFirst("img")?.attr("onerror")?.split("=")?.get(1)
                        ?.replace(Regex("[';]"), "")
                }

                val epNum = Regex("""Episode (\d+)""").find(epTitle)?.destructured?.component1()
                    ?.toIntOrNull()
                if (year == null) {
                    year = epDate.split("-")[0].toIntOrNull()
                }
                newEpisode(li.selectFirst("a")!!.attr("href")) {
                    this.episode = epNum
                    this.posterUrl = epThumb
                    addDate(epDate)
                }
            }.reversed()

        // Make sure to get the type right to display the correct UI.
        val tvType =
            if (episodes.size == 1 && episodes[0].name == title) TvType.Movie else TvType.TvSeries

        return when (tvType) {
            TvType.TvSeries -> {
                TvSeriesLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes,
                    poster,
                    year,
                    description,
                    ShowStatus.Ongoing,
                    null,
                    null
                )
            }
            TvType.Movie -> {
                MovieLoadResponse(
                    title,
                    url,
                    this.name,
                    tvType,
                    episodes[0].data,
                    poster,
                    year,
                    description,
                    null,
                    null
                )
            }
            else -> null
        }
    }

    // This loads the homepage, which is basically a collection of search results with labels.
    // Optional function, but make sure to enable hasMainPage if you program this.
    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val urls = homePageUrlList
        val homePageList = ArrayList<HomePageList>()
        // .pmap {} is used to fetch the different pages in parallel
        urls.apmap { url ->
            val response = app.get(url, timeout = 20).text
            val document = Jsoup.parse(response)
            document.select("div.main-inner").forEach { inner ->
                // Always trim your text unless you want the risk of spaces at the start or end.
                val title = inner.select(".widget-title").text().trim()
                val elements = inner.select(".video-block").map {
                    val link = fixUrl(it.select("a").attr("href"))
                    val image = it.select(".picture > img").attr("src")
                    val name =
                        it.select("div.name").text().trim().replace(Regex("""[Ee]pisode \d+"""), "")
                    val isSeries = (name.contains("Season") || name.contains("Episode"))

                    if (isSeries) {
                        newTvSeriesSearchResponse(name, link) {
                            posterUrl = image
                        }
                    } else {
                        newMovieSearchResponse(name, link) {
                            posterUrl = image
                        }
                    }
                }

                homePageList.add(
                    HomePageList(
                        title, elements
                    )
                )
            }
        }
        return HomePageResponse(homePageList)
    }

    // loadLinks gets the raw .mp4 or .m3u8 urls from the data parameter in the episodes class generated in load()
    // See Episode(...) in this provider.
    // The data are usually links, but can be any other string to help aid loading the links.
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        // These callbacks are functions you should call when you get a link to a subtitle file or media file.
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        // "?: return" is a very useful statement which returns if the iframe link isn't found.
        val iframeLink =
            Jsoup.parse(app.get(data).text).selectFirst("iframe")?.attr("src") ?: return false

//        extractVidstream(
//            iframeLink,
//            this.name,
//            callback,
//            iv,
//            secretKey,
//            secretDecryptKey,
//            isUsingAdaptiveKeys,
//            isUsingAdaptiveData
//        )
        // In this case the video player is a vidstream clone and can be handled by the vidstream extractor.
        // This case is a both unorthodox and you normally do not call extractors as they detect the url returned and does the rest.
        val vidstreamObject = Vidstream(vidstreamExtractorUrl ?: mainUrl)
        // https://vidembed.cc/streaming.php?id=MzUwNTY2&... -> MzUwNTY2
        val id = Regex("""id=([^&]*)""").find(iframeLink)?.groupValues?.get(1)

        if (id != null) {
            vidstreamObject.getUrl(id, isCasting, subtitleCallback, callback)
        }

        val html = app.get(fixUrl(iframeLink)).text
        val soup = Jsoup.parse(html)

        val servers = soup.select(".list-server-items > .linkserver").mapNotNull { li ->
            if (!li?.attr("data-video").isNullOrEmpty()) {
                Pair(li.text(), fixUrl(li.attr("data-video")))
            } else {
                null
            }
        }
        servers.apmap {
            // When checking strings make sure to make them lowercase and trimmed because edgecases like "beta server " wouldn't work otherwise.
            if (it.first.trim().equals("beta server", ignoreCase = true)) {
                // Group 1: link, Group 2: Label
                // Regex can be used to effectively parse small amounts of json without bothering with writing a json class.
                val sourceRegex =
                    Regex("""sources:[\W\w]*?file:\s*["'](.*?)["'][\W\w]*?label:\s*["'](.*?)["']""")
                val trackRegex =
                    Regex("""tracks:[\W\w]*?file:\s*["'](.*?)["'][\W\w]*?label:\s*["'](.*?)["']""")

                // Having a referer is often required. It's a basic security check most providers have.
                // Try to replicate what your browser does.
                val serverHtml = app.get(it.second, headers = mapOf("referer" to iframeLink)).text
                sourceRegex.findAll(serverHtml).forEach { match ->
                    callback.invoke(
                        ExtractorLink(
                            this.name,
                            match.groupValues.getOrNull(2)?.let { "${this.name} $it" } ?: this.name,
                            match.groupValues[1],
                            it.second,
                            // Useful function to turn something like "1080p" to an app quality.
                            getQualityFromName(match.groupValues.getOrNull(2) ?: ""),
                            // Kinda risky
                            // isM3u8 makes the player pick the correct extractor for the source.
                            // If isM3u8 is wrong the player will error on that source.
                            URI(match.groupValues[1]).path.endsWith(".m3u8"),
                        )
                    )
                }
                trackRegex.findAll(serverHtml).forEach { match ->
                    subtitleCallback.invoke(
                        SubtitleFile(
                            match.groupValues.getOrNull(2) ?: "Unknown",
                            match.groupValues[1]
                        )
                    )
                }
            }
        }

        return true
    }
}



================================================
FILE: VidstreamProviderTemplate/src/main/kotlin/com/lagradost/VidstreamProviderTemplatePlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context
import com.lagradost.cloudstream3.extractors.Vidstream

@CloudstreamPlugin
class VidstreamProviderTemplatePlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerExtractorAPI(MultiQuality())
        registerMainAPI(VidstreamProviderTemplate())
    }
}


================================================
FILE: VMoveeProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: VMoveeProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: VMoveeProvider/src/main/kotlin/com/lagradost/VMoveeProvider.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName
import org.jsoup.Jsoup

class VMoveeProvider : MainAPI() {
    override var name = "VMovee"
    override var mainUrl = "https://www.vmovee.watch"

    override val supportedTypes = setOf(TvType.Movie)

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/?s=$query"
        val response = app.get(url).text
        val document = Jsoup.parse(response)
        val searchItems = document.select("div.search-page > div.result-item > article")
        if (searchItems.size == 0) return ArrayList()
        val returnValue = ArrayList<SearchResponse>()
        for (item in searchItems) {
            val details = item.selectFirst("> div.details")
            val imgHolder = item.selectFirst("> div.image > div.thumbnail > a")
            // val href = imgHolder.attr("href")
            val poster = imgHolder!!.selectFirst("> img")!!.attr("data-lazy-src")
            val isTV = imgHolder.selectFirst("> span")!!.text() == "TV"
            if (isTV) continue // no TV support yet

            val titleHolder = details!!.selectFirst("> div.title > a")
            val title = titleHolder!!.text()
            val href = titleHolder.attr("href")
            val meta = details.selectFirst("> div.meta")
            val year = meta!!.selectFirst("> span.year")!!.text().toIntOrNull()
            // val rating = parseRating(meta.selectFirst("> span.rating").text().replace("IMDb ", ""))
            // val descript = details.selectFirst("> div.contenido").text()
            returnValue.add(
                if (isTV) TvSeriesSearchResponse(title, href, this.name, TvType.TvSeries, poster, year, null)
                else MovieSearchResponse(title, href, this.name, TvType.Movie, poster, year)
            )
        }
        return returnValue
    }

    data class LoadLinksAjax(
        @JsonProperty("embed_url")
        val embedUrl: String,
    )

    data class ReeoovAPIData(
        @JsonProperty("file")
        val file: String,
        @JsonProperty("label")
        val label: String,
    )

    data class ReeoovAPI(
        @JsonProperty("data")
        val data: List<ReeoovAPIData>,
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        val url = "$mainUrl/dashboard/admin-ajax.php"
        val post =
            app.post(
                url,
                headers = mapOf("referer" to url),
                data = mapOf("action" to "doo_player_ajax", "post" to data, "nume" to "2", "type" to "movie")
            ).text

        val ajax = parseJson<LoadLinksAjax>(post)
        var realUrl = ajax.embedUrl
        if (realUrl.startsWith("//")) {
            realUrl = "https:$realUrl"
        }

        val request = app.get(realUrl)
        val prefix = "https://reeoov.tube/v/"
        if (request.url.startsWith(prefix)) {
            val apiUrl = "https://reeoov.tube/api/source/${request.url.removePrefix(prefix)}"
            val apiResponse = app.post(
                apiUrl,
                headers = mapOf("Referer" to request.url),
                data = mapOf("r" to "https://www.vmovee.watch/", "d" to "reeoov.tube")
            ).text
            val apiData = parseJson<ReeoovAPI>(apiResponse)
            for (d in apiData.data) {
                callback.invoke(
                    ExtractorLink(
                        this.name,
                        this.name + " " + d.label,
                        d.file,
                        "https://reeoov.tube/",
                        getQualityFromName(d.label),
                        false
                    )
                )
            }
        }

        return true
    }

    override suspend fun load(url: String): LoadResponse {
        val response = app.get(url).text
        val document = Jsoup.parse(response)

        val sheader = document.selectFirst("div.sheader")

        val poster = sheader!!.selectFirst("> div.poster > img")!!.attr("data-lazy-src")
        val data = sheader.selectFirst("> div.data")
        val title = data!!.selectFirst("> h1")!!.text()
        val descript = document.selectFirst("div#info > div")!!.text()
        val id = document.select("div.starstruck").attr("data-id")

        return MovieLoadResponse(title, url, this.name, TvType.Movie, id, poster, null, descript, null, null)
    }
}


================================================
FILE: VMoveeProvider/src/main/kotlin/com/lagradost/VMoveeProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class VMoveeProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(VMoveeProvider())
    }
}


================================================
FILE: WatchAsianProvider/build.gradle.kts
================================================
dependencies {
    implementation(project(mapOf("path" to ":VidstreamProviderTemplate")))
}
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: WatchAsianProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: WatchAsianProvider/src/main/kotlin/com/lagradost/AsianEmbedHelper.kt
================================================
package com.lagradost

import android.util.Log
import com.lagradost.cloudstream3.SubtitleFile
import com.lagradost.cloudstream3.apmap
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class AsianEmbedHelper {
    companion object {
        suspend fun getUrls(
            url: String,
            subtitleCallback: (SubtitleFile) -> Unit,
            callback: (ExtractorLink) -> Unit
        ) {
            // Fetch links
            val doc = app.get(url).document
            val links = doc.select("div#list-server-more > ul > li.linkserver")
            if (!links.isNullOrEmpty()) {
                links.apmap {
                    val datavid = it.attr("data-video") ?: ""
                    //Log.i("AsianEmbed", "Result => (datavid) ${datavid}")
                    if (datavid.isNotBlank()) {
                        val res = loadExtractor(datavid, url, subtitleCallback, callback)
                        Log.i("AsianEmbed", "Result => ($res) (datavid) $datavid")
                    }
                }
            }
        }
    }
}


================================================
FILE: WatchAsianProvider/src/main/kotlin/com/lagradost/WatchAsianProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.extractors.Vidstream
//import com.lagradost.cloudstream3.animeproviders.GogoanimeProvider.Companion.extractVidstream
//import com.lagradost.cloudstream3.extractors.XStreamCdn
//import com.lagradost.cloudstream3.extractors.helper.AsianEmbedHelper
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.AppUtils.toJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor

class WatchAsianProvider : MainAPI() {
    override var mainUrl = "https://watchasian.cx"
    override var name = "WatchAsian"
    override val hasQuickSearch = false
    override val hasMainPage = true
    override val hasChromecastSupport = false
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(TvType.AsianDrama)

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val headers = mapOf("X-Requested-By" to mainUrl)
        val doc = app.get(mainUrl, headers = headers).document
        val rowPair = mutableListOf<Pair<String, String>>()
        doc.select("div.block-tab").forEach {
            it?.select("ul.tab > li")?.mapNotNull { row ->
                val link = row?.attr("data-tab") ?: return@mapNotNull null
                val title = row.text() ?: return@mapNotNull null
                Pair(title, link)
            }?.let { it1 ->
                rowPair.addAll(
                    it1
                )
            }
        }

        return HomePageResponse(
            rowPair.mapNotNull { row ->
                val main = (doc.select("div.tab-content.${row.second}")
                    ?: doc.select("div.tab-content.${row.second}.selected"))
                    ?: return@mapNotNull null

                val title = row.first
                val inner = main.select("li") ?: return@mapNotNull null

                HomePageList(
                    title,
                    inner.map {
                        // Get inner div from article
                        val innerBody = it?.selectFirst("a")
                        // Fetch details
                        val link = fixUrlNull(innerBody?.attr("href")) ?: return@map null
                        val image =
                            fixUrlNull(innerBody?.select("img")?.attr("data-original")) ?: ""
                        val name = (innerBody?.selectFirst("h3.title")?.text() ?: innerBody?.text())
                            ?: "<Untitled>"
                        //Log.i(this.name, "Result => (innerBody, image) ${innerBody} / ${image}")
                        MovieSearchResponse(
                            name,
                            link,
                            this.name,
                            TvType.TvSeries,
                            image,
                            year = null,
                            id = null,
                        )
                    }.filterNotNull().distinctBy { c -> c.url })
            }.filter { a -> a.list.isNotEmpty() }
        )
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search?type=movies&keyword=$query"
        val document = app.get(url).document.getElementsByTag("body")
            .select("div.block.tab-container > div > ul > li") ?: return listOf()

        return document.mapNotNull {
            val innerA = it?.selectFirst("a") ?: return@mapNotNull null
            val link = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null
            val title = it.select("h3.title").text() ?: return@mapNotNull null
            if (title.isEmpty()) {
                return@mapNotNull null
            }
            val year = null
            val imgsrc = innerA.select("img").attr("data-original") ?: return@mapNotNull null
            val image = fixUrlNull(imgsrc)
            //Log.i(this.name, "Result => (img movie) $title / $link")
            MovieSearchResponse(
                title,
                link,
                this.name,
                TvType.Movie,
                image,
                year
            )
        }.distinctBy { a -> a.url }
    }

    override suspend fun load(url: String): LoadResponse {
        val body = app.get(url).document
        // Declare vars
        val isDramaDetail = url.contains("/drama-detail/")
        var poster: String? = null
        var title = ""
        var descript: String? = null
        var year: Int? = null
        var tags: List<String>? = null
        if (isDramaDetail) {
            val main = body.select("div.details")
            val inner = main.select("div.info")
            // Video details
            poster = fixUrlNull(main.select("div.img > img").attr("src"))
            //Log.i(this.name, "Result => (imgLinkCode) ${imgLinkCode}")
            title = inner.select("h1").firstOrNull()?.text() ?: ""
            //Log.i(this.name, "Result => (year) ${title.substring(title.length - 5)}")
            descript = inner.text()

            inner.select("p").forEach { p ->
                val caption =
                    p?.selectFirst("span")?.text()?.trim()?.lowercase()?.removeSuffix(":")?.trim()
                        ?: return@forEach
                when (caption) {
                    "genre" -> {
                        tags = p.select("a").mapNotNull { it?.text()?.trim() }
                    }
                    "released" -> {
                        year = p.select("a").text().trim()?.toIntOrNull()
                    }
                }
            }
        } else {
            poster = body.select("meta[itemprop=\"image\"]")?.attr("content") ?: ""
            title = body.selectFirst("div.block.watch-drama")?.selectFirst("h1")
                ?.text() ?: ""
            year = null
            descript = body.select("meta[name=\"description\"]")?.attr("content")
        }
        //Fallback year from title
        if (year == null) {
            year = if (title.length > 5) {
                title.replace(")", "").replace("(", "").substring(title.length - 5)
                    .trim().trimEnd(')').toIntOrNull()
            } else {
                null
            }
        }

        // Episodes Links
        //Log.i(this.name, "Result => (all eps) ${body.select("ul.list-episode-item-2.all-episode > li")}")
        val episodeList = body.select("ul.list-episode-item-2.all-episode > li").mapNotNull { ep ->
            //Log.i(this.name, "Result => (epA) ${ep.select("a")}")
            val innerA = ep.select("a") ?: return@mapNotNull null
            //Log.i(this.name, "Result => (innerA) ${fixUrlNull(innerA.attr("href"))}")
            val epLink = fixUrlNull(innerA.attr("href")) ?: return@mapNotNull null

            val regex = "(?<=episode-).*?(?=.html)".toRegex()
            val count = regex.find(epLink, mainUrl.length)?.value?.toIntOrNull() ?: 0
            //Log.i(this.name, "Result => $epLink (regexYear) ${count}")
            Episode(
                name = null,
                season = null,
                episode = count,
                data = epLink,
                posterUrl = poster,
                date = null
            )
        }
        //If there's only 1 episode, consider it a movie.
        if (episodeList.size == 1) {
            //Clean title
            title = title.trim().removeSuffix("Episode 1")
            val streamlink = getServerLinks(episodeList[0].data)
            //Log.i(this.name, "Result => (streamlink) $streamlink")
            return MovieLoadResponse(
                name = title,
                url = url,
                apiName = this.name,
                type = TvType.Movie,
                dataUrl = streamlink,
                posterUrl = poster,
                year = year,
                plot = descript,
                tags = tags
            )
        }
        return TvSeriesLoadResponse(
            name = title,
            url = url,
            apiName = this.name,
            type = TvType.AsianDrama,
            episodes = episodeList.reversed(),
            posterUrl = poster,
            year = year,
            plot = descript,
            tags = tags
        )
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val links = if (data.startsWith(mainUrl)) {
            getServerLinks(data)
        } else {
            data
        }
        var count = 0
        parseJson<List<String>>(links).apmap { item ->
            count++
            val url = fixUrl(item.trim())
            //Log.i(this.name, "Result => (url) $url")
            when {
                url.startsWith("https://asianembed.io") || url.startsWith("https://asianload.io") -> {
                    val iv = "9262859232435825"
                    val secretKey = "93422192433952489752342908585752"
                    Vidstream.extractVidstream(
                        url, this.name, callback, iv, secretKey, secretKey,
                        isUsingAdaptiveKeys = false,
                        isUsingAdaptiveData = false
                    )
                    AsianEmbedHelper.getUrls(url, subtitleCallback, callback)
                }
                url.startsWith("https://embedsito.com") -> {
                    val extractor = XStreamCdn()
                    extractor.domainUrl = "embedsito.com"
                    extractor.getSafeUrl(
                        url,
                        subtitleCallback = subtitleCallback,
                        callback = callback,
                    )
                }
                else -> {
                    loadExtractor(url, mainUrl, subtitleCallback, callback)
                }
            }
        }
        return count > 0
    }

    private suspend fun getServerLinks(url: String): String {
        val moviedoc = app.get(url, referer = mainUrl).document
        return moviedoc.select("div.anime_muti_link > ul > li")
            .mapNotNull {
                fixUrlNull(it?.attr("data-video")) ?: return@mapNotNull null
            }.toJson()
    }
}



================================================
FILE: WatchAsianProvider/src/main/kotlin/com/lagradost/WatchAsianProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class WatchAsianProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(WatchAsianProvider())
        registerExtractorAPI(XStreamCdn())
        registerExtractorAPI(LayarKaca())
        registerExtractorAPI(DBfilm())
        registerExtractorAPI(Luxubu())
        registerExtractorAPI(FEmbed())
        registerExtractorAPI(Fplayer())
        registerExtractorAPI(FeHD())
    }
}


================================================
FILE: WatchAsianProvider/src/main/kotlin/com/lagradost/XStreamCdn.kt
================================================
package com.lagradost

import com.fasterxml.jackson.annotation.JsonProperty
import com.lagradost.cloudstream3.app
import com.lagradost.cloudstream3.utils.AppUtils
import com.lagradost.cloudstream3.utils.ExtractorApi
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.getQualityFromName

class LayarKaca: XStreamCdn() {
    override val name: String = "LayarKaca-xxi"
    override val mainUrl: String = "https://layarkacaxxi.icu"
}

class DBfilm: XStreamCdn() {
    override val name: String = "DBfilm"
    override val mainUrl: String = "https://dbfilm.bar"
}

class Luxubu : XStreamCdn(){
    override val name: String = "FE"
    override val mainUrl: String = "https://www.luxubu.review"
}

class FEmbed: XStreamCdn() {
    override val name: String = "FEmbed"
    override val mainUrl: String = "https://www.fembed.com"
}

class Fplayer: XStreamCdn() {
    override val name: String = "Fplayer"
    override val mainUrl: String = "https://fplayer.info"
}

class FeHD: XStreamCdn() {
    override val name: String = "FeHD"
    override val mainUrl: String = "https://fembed-hd.com"
    override var domainUrl: String = "fembed-hd.com"
}

open class XStreamCdn : ExtractorApi() {
    override val name: String = "XStreamCdn"
    override val mainUrl: String = "https://embedsito.com"
    override val requiresReferer = false
    open var domainUrl: String = "embedsito.com"

    private data class ResponseData(
        @JsonProperty("file") val file: String,
        @JsonProperty("label") val label: String,
        //val type: String // Mp4
    )

    private data class ResponseJson(
        @JsonProperty("success") val success: Boolean,
        @JsonProperty("data") val data: List<ResponseData>?
    )

    override fun getExtractorUrl(id: String): String {
        return "$domainUrl/api/source/$id"
    }

    override suspend fun getUrl(url: String, referer: String?): List<ExtractorLink> {
        val headers = mapOf(
            "Referer" to url,
            "User-Agent" to "Mozilla/5.0 (Windows NT 10.0; rv:78.0) Gecko/20100101 Firefox/78.0",
        )
        val id = url.trimEnd('/').split("/").last()
        val newUrl = "https://${domainUrl}/api/source/${id}"
        val extractedLinksList: MutableList<ExtractorLink> = mutableListOf()
        with(app.post(newUrl, headers = headers)) {
            if (this.code != 200) return listOf()
            val text = this.text
            if (text.isEmpty()) return listOf()
            if (text == """{"success":false,"data":"Video not found or has been removed"}""") return listOf()
            AppUtils.parseJson<ResponseJson?>(text)?.let {
                if (it.success && it.data != null) {
                    it.data.forEach { data ->
                        extractedLinksList.add(
                            ExtractorLink(
                                name,
                                name = name,
                                data.file,
                                url,
                                getQualityFromName(data.label),
                            )
                        )
                    }
                }
            }
        }
        return extractedLinksList
    }
}


================================================
FILE: XcineProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: XcineProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: XcineProvider/src/main/kotlin/com/lagradost/XcineProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.AppUtils.parseJson
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.Qualities
import org.jsoup.nodes.Element
import org.mozilla.javascript.Context
import org.mozilla.javascript.Scriptable

class XcineProvider : MainAPI() {
    override var lang = "de"
    override var mainUrl = "https://xcine.me"
    override var name = "Xcine"
    override val usesWebView = false
    override val hasMainPage = true
    override val supportedTypes =
        setOf(TvType.TvSeries, TvType.Movie, TvType.Anime, TvType.AnimeMovie)

    var cookies: MutableMap<String, String> = mutableMapOf()

    private fun Element.toSearchResponse(): SearchResponse? {
        val url = this.attr("href") ?: return null
        val poster = select("div.poster-film-small").attr("data-src")

        val title = this.attr("title")
        val yearRegex = Regex("""\((\d{4})\)\s*stream$""")
        val year = yearRegex.find(title)?.groupValues?.getOrNull(1)?.toIntOrNull()
        val fixedTitle = title.replace(yearRegex, "")

        // If you need to differentiate use the url.
        return MovieSearchResponse(
            fixedTitle,
            url,
            this@XcineProvider.name,
            TvType.TvSeries,
            poster,
            year,
            null,
        )
    }

    override suspend fun getMainPage(page: Int, request : MainPageRequest): HomePageResponse {
        val document = app.get(mainUrl).document
        val sections = document.select("div.group-film")
        return HomePageResponse(sections.mapNotNull { section ->
            val title = section.select("a.more").attr("title")
            val searchResponses =
                section.select("a.film-small").mapNotNull { it.toSearchResponse() }
            if (searchResponses.isEmpty()) return@mapNotNull null
            HomePageList(title, searchResponses)
        })
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val url = "$mainUrl/search?key=$query"
        val document = app.get(url).document
        return document.select("a.film-small").mapNotNull {
            it.toSearchResponse()
        }
    }

    private fun String.getIntFromText(): Int? {
        return Regex("""\d+""").find(this)?.groupValues?.firstOrNull()?.toIntOrNull()
    }

    data class EpisodeData(
        val episodeId: Int,
        val showId: Int,
        val episodeUrl: String,
        val key: String,
        val keyValue: String,
        val cookies: Map<String, String>
    )

    private fun Element.toEpisode(
        showId: Int,
        key: String,
        keyValue: String,
        cookies: Map<String, String>
    ): Episode? {
        val id = this.attr("data-episode-id").toIntOrNull() ?: return null
        val title = this.attr("title")
        val titleRegex = Regex("""Staffel\s*(\d*).*folge\s*(\d*)""")
        val url = this.attr("href")
        val found = titleRegex.find(title)

        return newEpisode(
            EpisodeData(id, showId, url, key, keyValue, cookies)
        ) {
            season = found?.groupValues?.getOrNull(1)?.toIntOrNull()
            episode = found?.groupValues?.getOrNull(2)?.toIntOrNull()
        }
    }


    override suspend fun load(url: String): LoadResponse {
        val (document, text) = app.get(url).let {
            it.document to it.text
        }

        val title = document.select("h1.title-film-detail-1").text()
        val posterRegex = Regex("""ImageObject.*url":"(.*?)"""")
        val posterUrl = posterRegex.find(text)?.groupValues?.getOrNull(1)?.replace("\\", "")

        val information = document.select("ul.infomation-film > li").associate {
            it.text().substringBefore(":") to it.select("span").text()
        }

        val year = information["Erscheinungsjahr"]?.toIntOrNull()
        val duration = information["Laufzeit"]?.getIntFromText()
        val tags = information["Genre"]?.split(",")

        val recommendations =
            document.select("a.film-small").mapNotNull {
                it.toSearchResponse()
            }

        val playUrl = document.select("a.play-film").attr("href")
        val (isSeries, episodes) = if (playUrl.isNotEmpty()) {
            val keyRegex = Regex("""loadStreamSV.*\n\s*(.*?)\s*:\s*(.*?)\s*\}""")
            val (playDoc, playText) = app.get(playUrl).let {
                val responseCookies = it.okhttpResponse.headers.filter { header ->
                    header.first.equals(
                        "set-cookie",
                        ignoreCase = true
                    )
                }
                responseCookies.forEach {
                    val (cookieKey, cookieValue) = it.second.split("=")
                    cookies[cookieKey] = cookieValue.substringBefore(";")
                }
                it.document to it.text
            }

            val rhino = Context.enter()
            rhino.optimizationLevel = -1
            val scope: Scriptable = rhino.initSafeStandardObjects()
            val decodeBase64 = "atob = function(s) {\n" +
                    "    var e={},i,b=0,c,x,l=0,a,r='',w=String.fromCharCode,L=s.length;\n" +
                    "    var A=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n" +
                    "    for(i=0;i<64;i++){e[A.charAt(i)]=i;}\n" +
                    "    for(x=0;x<L;x++){\n" +
                    "        c=e[s.charAt(x)];b=(b<<6)+c;l+=6;\n" +
                    "        while(l>=8){((a=(b>>>(l-=8))&0xff)||(x<(L-2)))&&(r+=w(a));}\n" +
                    "    }\n" +
                    "    return r;\n" +
                    "};"
            val doc = """
                var document = {};
                var window = {
                    document: document,
                    eval: eval,
                    atob: atob
                };
            """.trimMargin()
            val jsRegex = Regex("""@context.*\n([\W\w]*?)</script""")
            val js = jsRegex.findAll(playText).last().groupValues[1].replace("let ", "")
            rhino.evaluateString(scope, decodeBase64 + doc + js, "JavaScript", 1, null)
            val jsEval = scope.get("document", scope) as? Scriptable
            val cookies = (jsEval?.get("cookie", jsEval) as String)
            val (cookieKey, cookieValue) = cookies.split(";")[0].split("=")

            val (key, keyValue) = keyRegex.find(playText)?.destructured
                ?: throw RuntimeException("No keys found")

            val playTitle = playDoc.select("p.title-film-detail-1")
            val showId = playDoc.select("input[name=movie_id]").`val`().toIntOrNull()
            if (showId != null) {
                val isSeries = playTitle.text().contains("staffel", ignoreCase = true)
                val episodes = playDoc.select("div.movie_episode_wrapper li > a").mapNotNull {
                    it.toEpisode(showId, key, keyValue, mapOf(cookieKey to cookieValue))
                }
                isSeries to episodes
            } else {
                false to emptyList()
            }
        } else {
            false to emptyList()
        }

        return if (isSeries || episodes.size > 1) newTvSeriesLoadResponse(
            title,
            url,
            TvType.TvSeries,
            episodes
        ) {
            this.comingSoon = playUrl.isEmpty()
        } else
            newMovieLoadResponse(
                title,
                url,
                TvType.Movie,
                episodes.firstOrNull()?.data ?: ""
            ) {
                this.posterUrl = posterUrl
                this.year = year
                this.tags = tags

                if (duration != 0)
                    this.duration = duration

                this.recommendations = recommendations
                this.comingSoon = playUrl.isEmpty() || episodes.isEmpty()
            }
    }


    data class File(
        val file: String? = null,
        val type: String? = null,
        val label: String? = null
    )

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {
        val parsed = parseJson<EpisodeData>(data)
        val url = "$mainUrl/movie/load-stream/${parsed.showId}/${parsed.episodeId}"
        val response = app.post(
            url,
            referer = parsed.episodeUrl,
            headers = mapOf(
                "X-Requested-With" to "XMLHttpRequest",
            ),
            data = mapOf(parsed.key to parsed.keyValue),
            cookies = parsed.cookies + cookies,
        ).text

        val urlRegex = Regex("""file['"].*?['"]([^'"]*)""")
        val link = urlRegex.find(response)?.groupValues!![1]

//        files.forEach { (isVip, list) ->
//            list.forEach file@{ file ->
//                if (file.file == null) return@file
        callback.invoke(
            ExtractorLink(
                this.name,
                this.name,
                link.replace("\\", ""),
                this.mainUrl,
//                        file.label?.getIntFromText() ?:
                Qualities.Unknown.value,
                true
//                        file.type?.contains("hls", ignoreCase = true) == true,
            )
        )
//            }
//        }

        return true // files.sumOf { it.second.size } > 0
    }
}



================================================
FILE: XcineProvider/src/main/kotlin/com/lagradost/XcineProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class XcineProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(XcineProvider())
    }
}


================================================
FILE: YomoviesProvider/build.gradle.kts
================================================
// use an integer for version numbers
version = 1


cloudstream {
    // All of these properties are optional, you can safely remove them

    // description = "Lorem Ipsum"
    // authors = listOf("Cloudburst")

    /**
    * Status int as the following:
    * 0: Down
    * 1: Ok
    * 2: Slow
    * 3: Beta only
    * */
    status = 1 // will be 3 if unspecified

    // Set to true to get an 18+ symbol next to the plugin
    adult = false // will be false if unspecified
}


================================================
FILE: YomoviesProvider/src/main/AndroidManifest.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest package="com.lagradost"/>


================================================
FILE: YomoviesProvider/src/main/kotlin/com/lagradost/YomoviesProvider.kt
================================================
package com.lagradost

import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.LoadResponse.Companion.addActors
import com.lagradost.cloudstream3.LoadResponse.Companion.addTrailer
import com.lagradost.cloudstream3.mvvm.safeApiCall
import com.lagradost.cloudstream3.utils.ExtractorLink
import com.lagradost.cloudstream3.utils.loadExtractor
import org.jsoup.nodes.Element

class YomoviesProvider : MainAPI() {
    override var mainUrl = "https://yomovies.skin"
    override var name = "Yomovies"
    override val hasMainPage = true
    override var lang = "hi"
    override val hasDownloadSupport = true
    override val supportedTypes = setOf(
        TvType.Movie,
        TvType.TvSeries,
    )

    override val mainPage = mainPageOf(
        "$mainUrl/most-favorites/page/" to "Most Viewed",
        "$mainUrl/genre/web-series/page/" to "Web Series Movies",
        "$mainUrl/genre/dual-audio/page/" to "Dual Audio Movies",
        "$mainUrl/genre/bollywood/page/" to "Bollywood Movies",
        "$mainUrl/genre/tv-shows/page/" to "TV Shows Movies",
        "$mainUrl/genre/hollywood/page/" to "Hollywood Movies",
        "$mainUrl/series/page/" to "All TV Series",
    )

    override suspend fun getMainPage(
        page: Int,
        request: MainPageRequest
    ): HomePageResponse {
        val document = app.get(request.data + page).document
        val home = document.select("div.ml-item").mapNotNull {
            it.toSearchResult()
        }
        return newHomePageResponse(request.name, home)
    }

    private fun Element.toSearchResult(): SearchResponse? {
        val title = this.selectFirst("h2")?.text()?.trim() ?: return null
        val href = fixUrl(this.selectFirst("a")?.attr("href").toString())
        val posterUrl = fixUrlNull(this.selectFirst("img")?.attr("data-original"))

        return newMovieSearchResponse(title, href, TvType.Movie) {
            this.posterUrl = posterUrl
        }
    }

    override suspend fun search(query: String): List<SearchResponse> {
        val document = app.get("$mainUrl/?s=$query").document

        return document.select("div.ml-item").mapNotNull {
            it.toSearchResult()
        }
    }

    override suspend fun load(url: String): LoadResponse? {
        val document = app.get(url).document

        val title = document.selectFirst("div.mvic-desc h3")?.text()?.trim() ?: return null
        val poster = fixUrlNull(document.selectFirst("div.thumb.mvic-thumb img")?.attr("src"))
        val tags = document.select("div.mvici-left p:nth-child(1) a").map { it.text() }
        val year = document.select("div.mvici-right p:nth-child(3) a").text().trim()
            .toIntOrNull()
        val tvType = if (document.selectFirst("div.les-content")
                ?.select("a")?.size!! > 1 || document.selectFirst("ul.idTabs li strong")?.text()
                ?.contains(Regex("(?i)(EP\\s?[0-9]+)|(episode\\s?[0-9]+)")) == true
        ) TvType.TvSeries else TvType.Movie
        val description = document.selectFirst("p.f-desc")?.text()?.trim()
        val trailer = fixUrlNull(document.select("iframe#iframe-trailer").attr("src"))
        val rating = document.select("div.mvici-right > div.imdb_r span").text().toRatingInt()
        val actors = document.select("div.mvici-left p:nth-child(3) a").map { it.text() }
        val recommendations = document.select("div.ml-item").mapNotNull {
            it.toSearchResult()
        }

        return if (tvType == TvType.TvSeries) {
            val episodes = if (document.selectFirst("div.les-title strong")?.text().toString()
                    .contains(Regex("(?i)EP\\s?[0-9]+|Episode\\s?[0-9]+"))
            ) {
                document.select("ul.idTabs li").map {
                    val id = it.select("a").attr("href")
                    Episode(
                        data = fixUrl(document.select("div$id iframe").attr("src")),
                        name = it.select("strong").text(),
                    )
                }
            } else {
                document.select("div.les-content a").map {
                    Episode(
                        data = it.attr("href"),
                        name = it.text().trim(),
                    )
                }
            }

            newTvSeriesLoadResponse(title, url, TvType.TvSeries, episodes) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        } else {
            newMovieLoadResponse(title, url, TvType.Movie, url) {
                this.posterUrl = poster
                this.year = year
                this.plot = description
                this.tags = tags
                this.rating = rating
                addActors(actors)
                this.recommendations = recommendations
                addTrailer(trailer)
            }
        }
    }

    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (SubtitleFile) -> Unit,
        callback: (ExtractorLink) -> Unit
    ): Boolean {

        if (data.startsWith(mainUrl)) {
            app.get(data).document.select("div.movieplay iframe").map { fixUrl(it.attr("src")) }
                .apmap { source ->
                    safeApiCall {
                        when {
                            source.startsWith("https://membed.net") -> app.get(
                                source,
                                referer = "$mainUrl/"
                            ).document.select("ul.list-server-items li")
                                .apmap {
                                    loadExtractor(
                                        it.attr("data-video").substringBefore("=https://msubload"),
                                        "$mainUrl/",
                                        subtitleCallback,
                                        callback
                                    )
                                }
                            else -> loadExtractor(source, "$mainUrl/", subtitleCallback, callback)
                        }
                    }
                }
        } else {
            loadExtractor(data, "$mainUrl/", subtitleCallback, callback)
        }

        return true
    }


}



================================================
FILE: YomoviesProvider/src/main/kotlin/com/lagradost/YomoviesProviderPlugin.kt
================================================

package com.lagradost

import com.lagradost.cloudstream3.plugins.CloudstreamPlugin
import com.lagradost.cloudstream3.plugins.Plugin
import android.content.Context

@CloudstreamPlugin
class YomoviesProviderPlugin: Plugin() {
    override fun load(context: Context) {
        // All providers should be added in this manner. Please don't edit the providers list directly.
        registerMainAPI(YomoviesProvider())
    }
}


================================================
FILE: .github/workflows/build.yml
================================================
name: Build

# https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#concurrency
concurrency: 
  group: "build"
  cancel-in-progress: true

on:
  push:
    branches:
      # choose your default branch
      - master
      - main
    paths-ignore:
      - '*.md'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@master
        with:
          path: "src"

      - name: Checkout builds
        uses: actions/checkout@master
        with:
          ref: "builds"
          path: "builds"

      - name: Setup JDK 11
        uses: actions/setup-java@v1
        with:
          java-version: 11

      - name: Setup Android SDK
        uses: android-actions/setup-android@v2

      - name: Build Plugins
        run: |
          cd $GITHUB_WORKSPACE/src
          chmod +x gradlew
          ./gradlew make makePluginsJson
          cp **/build/*.cs3 $GITHUB_WORKSPACE/builds
          cp build/plugins.json $GITHUB_WORKSPACE/builds

      - name: Push builds
        run: |
          cd $GITHUB_WORKSPACE/builds
          git config --local user.email "actions@github.com"
          git config --local user.name "GitHub Actions"
          git add .
          git commit -m "Build $GITHUB_SHA" || exit 0   # do not error if nothing to commit
          git push


